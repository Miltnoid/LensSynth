\newif\ifdraft\drafttrue  % set true to show comments
\newif\ifplentyoftime\plentyoftimefalse  % :-)

\documentclass[acmsmall,review,anonymous]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}
% % For double-blind review submission, w/ CCS and ACM Reference
% \documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
% % For single-blind review submission, w/o CCS and ACM Reference (max
% submission space)
% \documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
% % For single-blind review submission, w/ CCS and ACM Reference
% \documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true} % For
% final camera-ready submission, w/ required CCS and ACM Reference
% \documentclass[acmsmall]{acmart}\settopmatter{}


% % Journal information % Supplied to authors by publisher for camera-ready
% submission; % use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{ICDP} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2018}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

% % Copyright information % Supplied to authors (based on authors' rights
% management selection; % see authors.acm.org) by publisher for camera-ready
% submission; % use 'none' for review submission.
\setcopyright{none}
\usepackage{amsmath, amssymb, verbatim, enumerate, graphicx, centernot, tikz,
array, mathtools, bussproofs, stmaryrd, enumitem, stackengine, subcaption}
\captionsetup{compatibility=false}
\usepackage{relsize}
\usepackage{listings}
\usepackage{proof}


\lstset{
language=Caml, 
basicstyle=\linespread{0.8}\upshape\sffamily,
keywordstyle=\upshape\sffamily\color{dkblue},
keepspaces=true,
framexleftmargin=1ex,
framexrightmargin=1ex,
showstringspaces=false,
commentstyle=\itshape\rmfamily,
emph={synth,project,perm,squash,normalize,using,ins,del,lens},
emphstyle=\upshape\sffamily\color{dkblue},
columns=flexible,
% BCP: I find this distracting:
% stringstyle=\sffamily\color{dkred},
mathescape,
 }

% %%%% Macros Colors
\definecolor{dkblue}{rgb}{0,0.1,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{dkred}{rgb}{0.6,0,0}
\definecolor{dkpurple}{rgb}{0.7,0,0.4}
\definecolor{olive}{rgb}{0.4, 0.4, 0.0}
\definecolor{teal}{rgb}{0.0,0.5,0.5}
\definecolor{orange}{rgb}{0.9,0.6,0.2}
\definecolor{lightyellow}{RGB}{255, 255, 179}
\definecolor{lightgreen}{RGB}{170, 255, 220}
\definecolor{teal}{RGB}{141,211,199}
\definecolor{darkbrown}{RGB}{121,37,0}

\newcommand{\FINISH}[3]{\ifdraft\textcolor{#1}{[#2: #3]}\fi}
\newcommand{\bcp}[1]{\FINISH{dkred}{B}{#1}}
\newcommand{\BCP}[1]{\FINISH{dkred}{B}{\bf #1}}
\newcommand{\afm}[1]{\FINISH{dkgreen}{A}{#1}}
\newcommand{\dpw}[1]{\FINISH{dkblue}{D}{#1}} % Toronto Maple Leafs Blue :-)
\newcommand{\saz}[1]{\FINISH{orange}{SZ}{#1}}
\newcommand{\ksf}[1]{\FINISH{teal}{K}{#1}}
\newcommand{\sam}[1]{\FINISH{dkpurple}{SM}{#1}}

% For Inference Rules
\newcommand{\Rule}[2]{\infer{#2}{#1}}
\newcommand{\RuleSide}[3]{\infer[#3]{#2}{#1}}
% \newcommand{\Axiom}[1]{\Rule{}{#1}}

\newcommand{\wf}[1]{\ensuremath{#1\;\mathsf{wf}}}

% FOR Regular Expression names
\newcommand{\re}[1]{\ensuremath{\mathtt{#1}}}
\newcommand{\kw}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\codefont}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\project}[2]{\ensuremath{\kw{project} \; #1 \mapsto #2}}
\newcommand{\squash}[3]{\ensuremath{\kw{squash} \; #1 \rightarrow #2\; \kw{using} \; #3}}
\newcommand{\perm}[2]{\ensuremath{\kw{perm}\; (#1)\; \kw{with}\; #2}}
\newcommand{\normalize}[3]{\ensuremath{\kw{normalize} \; (#1, #2, #3)}}
\newcommand{\sep}{\ensuremath{\ | \ }}
\newcommand{\canonizer}{\ensuremath{\kw{Canonizer}}}
\newcommand{\bibtex}{\textsc{Bib}\TeX{}}
\newcommand{\get}{\ensuremath{\kw{get}}}
\newcommand{\semicolon}{\ensuremath{\; ; \;}}
\newcommand{\lput}{\ensuremath{\kw{put}}}
\newcommand{\create}{\ensuremath{\kw{create}}}
\newcommand{\eqrel}[1]{\ensuremath{\equiv_{#1}}}

\newcommand{\Name}{Optometrist}

\newcommand{\QRESize}{\textbf{QS}}
\newcommand{\CanonizerAndSpecSize}{\textbf{CS}}
\newcommand{\LensAndSpecSize}{\textbf{LS}}

\newcommand{\OpticianRuntime}{\textbf{OO}}
\newcommand{\SystemOnOptician}{\textbf{SO}}
\newcommand{\SystemOnBenchmarks}{\textbf{SS}}
\newcommand{\cd}[1]{\lstinline[backgroundcolor=\color{white}]$#1$}


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Synthesizing Quotient Lenses}
\begin{abstract}
While there currently exist many bidirectional programming languages, many of
them do not have built-in support for transformations that operate on data
modulo equivalence relations such as whitespace or permutation quotienting.
Moreover, langauges such as Boomerang which do allow for such transformations
are often difficult to program \sam{why?}. To address these shortcomings, this
paper (1) introduces a language of {\em quotient regular expressions} or QREs
for defining equivalences on regular expressions as well as a language of {\em
QRE lenses}, which are lenses that map between QREs, and (2) shows how to {\em
synthesize} QRE lenses from a pair of QREs and a set of example input-output
pairs. We also describe an implementation of QREs and QRE lens synthesis in
Boomerang, and demonstrate the utility of our implementation by using it to
synthesize QRE lenses between data formats drawn from {\tt data.gov} database.
\end{abstract}

\keywords{quotient regular expressions, QRE lens, synthesis}
\maketitle

\section{Introduction}

Oftentimes, the same data is stored in a variety different formats. For
example, \bibtex{} and EndNote both store bibliography data; spreadsheet data
can be represented as a CSV file or a TSV file; web APIs can return data as a
JSON or
XML object. When different applications manipulate the same data in different formats,
synchronizing the applications amounts to synchronizing their respective data
formats. One way to synchronize data formats is to use \emph{lenses}, \emph{i.e.,} programs that represent pairs of functions for translating data from
format A to B (the \emph{get} direction) and back again (the \emph{put}
direction).  These lenses, when defined using domain-specific
languages like Boomerang~\cite{boomerang} or
BiGul~\cite{ko2016bigul}, typically come with a variety of guarantees,
\emph{lens laws}, that help ensure put and get functions are effective
inverses of one another.%comprise such synchronization functions, and the ``lens
%laws'' provide restrictions on how these synchronization functions interoperate%.
%Bidirectional languages like Boomerang~\cite{boomerang} and
%BiGul~\cite{DBLP:conf/pepm/KoZH16} use a single expression to encode all of the
%lens's synchronization functions at the same time.

One way to classify lenses is by the laws they obey.  Amongst the most
restrictive lenses are the \emph{bijective lenses}.  These lenses demand
that get and put functions form a bijection, meaning no information
is lost when one translates from one data format to another.  While this
strong guarantee can be useful in some contexts, it is more often the case
that some of the information in one or both of the data formats is superfluous.
For instance, one typically does not care to preserve the amount of
whitespace between characters.  In other circumstances, capitalization
or the order of fields in a record or items in a list may be unimportant.
%
%bijective lenses have
%strong correctness guarantees, they are often
%However, these lens laws are too restrictive for many important transformations.
%The bijective lens laws do not permit transformations that ignore this
%unimportant information---.
Many data formats have other ad hoc rules as well.
In bibliographies, for example, recall that in \bibtex{},
an author can be specified as
``\cd{lastname, firstname}'' or as ``\cd{firstname lastname}''---it does not matter which of the
two formats is used.
%While it is important to allow authors
%to be input in both ways, we would like these authors to only be output as
%\cd{firstname lastname}, but the lens laws prevent such functions.
%
{\em Quotient lenses}~\cite{quotientlenses} loosen many of the restrictions
of bijective lenses by introducing an equivalence relation and considering
bijections modulo that relation.  Such quotient lenses make it possible
to align many more data sources than would otherwise be possible by
ignoring details that a programmer views as inessential.
%each of the data formats is quotiented by some equivalence relation and the lens
%laws are taken modulo equivalence.
%This allows lenses to be simpler and more
%flexible. For example, inessential details like whitespace and orderings of
%fields can be ignored when writing the transformations between the formats.

%However, while plain lenses are widely used in both standalone systems and
%popular libraries, Boomerang~\cite{boomerang} is the only implementation
%currently offering quotient lenses. Even though quotient lenses permit simpler
%transformations between the formats, they merely push complexity elsewhere.
Ordinary bijective lenses are fairly tricky to program, especially for
beginners, as they require programmers to think in two directions at once
and to learn a new type system, which comes with some tricky ambiguity constraints.
Unfortunately, quotient lenses do not improve the situation:  To
write a quotient lens in Boomerang, programmers must work with standard lens
combinators as well as a system of \emph{canonizers}.
These canonizers encode two functions, one that
maps data represented in the original external format
to a canonical element, and another, in the opposite direction, that chooses
which elements of the original format correspond to values in the canonical
format. Furthermore, if a user wants to define the domain and range of
a lens explicitly (a programming practice that is encouraged), she must
provide regular expressions defining input and output formats.
Consequently, to define a quotient lens, one must often
construct three different sorts
of terms: (1) regular expressions that define the two data formats
to be processed, (2) canonizers to normalize the data
and choose representatives, and (3) a bijective lens that maps
one canonical form into another.  Somewhat frustratingly,
these three terms share a fair amount of structure.
%Moreover, writing the lens between the equivalence classes can be
%challenging due to the rather fiddly typechecking, mainly due to
%``non-ambiguity'' conditions in the lens well-formedness rules.

In this paper, we improve the process of programming quotient lenses
in two distinct, but connected ways. First, we
introduce a new language of {\em Quotient Regular Expressions}, or QREs, which
enable a programmer to simultaneously specify a regular expression as well as
a set of canonical representatives for strings that match the regular
expression. With
QREs, programmers do not need to define the data and canonization functions
separately---by adding simple annotations to ordinary regular expressions,
canonization functions can be inferred.

Second, we use QREs to define a class of quotient lenses called {\em QRE
lenses}, and, we show how to synthesize such QRE
lenses automatically.
More specifically, in
order to generate a lens, a programmer provides a pair of QREs
describing the source and target formats, and, optionally,
a suite of examples that demonstrates how the
lens should act on certain inputs.  Given this information,
we are able to exploit and extend recent work on algorithms for synthesis of
bijective lenses~\cite{optician} to generate quotient lenses.
Importantly, the lenses generated by
our synthesis algorithm are guaranteed to translate data back and forth
between source and target QREs and to satisfy the provided examples.
Moreover, while our synthesized quotient lenses have a relatively
restricted form (a fact that cuts down the amount of non-determinism in
a specification and thus helps speed up synthesis), we prove that
this rigidity does not compromise expressiveness.

The following list summarizes the central contributions of our work.
\begin{enumerate}
  \item We introduce {\em Quotient Regular Expressions} (QREs),
  a compact, convenient notation for simultaneously defining a
  regular language modulo some equivalence relation, and a canonizer
  for that relation (Section~\ref{QRE}).
  \item We define a language of {\em QRE lenses}.  This language is
  a subset of the full set of bijective quotient
  lenses whose types are given by QREs. Our main technical contribution
  is a proof that our QREs are just as expressive as the full set of bijective
  quotient lenses.
  % In other words, if there eeach QRE lens $q$ defines the same transformation as a
  %QRE lens $q'$ that is in normal form.
  (Section~\ref{QRE-lenses}).
  \item We reduce the problem of {\em synthesizing}
  QRE lenses to the previously studied problem of synthesizing bijective lenses
  between regular languages (Section~\ref{synth}).
  \item We extend the Boomerang {\em implementation} with QREs
  and QRE lens synthesis.  We demonstrate the utility of our
  implementation by using it to
  synthesize QRE lenses between data formats drawn from the
  {\tt data.gov} database (Section~\ref{impl}).
\end{enumerate}
Sections~\ref{relwork} discusses related work and~\ref{concl} summarizes the
results of the paper.

\section{Quotients by Example}
\label{sec:example}

%In this section, we explain the difficulties of programming with quotient
%lenses in Boomerang and show, by way of example, how our
%{\em Quotient Regular Expressions} (QREs) help alleviate these difficulties.

\emph{Lenses} define computations that can be read in two directions,
the get direction (forwards) and the put direction (backwards).  The simplest lenses define bijections between source and
data, but we are interested in \emph{quotient lenses}, which define
bijections modulo some equivalence relation.  The remainder of this section
describes and motivates a new language and system for defining such lenses.

To begin, consider a bidirectional transformation that converts
\bibtex{} citation records such as
\begin{verbatim}
@Book {Doe,
Author = "John Doe",
Title = {Generic Title}
}
\end{verbatim}
\noindent
into an equivalent EndNote format like the following
\begin{verbatim}
%0 Book
%T Generic Title
%A John Doe
%F Doe
\end{verbatim}
\noindent
and vice versa.
%
Notice that transformations from one format to the other preserve
most of the information present in the data:  the title, the author,
and the label, for instance.  However, some of the syntactic information
may be lost.  For instance, users are typically uninterested in preserving
whitespace between words or
between fields.  The order of author and title fields is also likely
irrelevant and there may be equivalent ways of writing the same
name:  ``Doe, John'' vs ``John Doe.''

%% Moreover,
%% if two \bibtex{} files differ only in ``inessential'' details, we would like
%% to treat them the same by mapping them to identical EndNote representations.
%% In this , the transformation should allow whitespace characters to occur
%% arbitrarily between the words in the label, author, and title fields, as well as
%% in between them. Second, an author's name can have the surname followed by a
%% comma and then the other names separated by arbitrary whitespace, or just all
%% the names separated by arbitrary whitespace (for example, the names ``Doe, J.
%% H.'' and ``John Doe'' are equivalent). Lastly, the transformation should
%% also ignore the order in which the author and title fields occur in each
%% citation record.

When two instances of the same format differ only terms of such inessential
information, it is often useful to treat them as identical and to map them
into canonical representations.
Continuing our example, the following two
\bibtex{} citations represent the same logical object and as a result, should
be translated to the same EndNote record.
\begin{verbatim}
@Book {Doe,
Author = "John Doe",
Title = {Generic Title},
}

@Book{     Doe,
Title = {Generic Title},
Author = "Doe, John",     }
\end{verbatim}

One natural way to define lenses that will synchronize data in these formats
is to provide the following items: \dpw{this is slightly redundant from the intro.  It
adds a little more info, but not much.  Should this be cut?  Should the intro be expanded
slightly?  Should it be left as is (more or less)?} \saz{I think that this is
not too redundant and that it can be left as-is, modulo space crunching.}

\begin{enumerate}
  \item A pair of descriptions of the external source and target formats, here
    \bibtex{} and EndNote.
  Such descriptions may be given by regular expressions, for instance.
  They serve as documentation to describe the domains over which the lens
  is to operate.
  \item A pair of \emph{canonizers} that map external source (and target)
  objects into internal, canonical forms.  Such canonizers will take
  care of stripping away irrelevant information and otherwise normalizing
  differences between equivalent representations of the same logical data.
  When given an internal representation, such canonizers must also operate
  in the reverse direction, \emph{choosing} an element in the external format
  to represent the canonical internal element.
  \item A pair of descriptions of the internal source and
  target formats, again, to document the structure of the transformation.
  \item A bijective lens to map back and forth between canonical elements
  of the internal source and target formats.
\end{enumerate}

\noindent
Indeed, Boomerang's quotient lenses are structured this
way~\cite{quotientlenses}.
Of course, some of these elements are optional.  For instance, it is
not necessary to document internal and external formats.  However, we do
view it as good engineering practice to do so, as such documentation makes
lenses easier to read, understand, use and maintain.  In this case, there is
significant redundancy here:  External and internal formats
typically have some overlap; external formats and canonizers have related
structure; and the structure of bijective lens computations is largely driven
by the structure of the internal formats.  Hence, overall, a more compact
notation would simplify description and legibility of such computations.
In addition,
the lens and canonizer languages themselves can be somewhat fiddly and
difficult to
master.  For instance, to quotient out whitespace inside, and between,
fields while also ignoring field order, one must nest canonizing combinators
in a somewhat tricky way.

We propose to do away with much of this overhead, and the burden of a
fiddly programming process, by defining a single new compact notation
to specify data formats modulo an equivalence relation and then by
synthesizing the lenses that map between these formats automatically.

\subsection{Quotient Regular Expressions}
\label{subsec:qre-expressions}

A {\em Quotient Regular Expression} (QRE) defines an external regular
expression $R$, an equivalence relation $\sim$ on the language
described by $R$, and a canonical set of representatives of $\sim$,
all at once.  QREs are constructed from a simple set of primitives
and composed using familiar regular operators
(choice `\cd{|}', concatenation `\cd{.}',
and Kleene star `$^*$').  % Users may also treat QREs as pairs of
% get and put functions and compose such pairs using the functional
% composition operator `;'.

For example, to begin construction of our \bibtex{} format, we might
first define a whitespace format, which, externally, matches
any non-zero number of whitespace characters, and converts
any such whitespace into a single space character (its canonical form).
This whitespace-normalizing QRE is easily defined by using the \kw{project} primitive:

\begin{lstlisting}
let p_wsp = project wsp+ $\to$ " "
\end{lstlisting}

Sometimes there are multiple disjoint representations of the same data.
In such situations, the \kw{squash} combinator creates a QRE that
allows external data to be in either format, and converts any
data in the first format to the second.
For instance, assume that
the \codefont{comma\_name} format describes ``Doe, John''
and that the \codefont{space\_name} format describes ``John Doe''
and \codefont{s\_to\_c} is a function from the first to the second.  In this case,
the following instance of \kw{squash} creates the desired canonizer.

%Figure~\ref{fig:example-qre} illustrates
%how to specify \bibtex{} records and their canonical elements using
%QREs.

\begin{lstlisting}
let name = squash comma_name $\to$ space_name using s_to_c
\end{lstlisting}

One way to define the \codefont{s\_to\_c} canonization function used by squash
is simply to write it from scratch. (Boomerang canonizers are written in OCaml.)
However, our system will also synthesize such functions automatically from pairs
of regular languages and examples---here, \codefont{s\_to\_c} is the
\codefont{get} direction of a lens that can be synthesized by:
%
\begin{lstlisting}
let l = synth comma_name $\Leftrightarrow$ space_name using {("Doe, John", "John Doe")}
let s_to_c = get l
\end{lstlisting}
%
The first line above synthesizes a \emph{bidirectional} lens between
\codefont{comma\_name} and \codefont{space\_name} using the listed example
transformation as a guide.  The second line simply
extracts the get direction transformation from the lens,
which is what we need for \kw{squash}.

Another QRE primitive is the sequential composition combinator ``;''.  For
example, suppose that we wish to express a name as $\kw{last\_name \cdot
``,\text{''} \cdot \text{wsp+} \cdot first\_name}$, or as $\kw{first\_name\cdot
\text{wsp+} \cdot last\_name}$, with $\kw{first\_name\cdot \text{wsp+} \cdot
last\_name}$ as the canonical representation. We also wish to project away the
extra whitespace in between \kw{first\_name} and \kw{last\_name} once this
identification has been made. Then we can express this compound equivalence
relation by a composition of a \kw{squash} QRE and a QRE that projects away
the extra whitespace in between \codefont{first\_name} and \codefont{last\_name}

\begin{figure}[t]

\begin{lstlisting}
let wsp = [ \n\t\r]

(* define name representations with a space and with a comma *)
let space_name = first_name . wsp+ . last_name
let comma_name = last_name . "," . wsp+ . first_name

(* synthesize a lens that maps comma representation to space representation *)
let l = synth comma_name $\Leftrightarrow$ space_name using {("Doe, John", "John Doe")}
let s_to_c = get l

(* squash QRE maps comma_name to space_name *)
let comma_to_space = squash comma_name $\to$ space_name using (get comma_to_space)

(* map arbitrary whitespace into " " as a canonical representative *)
let p_wsp = project wsp+ $\to$ " "

(* Project away whitespace in space_name representation *)
let project_in_space = first_name . p_wsp . last_name

(* Compose the two QREs to get a canonical representation for a name *)
let name = project_in_space ; comma_to_space

(* define rest of bibtex fields *)
let name_sep = p_wsp . "and" . p_wsp
let bib_names = name | (name . name_sep . (name . name_sep)$^*$ . name)
let bib_author = "author = \"" . bib_names . "\""
let title = word | (word . p_wsp . (word . p_wsp)$^*$ . word)
let bib_title = "title = {" . title . "}"

(* allow any permutation of fields interspersed with arbitrary whitespace *)
let bib_fields = perm (label, bib_author, bib_title) with (project (wsp+ . "," . wsp+) $\to$ ",\n")
let bibtex = "@book{" . bib_fields . "}"
\end{lstlisting}

\caption{QRE specification of \bibtex{} records. }
\label{fig:example-qre}
\end{figure}

The permutation QRE combinator, \kw{perm}, allows data to be unordered. For
example, the following instance of \kw{perm} allows the label, author and title
fields (which we assume have been defined earlier) to appear in any order among
the fields of a bibliography entry.
%
\begin{lstlisting}
let bib_fields = perm (label, bib_author, bib_title)
\end{lstlisting}
%
To normalize any repeated separator between fields, one can extend a permutation
with any other QRE.  For instance, below, we normalize whitespace between fields,
leaving only comma followed by a single newline.
%
\begin{lstlisting}
let bib_fields = perm (label, bib_author, bib_title) 
                 with (project (wsp+ . "," . wsp+) $\to$ ",\n")
\end{lstlisting}
%
The final QRE combinator is the \kw{normalize} combinator.  This combinator is an
``escape hatch'' that allows a programmer to manually define a function $f$
that sends each string matching a regular expression $R$ to some canonical
representative in another regular expression $R'$. The equivalence relation
defined by the normalize combinator is hence the equivalence relation defined by
the {\em fibres} of $f$; that is, for all strings $s$ and $s'$ that match $R$,
$s$ is equivalent to $s'$ if and only if $f(s) = f(s')$.

For instance, assume that $f(s)=$ `` '' for all whitespace strings $s$. Then the
project QRE \kw{p\_wsp} which matches any non-zero number of whitespace
characters and converts any such whitespace into a single space character could
be expressed using the \kw{normalize} combinator as
\begin{lstlisting}
let p_wsp = normalize (wsp+, " ", f)
\end{lstlisting}
However, although it is in some sense ``universal'' (see the discussion below
\saz{TODO}))the \kw{normalize} QRE imposes significant requirements on the
canonization function $f$, so it is usually simpler to use the other QRE
constructs where possible. 

A QRE for the \bibtex{} format is presented in its
entirety in Figure~\ref{fig:example-qre}.

\subsection{QRE Lenses}
QREs allow users to specify regular languages modulo equivalence relations,
a first step in writing many data transformations.  However, writing the
inner bijective lens itself still takes a fair amount of work.  Each such lens
is constructed from simple primitive combinators including:
%
\begin{itemize}
  \item \kw{del} $s$: \textit{delete} the constant string $s$ in the get direction;
  insert it in the put direction.
  \item \kw{ins} $s$: \textit{insert} the constant string $s$ in the get direction;
  delete it in the put direction.
  \item \kw{copy} $R$: copy the text matching the regular expression $R$ in both
  directions.
\end{itemize}
In addition, such primitives may be combined using the regular operators
Kleene star, alternation and concatenation, or functional composition of
lenses.  Figure~\ref{fig:example-lens} illustrates the use of these
combinators to transform \bibtex{} to EndNote (and vice versa).
There is a fair amount of trickiness in writing these transformations, because
the programmer must keep mental track of what they have parsed so far \emph{in both
directions}, carefully inserting and deleting the relevant syntax on both
sides.

%% While QREs make it easier to write equivalence relations on regular expressions
%% by specifying the data and the equivalence relation on the data in one
%% expression, in order to define a quotient lens, the programmer still has to
%% manually derive the underlying lens that maps the equivalence classes of the
%% source data to the equivalence classes of the target data. This is itself a
%% tricky task as Figure~\ref{fig:example-lens} illustrates.

\begin{figure}[t]
\begin{lstlisting}
let preamble : (lens in "@book{" $\Leftrightarrow$ "%0 Book\n%F ") =
    del "@book{" . ins "%0 Book\n%F "

let author_lens : (lens in (",\n" . bib_author) $\Leftrightarrow$ ("\n" . end_author)) =
    del ",\nauthor = \""
        . ins "\n%A "
        . name
        . (del " and "
        . ins "\n"
        . (ins "%A " . name . del " and " . ins "\n")* 
        . ins "%A "
        . name
        || "")

let title_lens : (lens in ("\",\n" . bib_title . "},\n}") $\Leftrightarrow$ ("\n" . end_title)) =
    del "\",\ntitle = {" . ins "\n%T " . title . del "},\n}"

let bib_to_end : (lens in bibtex $\Leftrightarrow$ end_note) =
    preamble . label . author_lens . title_lens
\end{lstlisting}
\caption{An example lens between \cd{bibtex} and \cd{end_note} regular
expressions with no equivalences.}
\label{fig:example-lens}
\end{figure}

%% The lens shown in Figure~\ref{fig:example-lens} transforms \bibtex{} data to
%% EndNote data  (and vice versa) by matching the delimiters and separators in a
%% bijective manner. For example, the \cd{preamble} lens replaces the \bibtex{}
%% preamble \verb|@Book| with the EndNote preamble \verb|%0 Book\n%F|. When the
%% programmer is writing the lens, she has to make sure that all of these small
%% deletions and insertions are correct, which can be a challenging task if the
%% lens is large enough, as in the definition of the lens \verb!author_lens! in
%% Figure~\ref{fig:example-lens}. This makes lens programming tedious and
%% error-prone.
To make this unsavory programming task more palatable, we identify a class of
quotient lenses that we call {\em QRE lenses} and show how to {\em synthesize}
them from a pair of QREs and a set of input-output examples. Our key
insight is to reduce the problem of synthesizing QRE lenses to the problem of
synthesizing {\em bijective lenses}~\cite{optician}, a simpler subset of
lenses that support strict bijections, rather than bijections modulo
equivalence relations.

Intuitively, our QRE lenses are bijective lenses with ``canonizers at the
edges''---Figure~\ref{fig:attheedges} presents the architecture of each lens.
Every QRE lens $q$ has a type $q: c \Leftrightarrow c'$ where $c$ and $c'$ are QREs.
In the get direction, a QRE lens $q: c \Leftrightarrow c'$ uses the source
QRE $c$ to compute a unique representative for the data modulo the equivalence
relation defined by $c$ and then applies the $\get$ function of a bijective
lens $\ell$ to this representative. In the backward direction, $q$ operates
similarly,  but using the view QRE $c'$ and the $\lput$ function of $\ell$.

Because the QREs $c$ and $c'$ determine the internal formats for data after
canonization, and because the algorithm for synthesizing bijective lenses is
directed by these formats, $c$ and $c'$ are all that is required to synthesize
QRE lenses end-to-end.  Indeed, we structured QRE lenses as bijective lenses with
canonizers at the edges, precisely to facilitate the use of this synthesis algorithm.

\begin{figure}[t]
\centering
\includegraphics[width=0.7\textwidth]{canonizers-outside}
\caption{Quotient Lens with ``Canonizers at the Edges''
\sam{We don't need a general choose function. With QREs the kernel language is
always contained in the whole language so we just use the inclusion as the
choose function.}\bcp{I can fix.}}
\label{fig:attheedges}
\end{figure}

%% One potential pitfall with QRE lenses is that the combinators that we define on
%% them may not preserve this normal form. For example, the composition $q'; q$ of
%% QRE lenses $q$ and $q'$ might not be equivalent to any quotient lens that has
%% the canonical normal form of a bijective lens with canonizers at the edges.

On the other hand, our restriction that canonizers appear only at the edges
raises a key technical question:  Are we limiting the expressiveness of our transformations
by demanding all programs fit into this normal form?  It turns out that we are not:
any lens that uses canonizers internally can be transformed into a lens that uses canonizers
at the edges.  The main technical contribution of this paper is a proof of this fact.  The
crucial step in the proof is a demonstration that functional composition of two lenses
with ``canonizers at the edge'' can be represented as some single lens with ``canonizers at the
edge.''

%% For example, suppose \cd{q_1 : bibtex} $\Leftrightarrow$ \cd{endnote} is a QRE
%% lens that maps between \bibtex{} and EndNote formats, and that \cd{q_2 : endnote
%% <=> xml} is a QRE lens that maps between EndNote and XML formats. The
%% composition \cd{(q_1 ; q2) : bibtex} $\Leftrightarrow$ \cd{xml} of \cd{q_1} and
%% \cd{q_2} is not necessarily in normal form due to the presence of canonizers
%% on each side of the intermediary EndNote format:

%% \sam{TODO: We need to put a diagram of composition here.}

%% \noindent However, while \cd{q_1 ; q_2} is not in normal form, our main theorem
%% shows that there is another QRE lens \cd{q : bibtex} $\Leftrightarrow$ \cd{xml}
%% of the same type as \cd{(q_1 ; q2) : bibtex} $\Leftrightarrow$ \cd{xml} such
%% that \cd{q_1 ; q_2} and \cd{q} define the same transformation.

This technical investigation justifies replacing manually constructed lenses that may use
functional composition and nested canonizers with synthesized lenses in normal form.
The end result is that users may synthesize complex transformations with a single line
of code.  For instance, all the code in Figure~\ref{fig:example-lens} may be replaced by
a single call to the synthesis prodedure:
\begin{lstlisting}
let bib_to_end : (lens in bibtex $\Leftrightarrow$ endnote) =
    synth bibtex $\Leftrightarrow$ endnote  using  {(bib_example, end_example)}
\end{lstlisting}
\noindent Here, the generated  quotient lens synchronizes \cd{bibtex} and
\cd{endnote} formats.  It uses \cd{bib_example} and \cd{end_example} (the two
concrete example strings givn at the beginning of this section) to disambiguate.
In addition, as we saw earlier with the definition of \cd{s_to_c}, the synthesis
procedure itself can be used to create lenses that are in turn used to define
other QREs. The ability to mix QRE specification with QRE lens synthesis
yields a powerful and flexible way of creating bidirectional transformations.

\section{Quotient Regular Expressions}
\label{QRE}
\subsection{Syntax and Semantics of QREs}
Formally, the language of Quotient Regular Expressions (QREs) is given by the
following grammar:
\begin{align*}
c := \; &R \sep \project{R}{s} \sep \squash{c_1}{c_2}{f} \sep
\perm{c_1, \ldots, c_n}{c} \\
& | \; \normalize{R_1}{R_2}{f} \sep c_1 \semicolon c_2 \sep c_1 \cdot c_2 \sep (c_1 \sep
c_2) \sep c^*,
\end{align*}
where $c$ ranges over QREs, $R$ ranges over regular expressions, $f$ ranges over
functions between regular languages, and $s$ ranges over character strings.

Using the conventional notation that $\mathcal{L}(R)$ is the language accepted
by the regular expression $R$, then each QRE $c$ enables us to express
\begin{enumerate}
  \item a regular expression $W(c)$ (the ``whole'' of $c$),
  \item an equivalence relation $\eqrel{c}$ on $\mathcal{L}(W(c))$,
  \item a regular expression $K(c)$ (the ``kernel'' of $c$)
  such that $\mathcal{L}(K(c))$ forms a complete set of representatives for
  $\eqrel{c}$, and
  \item a ``canonizing'' function $\canonizer(c):\mathcal{L}(W(c))
  \longrightarrow \mathcal{L}(K(c))$ which given any $w \in \mathcal{L}(W(c))$,
  computes $\canonizer(c)(w)$ as the unique $k$ in $\mathcal{L}(K(c))$ such that
  $k$ is equivalent to $w$ mod $\eqrel{c}$
\end{enumerate}
Figures~\ref{fig:wk} gives the inductive definitions for the whole and
kernel languages $W(c)$ and $K(c)$ of a QRE.
\begin{figure}[t]
\centering
\[
\begin{array}{l@{\quad}l@{\quad}l}

c & W(c) & K(c) \\ \hline
R & R & R \\
\project{R}{s} & R & s \\
\squash{c_1}{c_2}{f} & W(c_1) \sep W(c_2) & K(c_2) \\
\normalize{R_1}{R_2}{f} & R_1 & R_2 \\
c_1 \; ; \; c_2 & W(c_1) & K(c_2) \\
c_1 \cdot c_2 & W(c_1) \cdot W(c_2) & K(c_1) \cdot K(c_2) \\
c_1 \sep c_2 & W(c_1) \sep W(c_2) & K(c_1) \sep K(c_2) \\
c^* & W(c)^* & K(c)^* \\
\end{array}
\]
\[
\begin{array}{r@{\quad}l}
W( \perm{c_1, \ldots, c_n}{c} ) = &
\bigcup \limits_{\sigma \in S_n} W(c_{\sigma(1)}) \cdot W(c) \cdot \ldots \cdot
W(c) \cdot W(c_{\sigma(n)})\\
K( \perm{c_1, \ldots, c_n}{c} ) = & K(c_1) \cdot K(c) \cdot \ldots \cdot K(c)
\cdot K(c_n)
\end{array}
\]
\caption{Whole and Kernel Regular Expressions \saz{Mentions somewhere that $S_n$
    is the set of all permutations.} \saz{Check that the semi-colon
    case is still correct}}
\label{fig:wk}
\end{figure}
The \kw{squash} and \kw{permutation} combinators give the two interesting
definitions. If $c = \squash{c_1}{c_2}{f}$, then the whole language of $c$ is
$W(c_1) \sep W(c_2)$. This is because the \kw{squash} combinator uses the
function $f : \mathcal{L}(W(c_1)) \longrightarrow \mathcal{L}(W(c_2))$ to maps
any strings from $\mathcal{L}(W(c_1))$ into $\mathcal{L}(W(c_2))$ (leaving the
$c_2$ strings alone), and then canonizes $W(c_2)$ into $K(c_2)$ using
$\canonizer(c_2)$.

For the $\perm{c_1, \ldots, c_n}{c}$ combinator, the whole language is the
union of languages of the form $W(c_{\sigma(1)}) \cdot W(c) \cdot \ldots \cdot
W(c) \cdot W(c_{\sigma(n)})$. This is because the \textit{permutation}
combinator allows for the string to match any permutation the $c_i$'s while also
taking into account the separator $c$ in between each of the $c_i$'s. The kernel
of the \textit{permutation} combinator is the language $K(c_1) \cdot K(c) \cdot
\ldots \cdot K(c) \cdot K(c_n)$, because the canonical permutation is the
identity permuation, with each of the parts of the string that match $c_i$
and $c$ canonized into $K(c_i)$ and $K(c)$ respectively.

Figure~\ref{fig:canonizers} gives the inductive definitions of the
$\canonizer{}$ function for each QRE.
\begin{figure}[t]
\begin{center}
\[
\begin{array}{l@\quad l @\quad l}
\canonizer(R) &=& id_{\mathcal{L}(R)} \\
\canonizer(\project{R}{s})(w) &=& s\\
\canonizer(\squash{c}{c'}{f})(w) &=&
\begin{cases}
\canonizer(c)(f(w)) & \text{if } w \in \mathcal{L}(W(c))\\
\canonizer(c')(w) & \text{otherwise}
\end{cases}\\
\canonizer(\normalize{R}{R'}{f}) &=& f\\
\canonizer(c' \; ; \; c) &=& \canonizer(c') \circ \canonizer(c)\\
\canonizer(c' \cdot c) &=& \canonizer(c') \cdot \canonizer(c)\\
\canonizer(c_1 \sep c_2)(w) &=&
\begin{cases}
\canonizer(c_1)(w) & \text{if } w \in \mathcal{L}(W(c_1))\\
\canonizer(c_2)(w) & \text{if } w \in \mathcal{L}(W(c_2))\\
\end{cases}\\
\canonizer(c^*) &=& \canonizer(c)^* \\
\end{array}
\]
\end{center}
\begin{align*}
&\canonizer(\perm{c_1, \ldots, c_n}{c})(r_{\sigma(1)}
\cdot s_1 \cdot \ldots \cdot s_{n-1} \cdot r_{\sigma(n)})\\
&= (\canonizer(c_1)(r_1)) \cdot (\canonizer(c)(s_1)) \cdot \ldots \cdot
(\canonizer(c_n)(r_n))
\end{align*}
\caption{QRE canonizers \saz{TODO: use $c_1$ and $c_2$ everywhere.}}
\label{fig:canonizers}
\end{figure}
Again, the \textit{permutation} combinator gives the most interesting
definition,
\begin{align*}\canonizer(\perm{c_1, \ldots, c_n}{c})(r_{\sigma(1)}
\cdot s_1 \cdot \ldots \cdot s_{n-1} \cdot r_{\sigma(n)}) \\
= (\canonizer(c_1)(r_1)) \cdot (\canonizer(c)(s_1)) \cdot \ldots \cdot
(\canonizer(c_n)(r_n))
\end{align*}
\noindent which as we have explained is defined so that the strings that match
$c_i, c$ are placed in the canonical permutation which is the identity
permutation before $\canonizer(c_i)$ and $\canonizer(c)$ are applied
respectively.

Finally, Figure ~\ref{fig:relations} gives the induction defintion of the
equivalence relation $\eqrel{c}$. These are the set-theoretic semantics of QREs
as an equivalence relation on a regular language.

\begin{figure}[t]
\centering
\[
\begin{array}{l@{\quad}l@{\quad}l}
w \; \equiv_R \; w' &\iff& w = w' \\
w \; \equiv_{\project{R}{s}} \; w' \text{ for all }w, w'\\
w \; \equiv_{\squash{c}{c'}{f}} \; w' &\iff& f(w) \equiv_{c'} w'
\text{ or } w \equiv_{c'} w' \\
w \; \equiv_{\normalize{R}{R'}{f}} \; w' &\iff&
f(w)=f(w') \text{ or }w = w'\\
w \; \equiv_{c_2 \; ; \; c_1} \; w' &\iff& \exists k, k' \in
\mathcal{L}(K(c_2)) \text{ such that } w \; \equiv_{c_1} \; k, \; w' \;
\equiv_{c_1} \; k', \text{ and } k \; \equiv_{c_2} \; k'\\
w \; \equiv_{c_1 \cdot c_2} \; w'  &\iff& w = r_1
\cdot r_2, \; w' = {r'}_1 \cdot {r'}_2 \text{ with } r_1 \; \equiv_{c_1}
\; {r'}_1, \; r_2 \; \equiv{c_n} \; {r'}_2\\
w \; \equiv_{c' \sep c} \; w' &\iff& w \; \equiv_{c_1} \; w'
\text{ or } \; w \; \equiv_{c_2} \; w'\\
w \; \equiv_{c^*} \; w' &\iff& w = r_1 \cdot \ldots \cdot r_n, \; w'
= {r'}_1 \cdot \ldots \cdot {r'}_n \text{ and } r_i \equiv_{c} \; {r'}_i
\\
w \; \equiv_{\perm{c_1, \ldots, c_n}{c}} \; w' &\iff& w = r_{\sigma(1)}
\cdot s_1 \cdot \ldots \cdot s_{n-1} \cdot r_{\sigma(n)}, \;
w' = {r'}_{\theta(1)} \cdot s'_1 \cdot \ldots \cdot s'_{n-1}
\cdot {r'}_{\theta(n)} \\
& & \text{ for some } \sigma, \theta \in S_n, \text{ with } r_i \;
\equiv_{q_i} \; r'_i \text{ and } s_k \; \equiv_{c} \; s'_{k}
\end{array}
\]
\caption{QRE Equivalence Relations \saz{TODO: use $c_1$ and $c_2$ everywhere.}}
\label{fig:relations}
\end{figure}
\subsection{Ambiguity and Well Formed QREs}
Before giving the inferrence rules for deriving well formed QREs, we address
the issue of {\em ambiguity}, which appears in the premises of the inferrence
rules for the regular combinators. If $c$ and $c'$ are QREs, then when applying
the regular combinators to QREs, we require that if a string $s$ matches any of
the regular expressions $W(c) \cdot W(c')$, $W(c) \sep W(c')$, $W(c)^*$, $K(c)
\cdot K(c')$, $K(c) \sep K(c')$, $K(c)^*$, then $s$ matches that regular
expression in only one way. This unambiguity condition is called {\em strong
unambiguity}~\cite{Sippu1988}, and is necessary because it ensures
that the canonizing function of a QRE is well-defined.

For example consider the QRE

\begin{lstlisting}
let ambiguous : canonizer = "a"* . (project "a"* $\to$ "a")
\end{lstlisting}

\noindent The behaviour of \cd{ambiguous} is not-well defined since the string
\cd{"aaa"} can be canonized to any of \cd{"a"}, \cd{"aa"}, or \cd{"aaa"} depending on how
\cd{"aaa"} is parsed. We also require that the regular combinators applied to
the kernels be unambiguous since the underlying lenses will end up operating
on the kernels, and these lenses impose the same restrictions for similar
reasons.

To this end, we say that regular expressions $R$ and $S$ are
\textit{unambiguosly concatenable}, written $R \cdot^! S$ if for all strings
$r, r' \in \mathcal{L}(R)$ and $s, s' \in \mathcal{L}(S)$, if $r \cdot s = r'
\cdot s'$, then $r = r'$ and $s = s'$. We say that a regular expression $R$ is
\textit{unambiguosly iterable}, written $R^{*!}$ if for all strings $r_1,
\ldots, r_m$ and $r'_1, \ldots, r'_n \in \mathcal{L}(R)$, if $r_1 \cdot \ldots
\cdot r_m = r'_1 \cdot \ldots \cdot r'_n$, then $m = n$ and $r_i = r'_i$.

We say that a regular expression $R$ is \textit{strongly unambiguous} if and
only if (1) $R = \varnothing$, or (2) $R = S_1 \cdot S_2$ with $S_1, S_2$
strongly unambiguous and $S_1 \cdot^! S_n$, or (3) $R = S_1 \sep S_2$ with
$S_1, S_2$ strongly unambiguous and $\mathcal{L}(S_1) \cap \mathcal{L}(S_2) =
\varnothing$, or (4) $R = S^*$ with $S$ strongly unambiguous and $S^{*!}$.

Figure~\ref{fig:qrerules} gives the inferrence rules for deriving well-formed
QREs.
\begin{figure}[tp!]
\begin{center}
\AxiomC{$R$ is strongly unambiguous}
\UnaryInfC{$\wf{\mathit{id}(R)}$}
\DisplayProof
\hskip 1.5em
\AxiomC{$s \in \mathcal{L}(R)$}
\UnaryInfC{$\wf{\project{R}{s}}$}
\DisplayProof
\hskip 1.5em
\end{center}

\begin{prooftree}
\AxiomC{$\wf{c_i, c}$}
\AxiomC{${\substack{\forall \sigma \neq \theta, \; W(c_{\sigma(1)}) \cdot W(c)
\cdot \ldots \cdot W(c_{\sigma(n)})\\ \cap W(c_{\theta(1)}) \cdot W(c)
\cdot \ldots \cdot W(c_{\theta(n)}) =\varnothing}}$}
\AxiomC{$K(c_1) \cdot^! K(c) \cdot^! \ldots \cdot^! K(c) \cdot^! K(c_n)$}
\TrinaryInfC{$\wf{\perm{c_1, \ldots, c_n}{c}}$}
\end{prooftree}

\begin{center}
\AxiomC{$\wf{c, c'}$}
\AxiomC{$\mathcal{L}(W(c)) \cap \mathcal{L}(W(c')) = \varnothing$}
\AxiomC{$f : \mathcal{L}(W(c)) \longrightarrow \mathcal{L}(W(c'))$}
\TrinaryInfC{$\wf{\squash{c}{c'}{f}}$}
\DisplayProof
\end{center}
\begin{center}

\begin{prooftree}
\AxiomC{$\mathcal{L}(R') \subseteq \mathcal{L}(R)$}
\AxiomC{$f : \mathcal{L}(R) \longrightarrow \mathcal{L}(R')$}
\AxiomC{$f$ is surjective}
\AxiomC{$f = f^2$}
\QuaternaryInfC{$\wf{\normalize{R}{R'}{f}}$}
\end{prooftree}

\end{center}
\begin{center}
\AxiomC{$\wf{c, c'}$}
\AxiomC{$K(c) = W(c')$}
\BinaryInfC{$\wf{c' \; ; \; c}$}
\DisplayProof
\hskip 1.5em
\AxiomC{$\wf{c}$}
\AxiomC{$W(c)^{*!}$}
\AxiomC{$K(c)^{*!}$}
\TrinaryInfC{$\wf{c^*}$}
\DisplayProof
\end{center}
\begin{center}

\begin{center}
\AxiomC{$\wf{c, c'}$}
\AxiomC{$W(c) \cdot^! W(c')$}
\AxiomC{$K(c) \cdot^! K(c')$}
\TrinaryInfC{$\wf{c \cdot c'}$}
\DisplayProof
\end{center}

\begin{center}
\AxiomC{$\wf{c, c'}$}
\AxiomC{$W(c) \cap W(c') = \varnothing$}
\BinaryInfC{$\wf{c \cdot c}$}
\DisplayProof
\hskip 1.5em
\AxiomC{$\wf{c}$}
\AxiomC{$W(c)^{*!}$}
\AxiomC{$K(c)^{*!}$}
\TrinaryInfC{$\wf{c^*}$}
\DisplayProof
\end{center}
\end{center}
\caption{Well-formed QREs
}
\label{fig:qrerules}
\end{figure}
As we already mentioned, the unambiguity conditions come into play when defining
QREs using the regular combinators. For example, the inferrence rule for
concatenation is as follows:
\begin{prooftree}
\AxiomC{$\wf{c, c'}$}
\AxiomC{$W(c) \cdot^! W(c')$}
\AxiomC{$K(c) \cdot^! K(c')$}
\TrinaryInfC{$\wf{c \cdot c'}$}
\end{prooftree}

\noindent This rule says that the concatenation $c \cdot c'$ of QREs $c$ and
$c'$ is well formed only if the concatentions of $W(c)$ and $W(c')$, and
$K(c)$ and $K(c')$ are unambiguous.

The most complicated inferrence rule is the rule for the \textit{permutation}
combinator:

\begin{prooftree}
\AxiomC{$\wf{c_i, c}$}
\AxiomC{${\substack{\forall \sigma \neq \theta, \; W(c_{\sigma(1)}) \cdot W(c)
\cdot \ldots \cdot W(c_{\sigma(n)})\\ \cap W(c_{\theta(1)}) \cdot W(c)
\cdot \ldots \cdot W(c_{\theta(n)}) =\varnothing}}$}
\AxiomC{$K(c_1) \cdot^! K(c) \cdot^! \ldots \cdot^! K(c) \cdot^! K(c_n)$}
\TrinaryInfC{$\wf{\perm{c_1, \ldots, c_n}{c}}$}
\end{prooftree}

\noindent The second hypothesis for the \textit{permutation} rule says that for
any two different permutations $\sigma$ and $\theta$, the languages
$W(c_{\sigma(1)}) \cdot W(c) \cdot \ldots \cdot W(c_{\sigma(n)})$ and
$W(c_{\theta(1)}) \cdot W(c) \cdot \ldots \cdot W(c_{\theta(n)})$ must be
disjoint. This is because any string that matches the \textit{permutation}
combinator matches the language $W(c_{\theta(1)}) \cdot W(c) \cdot \ldots \cdot
W(c_{\theta(n)})$ for some permutation $\theta$, so we require that these
regular expressions be disjoint.

The third hypothesis says that the regular expression $K(c_1) \cdot K(c)
\cdot \ldots \cdot K(c) \cdot K(c_n)$ must be unambiguous. This is because the
underlying lens that maps to or from a \textit{permutation} QRE operates on
the language $K(c_1) \cdot K(c) \cdot \ldots \cdot K(c) \cdot K(c_n)$ which is
the kernel of the \textit{permutation} QRE. As we mentioned, the underlying
lens will require that the source and target regular expressions of the lens be
unambiguous so that the lens can match strings uniquely.

At this point we also bring to attention the fact that in order for the {\em
normalize} QRE to be well-formed, then canonizing function $f$ used by this
combinator must be surjective and idempotent. Unfortunately, verifying
that a function satisfies these properties is in general undecidable.
Nonetheless, we allow a programmer to use normalize at their own risk without
checking these side conditions.

We do this firstly because the {\em normalize} combinator allows one to express
equivalence relations that are either difficult to define, or that cannot be
defined using the other combinators. Secondly, the {\em normalize} canonizer
enjoys the property that each of the other combinators $c$ is semantically
equivalent to $\normalize{W(c)}{K(c)}{f}$ for some surjective, idempotent
function $f : \mathcal{L}(W(c)) \longrightarrow \mathcal{L}(K(c))$. The {\em
normalize} combinator hence gives a sufficient condition for potential QREs to
be ``well-behaved'', particularly with respect to our strategy for synthesizing
quotient lenses which we shall introduce in Section~\ref{synth}.

In spite of this ``completeness'' property of the {\em normalize} combinator,
our experience with QREs shows that using the {\em project}, {\em squash} and
{\em perm} combinators as well as the regular operators applied to these is
much easier than using just {\em normalize} because of the compositional nature
of the other combinators.

The formal semantics of QREs satisfy the following theorem:
\begin{theorem}
If $c$ is a well formed QRE, then
\begin{enumerate}
  \item $W(c)$ and $K(c)$ are well defined regular expressions,
  \item  $\eqrel{c}$ is an equivalence relation on $\mathcal{L}(W(c))$,
  \item  $\mathcal{L}(K(c))$ forms a complete set of representatives for
  $\eqrel{c}$,
  \item $\canonizer(c):\mathcal{L}(W(c)) \longrightarrow \mathcal{L}(K(c))$ is
  a well-defined function, and
  \item  given any $w \in \mathcal{L}(W(c))$, $\canonizer(c)(w)$ is the unique
  $k$ in $\mathcal{L}(K(c))$ such that $k$ is equivalent to $w$ modulo
  $\eqrel{c}$.
\end{enumerate}
\end{theorem}
\section{QRE Lenses}
\label{QRE-lenses}
As we have seen, QREs express a broad class of equivalence relations
directly on regular languages.  QREs are therefore a good \textit{specification}
language for quotient lenses. In this section of the paper, we introduce
\textit{QRE Lenses}, a class of quotient lenses specified using QREs.

Given regular expressions $R, S$ and equivalence relations
$\sim_R$ and $\sim_S$ defined on $\mathcal{L}(R)$ and $\mathcal{L}(S)$
respectively, we define a {\em bijective quotient lens} $q : R /{\sim_R}
\Leftrightarrow S/{\sim_S}$ to be a pair of functions $q.get :
\mathcal{L}(R) \longrightarrow \mathcal{L}(S)$ and $q.put : \mathcal{L}(S)
\longrightarrow \mathcal{L}(R)$ such that for all $r \in \mathcal{L}(R)$ and $s
\in \mathcal{L}(S)$,
\begin{align*}
q.put(q.get(r)) &\sim_R r \text{, and}\\
q.get(q.put(s)) &\sim_R s
\end{align*}
Moreover, if $r \sim_R r'$, then $q.get(r) = q.get(r')$, and if $s \sim_S s'$,
then $q.put(s) = q.put(s')$.

In words, a bijective quotient lens $q$ from $R$ to $S$ modulo $\sim_R$
and $\sim_S$ is a pair of functions $q.get$ and $q.put$ such that $q.get$
respects $\sim_R$ and $q.put$ respects $\sim_S$, and such that the respective
functions defined on $\mathcal{L}(R)/{\sim_R}$ and $\mathcal{L}(S)/{\sim_S}$ are
mutual inverses of each other.

Now let $c$ and $c'$ be QREs. Given a bijection $\ell : K(c) \Leftrightarrow
K(c')$, we may define a quotient lens $q : W(c)/\eqrel{c} \Leftrightarrow
W(c')/\eqrel{c'}$ by
\begin{equation}\label{normalform}
q.get = \ell \circ \canonizer(c) \text{ and } q.put = \ell^{-1} \circ
\canonizer(c'),
\end{equation}

\noindent In other words, the get function of the $q$ first canonizes the source
data using $\canonizer(c)$ and then applies $f$ to the result, while the
put function of the $q$ first canonizes the target data using
$\canonizer(c')$ and the applies $f^{-1}$ to the result. This is our approach in
defining QRE lenses.

One potential pitfall with QRE lenses is that the combinators that
we define on them may not preserve this normal form. For example, the
composition $q' \; ; \; q$ of QRE lenses $q$ and $q'$ may not be equivalent to
any quotient lens that has the canonical normal form of a bijective lens with
canonizers a the edges. Consequently, in order to guarantee that every QRE
lens $q$ is equivalent to a QRE lens $q'$ which has the canonical form of
a bijection with canonizers at the edges, we need to identify a set $S$ of
bijections that will ensure that QRE lenses are closed under the action of QRE
lens combinators. Our choice is to use the class of \textit{bijective lenses},
which we briefly discuss in the next section.

\subsection{Bijective Lenses}
We define the set of \textit{bijective lenses} to be the set of bijections
between regular languages created using Boomerang lens combinators.
The syntax for the language of bijective lenses is given by
$$\ell := \mathit{id} \; (R) \sep const(s, s') \sep  swap(\ell,
\ell) \sep \ell \cdot \ell' \; |  \; (\ell \sep \ell') \sep \ell^* \;
| \; \ell \circ \ell',$$ where $R$ ranges over regular expressions and $s$
ranges over character strings.

The denotation of a lens $\ell$ is $\llbracket \ell \rrbracket \subseteq
\mathit{String} \times \mathit{String}$. If $(s_1, s_2) \in \llbracket \ell
\rrbracket$, then $\ell$ maps between $s_1$ and $s_2$.
\begin{align*}
\llbracket R \rrbracket &= \{(r, r) \sep r \in \mathcal{L}(R)\}\\
\llbracket const(r, s) \rrbracket &= \{(r, s)\}\\
\llbracket swap(\ell, \ell') \rrbracket &= \{(s \cdot t, t' \cdot s') \sep
(s, s') \in \llbracket \ell \rrbracket \text{ and } (t, t') \in \llbracket
\ell' \rrbracket\}\\
\llbracket \ell \cdot \ell' \rrbracket &= \{(s \cdot t, s' \cdot t) \sep
(s, s') \in \llbracket \ell \rrbracket \text{ and } (t, t') \in \llbracket
\ell' \rrbracket\}\\
\llbracket \ell \sep \ell' \rrbracket &= \{(s \cdot t) \sep
(s, t) \in \llbracket \ell \rrbracket \text{ or } (s, t) \in \llbracket
\ell' \rrbracket\}\\
\llbracket \ell^* \rrbracket &= \{(s_1 \cdot \ldots \cdot s_n, t_1 \cdot \ldots
\cdot t_n) \sep (s_i, t_i) \in \llbracket \ell \rrbracket \text{ for } 1
\leq i \leq n\}\\
\llbracket \ell_2 \circ \ell_1 \rrbracket &= \{(r, t) \sep \text{there exists }s
\text{ such that } (r, s) \in \llbracket \ell_1 \rrbracket \text{ and } (s, t)
\in \llbracket \ell_2 \rrbracket\}
\end{align*}
The $\mathit{const}(s, t)$ lens replaces the string $s$ with $t$ in the source
data in the forward direction, and $t$ with $s$ in the target data in the backward
direction. $\mathit{id}(R)$ applies the identity function to the source and target
in $\mathcal{L}(R)$ in both directions. The composition lens $\ell' \circ \ell$
applies $\ell$ followed by then $\ell'$ to the source in the forward direction,
and applies $\ell'$ followed by $\ell$ to the target in the backward direction.
The lens $\ell \cdot \ell'$ first splits the string $s$ into $s_1$ and $s_2$,
applies $\ell$ and $\ell'$ to $s_1$ and $s_2$ to get $t_1$ and $t_2$
respectively, then concatenates $t_1$ and $t_2$ and returns $t_1 \cdot t_2$ as
the final result in the forward direction. $\ell \cdot \ell'$ operates
similarly in the backward direction, but with $s, s_1$ and $s_2$ substituted
for $t, t_1$ and $t_2$. The $\mathit{swap} \; (\ell, \ell')$ lens operates
like $\ell \cdot \ell'$, except that it swaps $t_1$ and $t_2$ before
concatenating the two for a final result of $t_2 \cdot t_1$ in the forward
direction. In the backward direction, $\mathit{swap}(\ell, \ell')$ first undoes
the swap, then proceeds as expected. The $\ell \; | \; \ell'$ lens
chooses to apply $\ell$ or $\ell'$ depending on whether the source
(resp. target) data is matched by $\ell$ or $\ell'$ in the forward (resp.
backward direction). The $\ell^*$ lens splits the string $s$ into strings $s_1,
\ldots, s_n$, applies $\ell$ to each $s_i$ to get $t_i$, and then concatenates
each of the $t_i$'s for a final result of $t_1 \cdot \ldots \cdot t_n$ in the
forward direction. $\ell^*$ operates similarly in the backward direction, but
with $s, s_i$ substituted for $t, t_i$.

Each bijective lens $\ell$ has a type $\ell : R \Leftrightarrow S$ where $R$ and
$S$ are regular expressions. If $\ell : R \Leftrightarrow S$, then the source
language of $\ell$ is $\mathcal{L}(R)$ and the target language of $\ell$ is
$\mathcal{L}(S)$. Interestingly, with the bijective lens type system, a lens
$\ell : R \Leftrightarrow S$ can also be considered to be of type $\ell : R'
\Leftrightarrow S'$ provided that $R$ (resp. $S$) can be proven to be
equivalent to $R'$ (resp. $S$) from the star-semiring axioms:

\begin{prooftree}
\AxiomC{$\ell : R \Leftrightarrow S$}
\AxiomC{$R \equiv^s R'$}
\AxiomC{$S \equiv^s S'$}
\TrinaryInfC{$\ell : R' \Leftrightarrow S'$}
\end{prooftree}

The other typing rules for bijective lenses are given in
Figure~\ref{fig:lensrules}.

\begin{figure}[t]
\begin{center}
\AxiomC{$s_1 \in \Sigma^*$}
\AxiomC{$s_2 \in \Sigma^*$}
\BinaryInfC{$\mathit{const} \; (s_1, s_t): s_1 \Leftrightarrow s_2$}
\DisplayProof
\hskip 1.5em
\AxiomC{$R$ is strongly unambiguous}
\UnaryInfC{$\mathit{id} \; (R): R \Leftrightarrow R$}
\DisplayProof
\end{center}

\begin{center}
\AxiomC{$\substack{\ell_1 : R_1 \Leftrightarrow S_1 \\ \ell_2 : R_2
\Leftrightarrow S_2}$}
\AxiomC{$\substack{R_1 \cdot^! R_2 \\S_1 \cdot^! S_2 }$}
\BinaryInfC{$\ell_1 \cdot \ell_2: R_1 \cdot R_2 \Leftrightarrow S_1 \cdot
S_2$}
\DisplayProof
\hskip 1.5em
\AxiomC{$\substack{\ell_1 : R_1 \Leftrightarrow S_1 \\ \ell_2 : R_2
\Leftrightarrow S_2}$}
\AxiomC{$\substack{R_1 \cdot^! R_2 \\ S_2 \cdot^! S_1}$}
\BinaryInfC{$\mathit{swap} \; (\ell_1, \ell_2): R_1 \cdot R_2
\Leftrightarrow S_2 \cdot S_1$}
\DisplayProof
\end{center}

\begin{center}
\AxiomC{$\ell_1 : R_1 \Leftrightarrow R_2$}
\AxiomC{$\ell_2 : R_2 \Leftrightarrow R_3$}
\BinaryInfC{$\ell_2 \circ \ell_1: R_1 \Leftrightarrow R_3$}
\DisplayProof
\hskip 1.5em
\AxiomC{$\substack{\ell_1 : R_1 \Leftrightarrow S_1 \\ \ell_2 : R_2
\Leftrightarrow S_2}$}
\AxiomC{$\substack{\mathcal{L}(R_1) \cap \mathcal{L}(R_2) =
\varnothing \\ \mathcal{L}(S_1) \cap \mathcal{L}(S_2) = \varnothing}$}
\BinaryInfC{$\ell_1 \sep \ell_2: R_1 \sep R_2 \Leftrightarrow S_1 \sep S_2$}
\DisplayProof
\end{center}

\begin{center}
\AxiomC{$\ell : R \Leftrightarrow S$}
\AxiomC{$R^{*!}$}
\AxiomC{$S^{*!}$}
\TrinaryInfC{$\ell^*: R \Leftrightarrow S$}
\DisplayProof
\hskip 1.5em
\AxiomC{$\ell : R \Leftrightarrow S$}
\AxiomC{$R \equiv^s R'$}
\AxiomC{$S \equiv^s S'$}
\TrinaryInfC{$\ell : R' \Leftrightarrow S'$}
\DisplayProof
\end{center}
\caption{Bijective Lens Typing Rules}
\label{fig:lensrules}
\end{figure}

\subsection{Syntax of QRE Lenses}
Having given a brief overview of the class of bijective lenses, we now introduce
the class of QRE lenses. The language of QRE lenses is given by following
grammar:
$$ q := \kw{lift}(\ell) \sep \kw{lquot}(q, \ell) \sep
\kw{rquot}(\ell, q) \sep q \cdot q' \sep (q \sep q') \sep q^* \sep q \circ q',$$
where $\ell$ ranges over bijective lenses.

The QRE lens combinators are inspired by the Boomerang lens combinators of the
same name. The $\kw{lift}(\ell)$ quotient lens enables a bijective lens
$\ell$ to be considered a quotient lens, with the equivalence relation applied
to both the source and target formats being the equality relation. The
regular combinators of concatenation `$\cdot$', Kleene star `$*$' and
`$|$' on QRE lenses exhibit the expected behaviour, with the caveat that these
combinators are strongly unambiguous. The composition operator `$;$' also
exhibits the expected behaviout, though the conditions that must be checked in
order for the composition to be well defined are perhaps unintuitive. The
reasons why these conditions are necesary will become more apparent when
proving normal forms for QRE lenses.

The interesting combinators are the $\kw{lquot}$ and $\kw{rquot}$
combinators. The $\kw{lquot}(c, q)$ combinator takes a quotient lens $q$ and
quotients the source data using $c$, assuming that the source data forms a
complete set of representatives for the equivalence relation $\eqrel{c}$. The
$\kw{lquot}(q, c)$ combinator does the same but on the target data.

For example, recall that in the \bibtex{} to EndNote transformation, we had the
QREs \cd{bibtex} and \cd{endnote} describing the \bibtex{} and EndNote records
respectively, and the bijective lens \cd{bib_to_end} that maps between
\cd{bibtex} and \cd{endnote}. The quotient lens that maps between
\cd{bibtex} and \cd{endnote} is given by the QRE lens

\begin{lstlisting}
let bib_to_end_q : (lens in bibtex $\Leftrightarrow$ endnote)  = rquot (lquot(bibtex, bib_to_end), endnote)
\end{lstlisting}

\iffalse
The difference between QRE lenses and Boomerang quotient lenses lies in the
typing judgements. More concretely, each QRE lens $q$ has a type $q : c
\Leftrightarrow c'$ where $c, c'$ are QREs. In contrast, the approach used to
type quotient lenses in Boomerang is to classify equivalences according to
whether they are or are not the equality relation. This type system is based on
two observations: first, that most quotient lenses originate as lifted basic
lenses, and therefore have types whose equivalence relations are both equality;
and second, that equality is preserved by many of the quotient lens
combinators. Foster et al also discuss a second possible approach to typing
quotient lenses, where equivalence relations are represented by rational
functions that induce them. While this second approach is more refined than the
first, Boomerang favours the first approach since the second appears to be too
expensive to be useful in practice~\cite{quotientlenses}.
\fi

\subsection{Semantics of QRE Lenses}

Each QRE lens $q$ has a type $q : c \Leftrightarrow c'$ where $c, c'$ are QREs.
If $q : c \Leftrightarrow c'$, then the source format is described by $W(c)$ and
the canonical set of representative for the source data is described by $K(c)$.
Similarly, the target format is described by $W(c')$ and the canonical set of
representatives for the target data is described by $K(c')$. The underlying lens
of $q$ is a bijective lens $\ell : K(c) \Leftrightarrow K(c')$.

The denotation $\llbracket q \rrbracket$ of a QRE lens $q:c \Leftrightarrow c'$
is a quotient lens $\llbracket q \rrbracket : W(c)/{\eqrel{c}}
\Longleftrightarrow W(c')/{\eqrel{c'}}$. The typing rules and denotation of QRE
lenses are given in Figure~\ref{fig:qlenssemantics}. The trickiest typing rule
is the typing rule for composition:

\begin{prooftree}
\AxiomC{$\substack{q_1 : c \Leftrightarrow c' \\ q_2 : c'' \Leftrightarrow
c'''}$}
\AxiomC{$\substack{\mathcal{L}(W(c'))= \mathcal{L}(W(c'')) \\ K(c') \equiv
K(c'')}$}
\AxiomC{$\canonizer(c') = \canonizer(c'')$}
\TrinaryInfC{$q_2 \circ q_1: c \Leftrightarrow c'''$}
\end{prooftree}

This derivation rule essentially says that the composition $q_2 \circ q_1$ is
well defined if and only if the intermediary QREs $c''$ and $c'''$ define the
same equivalence relation on the same regular language. The condition
$\mathcal{L}(W(c')) = \mathcal{L}(W(c''))$ says that the intermediary language
is the same on both sides, while the condition $K(c') \equiv K(c'')$ says that
the kernel regular expressions are syntactically the same. Finally, the
condition $\canonizer(c') = \canonizer(c'')$ says that $c'$ and $c''$ define
the same equivalence relation on $\mathcal{L}(W(c'))= \mathcal{L}(W(c''))$.

In general, checking that $\canonizer(c') = \canonizer(c'')$ is an undecidable
task, especially because of the $\normalize{R}{R'}{f}$ QRE. Therefore, our
actual implementation of the composition rule for QRE lenses follows Boomerang's
approach, which is to define the composition on QRE lenses if and only if
$c'$ and $c''$ are syntactially equal to $id(R)$ and $id(R')$ for some $R$ and
$R'$ satisfying $\mathcal{L}(R) = \mathcal{L}(R')$.

Foster et al based this approach on two observations: first, that most quotient
lenses originate as lifted basic lenses, and therefore have types whose
equivalence relations are both equality; and second, that equality is preserved
by many of the quotient lens combinators. Foster et al also discuss a second
possible approach, where equivalence relations are represented by rational
functions that induce them. While this second approach is more refined than the
first, Boomerang favours the first approach since the second appears to be too
expensive to be useful in practice~\cite{quotientlenses}.

The semantics defined on QRE lenses imply the following theorem:
\begin{theorem}
If there is a derivation $q : c \Leftrightarrow c'$, then $\llbracket q
\rrbracket : W(c)/{\eqrel{c}} \Leftrightarrow W(c')/{\eqrel{c'}}$ is a
well-defined quotient lens.
\end{theorem}


\begin{figure}[ht]
\centering
\[
\begin{array}[b]{l@{\qquad}l}
\Rule{\ell : R \Leftrightarrow S}{\kw{lift}(\ell): id(R) \Leftrightarrow id(S)}
&
\begin{array}[b]{rcl}
\llbracket \kw{lift}(\ell) \rrbracket.get &=&  \llbracket \ell \rrbracket\\
\llbracket \kw{lift}(\ell) \rrbracket.put &=& \llbracket \ell \rrbracket^{-1}
\end{array}
\end{array}
\]
\[
\begin{array}[b]{c@{\qquad}l}
\Rule{q : c'  \Leftrightarrow c'' &
\wf{c} &
K(c) = W(c')}
{\kw{lquot}(c, q): c' \circ c \Leftrightarrow c''} &
\begin{array}[b]{rcl}
\llbracket \kw{lquot}(c, q) \rrbracket.get  &=& \llbracket q
\rrbracket.get \circ \canonizer(c)\\
\llbracket \kw{lquot}(c, q) \rrbracket.put &=& \llbracket q \rrbracket.put
\end{array}
\end{array}
\]

\[
\begin{array}[b]{c@{\qquad}c}
\Rule{q : c'  \Leftrightarrow c'' &
\wf{c} &
K(c) = W(c')}
{\kw{lquot}(c, q): c' \circ c \Leftrightarrow c''} &
\begin{array}[b]{rcl}
\llbracket \kw{lquot}(c, q) \rrbracket.get  &=& \llbracket q
\rrbracket.get \circ \canonizer(c)\\
\llbracket \kw{lquot}(c, q) \rrbracket.put &=& \llbracket q \rrbracket.put
\end{array}
\end{array}
\]

\[
\begin{array}[b]{c@{\qquad}c}
\Rule{q : c \Leftrightarrow c'' &
\wf{c''} &
W(c'') = K(c')}
{\kw{rquot}(q, c):c \Leftrightarrow c'' \circ c'} &
\begin{array}[b]{rcl}
\llbracket \kw{rquot}(q, c) \rrbracket.get  &=& \llbracket q
\rrbracket.get\\
\llbracket \kw{rquot}(q, c) \rrbracket.put &=& \llbracket q
\rrbracket.put \circ \canonizer(c'')
\end{array}
\end{array}
\]

\[
\begin{array}[b]{l@{\qquad}c}
\Rule{q : c \Leftrightarrow c' &
W(c)^{*!},W(c')^{*!} & K(c)^{*!}, K(c')^{*!}}
{{q}^* : c^* \Leftrightarrow {c'}^*} &
\begin{array}[b]{rcl}
\llbracket {q}^* \rrbracket.get  &=& (\llbracket q \rrbracket.get)^*\\
\llbracket {q}^* \rrbracket.put &=& (\llbracket q \rrbracket.get)^*
\end{array}
\end{array}
\]

\[
\begin{array}[b]{l@{\qquad}c}
\Rule{\substack{q_1 : c_1 \Leftrightarrow d_1 \\ q_2 : c_2 \Leftrightarrow
d_2} & {\substack{W(c_1) \cdot^! W(c_2)\\ K(c_1) \cdot^! K(c_2)}}
& {\substack{W(d_1) \cdot^! W(d_2)\\ K(d_1) \cdot^! K(d_2)}}}
{q_1 \cdot q_2: c_1 \cdot c_2 \Leftrightarrow d_1 \cdot d_2} &
\begin{array}[b]{rcl}
\llbracket q_1 \cdot q_2 \rrbracket.get  &=& \llbracket q_1 \rrbracket.get
\cdot \llbracket q_2 \rrbracket.get\\
\llbracket q_1 \cdot q_2\rrbracket.put &=& \llbracket q_1 \rrbracket.put
\cdot \llbracket q_2 \rrbracket.put
\end{array}
\end{array}
\]

\[
\begin{array}[b]{l@{\qquad}c}
\Rule{\substack{q_1 : c_1 \Leftrightarrow d_1 \\ q_2 : c_2 \Leftrightarrow
d_2} & \substack{\mathcal{L}(W(c_1)) \cap \mathcal{L}(W(c_2)) = \varnothing
\\ \mathcal{L}(W(d_1)) \cap \mathcal{L}(W(d_2)) = \varnothing }}
{q_1 \sep q_2: (c_1 \sep c_2)\Leftrightarrow (d_1 \sep d_2)} &
\begin{array}[b]{rcl}
\llbracket q_1 \sep q_2 \rrbracket.get(s) =
\begin{cases}
\llbracket q_1 \rrbracket.get (s) & \text{if } s \in \mathcal{L}(W(c_1))\\
\llbracket q_2 \rrbracket.get (s) & \text{if } s \in \mathcal{L}(W(c_2))\\
\end{cases}\\
\llbracket q_1 \sep q_2 \rrbracket.put(s) =
\begin{cases}
\llbracket q_1 \rrbracket.put (s) & \text{if } s \in \mathcal{L}(W(d_1))\\
\llbracket q_2 \rrbracket.put (s) & \text{if } s \in \mathcal{L}(W(d_2))\\
\end{cases}
\end{array}
\end{array}
\]

\begin{prooftree}
\AxiomC{$\substack{q_1 : c \Leftrightarrow c' \\ q_2 : c'' \Leftrightarrow
c'''}$}
\AxiomC{$\substack{\mathcal{L}(W(c'))= \mathcal{L}(W(c'')) \\ K(c') \equiv
K(c'')}$}
\AxiomC{$\canonizer(c') = \canonizer(c'')$}
\TrinaryInfC{$q_2 \circ q_1: c \Leftrightarrow c'''$}
\end{prooftree}
\begin{align*}
\llbracket q \rrbracket.get &= \llbracket q_2 \rrbracket.get\circ \llbracket
q_1 \rrbracket.get, \text{ and }\\
\llbracket q \rrbracket.put &= \llbracket q_1 \rrbracket.put \circ \llbracket
q_2 \rrbracket.put
\end{align*}

\caption{Denotation and Typing Rules for QRE Lenses}
\label{fig:qlenssemantics}
\end{figure}

\subsection{Normal Forms for QRE Lenses}
Recall that our approach in defining QRE lenses is to have each QRE lens $q: c
\Leftrightarrow c'$ be such that
\begin{align*}
\llbracket q \rrbracket.get &= \ell \circ \canonizer(c)\\
\llbracket q \rrbracket.put &= \ell^{-1} \circ
\canonizer(c')
\end{align*}
for some bijective lens $\ell$. In other words, each QRE lens is the same as a
bijective lens with canonizers at the edges. The following theorem,
which is the main technical contribution of this paper, confirms that this
indeed is the case:

\begin{theorem}\label{normal form}
If there is a derivation $q : c \Leftrightarrow c'$, then there exists a
bijective lens $\ell : K(c) \Leftrightarrow K(c')$ such that
\begin{align*}
\llbracket q \rrbracket.get &= \llbracket \ell \rrbracket\circ \canonizer(c)\\
\llbracket q \rrbracket.put &= \llbracket \ell \rrbracket^{-1} \circ
\canonizer(c')
\end{align*}
\end{theorem}
\begin{proof}
We elide a full proof of this statement, since the proof is attained via a
straightforward induction on the derivation $q : c \Leftrightarrow c$ (the
full details can be found in the appendix {\sam{which I need to write}}). Since
bijective lenses are closed under strongly unambiguous regular operators, the
tricky case is composition. The composition case is more involved since we need
to show that we can get rid of the canonizers in the middle:

\sam{TODO: Put a diagram here to show what you mean.}

The derivation rule and denotation for composition are as follows:
\begin{prooftree}
\AxiomC{$\substack{q_1 : c \Leftrightarrow c' \\ q_2 : c'' \Leftrightarrow
c'''}$}
\AxiomC{$\substack{\mathcal{L}(W(c'))= \mathcal{L}(W(c'')) \\ K(c') \equiv
K(c'')}$}
\AxiomC{$\canonizer(c') = \canonizer(c'')$}
\TrinaryInfC{$q_2 \circ q_1: c \Leftrightarrow c'''$}
\end{prooftree}

\begin{align*}
\llbracket q \rrbracket.get &= \llbracket q_2 \rrbracket.get\circ \llbracket
q_1 \rrbracket.get, \text{ and }\\
\llbracket q \rrbracket.put &= \llbracket q_1 \rrbracket.put \circ \llbracket
q_2 \rrbracket.put
\end{align*}

By the induction hypothesis, there exist bijective lenses
$\ell_1 :
K(c) \Leftrightarrow K(c')$ and $\ell_2 : K(c'') \Leftrightarrow K(c''')$ such
that
\begin{align*}
\llbracket q_1 \rrbracket.get &= \llbracket \ell_1 \rrbracket \circ
\canonizer(c)\\
\llbracket q_1 \rrbracket.put &= {\llbracket \ell_1 \rrbracket}^{-1} \circ
\canonizer(c')
\end{align*}
and
\begin{align*}
\llbracket q_2 \rrbracket.get &= \llbracket \ell_2 \rrbracket \circ
Canonize(c')\\
\llbracket q_2 \rrbracket.put &= {\llbracket \ell_2 \rrbracket}^{-1} \circ
Canonize(c'')
\end{align*}
Consequently,
\begin{align*}
\llbracket q_2 \rrbracket.get \circ \llbracket q_1 \rrbracket.get &=
(\llbracket \ell_2 \rrbracket \circ \canonizer(c')) \circ (\llbracket \ell_1
\rrbracket \circ \canonizer(c))\\
&= \llbracket \ell_2 \rrbracket \circ (\canonizer(c') \circ \llbracket \ell_1
\rrbracket) \circ \canonizer(c)\\
&= (\llbracket \ell_2 \rrbracket \circ \llbracket \ell_1 \rrbracket) \circ
\canonizer(c)\\
&= \llbracket \ell_2  \circ  \ell_1 \rrbracket \circ
\canonizer(c)
\end{align*}
We are permitted to claim the third step from the second since
$\canonizer(c')$ is the identity function on $K(c'')$ which is
syntactically equal to $K(c')$ by assumption. A similar argument shows that
$$\llbracket q_1 \rrbracket.put \circ \llbracket q_2 \rrbracket.put =
\llbracket \ell_2  \circ  \ell_1 \rrbracket^{-1} \circ
\canonizer(c)$$

The other cases of the proof are similar in that they follow from a
straightforward application of the induction hypothesis followed by unrolling
the equations that give the denotation for QRE lenses.\qed
\end{proof}
\iffalse
\begin{proof}
Assume that $q : c \Leftrightarrow c'$. We proceed by induction over the
derivation $q : c \Leftrightarrow c'$.
\begin{enumerate}
  \item
  $\kw{lift}(\ell): R/\mathit{id}(R) \Leftrightarrow S/\mathit{id}(S)$ where
  $\ell :
  R \Leftrightarrow S$. Then
  \begin{align*}
\llbracket \kw{lift}(\ell) \rrbracket.get &=  \llbracket \ell \rrbracket
= \llbracket \ell \rrbracket \circ id_{\mathcal{L}(R)} =
\llbracket \ell \rrbracket \circ \canonizer(\mathit{id}(R)), \text{ and }\\
\llbracket \kw{lift}(\ell) \rrbracket.put &= \llbracket \ell
\rrbracket^{-1} = \llbracket \ell \rrbracket^{-1} \circ id_{\mathcal{L}(S)} =
\llbracket \ell \rrbracket^{-1} \circ \canonizer(id(S))
\end{align*}
\item
$\kw{lquot}(c, q'): c' \circ c \Leftrightarrow c''$ where $q' : c'
\Leftrightarrow c''$, $c$ is well formed and $K(c) = W(c')$. Then
\begin{align*}
\llbracket q \rrbracket.get  &= \llbracket q'
\rrbracket.get \circ \canonizer(c)\\
\llbracket q \rrbracket.put &= \llbracket q' \rrbracket.put
\end{align*}
By the induction hypothesis, there exists a bijective lens $\ell :
K(c') \Leftrightarrow K(c'')$ such that
\begin{align*}
\llbracket q' \rrbracket.get &= \llbracket \ell \rrbracket \circ \canonizer(c')\\
\llbracket q' \rrbracket.put &= \llbracket \ell \rrbracket^{-1} \circ
Canonize(c'')
\end{align*}
Consequently
\begin{align*}
\llbracket q \rrbracket.get  &= (\llbracket \ell \rrbracket \circ
\canonizer(c')) \circ \canonizer(c) = \llbracket \ell \rrbracket \circ
(\canonizer(c' \circ c))\\
\llbracket q \rrbracket.put &= \llbracket \ell \rrbracket^{-1} \circ
Canonize(c'')
\end{align*}

\item
$\kw{rquot}(q', c''):c \Leftrightarrow c'' \circ c'$ where $q' : c \Leftrightarrow
c'$, $c''$ is well formed and $K(c'') = W(c')$. Proceed as in the previous
case.
\item
$q_2 \circ q_1: c \Leftrightarrow c''$ where $q_1 : c \Leftrightarrow c'$ and
$q_2 : c' \Leftrightarrow c''$. Then
\begin{align*}
\llbracket q \rrbracket.get &= \llbracket q_2 \rrbracket.get\circ \llbracket
q_1 \rrbracket.get, \text{ and }\\
\llbracket q \rrbracket.put &= \llbracket q_1 \rrbracket.put \circ \llbracket
q_2 \rrbracket.put
\end{align*}
By the induction hypothesis, there exist bijective lenses
$\ell_1 :
K(c) \Leftrightarrow K(c')$ and $\ell_2 : K(c') \Leftrightarrow K(c'')$ such
that
\begin{align*}
\llbracket q_1 \rrbracket.get &= \llbracket \ell_1 \rrbracket \circ
\canonizer(c)\\
\llbracket q_1 \rrbracket.put &= {\llbracket \ell_1 \rrbracket}^{-1} \circ
\canonizer(c')
\end{align*}
and
\begin{align*}
\llbracket q_2 \rrbracket.get &= \llbracket \ell_2 \rrbracket \circ
Canonize(c')\\
\llbracket q_2 \rrbracket.put &= {\llbracket \ell_2 \rrbracket}^{-1} \circ
Canonize(c'')
\end{align*}
Consequently,
\begin{align*}
\llbracket q_2 \rrbracket.get \circ \llbracket q_1 \rrbracket.get &=
(\llbracket \ell_2 \rrbracket \circ \canonizer(c')) \circ (\llbracket \ell_1
\rrbracket \circ \canonizer(c))\\
&= \llbracket \ell_2 \rrbracket \circ (\canonizer(c') \circ \llbracket \ell_1
\rrbracket) \circ \canonizer(c)\\
&= (\llbracket \ell_2 \rrbracket \circ \llbracket \ell_1 \rrbracket) \circ
\canonizer(c)\\
&= \llbracket \ell_2  \circ  \ell_1 \rrbracket \circ
\canonizer(c)
\end{align*}
A similar argument shows that
$$\llbracket q_1 \rrbracket.put \circ \llbracket q_2 \rrbracket.put =
\llbracket \ell_2  \circ  \ell_1 \rrbracket^{-1} \circ
\canonizer(c)$$
\item
${q'}^* : c^* \Leftrightarrow {c'}^*$ where $q' : c \Leftrightarrow c'$,
$W(c)^{*!}$ and $W(c')^{*!}$ and $K(c)^{*!}$ and $K(c')^{*!}$. Then
\begin{align*}
\llbracket {q'}^* \rrbracket.get &= (\llbracket q' \rrbracket.get)^*, \text{
and }\\
\llbracket {q'}^* \rrbracket.put &= (\llbracket q' \rrbracket.put)^*
\end{align*}
By the induction hypothesis there exists a bijective lens $\ell : K(c)
\Leftrightarrow K(c')$ such that
that
\begin{align*}
\llbracket q' \rrbracket.get &= \llbracket \ell \rrbracket \circ
\canonizer(c)\\
\llbracket q' \rrbracket.put &= {\llbracket \ell \rrbracket}^{-1} \circ
\canonizer(c')
\end{align*}
Consequentlty
\begin{align*}
\llbracket {q'}^* \rrbracket.get &= (\llbracket \ell \rrbracket \circ
\canonizer(c))^* = \llbracket \ell \rrbracket^* \circ
\canonizer(c)^* = \llbracket \ell^* \rrbracket \circ
\canonizer(c^*)\\
\llbracket {q'}^* \rrbracket.put &= (\llbracket \ell \rrbracket^{-1} \circ
\canonizer(c'))^* = (\llbracket \ell \rrbracket^{-1})^* \circ
\canonizer(c')^* = \llbracket \ell^* \rrbracket^{-1} \circ
\canonizer(c'^*)\\
\end{align*}
\item
$q_1 \cdot q_2: c_1 \cdot c_2 \Leftrightarrow d_1 \cdot d_2$, where $q_1 : c_1
\Leftrightarrow d_1 $,  $q_2 : c_2 \Leftrightarrow d_2$, $W(c_1)
\cdot^! W(c_2)$, $K(c_1) \cdot^! K(c_2)$, $W(d_1) \cdot^! W(d_2)$ and $
K(d_1) \cdot^! K(d_2)$. Then
\begin{align*}
\llbracket q \rrbracket.get &= \llbracket q_1 \rrbracket.get \cdot \llbracket
q_2 \rrbracket.get, \text{ and }\\
\llbracket q \rrbracket.put &= \llbracket q_1 \rrbracket.put \cdot \llbracket
q_2 \rrbracket.put
\end{align*}
By the induction hypothesis, there exist bijective lenses $\ell_1 : K(c_1)
\Leftrightarrow K(d_1)$ and $\ell_2 : K(c_2) \Leftrightarrow K(d_2)$ such that
\begin{align*}
\llbracket q_1 \rrbracket.get &= \llbracket \ell_1 \rrbracket \circ
\canonizer(c_1)\\
\llbracket q_1 \rrbracket.put &= {\llbracket \ell_1 \rrbracket}^{-1} \circ
\canonizer(d_1)
\end{align*}
and
\begin{align*}
\llbracket q_2 \rrbracket.get &= \llbracket \ell_2 \rrbracket \circ
\canonizer(c_2)\\
\llbracket q_2 \rrbracket.put &= {\llbracket \ell_2 \rrbracket}^{-1} \circ
\canonizer(d_2)
\end{align*}
Consequently,
\begin{align*}
\llbracket q \rrbracket.get &= (\llbracket \ell_1 \rrbracket \circ
\canonizer(c_1)) \cdot  (\llbracket \ell_2 \rrbracket \circ
\canonizer(c_2))\\
&= (\llbracket \ell_1 \rrbracket \cdot \llbracket \ell_2
\rrbracket) \circ (\canonizer(c_1) \cdot \canonizer(c_2))\\
&= \llbracket \ell_1 \cdot  \ell_2 \rrbracket \circ \canonizer(c_1 \cdot c_2)
\end{align*}
Similarly
$$
\llbracket q \rrbracket.put = \llbracket \ell_1 \cdot  \ell_2 \rrbracket^{-1}
\circ \canonizer(d_1 \cdot d_2) $$
\item
$q = q_1 \sep q_2$ where $q_1 : c_1 \Leftrightarrow d_1 $, $q_2 : c_2
\Leftrightarrow d_2$, $\mathcal{L}(W(c_1)) \cap \mathcal{L}(W(c_2)) =
\varnothing$ and $\mathcal{L}(W(d_1)) \cap \mathcal{L}(W(d_2)) = \varnothing$.
Then
$$
\llbracket q_1 \sep q_2 \rrbracket.get(s) =
\begin{cases}
\llbracket q_1 \rrbracket.get (s) & \text{if } s \in \mathcal{L}(W(c_1))\\
\llbracket q_2 \rrbracket.get (s) & \text{if } s \in \mathcal{L}(W(c_2))\\
\end{cases}$$
$$\llbracket q_1 \sep q_2 \rrbracket.put(s) =
\begin{cases}
\llbracket q_1 \rrbracket.put (s) & \text{if } s \in \mathcal{L}(W(d_1))\\
\llbracket q_2 \rrbracket.put (s) & \text{if } s \in \mathcal{L}(W(d_2))\\
\end{cases}
$$
By the induction hypothesis, there exist bijective lenses $\ell_1 : K(c_1)
\Leftrightarrow K(d_1)$ and $\ell_2 : K(c_2) \Leftrightarrow K(d_2)$ such that
\begin{align*}
\llbracket q_1 \rrbracket.get &= \llbracket \ell_1 \rrbracket \circ
\canonizer(c_1)\\
\llbracket q_1 \rrbracket.put &= {\llbracket \ell_1 \rrbracket}^{-1} \circ
\canonizer(d_1)
\end{align*}
and
\begin{align*}
\llbracket q_2 \rrbracket.get &= \llbracket \ell_2 \rrbracket \circ
\canonizer(c_2)\\
\llbracket q_2 \rrbracket.put &= {\llbracket \ell_2 \rrbracket}^{-1} \circ
\canonizer(d_2)
\end{align*}
Consequently,
$$
\llbracket q_1 \sep q_2 \rrbracket.get(s) =
\begin{cases}
\llbracket \ell_1 \rrbracket \circ
\canonizer(c_1) (s) & \text{if } s \in \mathcal{L}(W(c_1))\\
\llbracket \ell_2 \rrbracket \circ
\canonizer(c_2) (s) & \text{if } s \in \mathcal{L}(W(c_2)),\\
\end{cases}$$
so $\llbracket q_1 \sep q_2 \rrbracket.get = \llbracket \ell_1 \sep
\ell_2 \rrbracket \circ \canonizer(c_1 \sep c_2)$. A similar argument shows
that $\llbracket q_1 \sep q_2 \rrbracket.put = \llbracket \ell_1 \sep
\ell_2 \rrbracket^{-1} \circ \canonizer(d_1 \sep d_2)$.\\
This completes the proof.
\end{enumerate}
\end{proof}

\fi
\section{Synthesizing QRE Lenses}
\label{synth}
Our goal in this section is to demonstrate how to synthesize a quotient lens
$q: c \Leftrightarrow c'$ from the QREs $c, c'$ and a set of input-output pairs
$\{(x_1, y_1), \ldots, (x_n, y_n)\}$ where the $x_i$'s are in $W(c)$ and the
$y_i$'s are in $W(c')$. We wish $q$ to map the equivalence class of $x_i$ to the
equivalence class of $y_i$ and vice versa:
\begin{align*}
q.get(x_i) &\equiv_{c'} y_i \text{, and}\\
q.put(y_i) &\equiv_c x_i
\end{align*}

Our approach in synthesizing QRE lenses is guided by Theorem~\ref{normal
form}, which says that if there is a derivation $q :
c \Leftrightarrow c'$ of a QRE lens, then there exists a bijective lens $\ell :
K(c) \Leftrightarrow K(c')$ such that
\begin{align*}
\llbracket q \rrbracket.get &= \llbracket \ell \rrbracket\circ \canonizer(c)\\
\llbracket q \rrbracket.put &= \llbracket \ell \rrbracket^{-1} \circ
\canonizer(c')
\end{align*}

For our synthesis task, since the $x_i$'s are in $W(c)$ and the $y_i$'s are
in $W(c')$, then ${x_i}' = \canonizer(c)(x_i)$ is in $K(c)$ and ${y_i}' =
\canonizer(c')(y_i)$ is in $K(c')$. Consequently in order to synthesize the
desired quotient lens $q: c \Leftrightarrow c'$ that is consistent with the
input-output examples $\{(x_1, y_1), \ldots, (x_n, y_n)\}$ it suffices to
synthesize a bijective lens $l :
K(c) \Leftrightarrow K(c')$ that is consistent with the canonized examples
$\{({x_1}', {y_1}'), \ldots, ({x_n}', {y_n}')\}$

Optician~\cite{optician} showed that given regular expressions
$R, S$ and a set of input-output pairs $\{(r_1, s_1), \ldots, (r_n, s_n)\}$, if
there is a derivation $\ell : R \Leftrightarrow S$ of a bijective lens that
maps $r_i$ to $s_i$ in the forward direction and $s_i$ to $r_i$ in the backward
direction, then there is an algorithm that computes a bijective lens $\ell' :
R' \Leftrightarrow S'$ such that $R \equiv R'$, $S \equiv S'$, $\ell'$ maps
$r_i$ to $s_i$ in the forward direction and $s_i$ to $r_i$ in the backward
direction, and $\llbracket \ell \rrbracket = \llbracket \ell'
\rrbracket$.

This implies that if there is a derivation $q : c \Leftrightarrow
c'$ of a QRE lens as well as a derivation $\ell : K(c) \Leftrightarrow K(c')$
that is consistent with the canonized examples $\{({x_1}', {y_1}'),
\ldots, ({x_n}', {y_n}')\}$, then we can synthesize a quotient lens $q$ of
type $c \Leftrightarrow c'$ that is consistent with $\{({x_1}', {y_1}'),
\ldots, ({x_n}', {y_n}')\}$. More concretely, in order to synthesize a
quotient lens $q: c \Leftrightarrow c'$, that is consistent with the examples
$\{(x_1, y_1), \ldots, (x_n, y_n)\}$ it suffices to perform the following
procedure:
\begin{enumerate}
  \item
  Compute $K(c)$, $K(c')$,
  \item
  Compute $\{({x_1}', {y_1}'), \ldots, ({x_n}', {y_n}')\}$ where ${x_i}' =
  \canonizer(c)(x_i)$ and ${y_i}' = \canonizer(c')(y_i)$,
  \item
  Synthesize a bijective lens $\ell : K(c) \Leftrightarrow K(c')$ that is
  consistent with the examples $\{({x_1}', {y_1}'), \ldots, ({x_n}',
  {y_n}')\}$
  \item
  Return $q = \kw{rquot}(\kw{lquot}(c, \ell), c') : c \Leftrightarrow
  c'$
\end{enumerate}
For example, recall that in the \bibtex{} to EndNote transformation we had the
QREs \cd{bibtex} and \cd{endnote} describing a \bibtex{} record and an Endnote
record respectively. We also had the example pair \cd{(bib_example ,
end_example)} where

\begin{lstlisting}
bib_example =
"@Book {Doe,
Author = \"John Doe\",
Title = {Generic Title},
}"
\end{lstlisting}

\noindent and

\begin{lstlisting}
end_example =
"%0 Book
%T Generic Title
%A John Doe
%F Doe"
\end{lstlisting}

Since the transformation between the kernel of \cd{bibtex} and the kernel of
\cd{endnote} that maps \cd{bib_example} to \cd{end_example} can be
expressed by a bijective lens, we can synthesize a lens that maps between the
QREs \cd{bibtex} and \cd{endnote}. We do this using the expression

\begin{lstlisting}
let bib_to_end : (lens in bibtex <=> endnote)
= synth bibtex <=> endnote  using  {(bib_example, end_example)}
\end{lstlisting}

\section{Implementation and Evaluation}
\label{impl}


We have integrated QREs and quotient lens synthesis into Boomerang allowing QREs
and synthesis tasks to be expressed alongside existing Boomerang expressions.

All evaluations were performed on a 2.5 GHz Intel Core i7 processor with 16 GB
of 1600 MHz DDR3 running macOS High Sierra.

Our evaluations serve to answer the following questions:
\begin{enumerate}
  \item Does synthesizing quotient lenses from QREs permit for an easier
  development process than existing approaches?
  
  \item Are QREs sufficiently expressive that more lenses can be synthesized
  without modifications to the format?
  
  \item Is our synthesis algorithm competitive with existing lens synthesis
  tools?
\end{enumerate}

\subsection{Benchmark Suite Construction}
Our benchmarks were constructed from two sources:
\begin{enumerate}
  \item 39 of our benchmarks were derived from the Optician system.  These
  benchmarks were a combination of custom benchmarks, benchmarks derived from
  FlashFill, and benchmarks derived from Augeas.  Many of the formats mapped
  between had to be modified to work with the bijectivity constraints
  Optician required.  Commonly, one format had whitespace where the other did
  not allow for whitespace.  To address the bijectivity issues surrounding this,
  we added whitespace to the format that typically did not have whitespace.  We
  were able to remove these alterations in adopting these benchmarks to our
  system.
  
  \item 8 of our benchmarks were derived from data.gov.  Data.gov contains
  many transformations between formats.  In addition to the formats previously
  adopted for Optician, we synthesized transformers between these formats.
\end{enumerate}

\subsection{Easing the Development Process}

\begin{figure}
\includegraphics{generated-graphs/asts.eps}
\caption{Count of benchmark programs definable using a given AST count. We find
that it takes far fewer AST nodes to define benchmark lenses in \Name{} than
with Optician or without synthesis. }
\label{fig:asts}
\end{figure}

To test if our tool eases the development process, we compare the following
number of AST nodes.
%
\begin{itemize}
  \item[\QRESize{}] \QRESize{} is the number of AST nodes in the QRE
  specifications involved in QRE lens synthesis task.
  \item[\CanonizerAndSpecSize{}] \CanonizerAndSpecSize{} is the number of
  AST nodes in $W(q)$ summed with the number of AST nodes in $\canonizer(q)$,
  for each QRE used in QRE lens synthesis task.
  \item[\LensAndSpecSize{}] \LensAndSpecSize{} is the number of AST nodes
  in $W(q)$ summed with the number of AST nodes in the synthesized QRE lens.
\end{itemize}

The value of \QRESize{} represents the difficulty in writing our benchmarks.

The value of \CanonizerAndSpecSize{} represents the difficulty in writing our
benchmarks without QREs.  This is only an approximation, as both $W(q)$ and
$\canonizer(q)$ are automatically generated from the QRE.  In our
experience, these automatically generated regular expressions and canonizers are
the ones we would naturally write.

The value of \LensAndSpecSize{} represents the difficulty in writing our benchmarks
with neither QREs nor synthesis.  This is also an approximation, as $W(q)$ and
$\canonizer(q)$ and the bijective lens are all automatically generated.
We have found that the generated bijective lens is fairly similar in size to the
one we would manually write, though it is typically less modular.

Figure~\ref{fig:asts} shows the number of benchmarks written with at most a
given number of AST nodes. For a given benchmark, we found \QRESize{} to be
about half as large as \CanonizerAndSpecSize, and about a third as large as
\LensAndSpecSize{}. This demonstrates that introducing QREs saves programmers
significant effort compared to both Optician and basic Boomerang.

\subsection{Increase of Expressivity}

Optician was only able to synthesize fully bijective data transformations.
\Name{} loosens that restriction, and is able to synthesize data which is
bijective when put in canonical form.
To determine the increase of expressivity, we analyzed:
\begin{enumerate}
  \item How many data formats in Optician's benchmark suite required modifications
  to be bijective.
  \item How many data formats in Optician's benchmark suite required modifications
  to be bijective when put in canonical form.
\end{enumerate}

We found that 10 of Opticians 39 benchmarks required modifications to be
bijective. We found that 4 of Optician's 39
benchmarks required modifications to be in bijective correspondence when in
canonical form.  Furthermore, we found that all of the data.gov examples
required no modifications to be in canonical form.  While we did not put the
data.gov examples into a form suitable for Optician, we found only 4 of
the 8 data.gov examples did not require canonization, so making suitable
for Optician would have required a modification of 4 of the data.gov
formats.

\subsection{Competitive Performance}

\begin{figure}
\centering
\begin{subfigure}[b]{.49\textwidth}
\centering
\includegraphics{generated-graphs/times_opt}
\caption{}
\label{subfig:lenssize}
\end{subfigure}
\begin{subfigure}[b]{.49\textwidth}
\includegraphics{generated-graphs/times_new.eps}
\caption{}
\label{subfig:examplesused}
\end{subfigure}
\caption{Runtimes of Optician and \Name{}.
In (a), we run Optician and \Name{} on Optician's benchmarks.  We find that
there is only a negligible difference incurred by Optometrist's overhead.
In (b), we run Optometrist on its benchmark suite.  We find that it is able
to synthesize all quotient lenses in under 20 seconds, and typically
finished in under 5 seconds. }
\label{fig:times}
\end{figure}

While we expanded on the Optician system, we found it important to validate
performance did not degrade in this expansion.  To validate this, we tested:
\begin{itemize}
  \item[\OpticianRuntime{}] Optician runs on its own benchmarks.
  \item[\SystemOnOptician{}] \Name{} runs on Optician's benchmarks.
  \item[\SystemOnBenchmarks{}] \Name{} runs on its own benchmarks.
\end{itemize}

We summarize the results of these experiments in Figure~\ref{fig:times}.
\Name{} was
able to synthesize all of Optician's benchmarks at a speed competitive with
Optician.  There was additional overhead in calculating $W(q)$ and $K(q)$,
resulting in a very slight decrease in performance.

Also notable was one of the data.gov examples, which converted demographic
statistics by zip code from xml form into rdf form.  This merely took longer because it was
an exceptionally large format, converting over 40 fields.  After adding in additional
fields to make this format bijective, it still took over 15 seconds to complete.

\section{Related Work}
\label{relwork}

\iffalse
Bidirectional transformations have been used in diverse areas of computing
where they arise as parsers and pretty printers, marshallers
and unmarshallers, serializers and deserializers, database views and view
updaters and many others\sam{TODO put citations}. Such transformations have
been extensively studied since they were proposed as a solution to the classical
{\em view-update problem} in the database community, where the challenge is to
derive a program that extracts a view of data from a source, as well as a
program that folds view updates back into the source safely and correctly.
\fi
This paper builds on the work of Foster et al~\cite{quotientlenses} who
introduced the theory of quotient lenses and implemented quotient lenses as a
refinement of the bidirectional string processing language Boomerang.
In Boomerang, the source and target types are specified using regular
expressions, and the equivalence relations are expressed using canonizers, which
are functions that map elements of a regular language to their canonical
representative. Boomerang canonizers can express a very broad class of
equivalence relations between regular languages, but actually doing so is often
difficult with complicated equivalence relations. For instance, Boomerang's
in-build permutation combinator does not account for separators in between the
regular expressions. Also, this combinator permutes regular expressions rather
than canonizers, thus making it difficult to express nested permutations that
occur in many data formats, especially XML and XML-like formats.

In their paper, Foster et al also discuss other bidirectional programming
languages that support quotienting of data including XSugar~\cite{xsugar},
biXid~\cite{bixid} and X/Inv~\cite{Hu2004,Mu2004,Mu2006}. XSugar programs
bidirectionally convert data stored in XML and ASCII formats respectively, with the
transformations specified by a pair of unambiguous grammars. The quotienting
occurs on the XML side by use of a generic canonizer that standardizes the
representation of trees. Well-formed XSugar programs are guaranteed to be
bijective modulo an equivalence relation that captures XML normalization. biXid
programs convert between pairs of XML documents, with the XML formats specified
using a pair of grammars as in XSugar. However, biXid grammars can be ambiguous.
This ambiguity is what allows biXid to express equivalences on the data.
Finally, Foster et al discuss a possible connection with the languages
X and Inv which support a primitive duplication combinator that does not work
well with the lens laws, but can be expressed using Boomerang quotient lenses.

As far as synthesis goes, though there is a good deal of recent research on
synthesizing unidirectional string
transformations~\cite{singh2012learning,le-pldi-2014,gulwani-popl-2014,perelman2014test,Singh:blinkfill},
the system Optician, which we introduced in ~\cite{optician}, is the first attempt
to synthesize bidirectional transformations that we are aware of. In that
publication, we compared Optician to two of these unidirectional string
transformers, Flash Fill~\cite{gulwani-popl-2014} and
FlashExtract~\cite{le-pldi-2014}, and found that these tools were unsuccessful
in synthesizing the complex transformatiunons that can be expressed in Optician.

While Optician improved on prior effors at synthesizing unidirectional string
transformers and introduced synthesis for bidirectional string transformations,
Optician was only able to synthesize fully bijective data transformations. Our
new system \Name{} improves on Optician in that \Name{} loosens this
restriction, and is able to synthesize data which is bijective when put in
canonical form. \Name{} is therefore a refinement of Optician since the
new synthesis algorithm (i.e. the quotient lens synthesis algorithm) restricted
to ``pure'' regular expressions degenerates to the synthesis algorithm that
we introduced in Optician. Indeed, as we mentioned in the evaluation section,
\Name{} was able to synthesize all of Optician's benchmarks at a speed
competitive with Optician, though there was additional overhead in calculating
the whole language $W(c)$ and the kernel language $K(c)$ of QREs, which
resulted in a very slight decrease in performance.

Much of the research in synthesis assumes that the synthesizer is provided with
a collection of examples. Optician and Optometrist differ in that they requires
that the programmer supplies both examples {\em and} format descriptions in the
form of regular expressions or QREs.  There is a trade-off here.  On the one
hand, a user must have some programming expertise to write regular expression
(or QRE) specifications and it requires some work. On the other hand, such
specifications provide a great deal of information to the synthesis system,
which decreases the number of examples needed (often to zero), makes the system
scale well, and allows it to handle large, complex formats.  By providing these
format specifications, the synthesis engine does not have to both infer the
format of the data as well as the transformations on it, obviating the need to
infer tricky formats like those involving nested iterations. Furthermore, by
focusing on bidirectional transformations, we limit the space of synthesized
functions to bijective ones, reducing the search space, and the expressiveness
of the search space.

There are many other recent results showing how to synthesize functions from
type-based
specifications~\cite{augustsson-2004,osera+:pldi15,feser-pldi-2015,scherer-icfp-2015,frankle+:popl16,armando+:pldi16}.
These systems enumerate programs of their target language, orienting their
search procedures to process only terms that are well-typed.
Optician is distinctive in that it synthesizes terms in a language with many
type equivalences.
Perhaps the system most similar to Optician is InSynth~\cite{gvero-pldi-2013}, a
system for synthesizing terms in the simply-typed lambda calculus that addresses
equivalences on types. Instead of trying to directly synthesize terms of the
simply-typed lambda calculus, InSynth synthesizes a well-typed term
in the succinct calculus, a language with types
that are equivalent ``modulo isomorphisms of products and
currying''~\cite{gvero-pldi-2013}. The type structure that we used in Optician
is significantly more complex.  In particular, because Optician types do not
have full canonical forms, we used a pseudo-canonical form, which captures part
of the equivalence relation over types. To preserve completeness, we pushed
some of the remaining parts of the type equivalence relation into a set of
rewriting rules and other parts into the synthesis algorithm itself.

Morpheus~\cite{morpheus} is another synthesis system that uses two
communicating synthesizers to generate programs.  In both Morpheus and
Optician, one synthesizer provides an
outline for the program, and the other fills in that outline with program
details that satisfy the user's specifications.
This approach works well in large search spaces that require some enumerative
search.
One important way that Optician differs from Morpheus is that in
Morpheus, an outline is a sketch---an
\emph{expression}
containing holes---whereas
an outline in Optician is a pair of regular
expressions, i.e., a
\emph{type}.  Moreover, in order to implement an efficient
search procedure, we had to create both a new type language and a new
term language for lenses.  Once we did so, we proved our new, more
constrained language
designed for synthesis was just as expressive as the original, more
flexible and compositional language designed for human programmers.


\section{Conclusion}
\label{concl}

\bibliographystyle{plain}
\bibliography{local}


\end{document}
