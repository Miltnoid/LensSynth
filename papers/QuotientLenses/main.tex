\newif\ifdraft\drafttrue  % set true to show comments
\newif\iflastminute\lastminutefalse  % for things to check at the end

\documentclass[acmsmall,review,anonymous]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}
% % For double-blind review submission, w/ CCS and ACM Reference
% \documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
% % For single-blind review submission, w/o CCS and ACM Reference (max
% submission space)
% \documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
% % For single-blind review submission, w/ CCS and ACM Reference
% \documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true} % For
% final camera-ready submission, w/ required CCS and ACM Reference
% \documentclass[acmsmall]{acmart}\settopmatter{}


% % Journal information % Supplied to authors by publisher for camera-ready
% submission; % use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{ICFP} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2018}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

% % Copyright information % Supplied to authors (based on authors' rights
% management selection; % see authors.acm.org) by publisher for camera-ready
% submission; % use 'none' for review submission.
\setcopyright{none}
\usepackage{amsmath, amssymb, verbatim, enumerate, graphicx, centernot, tikz,
array, mathtools, bussproofs, stmaryrd, enumitem, stackengine, subcaption,
cleveref}
\captionsetup{compatibility=false}
\usepackage{relsize}
\usepackage{listings}
\usepackage{proof}
\usepackage{xspace}

\lstset{ language=Caml, basicstyle=\linespread{0.8}\upshape\sffamily,
keywordstyle=\upshape\sffamily\color{dkblue}, keepspaces=true,
framexleftmargin=1ex, framexrightmargin=1ex, showstringspaces=false,
keepspaces=true,
commentstyle=\itshape\rmfamily,
emph={synth,project,perm,squash,normalize,using,ins,del,lens},
emphstyle=\upshape\sffamily\color{dkblue}, columns=flexible,
% BCP: I find this distracting:
% stringstyle=\sffamily\color{dkred},
mathescape, }

% %%%% Macros Colors
\definecolor{dkblue}{rgb}{0,0.1,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{dkred}{rgb}{0.6,0,0}
\definecolor{dkpurple}{rgb}{0.7,0,0.4}
\definecolor{olive}{rgb}{0.4, 0.4, 0.0}
\definecolor{teal}{rgb}{0.0,0.5,0.5}
\definecolor{orange}{rgb}{0.9,0.6,0.2}
\definecolor{lightyellow}{RGB}{255, 255, 179}
\definecolor{lightgreen}{RGB}{170, 255, 220}
\definecolor{teal}{RGB}{141,211,199}
\definecolor{darkbrown}{RGB}{121,37,0}

\newcommand{\FINISH}[3]{\ifdraft\textcolor{#1}{[#2: #3]}\fi}
\newcommand{\bcp}[1]{\FINISH{dkred}{B}{#1}}
\newcommand{\BCP}[1]{\FINISH{dkred}{B}{\bf #1}}
\newcommand{\afm}[1]{\FINISH{dkgreen}{A}{#1}}
\newcommand{\dpw}[1]{\FINISH{dkblue}{D}{#1}} % Toronto Maple Leafs Blue :-)
\newcommand{\saz}[1]{\FINISH{orange}{SZ}{#1}}
\newcommand{\ksf}[1]{\FINISH{teal}{K}{#1}}
\newcommand{\sam}[1]{\FINISH{dkpurple}{SM}{#1}}

% For Inference Rules
\newcommand{\Rule}[2]{\infer{#2}{#1}}
\newcommand{\RuleSide}[3]{\infer[#3]{#2}{#1}}
% \newcommand{\Axiom}[1]{\Rule{}{#1}}

\newcommand{\wf}[1]{\ensuremath{#1\;\mathsf{wf}}}

% FOR Regular Expression names
\newcommand{\re}[1]{\ensuremath{\mathtt{#1}}}
\newcommand{\kw}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\codefont}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\project}[2]{\ensuremath{\kw{project} \; #1 \mapsto #2}}
\newcommand{\squash}[3]{\ensuremath{\kw{squash} \; #1 \rightarrow #2\; \kw{using} \; #3}}
\newcommand{\perm}[2]{\ensuremath{\kw{perm}\; (#1)\; \kw{with}\; #2}}
\newcommand{\normalize}[3]{\ensuremath{\kw{normalize} \; (#1, #2, #3)}}
\newcommand{\sep}{\ensuremath{\ | \ }}
\newcommand{\canonizer}{\ensuremath{\kw{canonizer}}}
\newcommand{\bibtex}{\textsc{Bib}\TeX{}}
\newcommand{\get}{\ensuremath{\kw{get}}}
\newcommand{\semicolon}{\ensuremath{\; ; \;}}
\newcommand{\lput}{\ensuremath{\kw{put}}}
\newcommand{\create}{\ensuremath{\kw{create}}}
\newcommand{\const}{\ensuremath{\kw{const}}}
\newcommand{\swap}{\ensuremath{\kw{swap}}}

\newcommand{\eqrel}[1]{\ensuremath{\equiv_{#1}}}

\newcommand{\Name}{Optometrist\xspace}

\newcommand{\QRESize}{\textbf{QS}}
\newcommand{\CanonizerAndSpecSize}{\textbf{CS}}
\newcommand{\LensAndSpecSize}{\textbf{LS}}

\newcommand{\OpticianRuntime}{\textbf{OO}}
\newcommand{\SystemOnOptician}{\textbf{QO}}
\newcommand{\SystemOnBenchmarks}{\textbf{QQ}}
\newcommand{\cd}[1]{\lstinline[backgroundcolor=\color{white}]$#1$}


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Synthesizing Quotient Lenses}
\begin{abstract}
There currently exist many bidirectional programming languages, some of which
allow a programmer to define a transformation that respects an equivalence
relation. For example, a language with this feature may allow a programmer to
define a transformation which ignores the order of fields in an XML file, so
that two files that have the same fields with the same data but with the fields
occuring in a different order are considered the same by the
transformation. This paper simplifies the task of programming such {\em
quotient lenses} in two main ways. First, we introduce {\em
quotient regular expressions} or QREs which are regular expressions
augmented with extra syntax that makes it easier to specify equivalence
relations on regular langauges than currently existing tools. Secondly, we
introduce {\em QRE lenses}, which are lenses that map between QREs, and show
how to {\em synthesize} QRE lenses from a pair of QREs and a set of example
input-output pairs. We also describe an implementation of QREs and QRE lens
synthesis in the bidirectional programming language Boomerang, and demonstrate
the utility of our implementation by using it to synthesize QRE lenses between
various real-world data formats used by the {\tt data.gov} database.
\end{abstract}

\keywords{quotient regular expressions, QRE lens, synthesis}
\maketitle

\section{Introduction}
Oftentimes, the same data is stored in a variety different formats. For
example, bibliography data may be stored in \bibtex{} and
EndNote formats; spreadsheet data can be represented as a CSV file
or a TSV file; web APIs can return data as a JSON or XML object. In such cases,
it is necessary to synchronize the two or more copies of data so that they
store the same information.

One way to synchronize data stored in different formats is to use \emph{lenses},
\emph{i.e.,} programs that represent pairs of functions for translating data
from format the source format to the target formant (the \emph{get}
direction) and back again (the \emph{put} direction). Lenses are usually
derived using domain-specific bidirectional languages which guarantee that the
lenses defined in that language satisfy a certain set of \emph{lens laws} that
give guarantees on how the two transformations interact.

Amongst the most restrictive lenses are the \emph{bijective lenses}.  These
lenses demand that get and put functions form a bijection, meaning no
information is lost when one translates from one data format to another.  While
this strong guarantee can be useful in some contexts, it is more often the case
that some of the information in one or both of the data formats is superfluous.
For instance, one typically does not care to preserve the amount of
whitespace between characters.  In other circumstances, capitalization
or the order of fields in a record or items in a list may be unimportant. Many
data formats have other ad hoc rules as well. In bibliographies, for example,
recall that in \bibtex{}, an author can be specified as
``\cd{lastname, firstname}'' or as ``\cd{firstname lastname}''---it does not
matter which of the two formats is used.

{\em Quotient lenses} loosen many of the restrictions of bijective lenses by
allowing a programmer to define an equivalence relation on the source and
target formats so that the round-tripping lens laws hold modulo these
equivalence rather than modulo equality. Quotient lenses thus make it possible
to align many more data sources than would otherwise be possible, by ignoring
details that a programmer views as inessential. The only language we are aware
of that implements a general class of quotient lenses is {\em
Boomerang}~\cite{quotientlenses}. While Boomerang's quotient lenses enable a
programmer to define a very general class of quotient lenses, these lenses to
have two main drawbacks.

First, in order to define an equivalence relation in Boomerang, a programmer
must define a {\em canonizer}; pair of functions $f$ and $g$ where $f$ maps
data represented in the original external format to a canonical element and $g$
chooses which elements of the original format correspond to values in the
canonical format. The disadvantage of this approach is that in order for a
programmer to {\em specify} a quotient lens in Boomerang, she must define four
different data formats: two ``outer'' formats which specify the data that is to
be transformed by the lens, and two ``inner'' formats which specify the
canonical formats for the source and target data.

Our solution to this shortcoming is to introduce {\em Quotient Regular
Expressions} or QREs, which enable a programmer to simultaneously specify a
regular expression as well as a set of canonical representatives for strings
that match the regular expression. QREs have the added advantage that once the
programmer has defined a well formed QRE, then she need not define a
canonization function seperately; the canonization function can automatically be
inferred from the QRE.

The second challenge with programming lenses in Boomerang is that even after the
programmer has specified the data as well as a canonizer that maps each member
in the source and target sets to their respective canonical representative, she
must still define the underlying lens that maps between the respective sets of
canonical representatives. This can be a slow and tedious task due to the
constraints that Boomerang imposes on its terms. For example, Boomerang
programmers often must rearrange the order of data items by recursively using
operators that \swap adjacent fields. Furthermore, the Boomerang type checker is
very strict, disallowing many programs because they contain ambiguity about how
certain data is transformed.

Our solution to this problem is that we use QREs to define a class of quotient
lenses called {\em QRE lenses}, and, we show how to synthesize such QRE lenses
automatically. More specifically, in order to generate a lens, a programmer
provides a pair of QREs describing the source and target formats, plus
a (possibly empty) suite of examples that demonstrates how the
lens should act in specific cases.  Given this information, we can exploit and
extend recent work on algorithms for synthesis of bijective
lenses~\cite{optician} to generate quotient lenses. The lenses generated by
our synthesis algorithm are guaranteed to translate data back and forth
between source and target QREs and to satisfy the provided examples.
Moreover, while our synthesized quotient lenses have a relatively
restricted form (which cuts down the amount of non-determinism in
a specification and greatly speeds up synthesis), we prove that
this rigidity does not compromise their expressiveness.

The following list summarizes the central contributions of our work.
\begin{enumerate}
  \item We introduce {\em Quotient Regular Expressions} (QREs),
  a compact, convenient notation for simultaneously defining a
  regular language modulo some equivalence relation and a canonizer
  for that relation (Section~\ref{QRE}).
  \item We define a language of {\em QRE lenses}.  This language is
  a subset of the full set of bijective quotient
  lenses whose types are given by QREs. Our main technical contribution
  is a proof that each QRE lens is functionally equivalent to a QRE lens in the
  canonical form of a bijective lens with ``canonizers at the edges''.
   (Section~\ref{QRE-lenses}).
  \item We reduce the problem of {\em synthesizing}
  QRE lenses to the previously studied problem of synthesizing bijective lenses
  between regular languages (Section~\ref{synth}).
  \item We extend the Boomerang {\em implementation} with QREs
  and QRE lens synthesis.  We demonstrate the utility of our
  implementation by using it to
  synthesize QRE lenses between data formats drawn from the
  {\tt data.gov} database (Section~\ref{impl}).
\end{enumerate}
Sections~\ref{relwork} and~\ref{concl} discuss related and future work.

\bcp{We've said that one of the main contributions of the paper is
synthesizing lenses, but we don't actually show this happening in the
introduction.  Should we?}

\section{QRE Lenses by Example}
\label{sec:example}
\subsection{Bijective Lenses}
Consider a bidirectional transformation that converts \bibtex{} citation records
such as
\begin{verbatim}
@Book {Doe,
Author = "John Doe",
Title = {Generic Title}
}
\end{verbatim}
\noindent
into an equivalent EndNote format like the following
\begin{verbatim}
%0 Book
%F Doe
%A John Doe
%T Generic Title
\end{verbatim}
\noindent
and vice versa. 

{\em Bijective lenses} are designed to define a bidirectional transformation
such as this, where the data formats can be matched in a one-to-one manner, in
this case by matching the label, author and title fields. Boomerang allows
programmers to define such bijecive transformations using combinators which
favour a compositional approach in which the programmer defines small lenses
which are then put together using the combinators to define larger and larger
lenses until the final lens is defined. 

Each bijective lens is constructed from simple primitive combinators including:
\begin{itemize}
  \item \kw{del} $s$: \textit{delete} the constant string $s$ in the get
  direction; insert it in the put direction.
  \item \kw{ins} $s$: \textit{insert} the constant string $s$ in the get
  direction; delete it in the put direction.
  \item \kw{copy} $R$: copy the text matching the regular expression $R$ in
  both directions.
\end{itemize}
In addition, such primitives may be combined using the regular operators
Kleene star, alternation and concatenation, or functional composition of
lenses.  Figure~\ref{fig:example-lens} illustrates the use of these
combinators to transform \bibtex{} to EndNote (and vice versa).
\begin{figure}[t]
\begin{lstlisting}
let preamble : (lens in "@book{" $\Leftrightarrow$ "%0 Book\n%F ") =
del "@book{" . ins "%0 Book\n%F "

let author_lens : (lens in (",\n" . bib_author) $\Leftrightarrow$ ("\n" . end_author)) =
del ",\nauthor = \""
. ins "\n%A "
. name
. (del " and "
. ins "\n"
. (ins "%A " . name . del " and " . ins "\n")*
. ins "%A "
. name
|| "")

let title_lens : (lens in ("\",\n" . bib_title . "},\n}") $\Leftrightarrow$ ("\n" . end_title)) =
del "\",\ntitle = {" . ins "\n%T " . title . del "},\n}"

let bib_to_end : (lens in bibtex $\Leftrightarrow$ end_note) = preamble . label . author_lens . title_lens
\end{lstlisting}
\caption{An example lens between \cd{bibtex} and \cd{end_note} regular
expressions with no equivalences.\bcp{And a readability suggestion:
define a named constant for a quote character.}}
\label{fig:example-lens}
\end{figure}

Unfortunately, programming bijective lenses in Boomerang is often slow and
tediuos because of the fiddly constraints that Boomerang imposes on its
terms. making lens programming slow and tedious. For example, Boomerang
programmers often must rearrange the order of data items by recursively using
operators that \swap adjacent fields. Furthermore, the Boomerang type checker is
very strict, disallowing many programs because they contain ambiguity about how
certain data is transformed. 

In our previous work in~\cite{optician}, we presented a solution to these
shortcomings of bijective lenses by developing a tool called {\em Optician}
which enables a programmer to synthesize a bijective lens from a pair of regular
expressions $(S, T)$ and a set of input-output example \cd{exs} pairs that
determines how the synthesized lens should behave on those examples. With {\em
Optician}, the programmer need only spend the effort of specifying the data
formats and the behaviour\bcp{Let's use American spellings: behavior} of the
lens on a few inputs in order to define a 
bijective lens. As a result defining bijective lenses becomes faster and less
error prone, since the programmer need only invoke the synthesis procedure
\lstinline{synth S <=> T using exs} in order to define a bijective lens rather
than manually derive the lens herself.

\subsection{Quotient Lenses}
Unfortunately, while our synthesis tool greatly simplifies the task of
programming bijective lenses, not all bidirectional tranformations are bijective
in nature. For instance, users are typically uninterested in preserving
whitespace between words or between fields.  The order of author and title
fields is also likely irrelevant and there may be equivalent ways of writing
the same name:  ``Doe, John'' vs ``John Doe.''

When two instances of the same format differ only terms of such inessential
information, it is useful\bcp{Would it be worth spelling out the alternative
(i.e., what lenses would look like if they had to preserve all this stuff?)}
to treat them as identical and to map them into canonical representations.
Continuing our example, the following two \bibtex{} citations represent the same
logical object and as a result, should be translated to the same EndNote record.
\begin{verbatim}
@Book {Doe,
Author = "John Doe",
Title = {Generic Title},
}

@Book{     Doe,
Title = {Generic
Title},
Author = "Doe, John",     }
\end{verbatim}

One natural way to define lenses that will synchronize data in these formats
is to provide the following items:
\begin{enumerate}
  \item A pair of descriptions of the external source and target formats, here
  \bibtex{} and EndNote. Such descriptions may be given by regular
  expressions, for instance.
  \item A pair of \emph{canonizers} that map external source (and target)
  objects into internal, canonical forms.  Such canonizers will take
  care of stripping away irrelevant information and otherwise normalizing
  differences between equivalent representations of the same logical data.
  When given an internal representation, such canonizers must also operate
  in the reverse direction, \emph{choosing} an element in the external format
  to represent the canonical internal element.
  \item A pair of descriptions of the internal source and
  target formats.
  \item A bijective lens to map back and forth between canonical elements
  of the internal source and target formats.
\end{enumerate}

\noindent
Indeed, Boomerang's quotient lenses are structured this
way~\cite{quotientlenses}. Of course, some of these elements are optional.  For
instance, it is not necessary to document internal and external formats.
However, we do view it as good engineering practice to do so, as such
documentation makes lenses easier to read, understand, use and maintain.

The first way in which our work simplifies Boomerang's quotient lenses is
that we merge the first three pieces of quotient lenses that we just described
into a single concept, {\em Quotient Regular Expression}, or QREs. A single QRE
enables a programmer to add annotations to the outer regular expression; these
annotations can then be used to infer an inner regular expression, as well as a
canonizer from the outer regular expression to the inner one. In the following
subsection, we describe the QRE combinators and use give an example of how a
programmer might define a QRE specification of \bibtex.

\subsection{Specifying \bibtex{} Using QREs}
\label{subsec:qre-expressions}
To construct a QRE specification of a \bibtex{} format, we might first define a
whitespace format, which, externally, matches any non-zero number of whitespace
characters, and converts any such whitespace into a single space character (its
canonical form). This whitespace-normalizing QRE is easily defined by using the
\kw{project} primitive: \bcp{Why is it called ``project''?}

\begin{lstlisting}
let wsp = project [ \n\t\r]$^+$ $\to$ " "
\end{lstlisting}
\iflastminute
\bcp{Can we display blanks as a distinct ``visible blank'' symbol
(throughout)?  That will make examples easier to read.}\bcp{I tried turning
on the showstringspaces option at the top, but that doesn't do everything we
want--it only works inside quotes.  But the latex ``textvisiblespace'' command
produces a single one, and the lstlisting ``escapechar'' option will allow
us to use it inside listings.  But we should save this for the final
tweaking stage.}
% Here is an example: if you set escapechar=\%, you could use it inside the
% listings as follows: \begin{lstlisting} t %\leftarrow% 0 \end{lstlisting} 
\fi

Sometimes there are multiple disjoint representations of the same data.
In such situations, the \kw{squash} combinator creates a QRE that
allows external data to be in either format, and converts any
data in the first format to the second.
For instance, assume that
the \codefont{comma\_name} format describes ``Doe, John''
and that the \codefont{space\_name} format describes ``John Doe''
and \codefont{s\_to\_c} is a function from the first to the second.  In this case,
the following instance of \kw{squash} creates the desired canonizer.

%Figure~\ref{fig:example-qre} illustrates
%how to specify \bibtex{} records and their canonical elements using
%QREs.

\begin{lstlisting}
let name = squash comma_name $\to$ space_name using s_to_c
\end{lstlisting}

One way to define the \codefont{s\_to\_c} canonization function used by squash
is simply to write it from scratch in some ordinary programming language. (Boomerang canonizers are written in OCaml.)
However, our system will also synthesize such functions automatically from pairs
of regular languages and examples---here, \codefont{s\_to\_c} is the
\codefont{get} direction of a lens that can be synthesized by:
%
\begin{lstlisting}
let l = synth comma_name $\Leftrightarrow$ space_name using {("Doe, John", "John Doe")}
let s_to_c = get l
\end{lstlisting}
%
\bcp{Three problems here. First, the idea of using half of a lens
as a canonizer comes out of nowhere.  The second is that this idea is a hack
(and always was).  Why bother defining / synthesizing a lens and then using only
half of it?  And the third is that, in the original quotient lens paper,
we used this trick on lenses that were not even bijective, which may confuse
people familiar with the earlier paper.}

\sam{OK I suppose it's a trick though I don't see an obvious solution. }

The first line above synthesizes a lens between \codefont{comma\_name} and
\codefont{space\_name} using the listed example transformation as a guide.  The
second line simply extracts the get direction transformation from the lens,
which is what we need for \kw{squash}.

Another QRE primitive is the sequential composition combinator ``;''.  For
example, suppose that we wish to express a name as $\kw{last\_name \cdot
``,\text{''} \cdot \text{wsp+} \cdot first\_name}$, or as $\kw{first\_name\cdot
\text{wsp+} \cdot last\_name}$, with $\kw{first\_name\cdot \text{wsp+} \cdot
last\_name}$ as the canonical representation. We also wish to project away the
extra whitespace in between \kw{first\_name} and \kw{last\_name} once this
identification has been made. Then we can express this compound equivalence
relation by a composition of a \kw{squash} QRE and a QRE that projects away
the extra whitespace in between \codefont{first\_name} and
\codefont{last\_name}.

The permutation QRE combinator, \kw{perm}, allows data to be unordered. For example,
the following instance of \kw{perm} allows label, author and title fields
(which we assume have been defined earlier) to appear in any order.
%
\begin{lstlisting}
let bib_fields = perm (label, bib_author, bib_title)
\end{lstlisting}
%
To normalize the field separators, one can specify that the components of the
permutation are conjoined by another QRE. For instance, below, we normalize
whitespace between fields, leaving only a single newline.
%
\begin{lstlisting}
let bib_fields = perm (label, bib_author, bib_title) with (project ("," .wsp+) $\to$ ",\n")
\end{lstlisting}

The final QRE combinator is the normalize combinator, which is also implemented
in Boomerang. This combinator allows a programmer to manually define a function
$f$ which sends each string that matches a regular expression $R$ to some
canonical representative in another regular expression $R'$. The equivalence
relation defined by the normalize combinator is hence the equivalence relation
defined by the {\em fibres} of $f$; that is, for all strings $s$ and $s'$ that
match $R$, $s$ is equivalent to $s'$ if and only if $f(s) = f(s')$.

For instance, assume that $f(s)=$ `` '' for all whitespace strings $s$. Then the
project QRE \kw{p\_wsp} which matches any non-zero number of whitespace
characters and converts any such whitespace into a single space character can
be expressed using the normalize combinator as 
\lstinline{normalize (wsp+, " ", f)}.

Figure~\ref{fig:example-qre} gives the complete QRE specification for the
\bibtex{}.
\begin{figure}
\begin{lstlisting}
let wsp = [ \n\t\r]

(* define name representations with a space and with a comma *)
let space_name = first_name . wsp+ . last_name
let comma_name = last_name . "," . wsp+ . first_name

(* synthesize a lens that maps comma representation to space representation *)
let l = synth comma_name $\Leftrightarrow$ space_name using {("Doe, John", "John Doe")}
let s_to_c = get l

(* squash QRE maps comma_name to space_name *)
let comma_to_space = squash comma_name $\to$ space_name using (get comma_to_space)

(* map arbitrary whitespace into " " as a canonical representative *)
let p_wsp = project wsp+ $\to$ " "

(* Project away whitespace in space_name representation *)
let project_in_space = first_name . p_wsp . last_name

(* Compose the two QREs to get a canonical representation for a name *)
let name = project_in_space ; comma_to_space

(* define rest of bibtex fields *)
let name_sep = p_wsp . "and" . p_wsp
let bib_names = name | (name . name_sep . (name . name_sep)$^*$ . name)
let bib_author = "author = \"" . bib_names . "\""
let title = word | (word . p_wsp . (word . p_wsp)$^*$ . word)
let bib_title = "title = {" . title . "}"

(* allow any permutation of fields interspersed with arbitrary whitespace *)
let bib_fields = perm (label, bib_author, bib_title) with (project ("," . wsp+) $\to$ ",\n")
let bibtex = "@book{" . bib_fields . "}"
\end{lstlisting}
\caption{QRE specification of \bibtex{} records. }
\label{fig:example-qre}
\end{figure}
\subsection{QRE Lenses and QRE Lens Synthesis}
\label{sec:examplesynth}
At this point we already have a tool for synthesizing bijective lenses from a
pair of regular expressions and a set of example input-output pairs, as well as
the language of QREs for defining equivalence relations on regular expressions.
An obvious next step in simplifying the quotient lens programming is thus to use
the bijective lens synthesis procedure as a subroutine for a quotient lens
synthesis procedure. This new procedure should take two QREs and a set
of example input-output pairs as input, compute the canonical data formats on
both sides of the lens from the pair of QREs, map the example input-output pairs
to their canonical representatives to get a set of examples in canonical form,
and then invoke the bijective lens synthesis procedure on the canonical data
formats and the new set of examples that are in canonical form.

Indeed this basic idea is what motivates our definition of {\em QRE Lenses}.
Intuitively, just like Boomerang's quotient lenses, our QRE lenses are bijective
lenses with ``canonizers at the edges''---Figure~\ref{fig:attheedges} presents
the architecture of each lens.
\begin{figure}[t]
\centering
\includegraphics[width=0.7\textwidth]{canonizers-outside}
\caption{Quotient Lens with ``Canonizers at the Edges''
\bcp{Maybe we should go a step further and label things like $K(c)$,
 $W(c)$, Canonizer(c), etc.  And probably we should display K as a subset of
 W.  I can make these changes later.)}}
\label{fig:attheedges}
\end{figure}
Every QRE lens $q_1$ has a type $q_1: c_1 \Leftrightarrow c_2$ where $c_1$ and $c_2$
are QREs. In the get direction, a QRE lens $q_1: c_1 \Leftrightarrow c_2$ uses the
source QRE $c_1$ to compute a unique representative for the data modulo the
equivalence relation defined by $c_1$ and then applies the $\get$ function of a
bijective lens $\ell_1$ to this representative. In the backward direction, $q_1$
operates similarly, but using the view QRE $c_2$ and the $\lput$ function of
$\ell_1$.

Because the QREs $c_1$ and $c_2$ determine the internal formats for data after
canonization, and because the algorithm for synthesizing bijective lenses is
directed by these formats, $c_1$ and $c_2$ are all that is required to
synthesize QRE lenses end-to-end. Indeed, we structured QRE lenses as bijective
lenses with canonizers at the edges, precisely to facilitate the use of this
synthesis algorithm.

On the other hand, our restriction that canonizers appear only at the edges
raises a key technical question:  Are we limiting the expressiveness of our
transformations by demanding all programs fit into this normal form?\bcp{I wish
we could have previewed this issue a bit more in the introduction, since it is
our main contribution.}  It turns out that we are not: any lens that uses
canonizers internally can be transformed into a lens that uses canonizers at
the edges. The main technical contribution of this paper is a proof of this
fact.

This technical investigation justifies replacing manually constructed lenses
using the QRE lens combinators with synthesized QRE lenses in normal form, thus
saving the programmer. For instance, after defining the \bibtex{} and EndNote
QREs and storing them in the variables \cd{bibtex} and \cd{endnote}
respectively, then all the code in Figure~\ref{fig:example-lens} may be
replaced by a single call to the synthesis prodedure:

\begin{lstlisting}
let bib_to_end : (lens in bibtex $\Leftrightarrow$ endnote) =
synth bibtex $\Leftrightarrow$ endnote using {(bib_example, end_example)}
\end{lstlisting}
\bcp{Again, the spacing is weird}
\noindent Here, the generated  quotient lens synchronizes \cd{bibtex} and
\cd{endnote} formats, using \cd{bib_example} and \cd{end_example} (the two
concrete example strings given at the beginning of this section) to
disambiguate. In addition, and as we saw earlier with the definition of
\cd{s_to_c}, the synthesis procedure itself can be used to create lenses that
are in turn used to define other QREs.  The ability to intermix QRE
specification with QRE lens synthesis yields a powerful and flexible way of
creating bidirectional transformations.

\section{Quotient Regular Expressions}
\label{QRE}
\subsection{Syntax and Semantics of QREs}
Formally, the language of Quotient Regular Expressions (QREs) is given by the
following grammar:
\begin{align*}
c := \; &R \sep \project{R}{s} \sep \squash{c_1}{c_2}{f} \sep
\perm{c_1, \ldots, c_n}{c} \\
& | \; \normalize{R}{R'}{f} \sep c_1 \semicolon c_2 \sep c_1 \cdot c_2 \sep (c_1
\sep c_2) \sep c^*,
\end{align*}
where $c$ ranges over QREs, $R$ ranges over regular expressions, $f$ ranges over
functions between regular languages, and $s$ ranges over character strings.

Using the conventional notation that $\mathcal{L}(R)$ is the language accepted
by the regular expression $R$, then each QRE $c$ enables us to express
\begin{enumerate}
  \item a regular expression $W(c)$ (the ``whole'' of $c$),
  \item an equivalence relation $\eqrel{c}$ on $\mathcal{L}(W(c))$,
  \item a regular expression $K(c)$ (the ``kernel'' of $c$)
  such that $\mathcal{L}(K(c))$ forms a complete set of representatives for
  $\eqrel{c}$, and
  \item a ``canonizing'' function\bcp{Why is it called ``canonizer'' rather
    than ``canonize''??} $\canonizer(c):\mathcal{L}(W(c))
  \longrightarrow \mathcal{L}(K(c))$ which given any $w \in \mathcal{L}(W(c))$,
  computes $\canonizer(c)(w)$ as the unique $k$ in $\mathcal{L}(K(c))$ such that
  $k$ is equivalent to $w$ mod $\eqrel{c}$
\end{enumerate}
Figures~\ref{fig:wk} gives the inductive definitions for the whole and
kernel languages $W(c)$ and $K(c)$ of a QRE.
\begin{figure}[t]
\centering
\[
\begin{array}{l@{\quad}l@{\quad}l}

c & W(c) & K(c) \\ \hline
R & R & R \\
\project{R}{s} & R & s \\
\squash{c}{c_1}{f} & W(c) \sep W(c_1) & K(c_1) \\
\normalize{R}{R'}{f} & R & R' \\
c_1 \; ; \; c_2 & W(c_1) & K(c_2) \\
c_1 \cdot c_2 & W(c_1) \cdot W(c_2) & K(c_1) \cdot K(c_2) \\
c_1 \sep c_2 & W(c_1) \sep W(c_2) & K(c_1) \sep K(c_2) \\
c^* & W(c)^* & K(c)^* \\
\end{array}
\]
\[
\begin{array}{r@{\quad}l}
W( \perm{c_1, \ldots, c_n}{c} ) = &
\bigcup \limits_{\sigma \in S_n} W(c_{\sigma(1)}) \cdot W(c) \cdot \ldots \cdot
W(c) \cdot W(c_{\sigma(n)})\\
K( \perm{c_1, \ldots, c_n}{c} ) = & K(c_1) \cdot K(c) \cdot \ldots \cdot K(c)
\cdot K(c_n)
\end{array}
\]
\caption{Whole and Kernel Regular Expressions}
\label{fig:wk}
\end{figure}
The \textit{squash} and \textit{permutation} combinators give the two
interesting definitions. If $c = \squash{c_1}{c_2}{f}$, then the whole language
of $c$ is $W(c_1) \sep W(c_2)$. This is because the \textit{squash} combinator
takes the whole language $W(c_1)$ of $c_1$, the whole language $W(c_2)$ of $c_2$
and a function $f : \mathcal{L}(W(c_1)) \longrightarrow \mathcal{L}(W(c_2))$,
maps $\mathcal{L}(W(c_1))$ into $\mathcal{L}(W(c_2))$ using $f$ and then
canonizes $W(c_2)$ into $K(c_2)$ using $\canonizer(c_2)$.

For the $\perm{c_1, \ldots, c_n}{c}$ combinator, the whole language is the
union of languages of the form $W(c_{\sigma(1)}) \cdot W(c) \cdot \ldots \cdot
W(c) \cdot W(c_{\sigma(n)})$ for any permutation $\sigma$ in $S_n$, where
$S_n$ is the set of all permutations of the numbers $1$ to $n$. This is because
the \textit{permutation} combinator allows for the string to match any
permutation the $c_i$'s while also taking into account the separator $c$ in
between each of the $c_i$'s. The kernel of the \textit{permutation} combinator
is the language $K(c_1) \cdot K(c) \cdot \ldots \cdot K(c) \cdot K(c_n)$,
because the canonical permutation is the identity permuation, with each of the
parts of the string that match $c_i$ and $c$ canonized into $K(c_i)$ and $K(c)$
respectively.

Figure~\ref{fig:canonizers} gives the inductive definitions of the
$\canonizer{}$ function for each QRE.
\begin{figure}[t]
\begin{center}
\[
\begin{array}{l@\quad l @\quad l}
\canonizer(R) &=& id_{\mathcal{L}(R)} \\
\canonizer(\project{R}{s})(w) &=& s\\
\canonizer(\squash{c_1}{c_2}{f})(w) &=&
\begin{cases}
\canonizer(c_1)(f(w)) & \text{if } w \in \mathcal{L}(W(c_1))\\
\canonizer(c_2)(w) & \text{otherwise}
\end{cases}\\
\canonizer(\normalize{R}{R'}{f}) &=& f\\
\canonizer(c_1 \; ; \; c_2) &=& \canonizer(c_2) \circ \canonizer(c_1)\\
\canonizer(c_1 \cdot c_2) &=& \canonizer(c_1) \cdot \canonizer(c_2)\\
\canonizer(c_1 \sep c_2)(w) &=&
\begin{cases}
\canonizer(c_1)(w) & \text{if } w \in \mathcal{L}(W(c_1))\\
\canonizer(c_2)(w) & \text{if } w \in \mathcal{L}(W(c_2))\\
\end{cases}\\
\canonizer(c^*) &=& \canonizer(c)^* \\
\end{array}
\]
\end{center}
\begin{align*}
&\canonizer(\perm{c_1, \ldots, c_n}{c})(r_{\sigma(1)}
\cdot s_1 \cdot \ldots \cdot s_{n-1} \cdot r_{\sigma(n)})\\
&= (\canonizer(c_1)(r_1)) \cdot (\canonizer(c)(s_1)) \cdot \ldots \cdot
(\canonizer(c_n)(r_n))
\end{align*}
\caption{QRE canonizers}
\label{fig:canonizers}
\end{figure}
Again, the \textit{permutation} combinator gives the most interesting
definition,
\begin{align*}\canonizer(\perm{c_1, \ldots, c_n}{c})(r_{\sigma(1)}
\cdot s_1 \cdot \ldots \cdot s_{n-1} \cdot r_{\sigma(n)}) \\
= (\canonizer(c_1)(r_1)) \cdot (\canonizer(c)(s_1)) \cdot \ldots \cdot
(\canonizer(c_n)(r_n))
\end{align*}
\noindent which, as we have explained, is defined so that the strings that match
$c_i, c$ are placed in the canonical permutation which is the identity
permutation before $\canonizer(c_i)$ and $\canonizer(c)$ are applied
respectively.

Finally, Figure ~\ref{fig:relations} gives the inductive definition of the
equivalence relation $\eqrel{c}$. This is the set-theoretic semantics of QREs
as an equivalence relation on a regular language.

\begin{figure}[t]
\centering
\[
\begin{array}{l@{}l@{\ \ }l}
w \; \equiv_R \; w' &\iff& w = w' \\
w \; \equiv_{\project{R}{s}} \; w' && \text{for all }w, w'\\
w \; \equiv_{\squash{c_1}{c_2}{f}} \; w' &\iff& f(w) \equiv_{c_2} w'
\text{ or } w \equiv_{c_2} w' \\
w \; \equiv_{\normalize{R}{R'}{f}} \; w' &\iff&
f(w)=f(w') \text{ or }w = w'\\
w \; \equiv_{c_1 \; ; \; c_2} \; w' &\iff& \exists k, k' \in
\mathcal{L}(K(c_2)) \text{ such that } w \; \equiv_{c_1} \; k, \; w' \;
\equiv_{c_1} \; k', \text{ and } k \; \equiv_{c_2} \; k'\\
w \; \equiv_{c_1 \cdot c_2} \; w'  &\iff& w = r_1
\cdot r_2, \; w' = {r'}_1 \cdot {r'}_2 \text{ with } r_1 \; \equiv_{c_1}
\; {r'}_1, \; r_2 \; \equiv{c_n} \; {r'}_2\\
w \; \equiv_{c_1 \sep c_2} \; w' &\iff& w \; \equiv_{c_1} \; w'
\text{ or } \; w \; \equiv_{c_2} \; w'\\
w \; \equiv_{c^*} \; w' &\iff& w = r_1 \cdot \ldots \cdot r_n, \; w'
= {r'}_1 \cdot \ldots \cdot {r'}_n \text{ and } r_i \equiv_{c} \; {r'}_i
\\
w \; \equiv_{\perm{c_1, \ldots, c_n}{c}} \; w' &\iff& w = r_{\sigma(1)}
\cdot s_1 \cdot \ldots \cdot s_{n-1} \cdot r_{\sigma(n)}, \;
w' = {r'}_{\theta(1)} \cdot s'_1 \cdot \ldots \cdot s'_{n-1}
\cdot {r'}_{\theta(n)} \\
& & \text{for some } \sigma, \theta \in S_n, \text{ with } r_i \;
\equiv_{q_i} \; r'_i \text{ and } s_k \; \equiv_{c} \; s'_{k}
\end{array}
\]
\caption{QRE Equivalence Relations}
\label{fig:relations}
\end{figure}
\subsection{Well Formed QREs}
\subsubsection{Completeness of {\em normalize}}
Before we present the full inference rules, for QREs, we discuss the {\em
normalize} QRE which is special in two main ways, the first of which has to do
with the premises in its inference rule:
\begin{prooftree}
\AxiomC{$\mathcal{L}(R') \subseteq \mathcal{L}(R)$}
\AxiomC{$f : \mathcal{L}(R) \longrightarrow \mathcal{L}(R')$}
\AxiomC{$f$ is surjective}
\AxiomC{$f = f^2$}
\RightLabel{(Normalize)}
\QuaternaryInfC{$\wf{\normalize{R}{R'}{f}}$}
\end{prooftree}
In order for the {\em normalize} QRE to be well-formed, then canonizing function
$f$ used by this combinator must be surjective and idempotent. Unfortunately,
verifying that a function satisfies these properties is in general undecidable.
Nonetheless, we allow a programmer to use normalize at their own risk without
checking these side conditions.

We do this firstly because the {\em normalize} combinator allows one to express
equivalence relations that are either difficult to define, or that cannot be
defined using the other combinators. Secondly, the {\em normalize} canonizer
enjoys the property that each of the other combinators $c$ is semantically
equivalent to $\normalize{W(c)}{K(c)}{f}$ for some surjective, idempotent
function $f : \mathcal{L}(W(c)) \longrightarrow \mathcal{L}(K(c))$; this is the
second property that distinguishes the {\em normalize} combinator from the other
QREs. The {\em normalize} combinator hence gives a sufficient condition for
potential QREs to be ``well-behaved'', particularly with respect to the
strategy for synthesizing quotient lenses which we shall introduce in
Section~\ref{synth}. This is the
\subsubsection{Ambiguity}
Another issue which we address before presenting the full set of inference
rules for QREs, we discuss the issue of {\em ambiguity}, which appears in the
premises of the inference rules for the regular combinators. If $c_1$ and $c_2$
are QREs, then when applying the regular combinators to QREs, we require that
if a string $s$ matches any of the regular expressions $W(c_1) \cdot W(c_2)$,
\quad $W(c_1) \sep W(c_2)$, \quad $W(c_1)^*$, \quad $K(c_1) \cdot K(c_2)$,
\quad $K(c_1) \sep K(c_2)$, \quad $K(c_1)^*$, then $s$ matches that regular
expression in only one way.

Formally, we say that regular expressions $R$ and $S$ are
\textit{unambiguosly concatenable}, written $R \cdot^! S$ if for all strings
$r, r' \in \mathcal{L}(R)$ and $s, s' \in \mathcal{L}(S)$, if $r \cdot s = r'
\cdot s'$, then $r = r'$ and $s = s'$. We say that a regular expression $R$ is
\textit{unambiguosly iterable}, written $R^{*!}$ if for all strings $r_1,
\ldots, r_m$ and $r'_1, \ldots, r'_n \in \mathcal{L}(R)$, if $r_1 \cdot \ldots
\cdot r_m = r'_1 \cdot \ldots \cdot r'_n$, then $m = n$ and $r_i = r'_i$. We say
that a regular expression $R$ is \textit{strongly unambiguous}\cite{Sippu1988}
if and only if (1) $R = \varnothing$, or (2) $R = S_1 \cdot S_2$ with $S_1,
S_2$ strongly unambiguous and $S_1 \cdot^! S_n$, or (3) $R = S_1 \sep S_2$ with
$S_1, S_2$ strongly unambiguous and $\mathcal{L}(S_1) \cap \mathcal{L}(S_2) =
\varnothing$, or (4) $R = S^*$ with $S$ strongly unambiguous and $S^{*!}$.

Strong unambiguity is necessary in the premises of the regular QRE combinators
because it ensures that the canonizing function of a QRE is well-defined.
For example consider the QRE \lstinline{"a"* . (project "a"* $\to$ "a")}. The
behaviour of this QRE is not-well defined since the string
\cd{"aaa"} can be canonized to any of \cd{"a"}, \cd{"aa"}, or \cd{"aaa"}
depending on how \cd{"aaa"} is parsed. We also require that the regular
combinators applied to the kernels of QREs be unambiguous since the underlying
bijective lens of a QRE lens operates on kernels, and bijective lenses
impose the same unambiguity restrictions so that they too are well defined as
functions.

Figure~\ref{fig:qrerules} gives the inference rules for deriving well-formed
QREs.
\begin{figure}[tp!]
\begin{center}
\AxiomC{$R$ is strongly unambiguous}
\RightLabel{(Id)}
\UnaryInfC{$\wf{\mathit{id}(R)}$}
\DisplayProof
\hskip 1.5em
\AxiomC{$s \in \mathcal{L}(R)$}
\RightLabel{(Project)}
\UnaryInfC{$\wf{\project{R}{s}}$}
\DisplayProof
\hskip 1.5em
\end{center}

\begin{prooftree}
\AxiomC{$\wf{c_i, c}$}
\RightLabel{(Perm)}
\AxiomC{${\substack{\forall \sigma \neq \theta, \; W(c_{\sigma(1)}) \cdot W(c)
\cdot \ldots \cdot W(c_{\sigma(n)})\\ \cap W(c_{\theta(1)}) \cdot W(c)
\cdot \ldots \cdot W(c_{\theta(n)}) =\varnothing}}$}
\AxiomC{$K(c_1) \cdot^! K(c) \cdot^! \ldots \cdot^! K(c) \cdot^! K(c_n)$}
\TrinaryInfC{$\wf{\perm{c_1, \ldots, c_n}{c}}$}
\end{prooftree}

\begin{center}
\AxiomC{$\wf{c_1, c_2}$}
\AxiomC{$\mathcal{L}(W(c_1)) \cap \mathcal{L}(W(c_2)) = \varnothing$}
\AxiomC{$f : \mathcal{L}(W(c_1)) \longrightarrow \mathcal{L}(W(c_2))$}
\RightLabel{(Squash)}
\TrinaryInfC{$\wf{\squash{c_1}{c_2}{f}}$}
\DisplayProof
\end{center}
\begin{center}

\begin{prooftree}
\AxiomC{$\mathcal{L}(R') \subseteq \mathcal{L}(R)$}
\AxiomC{$f : \mathcal{L}(R) \longrightarrow \mathcal{L}(R')$}
\AxiomC{$f$ is surjective}
\AxiomC{$f = f^2$}
\RightLabel{(Normalize)}
\QuaternaryInfC{$\wf{\normalize{R}{R'}{f}}$}
\end{prooftree}

\end{center}
\begin{center}
\AxiomC{$\wf{c_1, c_2}$}
\AxiomC{$K(c_1) = W(c_2)$}
\RightLabel{(Compose)}
\BinaryInfC{$\wf{c_1 \; ; \; c_2}$}
\DisplayProof
\hskip 1.5em
\AxiomC{$\wf{c}$}
\AxiomC{$W(c)^{*!}$}
\AxiomC{$K(c)^{*!}$}
\RightLabel{(Star)}
\TrinaryInfC{$\wf{c^*}$}
\DisplayProof
\end{center}
\begin{center}

\begin{center}
\AxiomC{$\wf{c_1, c_2}$}
\AxiomC{$W(c_1) \cdot^! W(c_2)$}
\AxiomC{$K(c_1) \cdot^! K(c_2)$}
\RightLabel{(Concat)}
\TrinaryInfC{$\wf{c_1 \cdot c_2}$}
\DisplayProof
\end{center}

\begin{center}
\AxiomC{$\wf{c_1, c_2}$}
\AxiomC{$W(c_1) \cap W(c_2) = \varnothing$}
\RightLabel{(Union)}
\BinaryInfC{$\wf{c_1 \sep c_2}$}
\DisplayProof
\
\end{center}
\end{center}
\caption{Well-formed QREs}
\label{fig:qrerules}
\end{figure}
As we already mentioned, the unambiguity conditions come into play when defining
QREs using the regular combinators. For example, the (Concat) inference rule
for concatenation says that the concatenation $c_1 \cdot c_2$ of QREs $c_1$ and
$c_2$ is well formed only if the concatentions of $W(c_1)$ and $W(c_2)$, and
$K(c_1)$ and $K(c_2)$ are unambiguous.

The most complicated inference rule is the (Perm) rule for the
\textit{permutation} combinator. The second hypothesis for the
\textit{permutation} rule says that for any two different permutations $\sigma$
and $\theta$, the languages $W(c_{\sigma(1)}) \cdot W(c) \cdot \ldots \cdot
W(c_{\sigma(n)})$ and $W(c_{\theta(1)}) \cdot W(c) \cdot \ldots \cdot
W(c_{\theta(n)})$ must be disjoint. This is because any string that matches the
\textit{permutation} combinator matches the language $W(c_{\theta(1)}) \cdot
W(c) \cdot \ldots \cdot W(c_{\theta(n)})$ for some permutation $\theta$, so we
require that these regular expressions be disjoint.
%
The third hypothesis says that the regular expression $K(c_1) \cdot K(c)
\cdot \ldots \cdot K(c) \cdot K(c_n)$ must be unambiguous. This is because the
underlying lens that maps to or from a \textit{permutation} QRE operates on
the language $K(c_1) \cdot K(c) \cdot \ldots \cdot K(c) \cdot K(c_n)$ which is
the kernel of the \textit{permutation} QRE. As we mentioned, the underlying
lens will require that the source and target regular expressions of the lens be
unambiguous so that the lens can match strings uniquely.


\section{QRE Lenses}
\label{QRE-lenses}
As we have seen, QREs express a broad class of equivalence relations
directly on regular languages.  QREs are therefore a good \textit{specification}
language for quotient lenses. We next introduce
\textit{QRE Lenses}, a class of quotient lenses specified using QREs.

\bcp{A question about variable names: If we use $R$ and $S$ for plain
  regular expressions, it seems inconsistent to use $c$ for QREs.  (And even
  more inconsistent to use $c$ and $c'$ or $c$ and $c_1$!) I suggest $P$ and
  $Q$ for QREs (with $Q$ as the default when we are only talking about
  one).}\sam{I made the notation consistent by just using $c_1$ and $c_2$. I
  personally feel that it is better not to use P and Q for QREs since we use
  p and q for QRE lenses, but if you disagree I will make the change.}\bcp{I
  agree that this is suboptimal, but I don't think it's worse than what we
  have now.  Or maybe the right fix is to choose different metavariables for
  QRE lenses.  Or to use capital letters other than $P$ and $Q$ for QREs.
  In any case, I don't like $c_1$ and $c_2$, both for the lower-case letter
  and for the subscripts---it's not at all consistent with our conventions
  elsewhere.}

Given regular expressions $R, S$ and equivalence relations
$\sim_R$ and $\sim_S$ defined on $\mathcal{L}(R)$ and $\mathcal{L}(S)$,
we\bcp{can we clarify that this is exactly Foster et al's 
definition?}\sam{this is not Foster et al's definition. It's just a
loosening of the definition for bijective lens used in the Optician
paper}\bcp{OK, then we should say this}define
a {\em bijective quotient lens} $q :
R /{\sim_R} \Leftrightarrow S/{\sim_S}$ to be a pair of functions $q.\get :
\mathcal{L}(R) \longrightarrow \mathcal{L}(S)$ and $q.\lput : \mathcal{L}(S)
\longrightarrow \mathcal{L}(R)$ such that for all $r \in \mathcal{L}(R)$ and $s
\in \mathcal{L}(S)$, we have $q.\lput(q_1.\get(r)) \sim_R r$ and
$q.\get(q_1.\lput(s)) \sim_R s$. Moreover, if $r \sim_R r'$, then $q.\get(r) =
q.\get(r')$, and if $s \sim_S s'$, then $q.\lput(s) = q.\lput(s')$.

In words, a bijective quotient lens $q$ from $R$ to $S$ modulo $\sim_R$
and $\sim_S$ is a pair of functions $q.\get$ and $q.\lput$ such that
$q.\get$ respects $\sim_R$ and $q.\lput$ respects $\sim_S$, and such that
the {\em get} and {\em put} functions lifted to $\mathcal{L}(R)/{\sim_R}$ and
$\mathcal{L}(S)/{\sim_S}$ are mutual inverses.

These laws are similar to the laws for bijective lenses\bcp{we should state
  them explicitly somewhere in this paper and refer to them here by number},
except that the 
equality restrictions in the bijective lens laws are loosened to allow for
equivalence relations. Also, the condition that $r \sim_R r'$ implies
$q.\get(r) = q.\get(r')$ ensures that the {\em get} function induced on
the equivalence classes if $\equiv_c$ is well-defined, and similarly for
the {\em put} function. 

Now let $c_1$ and $c_2$ be QREs. Given a bijection $\ell : K(c_1)
\Leftrightarrow K(c_2)$, we may define a quotient lens $q : W(c_1)/\eqrel{c_1}
\Leftrightarrow W(c_2)/\eqrel{c_2}$ by $q.\get = \ell \circ \canonizer(c_1)
$ and $q.\lput = \ell_1^{-1} \circ \canonizer(c_2)$. In other words, the get
function of $q$ first canonizes the source data using $\canonizer(c_1)$
and then applies $f$ to the result, while the put function of $q$ first
canonizes the target data using $\canonizer(c_2)$ and the applies $f^{-1}$ to
the result. This is our approach in defining QRE lenses.

One potential pitfall\bcp{Why is this a pitfall?  I.e., why do we care about
this norman form?  (The answer is synthesis, of course, but we haven't said
so here.)} with QRE lenses is that the combinators that
we define on them may not preserve this normal form\bcp{In what sense is
  this a ``normal form''?  What you've given above is just a definition:
  quotient lenses can be defined in such and such way.  You haven't said we
  want to consider it a normal form, or specified what process it is the
  normal form {\em of}.}. For example, the
composition $q_1 \; ; \; q_2$ of QRE lenses $q_1$ and $q_2$ may not be
equivalent to any quotient lens that has the canonical normal form of a
bijective lens with canonizers a the edges. Consequently, in order to guarantee
that every QRE lens $q_1$ is equivalent to a QRE lens $q_2$ in this
canonical form\bcp{This paragraph uses variables $q_1$ and $q_2$ twice, with
two different meanings.}, we need to identify a set $S$ of bijections that
will ensure 
that every QRE lens is functionally equivalent to a QRE lens in canonical
form.\bcp{This is not very clear, in part because it is not very precise:
  It is assuming, implicitly, that the class of QRE lenses is 
  parameterized on a particular set of bijections on kernels, and then
  asking what sets of bijections can be used.  This question makes sense,
  but the reader may not realize that this is what's being asked. } 
Our choice is to use the class of \textit{bijective lenses}, which we studied in
\cite{optician} and has this desired property. The following part of the paper
briefly discusses bijective lenses.

\subsection{Bijective Lenses}
\bcp{There's a persistent opportunity for confusion between the semantic
  space of {\em all} bijective lenses (perhaps between arbitrary structures,
  not just strings) and the rather specific bijections that are picked out
  by our combinators.  One way to help, I think, would be to use the phrase
  ``bijective string lenses'' instead of just ``bijective lenses.''}
We define the set of \textit{bijective lenses} to be the set of bijections
between regular languages created using Boomerang lens combinators.\bcp{Why
  do we choose Boomerang's set of combinators?  Does it have some formal
  property that we find attractive?  Or did it just happen to be lying around?}
The syntax for the language of bijective lenses is given by
$$\ell_1 := \mathit{id} \; (R) \sep \const(s_1, s_2) \sep  \swap(\ell_1,
\ell_2) \sep \ell_1 \cdot \ell_2 \; |  \; (\ell_1 \sep \ell_2) \sep \ell^* \;
| \; \ell_1 \; ; \;  \ell_2,$$ where $R$ ranges over regular expressions and $s$
ranges over character strings.

The denotation of a lens $\ell_1$ is $\llbracket \ell_1 \rrbracket \subseteq
\mathit{String} \times \mathit{String}$. If $(s_1, s_2) \in \llbracket \ell_1
\rrbracket$, then $\ell_1$ maps between $s_1$ and $s_2$.
\begin{align*}
\llbracket R \rrbracket &= \{(r, r) \sep r \in \mathcal{L}(R)\}\\
\llbracket \const(r, s) \rrbracket &= \{(r, s)\}\\
\llbracket \swap(\ell_1, \ell_2) \rrbracket &= \{(s \cdot t, t' \cdot s') \sep
(s, s') \in \llbracket \ell_1 \rrbracket \text{ and } (t, t') \in \llbracket
\ell_2 \rrbracket\}\\
\llbracket \ell_1 \cdot \ell_2 \rrbracket &= \{(s \cdot t, s' \cdot t) \sep
(s, s') \in \llbracket \ell_1 \rrbracket \text{ and } (t, t') \in \llbracket
\ell_2 \rrbracket\}\\
\llbracket \ell_1 \sep \ell_2 \rrbracket &= \{(s \cdot t) \sep
(s, t) \in \llbracket \ell_1 \rrbracket \text{ or } (s, t) \in \llbracket
\ell_2 \rrbracket\}\\
\llbracket \ell^* \rrbracket &= \{(s_1 \cdot \ldots \cdot s_n, t_1 \cdot \ldots
\cdot t_n) \sep (s_i, t_i) \in \llbracket \ell \rrbracket \text{ for } 1
\leq i \leq n\}\\
\llbracket \ell_1 \; ; \; \ell_2 \rrbracket &= \{(r, t) \sep \text{there exists }s
\text{ such that } (r, s) \in \llbracket \ell_1 \rrbracket \text{ and } (s, t)
\in \llbracket \ell_2 \rrbracket\}
\end{align*}
The $\mathit{\const}(s, t)$ lens replaces the string $s$ with $t$ in the source
data in the forward direction, and $t$ with $s$ in the target data in the backward
direction. \bcp{Don't begin a sentence with a lower-case letter, even if it
  is a math symbol.  Find a way to rewrite so that it doesn't need to be at
  the beginning.}$\mathit{id}(R)$ applies the identity function to the
source and target 
in $\mathcal{L}(R)$ in both directions. The composition lens $\ell_1 \; ; \; \ell_2$
applies $\ell_1$ followed by then $\ell_2$ to the source in the forward direction,
and applies $\ell_2$ followed by $\ell_1$ to the target in the backward direction.
The lens $\ell_1 \cdot \ell_2$ first splits the string $s$ into $s_1$ and $s_2$,
applies $\ell_1$ and $\ell_2$ to $s_1$ and $s_2$ to get $t_1$ and $t_2$
respectively, then concatenates $t_1$ and $t_2$ and returns $t_1 \cdot t_2$ as
the final result in the forward direction. $\ell_1 \cdot \ell_2$ operates
similarly in the backward direction, but with $s, s_1$ and $s_2$ substituted
for $t, t_1$ and $t_2$. The $\mathit{\swap} \; (\ell_1, \ell_2)$ lens operates
like $\ell_1 \cdot \ell_2$, except that it swaps $t_1$ and $t_2$ before
concatenating the two for a final result of $t_2 \cdot t_1$ in the forward
direction. In the backward direction, $\mathit{\swap}(\ell_1, \ell_2)$ first undoes
the \swap, then behaves like $cdot$. The $\ell_1 \; | \; \ell_2$ lens
chooses to apply $\ell_1$ or $\ell_2$ depending on whether the source
(resp. target) data is matched by $\ell_1$ or $\ell_2$ in the forward (resp.
backward direction). The $\ell^*$ lens splits the string $s$ into strings $s_1,
\ldots, s_n$, applies $\ell_1$ to each $s_i$ to get $t_i$, and then concatenates
each of the $t_i$'s for a final result of $t_1 \cdot \ldots \cdot t_n$ in the
forward direction. \bcp{ditto}$\ell^*$ operates similarly in the backward direction, but
with $s, s_i$ substituted for $t, t_i$.

Each bijective lens $\ell$ has a type $\ell : R \Leftrightarrow S$ where $R$ and
$S$ are regular expressions. If $\ell : R \Leftrightarrow S$, then the source
language of $\ell$ is $\mathcal{L}(R)$ and the target language of $\ell$ is
$\mathcal{L}(S)$. Interestingly, with the bijective lens type system, a lens
$\ell : R \Leftrightarrow S$ can also be considered to be of type $\ell : R'
\Leftrightarrow S'$ provided that $R$ (resp. $S$) can be proven to be
equivalent to $R'$ (resp. $S$) from the star-semiring axioms\bcp{people may
  not know what these are}:

\begin{prooftree}
\AxiomC{$\ell_1 : R \Leftrightarrow S$}
\AxiomC{$R \equiv^s R'$}
\AxiomC{$S \equiv^s S'$}
\TrinaryInfC{$\ell_1 : R' \Leftrightarrow S'$}
\end{prooftree}

The other typing rules for bijective lenses are given in
Figure~\ref{fig:lensrules}.

\begin{figure}[t]
\begin{center}
\AxiomC{$s_1 \in \Sigma^*$}
\AxiomC{$s_2 \in \Sigma^*$}
\BinaryInfC{$\mathit{\const} \; (s_1, s_t): s_1 \Leftrightarrow s_2$}
\DisplayProof
\hskip 1.5em
\AxiomC{$R$ is strongly unambiguous}
\UnaryInfC{$\mathit{id} \; (R): R \Leftrightarrow R$}
\DisplayProof
\end{center}

\begin{center}
\AxiomC{$\substack{\ell_1 : R_1 \Leftrightarrow S_1 \\ \ell_2 : R_2
\Leftrightarrow S_2}$}
\AxiomC{$\substack{R_1 \cdot^! R_2 \\S_1 \cdot^! S_2 }$}
\BinaryInfC{$\ell_1 \cdot \ell_2: R_1 \cdot R_2 \Leftrightarrow S_1 \cdot
S_2$}
\DisplayProof
\hskip 1.5em
\AxiomC{$\substack{\ell_1 : R_1 \Leftrightarrow S_1 \\ \ell_2 : R_2
\Leftrightarrow S_2}$}
\AxiomC{$\substack{R_1 \cdot^! R_2 \\ S_2 \cdot^! S_1}$}
\BinaryInfC{$\mathit{\swap} \; (\ell_1, \ell_2): R_1 \cdot R_2
\Leftrightarrow S_2 \cdot S_1$}
\DisplayProof
\end{center}

\begin{center}
\AxiomC{$\ell_1 : R_1 \Leftrightarrow R_2$}
\AxiomC{$\ell_2 : R_2 \Leftrightarrow R_3$}
\BinaryInfC{$\ell_1 \; ; \; \ell_2: R_1 \Leftrightarrow R_3$}
\DisplayProof
\hskip 1.5em
\AxiomC{$\substack{\ell_1 : R_1 \Leftrightarrow S_1 \\ \ell_2 : R_2
\Leftrightarrow S_2}$}
\AxiomC{$\substack{\mathcal{L}(R_1) \cap \mathcal{L}(R_2) =
\varnothing \\ \mathcal{L}(S_1) \cap \mathcal{L}(S_2) = \varnothing}$}
\BinaryInfC{$\ell_1 \sep \ell_2: R_1 \sep R_2 \Leftrightarrow S_1 \sep S_2$}
\DisplayProof
\end{center}

\begin{center}
\AxiomC{$\ell : R \Leftrightarrow S$}
\AxiomC{$R^{*!}$}
\AxiomC{$S^{*!}$}
\TrinaryInfC{$\ell^*: R \Leftrightarrow S$}
\DisplayProof
\hskip 1.5em
\AxiomC{$\ell : R \Leftrightarrow S$}
\AxiomC{$R \equiv^s R'$}
\AxiomC{$S \equiv^s S'$}
\TrinaryInfC{$\ell : R' \Leftrightarrow S'$}
\DisplayProof
\end{center}
\caption{Bijective Lens Typing Rules}
\label{fig:lensrules}
\end{figure}

\subsection{Syntax of QRE Lenses}
Having given a brief overview of the class of bijective lenses, we now introduce
the class of QRE lenses. The language of QRE lenses is given by following
grammar:
$$ q := \kw{lift}(\ell) \sep \kw{lquot}(q, \ell) \sep
\kw{rquot}(\ell, q) \sep q_1 \cdot q_2 \sep (q_1 \sep q_2) \sep q^* \sep
q_1 \; ; \; q_2,$$ where $\ell$ ranges over bijective lenses.
\BCP{Is this really what we want?  E.g., isn't it reasonable for the 
  programmer to write $\mathit{\swap}(q_1, q_2)$?}

The QRE lens combinators are inspired by the Boomerang lens combinators of the
same name. The $\kw{lift}(\ell)$ quotient lens enables a bijective lens
$\ell$ to be considered a quotient lens, with the equivalence relation applied
to both the source and target formats being the equality relation. The
regular combinators of concatenation `$\cdot$', Kleene star `$*$' and
`$|$' on QRE lenses exhibit the expected behaviour\bcp{Is the behavior really
  ``expected''---i.e., will it be obvious to all readers?}, with the caveat
that these 
combinators are strongly unambiguous. The composition operator `$;$' also
exhibits the expected behaviour, though the conditions that must be checked in
order for the composition to be well defined are perhaps unintuitive. The
reasons why these conditions are necessary will become more apparent when
proving normal forms for QRE lenses.

The interesting combinators are the $\kw{lquot}$ and $\kw{rquot}$
combinators. The $\kw{lquot}(c, q)$ combinator takes a quotient lens $q$ and
quotients the source data using $c$, assuming that the source data forms a
complete set of representatives for the equivalence relation $\eqrel{c}$. The
$\kw{lquot}(q, c)$ combinator does the same but on the target data.

For example, recall that in the \bibtex{} to EndNote transformation, we had the
QREs \cd{bibtex} and \cd{endnote} and the bijective lens \cd{bib_to_end}
that maps between 
\cd{bibtex} and \cd{endnote}. The quotient lens that maps between
\cd{bibtex} and \cd{endnote} is then given by the following QRE lens:

\begin{lstlisting}
let bib_to_end_q : (lens in bibtex $\Leftrightarrow$ endnote) = 
  rquot (lquot(bibtex, bib_to_end), endnote)
\end{lstlisting}

\iffalse
The difference between QRE lenses and Boomerang quotient lenses lies in the
typing judgements. More concretely, each QRE lens $q_1$ has a type $q_1 : c
\Leftrightarrow c_1$ where $c, c_1$ are QREs. In contrast, the approach used to
type quotient lenses in Boomerang is to classify equivalences according to
whether they are or are not the equality relation. This type system is based on
two observations: first, that most quotient lenses originate as lifted basic
lenses, and therefore have types whose equivalence relations are both equality;
and second, that equality is preserved by many of the quotient lens
combinators. Foster et al also discuss a second possible approach to typing
quotient lenses, where equivalence relations are represented by rational
functions that induce them. While this second approach is more refined than the
first, Boomerang favours the first approach since the second appears to be too
expensive to be useful in practice~\cite{quotientlenses}.
\fi

\subsection{Semantics of QRE Lenses}

Each QRE lens $q$ has a type $q : c_1 \Leftrightarrow c_2$ where $c_1, c_2$ are
QREs. If $q : c_1 \Leftrightarrow c_2$, then the source format is described by
$W(c_1)$ and the canonical set of representative for the source data is
described by $K(c_1)$.
Similarly, the target format is described by $W(c_2)$ and the canonical set of
representatives for the target data is described by $K(c_2)$. The underlying
lens of $q$ is a bijective lens $\ell : K(c_1) \Leftrightarrow K(c_2)$.

The denotation $\llbracket q \rrbracket$ of a QRE lens $q : c_1 \Leftrightarrow
c_2$ is a quotient lens $\llbracket q \rrbracket : W(c_1)/{\eqrel{c_1}}
\Longleftrightarrow W(c_2)/{\eqrel{c_2}}$. The typing rules and denotation of
QRE lenses are given in Figure~\ref{fig:qlenssemantics}.
\begin{figure}[ht]
\centering
\[
\begin{array}[b]{l@{\qquad}l}
\RuleSide{\ell : R \Leftrightarrow S}{\kw{lift}(\ell): id(R) \Leftrightarrow
id(S)}{\mathit{(Lift)}} &
\begin{array}[b]{rcl}
\llbracket \kw{lift}(\ell) \rrbracket.\get &=&  \llbracket \ell \rrbracket\\
\llbracket \kw{lift}(\ell) \rrbracket.\lput &=& \llbracket \ell \rrbracket^{-1}
\end{array}
\end{array}
\]
\[
\begin{array}[b]{c@{\qquad}c}
\RuleSide{q : c_2  \Leftrightarrow c_3 &
\wf{c_1} &
K(c_1) = W(c_2)}
{\kw{lquot}(c_1, q): c_1 \; ; \; c_2 \Leftrightarrow c_3}{\mathit(Lquot)} &
\begin{array}[b]{rcl}
\llbracket \kw{lquot}(c_1, q) \rrbracket.\get  &=& \llbracket q
\rrbracket.\get \circ \canonizer(c_1)\\
\llbracket \kw{lquot}(c_1, q) \rrbracket.\lput &=& \llbracket q
\rrbracket.\lput
\end{array}
\end{array}
\]

\[
\begin{array}[b]{c@{\qquad}c}
\RuleSide{q : c_1 \Leftrightarrow c_3 & \wf{c_3} & W(c_3) = K(c_2)}
{\kw{rquot}(q, c_1):c_1 \Leftrightarrow c_2 \; ; \; c_3}{\mathit{(Rquot)}} &
\begin{array}[b]{rcl}
\llbracket \kw{rquot}(q, c_1) \rrbracket.\get  &=& \llbracket q
\rrbracket.\get\\
\llbracket \kw{rquot}(q, c_1) \rrbracket.\lput &=& \llbracket q
\rrbracket.\lput \circ \canonizer(c_3)
\end{array}
\end{array}
\]

\[
\begin{array}[b]{l@{\qquad}c}
\RuleSide{q : c_1 \Leftrightarrow c_2 &
W(c_1)^{*!},W(c_2)^{*!} & K(c_1)^{*!}, K(c_2)^{*!}}
{{q}^* : {c_1}^* \Leftrightarrow {c_2}^*}{\mathit{(Star)}} &
\begin{array}[b]{rcl}
\llbracket {q}^* \rrbracket.\get  &=& (\llbracket q \rrbracket.\get)^*\\
\llbracket {q}^* \rrbracket.\lput &=& (\llbracket q \rrbracket.\get)^*
\end{array}
\end{array}
\]

\[
\begin{array}[b]{l@{\qquad}c}
\RuleSide{\substack{q_1 : c_1 \Leftrightarrow d_1 \\ q_2 : c_2 \Leftrightarrow
d_2} & {\substack{W(c_1) \cdot^! W(c_2)\\ K(c_1) \cdot^! K(c_2)}}
& {\substack{W(d_1) \cdot^! W(d_2)\\ K(d_1) \cdot^! K(d_2)}}}
{q_1 \cdot q_2: c_1 \cdot c_2 \Leftrightarrow d_1 \cdot d_2}{\mathit{(Concat)}}
&
\begin{array}[b]{rcl}
\llbracket q_1 \cdot q_2 \rrbracket.\get  &=& \llbracket q_1 \rrbracket.\get
\cdot \llbracket q_2 \rrbracket.\get\\
\llbracket q_1 \cdot q_2\rrbracket.\lput &=& \llbracket q_1 \rrbracket.\lput
\cdot \llbracket q_2 \rrbracket.\lput
\end{array}
\end{array}
\]

\[
\begin{array}[b]{l@{\qquad}c}
\RuleSide{\substack{q_1 : c_1 \Leftrightarrow d_1 \\ q_2 : c_2 \Leftrightarrow
d_2} & \substack{\mathcal{L}(W(c_1)) \cap \mathcal{L}(W(c_2)) = \varnothing
\\ \mathcal{L}(W(d_1)) \cap \mathcal{L}(W(d_2)) = \varnothing }}
{q_1 \sep q_2: (c_1 \sep c_2)\Leftrightarrow (d_1 \sep d_2)}{\mathit{(Or)}} &
\begin{array}[b]{rcl}
\llbracket q_1 \sep q_2 \rrbracket.\get(s) =
\begin{cases}
\llbracket q_1 \rrbracket.\get (s) & \text{if } s \in \mathcal{L}(W(c_1))\\
\llbracket q_2 \rrbracket.\get (s) & \text{if } s \in \mathcal{L}(W(c_2))\\
\end{cases}\\
\llbracket q_1 \sep q_2 \rrbracket.\lput(s) =
\begin{cases}
\llbracket q_1 \rrbracket.\lput (s) & \text{if } s \in \mathcal{L}(W(d_1))\\
\llbracket q_2 \rrbracket.\lput (s) & \text{if } s \in \mathcal{L}(W(d_2))\\
\end{cases}
\end{array}
\end{array}
\]

\begin{prooftree}
\AxiomC{$\substack{q_1 : c_1 \Leftrightarrow c_2 \\ q_2 : c_3 \Leftrightarrow
c_4}$}
\RightLabel{(Compose)}
\AxiomC{$\substack{\mathcal{L}(W(c_2))= \mathcal{L}(W(c_3)) \\ K(c_2) \equiv^s
K(c_3)}$}
\AxiomC{$\canonizer(c_2) = \canonizer(c_3)$}
\TrinaryInfC{$q_1 \; ; \; q_2: c_1 \Leftrightarrow c_4$}
\end{prooftree}
\begin{align*}
\llbracket q_1 \; ; \; q_2 \rrbracket.\get &= \llbracket q_2
\rrbracket.\get\circ \llbracket q_1 \rrbracket.\get\\
\llbracket q_1 \; ; \; q_2 \rrbracket.\lput &= \llbracket q_1 \rrbracket.\lput
\circ \llbracket q_2 \rrbracket.\lput
\end{align*}
\caption{Denotation and Typing Rules for QRE Lenses}
\label{fig:qlenssemantics}
\end{figure}
The trickiest typing rule is the typing rule for composition:

\begin{prooftree}
\AxiomC{$\substack{q_1 : c_1 \Leftrightarrow c_2 \\ q_2 : c_3 \Leftrightarrow
c_4}$}
\AxiomC{$\substack{\mathcal{L}(W(c_2))= \mathcal{L}(W(c_3)) \\ K(c_2) \equiv^s
K(c_3)}$}
\AxiomC{$\canonizer(c_2) = \canonizer(c_3)$}
\TrinaryInfC{$q_1 \; ; \; q_2: c_1 \Leftrightarrow c_4$}
\end{prooftree}

This derivation rule essentially says that the composition $q_1 \; ; \; q_2$ is
well defined if and only if the intermediary QREs $c_3$ and $c_4$ define the
same equivalence relation on regular languages that are equivalent modulo the
star-semiring axioms. The condition $\mathcal{L}(W(c_2)) = \mathcal{L}(W(c_3))$
says that the intermediary language is the same on both sides, while the
condition $K(c_2) \equiv^s K(c_3)$ says that the kernel regular expressions are
equivalent modulo the star-semiring axioms. Finally, the condition
$\canonizer(c_2) = \canonizer(c_3)$ says that $c_2$ and $c_3$ define the same
equivalence relation on $\mathcal{L}(W(c_2))= \mathcal{L}(W(c_3))$.

In general, checking that $\canonizer(c_2) = \canonizer(c_3)$ is undecidable
because of the {\em normalize} QRE which allows uses an arbitrary
idempotent function as the canonizer. Therefore, our actual implementation of
the composition rule for QRE lenses follows Boomerang's approach, which is to
define the composition on QRE lenses if and only if $c_2$ and $c_3$ are
syntactially equal to $id(R)$ and $id(R')$ for some $R$ and $R'$ satisfying
$\mathcal{L}(R) = \mathcal{L}(R')$.  \BCP{Here, once again, I worry that we
  are mixing fundamental theory with pragmatic language design /
  implementation, to the detriment of both.  At a theoretical level, this
  restriction is nonsensical, and making it here raises questions like
  ``Does the proof that composition can be normalized away depend on this
  restriction?''} 

Foster et al based this approach on two observations: first, that most quotient
lenses originate as lifted basic lenses, and therefore have types whose
equivalence relations are both equality; and second, that equality is preserved
by many of the quotient lens combinators. Foster et al also discuss a second
possible approach, where equivalence relations are represented by rational
functions that induce them. While this second approach is more refined than the
first, Boomerang favours the first approach since the second appears to be too
expensive to be useful in practice~\cite{quotientlenses}.

The semantics defined on QRE lenses imply the following theorem:
\begin{theorem}
If there is a derivation $q : c_1 \Leftrightarrow c_2$, then $\llbracket q
\rrbracket : W(c_1)/{\eqrel{c_1}} \Leftrightarrow W(c_2)/{\eqrel{c_2}}$ is a
well-defined quotient lens.
\end{theorem}
\subsection{Normal Forms of QRE Lenses}
Recall that our approach in defining QRE lenses is to have each QRE lens $q: c_1
\Leftrightarrow c_2$ be such that
\begin{align*}
\llbracket q \rrbracket.\get &= \ell \circ \canonizer(c_1)\\
\llbracket q \rrbracket.\lput &= \ell^{-1} \circ \canonizer(c_2)
\end{align*}
for some bijective lens $\ell$. In other words, each QRE lens is the same as a
bijective lens with canonizers at the edges. The following theorem,
which is the main technical contribution of this paper, confirms that this
indeed is the case:

\begin{theorem}\label{normal form}
If there is a derivation $q : c_1 \Leftrightarrow c_2$, then there exists a
bijective lens $\ell : K(c_1) \Leftrightarrow K(c_2)$ such that:
\begin{align*}
\llbracket q \rrbracket.\get &= \llbracket \ell \rrbracket\circ
\canonizer(c_1)\\
\llbracket q \rrbracket.\lput &= \llbracket \ell \rrbracket^{-1} \circ
\canonizer(c_2)
\end{align*}
\end{theorem}
\begin{proof}
By straightforward induction on the derivation
$q_1 : c_1 \Leftrightarrow c_2$. Since bijective lenses are closed under strongly unambiguous
regular operators, the tricky case is composition.  The composition case is
more involved since we need to show that we can get rid of the canonizers in
the middle:

\sam{TODO: Put a diagram here to show what you mean.}

The derivation rule and denotation for composition are as follows:
\begin{prooftree}
\AxiomC{$\substack{q_1 : c_1 \Leftrightarrow c_2 \\ q_2 : c_3 \Leftrightarrow
c_4}$}
\AxiomC{$\substack{\mathcal{L}(W(c_2))= \mathcal{L}(W(c_3)) \\ K(c_2) \equiv
K(c_3)}$}
\AxiomC{$\canonizer(c_2) = \canonizer(c_3)$}
\TrinaryInfC{$q_1 \; ; \; q_2: c_1 \Leftrightarrow c_4$}
\end{prooftree}

\begin{align*}
\llbracket q_1 \; ; \; q_2 \rrbracket.\get &= \llbracket q_2 \rrbracket.\get\circ
\llbracket q_1 \rrbracket.\get\\
\llbracket q_1 \; ; \; q_2 \rrbracket.\lput &= \llbracket q_1 \rrbracket.\lput
\circ \llbracket q_2 \rrbracket.\lput
\end{align*}

By the induction hypothesis, there exist bijective lenses
$\ell_1 : K(c_1) \Leftrightarrow K(c_2)$ and $\ell_2 : K(c_3) \Leftrightarrow
K(c_4)$ such that
\begin{center}

\begin{tabular}{l l}
$\llbracket q_1 \rrbracket.\get = \llbracket \ell_1 \rrbracket \circ
\canonizer(c_1)$ & $\llbracket q_2 \rrbracket.\get = \llbracket \ell_2
\rrbracket \circ \canonizer(c_3)$ \\
$\llbracket q_1 \rrbracket.\lput = {\llbracket \ell_1 \rrbracket}^{-1} \circ
\canonizer(c_2)$ & $\llbracket q_2 \rrbracket.\lput = {\llbracket \ell_2
\rrbracket}^{-1} \circ \canonizer(c_4)$
\end{tabular}

\end{center}
%
Consequently,
\begin{align*}
\llbracket q_2 \rrbracket.\get \circ \llbracket q_1 \rrbracket.\get &=
(\llbracket \ell_2 \rrbracket \circ \canonizer(c_3)) \circ (\llbracket \ell_1
\rrbracket \circ \canonizer(c_1))\\
&= \llbracket \ell_2 \rrbracket \circ (\canonizer(c_3) \circ \llbracket \ell_1
\rrbracket) \circ \canonizer(c_1)\\
&= (\llbracket \ell_2 \rrbracket \circ \llbracket \ell_1 \rrbracket) \circ
\canonizer(c_1)\\
&= \llbracket \ell_1 \; ; \; \ell_2 \rrbracket \circ \canonizer(c_1)
\end{align*}
We are permitted to claim the third step from the second since
$\canonizer(c_3)$ is the identity function on $K(c_2)$ which is
syntactically equal to $K(c_3)$ by assumption. A similar argument shows that
$$\llbracket q_1 \rrbracket.\lput \circ \llbracket q_2 \rrbracket.\lput =
\llbracket \ell_1 \; ; \; \ell_2 \rrbracket^{-1} \circ
\canonizer(c_4)$$

The other cases of the proof are similar, proceeding by a
straightforward application of the induction hypothesis followed by unrolling
the equations that give the denotation for QRE lenses.  Full details can be
found in the appendix.
\end{proof}

\section{Synthesizing QRE Lenses}
\label{synth}

QRE lenses address some of the limitations of bijective lenses because a single
lens program expresses both the canonizers and the transformation between kernel
languages simultaneously, which reduces programmer effort.  But we can go even
further by recognizing that the type structure of QRE lenses contains
information that can be exploited to automatically synthesize lenses from their
types.  Rather than writing the QRE lens manually, the programmer can instead
specify the desired behavior of a lens by giving its interface types and providing
examples, if necessary, to disambiguate among possible implementations.  This
way of constructing lenses can often be much simpler than building them by
hand, as we saw in Section~\ref{sec:examplesynth}.

The Optician framework~\cite{optician} showed how to do such lens synthesis in
the case for bijective lenses. Here we show how to reduce QRE lens synthesis to
that case, so that we can re-use the Optician algorithm but in the more
expressive context of QRE lenses.  The basic idea is straightforward: we run the
Optician algorithm to synthesize a lens between the kernels of two QREs and then
apply the canonizers at the edges to recover a lens between the whole
languages.  This simple strategy turns out to be remarkably effective, and the
idea of using Optician in this way is part of the impetus\bcp{What was the
  other part??} for the design of our QRE lenses.  

The Optician synthesis algorithm works as follows. Given regular expressions $R$
and $S$ and a set of example input--output pairs
$\{(r_1, s_1),\allowbreak \ldots,\allowbreak (r_n, s_n)\}$, Optician will try to
find a bijective lens $\ell : R \Leftrightarrow S$ that that agrees on the
examples, \textit{i.e.}, it maps $r_i$ to $s_i$ in the forward direction and
$s_i$ to $r_i$ in the backward direction.  The Optician algorithm is guaranteed
to succeed (eventually!) if such a lens exists.    \saz{We should probably
  mention what happens if the examples aren't sufficient to uniquely
  determine the lens.}

In our setting, we want to synthesize a quotient lens $q: c_1 \Leftrightarrow
c_2$ from the QREs $c_1$ and $c_2$ and a set of example input-output pairs
$\{(x_1, y_1),\allowbreak \ldots,\allowbreak (x_n, y_n)\}$ where the $x_i$'s are
in $W(c_1)$ and the $y_i$'s are in $W(c_2)$. We furthermore wish $q$ to map the
equivalence class of $x_i$ to the equivalence class of $y_i$ and vice versa:
\begin{align*}
q.\get(x_i) &\equiv_{c_2} y_i \text{, and}\\
q.\lput(y_i) &\equiv_{c_1} x_i
\end{align*}
Our approach to synthesizing QRE lenses is guided by Theorem~\ref{normal form},
which says that, if there is a derivation $q : c_1 \Leftrightarrow c_2$ of a
QRE lens, then there exists a bijective lens $\ell : K(c_1) \Leftrightarrow
K(c_2)$ such that
\begin{align*}
\llbracket q \rrbracket.\get &= \llbracket \ell \rrbracket\circ \canonizer(c_1)\\
\llbracket q \rrbracket.\lput &= \llbracket \ell \rrbracket^{-1} \circ
\canonizer(c_2).
\end{align*}
\bcp{This math display and the previous one are punctuated perfedtly: In the
first, the colon replaces a period at the end of the sentence (so no need
for another period at the end of the display).  In the second, the display
is punctuated as if it were inline.  Please go through and make sure all the
other displayed material follows one or the other of these rules.}

For the\bcp{why ``the''?  Are we talking about some set of QRE examples
  already?} QRE examples, the $x_i$'s are in $W(c_1)$ and the $y_i$'s are 
in $W(c_2)$, so we can construct ${x'_i} = \canonizer(c_1)(x_i)$ in $K(c_1)$
and ${y'_i} = \canonizer(c_2)(y_i)$ is in $K(c_2)$. To synthesize the
desired quotient lens $q: c_1 \Leftrightarrow c_2$ that is consistent with the
input-output examples $\{(x_1, y_1), \ldots, (x_n, y_n)\}$ it suffices to
synthesize a bijective lens $\ell : K(c_1) \Leftrightarrow K(c_2)$ that is
consistent with the canonized examples $\{({x'_1}, {y'_1}), \ldots, ({x'_n},
{y'_n})\}$ and then apply the canonizers at the outside. Our procedure for QRE
lens synthesis is thus
\begin{enumerate}
  \item
  Compute $K(c_1)$, $K(c_2)$,
  \item
  Compute $\{({x'_1}, {y'_1}), \ldots, ({x'_n}, {y'_n})\}$ where ${x'_i} =
  \canonizer(c_1)(x_i)$ and ${y'_i} = \canonizer(c_2)(y_i)$,
\item Synthesize, using Optician's algorithm, a bijective lens
  $\ell : K(c_1) \Leftrightarrow K(c_2)$ that is consistent with the examples
  $\{({x'_1}, {y'_1}),\allowbreak \ldots,\allowbreak ({x'_n}, {y'_n})\}$
  \item
  Return $q = \kw{rquot}(\kw{lquot}(c_1, \ell), c_2) : c_1 \Leftrightarrow
  c_2$ \bcp{punctuate this enumeration as if it were running text: ``, and''
  at the end of (3) and period here.}
\end{enumerate}

\saz{Do we want to state formally the completeness of this algorithm?}

Returning to the \bibtex{} to EndNote transformation of
Section~\ref{sec:examplesynth}, we had the QREs \cd{bibtex} and \cd{endnote}
describing a \bibtex{} record and an Endnote record respectively. We also had
the example pair \cd{(bib_example , end_example)} where

\begin{center}
\begin{minipage}{2.5in}
\begin{lstlisting}
bib_example =
"@Book {Doe,
 Author = \"John Doe\",
 Title = {Generic Title},
}"
\end{lstlisting}
\end{minipage}
\begin{minipage}{1.5in}
\begin{lstlisting}
end_example =
"%0 Book
 %T Generic Title
 %A John Doe
 %F Doe"
\end{lstlisting}
\end{minipage}
\end{center}

Since the transformation between the kernel of \cd{bibtex} and the kernel of
\cd{endnote} that maps \cd{bib_example} to \cd{end_example} can be
expressed as a bijective lens, we can synthesize a lens that maps between the
QREs \cd{bibtex} and \cd{endnote}, using the code below:

\begin{lstlisting}
let bib_to_end : (lens in bibtex <=> endnote) = 
  synth bibtex <=> endnote
  using {(bib_example, end_example)}
\end{lstlisting}

In this case, one example is sufficient to uniquely determine the desired
transformation.\saz{Is that true?}

\saz{We might want to say something more precise about the running time or
  expected performance of this algorithm, perhaps to set up the evaluation
  section.  Something along the lines of: ``Although the algorithm is complete
  in theory, in the worst case, it may take an unbounded [???IS THIS CORRECT?]
  amount time to search for a satisfactory lens.  Nevertheless, this algorithm
  performs well in practice on numerous examples, as we show in the next
  section.} 


\section{Implementation and Evaluation}
\label{impl}


We have implemented QREs and the quotient lens synthesis algorithm described
above as part of Boomerang. Thanks to this integration, QREs and quotient lens
synthesis tasks can now be expressed alongside existing Boomerang terms, and we
can combine the two kinds of lenses seamlessly in the same application.
Intuition suggests that the increased expressiveness of QREs should make many
lens programming tasks easier, but we would like more quantitative understanding
of that claim.  We thus conducted several experiments that aim to provide
answers to the following questions:

\begin{enumerate}
  \item Does synthesizing quotient lenses from QREs permit an easier development
  process than existing approaches?
  
  \item Does the increase in expressivity gained from synthesizing from QREs
  permit synthesis of more useful lenses than existing approaches.
  
  \item Does our tool synthesize lenses fast enough to be used as part of a
  standard development process.
\end{enumerate}

All evaluations were performed on a 2.5 GHz Intel Core i7 processor with 16 GB
of 1600 MHz DDR3 running macOS High Sierra.


\subsection{Benchmark Suite Construction}

To evaluate our QRE implementation, we constructed a set of lens synthesis tasks
drawn from two sources:
\begin{enumerate}
\item 39 of our benchmarks were adapted from the evaluation of the original
  Optician system.  These benchmarks are a combination of custom benchmarks,
  benchmarks derived from FlashFill~\cite{flashfill}, and benchmarks
  derived from Augeas~\cite{augeas2}. In the pre-QRE version of
  Optician, many of these data formats had to be modified to work with the
  bijectivity constraints that Optician required.  For instance, when one format
  permits whitespace where the other does not allow it, the original versions of
  benchmark formats were modified to allow more whitespace, thereby restoring
  bijectivity.  With the new QRE support, we were able to remove these
  alterations when porting these benchmarks.  (This experience alone suggests
  that QREs make the lens development process easier.)
  
\item The remaining eight benchmarks were derived from
  data.gov.\footnote{\url{http://data.gov}} These datasets include census
  population data, wage comparison data, demographics statistics data and
  crime index data. We chose these datasets since they were stored in XML, CSV
  and RDF formats which are more easily specified using regular expressions than
  plain text or PDF documents.
\end{enumerate}

\subsection{Easing the Development Process}

\begin{figure}[t]
\includegraphics{generated-graphs/asts.eps}
\caption{Count of benchmark programs definable using a given AST count. We find
that it takes far fewer AST nodes to define benchmark lenses using QRE
synthesis than with Optician without QRE synthesis or without synthesis.\saz{Why
is the bar for ``All QRE Benchmarks'' at 14? Shouldn't it be at 47 = 39+8? Are
we not testing all QRE benchmarks?}}
\label{fig:asts}
\end{figure}

To get a sense of how much the new expressiveness that combining QRE lenses with
synthesis saves in terms of programmer effort, we compared the amount of code
that would need to be written for each of the lens benchmarks.  We use number of
nodes in the abstract syntax tree as a measure of code size, and calculated
three quantities for each lens synthesis benchmark task.  \saz{Say something
  about why there are only 14 benchmarks?}
%
\begin{itemize}
  \item[\QRESize{}] the number of AST nodes in the QRE
  specifications (including examples)\saz{CHECK THIS}
  \item[\CanonizerAndSpecSize{}]  the number of
  AST nodes in $W(q_1)$ summed with the number of AST nodes in $\canonizer(q_1)$
  \item[\LensAndSpecSize{}] the number of AST nodes
  in $W(q_1)$ summed with the number of AST nodes in the synthesized QRE lens.
\end{itemize}

The value of \QRESize{} is our measure of the programmer burden for
writing our benchmarks---it measures the number of AST nodes the programmer has
to write using the full expressiveness of QREs and synthesis.

The value of \CanonizerAndSpecSize{} estimates the burden for writing our
benchmarks within the Optician system, without QREs but still using
synthesis. This is only an approximation, as both $W(q_1)$ and $\canonizer(q_1)$ are
automatically generated from the QRE, and it is possible that a human-written
version might be smaller.

The value of \LensAndSpecSize{} estimates the burden in writing our benchmarks
in Boomerang, using neither QREs nor synthesis. This value is also an
approximation, as $W(q_1)$ and $\canonizer(q_1)$ and the bijective lens are all
automatically generated.

Figure~\ref{fig:asts} shows the number of benchmarks that can be expressed using
at most a given number of AST nodes. For a given benchmark, we found \QRESize{}
to be about half as large as \CanonizerAndSpecSize, and about a third as large
as \LensAndSpecSize{}. This demonstrates that introducing QREs saves programmers
significant effort compared to both Optician and basic Boomerang.

\subsection{Increasing Expressivity}

The pre-QRE version of Optician was only able to synthesize fully bijective data
transformations.  Synthesizing from QREs loosens that restriction, making it
possible to synthesize data which is bijective when put in canonical form. To
determine the increase of expressivity, we analyzed:
\begin{enumerate}
  \item How many data formats in Optician's benchmark suite required modifications
  to be bijective.
  \item How many data formats in Optician's benchmark suite required modifications
  to be bijective when put in canonical form.
\end{enumerate}

We found that 10 of Optician's 39 benchmarks required modifications to be
bijective. We found that 4 of Optician's 39 benchmarks required modifications to
be in bijective correspondence when in canonical form.\saz{Is this somehow where
  the 14 = 10+4 points in Fig. 10 come from?}\saz{Do these 10 and 4 intersect?}
Furthermore, we found that all eight of the data.gov examples required no
modifications to be in bijective correspondence when in canonical form. While we
did not put the data.gov examples into a form suitable for pre-QRE Optician, we
found that only four of the eight data.gov examples did not require
canonization, so making them suitable for pre-QRE Optician would have required 
changes to of four of the data.gov formats.  Here again, we see that QREs add
significant expressive power.

\subsection{Maintaining Competitive Performance}

\begin{figure}[t]
\centering
\begin{subfigure}[b]{.49\textwidth}
\centering
\includegraphics{generated-graphs/times_opt}
\caption{}
\label{subfig:lenssize}
\end{subfigure}
\begin{subfigure}[b]{.49\textwidth}
\includegraphics{generated-graphs/times_new.eps}
\caption{}
\label{subfig:examplesused}
\end{subfigure}
\caption{Runtimes of Optician and our system.
In (a), we run Optician and our system on Optician's benchmarks.  We find that
there is only a negligible difference incurred by Optometrist's overhead.
In (b), we run Optometrist on its benchmark suite.  We find that it is able
to synthesize all quotient lenses in under 20 seconds, and typically
finished in under 5 seconds. \bcp{The left-hand graph, especially, is hard
  to make anything out of, because the curves are squished against the
  axes.  Not sure what to do about this.  Also, I'm finding the terms
  ``Optician'' and ``Optometrist'' really hard to keep straight---in part
  because, in English, they are almost synonyms.}}
\label{fig:times}
\end{figure}

To assess the performance impact of adding QRE support to Optician, we measured
the running time of the following configurations:
\begin{itemize}
  \item[\OpticianRuntime{}] pre-QRE Optician running on its own benchmarks.
  \item[\SystemOnOptician{}] Optician with QREs running on the pre-QRE benchmarks.
  \item[\SystemOnBenchmarks{}] Optician with QREs running on its own benchmarks.
\end{itemize}

We summarize the results of these experiments in Figure~\ref{fig:times}.  The
new version of Optician was able to synthesize all of pre-QRE Optician's
benchmarks at a speed competitive with the old version.  There is a small amount
of additional overhead introduced by QREs when calculating $W(q_1)$ and $K(q_1)$,
resulting in a very slight decrease in performance.

Also notable is one of the data.gov examples, which converts demographic
statistics by zip code from xml form into rdf form. This took longer because it
was an exceptionally large format, converting over 40 fields.\saz{We need to
  explain more detail here.  I guess this is about the last benchmark in Fig. 11
  (b), which takes a long time?}  We added in additional fields to make this
format suitable for Optician, which took over 15 seconds synthesize the modified
lens.\saz{This needs more context, explanation.}

\section{Related Work}
\label{relwork}

\iffalse
Bidirectional transformations have been used in diverse areas of computing
where they arise as parsers and pretty printers, marshallers
and unmarshallers, serializers and deserializers, database views and view
updaters and many others\sam{TODO put citations}. Such transformations have
been extensively studied since they were proposed as a solution to the classical
{\em view-update problem} in the database community, where the challenge is to
derive a program that extracts a view of data from a source, as well as a
program that folds view updates back into the source safely and correctly.
\fi
This paper builds on the work of Foster et al~\cite{quotientlenses} who
introduced the theory of quotient lenses and implemented quotient lenses as a
refinement of the bidirectional string processing language Boomerang.
In Boomerang, the source and target types are specified using regular
expressions, and the equivalence relations are expressed using canonizers, which
are functions that map elements of a regular language to their canonical
representative. Boomerang canonizers can express a very broad class of
equivalence relations between regular languages, but actually doing so is often
difficult with complicated equivalence relations. For instance, Boomerang's
in-build permutation combinator does not account for separators in between the
regular expressions. Also, this combinator permutes regular expressions rather
than canonizers, thus making it difficult to express nested permutations that
occur in many data formats, especially XML and XML-like formats.

In their paper, Foster et al also discuss other bidirectional programming
languages that support quotienting of data including XSugar~\cite{xsugar},
biXid~\cite{bixid} and X/Inv~\cite{Hu2004,Mu2004,Mu2006}. XSugar programs
bidirectionally convert data stored in XML and ASCII formats respectively, with the
transformations specified by a pair of unambiguous grammars. The quotienting
occurs on the XML side by use of a generic canonizer that standardizes the
representation of trees. Well-formed XSugar programs are guaranteed to be
bijective modulo an equivalence relation that captures XML normalization. biXid
programs convert between pairs of XML documents, with the XML formats specified
using a pair of grammars as in XSugar. However, biXid grammars can be ambiguous.
This ambiguity is what allows biXid to express equivalences on the data.
Finally, Foster et al discuss a possible connection with the languages
X and Inv which support a primitive duplication combinator that does not work
well with the lens laws, but can be expressed using Boomerang quotient lenses.

As far as synthesis goes, though there is a good deal of recent research on
synthesizing unidirectional string
transformations~\cite{singh2012learning,le-pldi-2014,gulwani-popl-2014,perelman2014test,Singh:blinkfill},
the system Optician, which we introduced in ~\cite{optician}, is the first attempt
to synthesize bidirectional transformations that we are aware of. In that
publication, we compared Optician to two of these unidirectional string
transformers, Flash Fill~\cite{gulwani-popl-2014} and
FlashExtract~\cite{le-pldi-2014}, and found that these tools were unsuccessful
in synthesizing the complex transformatiunons that can be expressed in Optician.

While Optician improved on prior effors at synthesizing unidirectional string
transformers and introduced synthesis for bidirectional string transformations,
Optician was only able to synthesize fully bijective data transformations. Our
new system \Name{} improves on Optician in that \Name{} loosens this
restriction, and is able to synthesize data which is bijective when put in
canonical form. \Name{} is therefore a refinement of Optician since the
new synthesis algorithm (i.e. the quotient lens synthesis algorithm) restricted
to ``pure'' regular expressions degenerates to the synthesis algorithm that
we introduced in Optician. Indeed, as we mentioned in the evaluation section,
\Name{} was able to synthesize all of Optician's benchmarks at a speed
competitive with Optician, though there was additional overhead in calculating
the whole language $W(c)$ and the kernel language $K(c)$ of QREs, which
resulted in a very slight decrease in performance.

Much of the research in synthesis assumes that the synthesizer is provided with
a collection of examples. Optician and Optometrist differ in that they requires
that the programmer supplies both examples {\em and} format descriptions in the
form of regular expressions or QREs.  There is a trade-off here.  On the one
hand, a user must have some programming expertise to write regular expression
(or QRE) specifications and it requires some work. On the other hand, such
specifications provide a great deal of information to the synthesis system,
which decreases the number of examples needed (often to zero), makes the system
scale well, and allows it to handle large, complex formats.  By providing these
format specifications, the synthesis engine does not have to both infer the
format of the data as well as the transformations on it, obviating the need to
infer tricky formats like those involving nested iterations. Furthermore, by
focusing on bidirectional transformations, we limit the space of synthesized
functions to bijective ones, reducing the search space, and the expressiveness
of the search space.

There are many other recent results showing how to synthesize functions from
type-based
specifications~\cite{augustsson-2004,osera+:pldi15,feser-pldi-2015,scherer-icfp-2015,frankle+:popl16,armando+:pldi16}.
These systems enumerate programs of their target language, orienting their
search procedures to process only terms that are well-typed.
Optician is distinctive in that it synthesizes terms in a language with many
type equivalences.
Perhaps the system most similar to Optician is InSynth~\cite{gvero-pldi-2013}, a
system for synthesizing terms in the simply-typed lambda calculus that addresses
equivalences on types. Instead of trying to directly synthesize terms of the
simply-typed lambda calculus, InSynth synthesizes a well-typed term
in the succinct calculus, a language with types
that are equivalent ``modulo isomorphisms of products and
currying''~\cite{gvero-pldi-2013}. The type structure that we used in Optician
is significantly more complex.  In particular, because Optician types do not
have full canonical forms, we used a pseudo-canonical form, which captures part
of the equivalence relation over types. To preserve completeness, we pushed
some of the remaining parts of the type equivalence relation into a set of
rewriting rules and other parts into the synthesis algorithm itself.

Morpheus~\cite{morpheus} is another synthesis system that uses two
communicating synthesizers to generate programs.  In both Morpheus and
Optician, one synthesizer provides an
outline for the program, and the other fills in that outline with program
details that satisfy the user's specifications.
This approach works well in large search spaces that require some enumerative
search.
One important way that Optician differs from Morpheus is that in
Morpheus, an outline is a sketch---an
\emph{expression}
containing holes---whereas
an outline in Optician is a pair of regular
expressions, i.e., a
\emph{type}.  Moreover, in order to implement an efficient
search procedure, we had to create both a new type language and a new
term language for lenses.  Once we did so, we proved our new, more
constrained language
designed for synthesis was just as expressive as the original, more
flexible and compositional language designed for human programmers.

\section{Conclusion}
\bcp{And future work!}  \saz{I'm lukewarm about including a description of
future work.  Unless there are specific conjectures or open problems that
are worth mentioning, I'm not sure that it's really that important.}
\bcp{Agreed. But don't we have any ideas for how to extend or generalize or
things to do next or additional questions to consider??  E.g.: 
\begin{itemize}
\item is it easy to extend all this to
asymmetric and symmetric lenses?  (If so, we should say so!)
\item What properties do the bijective lens combinators have to have in
order to validate the normalization property?  (I.e., if we tried to extend
Boomerang's bijective lens combinators with another one, what would happen?)
\item Do we have more ideas for QRE primitives?
\item Etc.
\end{itemize}
}
\label{concl}

\section{Appendix}
\bcp{Appendices should be numbered differently (with letters, probably) and
  belong after the references.}
%
We give a full proof of \cref{normal form}: If there is a derivation $q : c_1
\Leftrightarrow c_2$, then there exists a bijective lens $\ell : K(c_1)
\Leftrightarrow K(c_2)$ such that:
\begin{align*}
\llbracket q \rrbracket.\get &= \llbracket \ell \rrbracket\circ
\canonizer(c_1)\\
\llbracket q \rrbracket.\lput &= \llbracket \ell \rrbracket^{-1} \circ
\canonizer(c_2)
\end{align*}
\begin{proof}
We proceed by induction over the derivation $q : c_1 \Leftrightarrow c_2$.
\begin{enumerate}
  \item
  $\kw{lift}(\ell): R/\mathit{id}(R) \Leftrightarrow S/\mathit{id}(S)$ where
  $\ell : R \Leftrightarrow S$. Then
  \begin{align*}
\llbracket \kw{lift}(\ell) \rrbracket.\get &=  \llbracket \ell \rrbracket
= \llbracket \ell \rrbracket \circ id_{\mathcal{L}(R)} =
\llbracket \ell \rrbracket \circ \canonizer(\mathit{id}(R)), \text{ and }\\
\llbracket \kw{lift}(\ell) \rrbracket.\lput &= \llbracket \ell
\rrbracket^{-1} = \llbracket \ell \rrbracket^{-1} \circ id_{\mathcal{L}(S)} =
\llbracket \ell \rrbracket^{-1} \circ \canonizer(id(S))
\end{align*}
\item
$\kw{lquot}(c_1, q): c_1 \; ; \; c_2 \Leftrightarrow c_3$ where $q : c_2
\Leftrightarrow c_3$, $c_1$ is well formed and $K(c_1) = W(c_2)$. Then
\begin{align*}
\llbracket \kw{lquot}(c_1, q) \rrbracket.\get  &= \llbracket q
\rrbracket.\get \circ \canonizer(c_1)\\
\llbracket \kw{lquot}(c_1, q) \rrbracket.\lput &= \llbracket q \rrbracket.\lput
\end{align*}
By the induction hypothesis, there exists a bijective lens $\ell :
K(c_2) \Leftrightarrow K(c_3)$ such that
\begin{align*}
\llbracket q \rrbracket.\get &= \llbracket \ell \rrbracket \circ
\canonizer(c_2)\\
\llbracket q \rrbracket.\lput &= \llbracket \ell \rrbracket^{-1} \circ
\canonizer(c_3)
\end{align*}
Consequently
\begin{align*}
\llbracket \kw{lquot}(c_1, q)\rrbracket.\get  &= (\llbracket \ell \rrbracket \circ
\canonizer(c_2)) \circ \canonizer(c_1) = \llbracket \ell \rrbracket \circ
(\canonizer(c_1 \; ; \; c_2))\\
\llbracket \kw{lquot}(c_1, q) \rrbracket.\lput &= \llbracket \ell \rrbracket^{-1} \circ
\canonizer(c_3)
\end{align*}

\item
$\kw{rquot}(q, c_3):c_1 \Leftrightarrow c_2 \; ; \; c_3$ where $q : c_1
\Leftrightarrow c_2$, $c_3$ is well formed and $K(c_3) = W(c_2)$. Proceed as in
the previous case.
\item
$q_1 \; ; \; q_2: c \Leftrightarrow c_2$ where $q_1 : c \Leftrightarrow c_1$ and
$q_2 : c_1 \Leftrightarrow c_2$. Then
\begin{align*}
\llbracket q_1 \rrbracket.\get &= \llbracket q_2 \rrbracket.\get\circ \llbracket
q_1 \rrbracket.\get, \text{ and }\\
\llbracket q_1 \rrbracket.\lput &= \llbracket q_1 \rrbracket.\lput \circ \llbracket
q_2 \rrbracket.\lput
\end{align*}
By the induction hypothesis, there exist bijective lenses
$\ell_1 :
K(c) \Leftrightarrow K(c_1)$ and $\ell_2 : K(c_1) \Leftrightarrow K(c_2)$ such
that
\begin{align*}
\llbracket q_1 \rrbracket.\get &= \llbracket \ell_1 \rrbracket \circ
\canonizer(c)\\
\llbracket q_1 \rrbracket.\lput &= {\llbracket \ell_1 \rrbracket}^{-1} \circ
\canonizer(c_1)
\end{align*}
and
\begin{align*}
\llbracket q_2 \rrbracket.\get &= \llbracket \ell_2 \rrbracket \circ
\canonizer(c_1)\\
\llbracket q_2 \rrbracket.\lput &= {\llbracket \ell_2 \rrbracket}^{-1} \circ
\canonizer(c_2)
\end{align*}
Consequently,
\begin{align*}
\llbracket q_2 \rrbracket.\get \circ \llbracket q_1 \rrbracket.\get &=
(\llbracket \ell_2 \rrbracket \circ \canonizer(c_1)) \circ (\llbracket \ell_1
\rrbracket \circ \canonizer(c))\\
&= \llbracket \ell_2 \rrbracket \circ (\canonizer(c_1) \circ \llbracket \ell_1
\rrbracket) \circ \canonizer(c)\\
&= (\llbracket \ell_2 \rrbracket \circ \llbracket \ell_1 \rrbracket) \circ
\canonizer(c)\\
&= \llbracket \ell_1 \; ; \; \ell_2 \rrbracket \circ
\canonizer(c)
\end{align*}
A similar argument shows that
$$\llbracket q_1 \rrbracket.\lput \circ \llbracket q_2 \rrbracket.\lput =
\llbracket \ell_1 \; ; \; \ell_2 \rrbracket^{-1} \circ
\canonizer(c)$$
\item
$q^* : {c_1}^* \Leftrightarrow {c_2}^*$ where $q : c_1 \Leftrightarrow c_2$,
$W(c_1)^{*!}$ and $W(c_2)^{*!}$ and $K(c_1)^{*!}$ and $K(c_2)^{*!}$. Then
\begin{align*}
\llbracket q^* \rrbracket.\get &= (\llbracket q \rrbracket.\get)^*, \text{
and }\\
\llbracket q^* \rrbracket.\lput &= (\llbracket q \rrbracket.\lput)^*
\end{align*}
By the induction hypothesis there exists a bijective lens $\ell : K(c_1)
\Leftrightarrow K(c_2)$ such that
that
\begin{align*}
\llbracket q \rrbracket.\get &= \llbracket \ell \rrbracket \circ
\canonizer(c_1)\\
\llbracket q \rrbracket.\lput &= {\llbracket \ell \rrbracket}^{-1} \circ
\canonizer(c_2)
\end{align*}
Consequentlty
\begin{align*}
\llbracket q^* \rrbracket.\get &= (\llbracket \ell \rrbracket \circ
\canonizer(c_1))^* = \llbracket \ell \rrbracket^* \circ
\canonizer(c_1)^* = \llbracket \ell^* \rrbracket \circ
\canonizer(c_1^*)\\
\llbracket q^* \rrbracket.\lput &= (\llbracket \ell \rrbracket^{-1} \circ
\canonizer(c_2))^* = (\llbracket \ell \rrbracket^{-1})^* \circ
\canonizer(c_2)^* = \llbracket \ell^* \rrbracket^{-1} \circ
\canonizer(c_2^*)\\
\end{align*}
\item
$q_1 \cdot q_2: c_1 \cdot c_2 \Leftrightarrow d_1 \cdot d_2$, where $q_1 : c_1
\Leftrightarrow d_1 $,  $q_2 : c_2 \Leftrightarrow d_2$, $W(c_1)
\cdot^! W(c_2)$, $K(c_1) \cdot^! K(c_2)$, $W(d_1) \cdot^! W(d_2)$ and $
K(d_1) \cdot^! K(d_2)$. Then
\begin{align*}
\llbracket q_1 \rrbracket.\get &= \llbracket q_1 \rrbracket.\get \cdot \llbracket
q_2 \rrbracket.\get, \text{ and }\\
\llbracket q_1 \rrbracket.\lput &= \llbracket q_1 \rrbracket.\lput \cdot \llbracket
q_2 \rrbracket.\lput
\end{align*}
By the induction hypothesis, there exist bijective lenses $\ell_1 : K(c_1)
\Leftrightarrow K(d_1)$ and $\ell_2 : K(c_2) \Leftrightarrow K(d_2)$ such that
\begin{align*}
\llbracket q_1 \rrbracket.\get &= \llbracket \ell_1 \rrbracket \circ
\canonizer(c_1)\\
\llbracket q_1 \rrbracket.\lput &= {\llbracket \ell_1 \rrbracket}^{-1} \circ
\canonizer(d_1)
\end{align*}
and
\begin{align*}
\llbracket q_2 \rrbracket.\get &= \llbracket \ell_2 \rrbracket \circ
\canonizer(c_2)\\
\llbracket q_2 \rrbracket.\lput &= {\llbracket \ell_2 \rrbracket}^{-1} \circ
\canonizer(d_2)
\end{align*}
Consequently,
\begin{align*}
\llbracket q_1 \rrbracket.\get &= (\llbracket \ell_1 \rrbracket \circ
\canonizer(c_1)) \cdot  (\llbracket \ell_2 \rrbracket \circ
\canonizer(c_2))\\
&= (\llbracket \ell_1 \rrbracket \cdot \llbracket \ell_2
\rrbracket) \circ (\canonizer(c_1) \cdot \canonizer(c_2))\\
&= \llbracket \ell_1 \cdot  \ell_2 \rrbracket \circ \canonizer(c_1 \cdot c_2)
\end{align*}
Similarly
$$
\llbracket q_1 \rrbracket.\lput = \llbracket \ell_1 \cdot  \ell_2 \rrbracket^{-1}
\circ \canonizer(d_1 \cdot d_2) $$
\item
$q_1 = q_1 \sep q_2$ where $q_1 : c_1 \Leftrightarrow d_1 $, $q_2 : c_2
\Leftrightarrow d_2$, $\mathcal{L}(W(c_1)) \cap \mathcal{L}(W(c_2)) =
\varnothing$ and $\mathcal{L}(W(d_1)) \cap \mathcal{L}(W(d_2)) = \varnothing$.
Then
$$
\llbracket q_1 \sep q_2 \rrbracket.\get(s) =
\begin{cases}
\llbracket q_1 \rrbracket.\get (s) & \text{if } s \in \mathcal{L}(W(c_1))\\
\llbracket q_2 \rrbracket.\get (s) & \text{if } s \in \mathcal{L}(W(c_2))\\
\end{cases}$$
$$\llbracket q_1 \sep q_2 \rrbracket.\lput(s) =
\begin{cases}
\llbracket q_1 \rrbracket.\lput (s) & \text{if } s \in \mathcal{L}(W(d_1))\\
\llbracket q_2 \rrbracket.\lput (s) & \text{if } s \in \mathcal{L}(W(d_2))\\
\end{cases}
$$
By the induction hypothesis, there exist bijective lenses $\ell_1 : K(c_1)
\Leftrightarrow K(d_1)$ and $\ell_2 : K(c_2) \Leftrightarrow K(d_2)$ such that
\begin{align*}
\llbracket q_1 \rrbracket.\get &= \llbracket \ell_1 \rrbracket \circ
\canonizer(c_1)\\
\llbracket q_1 \rrbracket.\lput &= {\llbracket \ell_1 \rrbracket}^{-1} \circ
\canonizer(d_1)
\end{align*}
and
\begin{align*}
\llbracket q_2 \rrbracket.\get &= \llbracket \ell_2 \rrbracket \circ
\canonizer(c_2)\\
\llbracket q_2 \rrbracket.\lput &= {\llbracket \ell_2 \rrbracket}^{-1} \circ
\canonizer(d_2)
\end{align*}
Consequently,
$$
\llbracket q_1 \sep q_2 \rrbracket.\get(s) =
\begin{cases}
\llbracket \ell_1 \rrbracket \circ
\canonizer(c_1) (s) & \text{if } s \in \mathcal{L}(W(c_1))\\
\llbracket \ell_2 \rrbracket \circ
\canonizer(c_2) (s) & \text{if } s \in \mathcal{L}(W(c_2)),\\
\end{cases}$$
so $\llbracket q_1 \sep q_2 \rrbracket.\get = \llbracket \ell_1 \sep
\ell_2 \rrbracket \circ \canonizer(c_1 \sep c_2)$. A similar argument shows
that $\llbracket q_1 \sep q_2 \rrbracket.\lput = \llbracket \ell_1 \sep
\ell_2 \rrbracket^{-1} \circ \canonizer(d_1 \sep d_2)$.\\
This completes the proof.
\end{enumerate}
\end{proof}


\bibliographystyle{plain}
\bibliography{local}


\end{document}
