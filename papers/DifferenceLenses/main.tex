\newif\ifdraft\drafttrue  % set true to show comments
\newif\ifplentyoftime\plentyoftimefalse  % :-)

% % For double-blind review submission, w/o CCS and ACM Reference (max
% submission space)
\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
% % For double-blind review submission, w/ CCS and ACM Reference
% \documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
% % For single-blind review submission, w/o CCS and ACM Reference (max
% submission space)
% \documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
% % For single-blind review submission, w/ CCS and ACM Reference
% \documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true} % For
% final camera-ready submission, w/ required CCS and ACM Reference
% \documentclass[acmsmall]{acmart}\settopmatter{}


% % Journal information % Supplied to authors by publisher for camera-ready
% submission; % use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{POPL} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2018}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

% % Copyright information % Supplied to authors (based on authors' rights
% management selection; % see authors.acm.org) by publisher for camera-ready
% submission; % use 'none' for review submission.
\setcopyright{none}
% \setcopyright{acmcopyright} \setcopyright{acmlicensed}
% \setcopyright{rightsretained} \ccopyrightyear{2018}           %% If different
% from \acmYear

% % Bibliography style %\bibliographystyle{ACM-Reference-Format} % Citation
% style % Note: author/year citations are required for papers published as an %
% issue of PACMPL.
% %\citestyle{acmauthoryear}   %% For author/year citations


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Note:
% Authors migrating a paper from PACMPL format to traditional % SIGPLAN
% proceedings format must update the '\documentclass' and % topmatter commands
% above; see 'acmart-sigplanproc-template.tex'.
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\usepackage{amsmath, amssymb, amsthm, enumerate, array, extarrows, mathrsfs,
mathtools, stmaryrd, listings, xspace, bussproofs}
\theoremstyle{definition}
\usepackage[capitalize]{cleveref}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{conjecture}{Conjecture}
\newtheorem{question}{Question}
\newtheorem{fact}{Fact}
\newtheorem{claim}{Claim}
\newtheorem{remark}{Remark}

% Macros Colors
\definecolor{dkblue}{rgb}{0,0.1,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{dkred}{rgb}{0.6,0,0}
\definecolor{dkpurple}{rgb}{0.7,0,0.4}
\definecolor{olive}{rgb}{0.4, 0.4, 0.0}
\definecolor{teal}{rgb}{0.0,0.5,0.5}
\definecolor{orange}{rgb}{0.9,0.6,0.2}
\definecolor{lightyellow}{RGB}{255, 255, 179}
\definecolor{lightgreen}{RGB}{170, 255, 220}
\definecolor{teal}{RGB}{141,211,199}
\definecolor{darkbrown}{RGB}{121,37,0}


\newcommand{\FINISH}[3]{\ifdraft\textcolor{#1}{[#2: #3]}\fi}
\newcommand{\bcp}[1]{\FINISH{dkred}{B}{#1}}
\newcommand{\BCP}[1]{\FINISH{dkred}{B}{\bf #1}}
\newcommand{\afm}[1]{\FINISH{dkgreen}{A}{#1}}
\newcommand{\dpw}[1]{\FINISH{dkblue}{D}{#1}} % Toronto Maple Leafs Blue :-)
\newcommand{\saz}[1]{\FINISH{orange}{SZ}{#1}}
\newcommand{\ksf}[1]{\FINISH{teal}{K}{#1}}
\newcommand{\sam}[1]{\FINISH{dkpurple}{SM}{#1}}


\newcommand{\kw}[1]{\ensuremath{\mathsf{#1}}\xspace}
\newcommand{\get}{\ensuremath{\kw{get}}\xspace}
\newcommand{\pput}{\ensuremath{\kw{put}}\xspace}
\newcommand{\create}{\ensuremath{\kw{create}}\xspace}
\newcommand{\res}{\ensuremath{\kw{res}}\xspace}
\newcommand{\ccopy}{\ensuremath{\kw{copy}}\xspace}
\newcommand{\const}{\ensuremath{\kw{const}}\xspace}
\newcommand{\default}{\ensuremath{\kw{default}}\xspace}
\newcommand{\length}{\ensuremath{\kw{length}}\xspace}
\newcommand{\match}{\ensuremath{\kw{match}}\xspace}
\newcommand{\filter}{\ensuremath{\kw{filter}}\xspace}
\newcommand{\strfilter}{\ensuremath{\kw{str\_filter}}\xspace}
\newcommand{\strunfilter}{\ensuremath{\kw{str\_unfilter}}\xspace}
\newcommand{\mergelens}{\ensuremath{\kw{merge}}\xspace}

\DeclareMathOperator*{\argmin}{argmin}
\DeclareMathOperator*{\argmax}{argmax} 


\lstset{ basicstyle=\ttfamily, escapeinside=|| }
\begin{document}

% % Title information
\title{Lenses with a Difference}         %% [Short Title] is optional;
% % when present, will be used in % header instead of Full Title.
% %\titlenote{with title note}             %% \titlenote is optional; % can be
% repeated if necessary; % contents suppressed with 'anonymous'
% %\subtitle{Subtitle}                     %% \subtitle is optional
% %\subtitlenote{with subtitle note}       %% \subtitlenote is optional; % can
% be repeated if necessary; % contents suppressed with 'anonymous'


% % Author information % Contents and number of authors suppressed with
% 'anonymous'.
% % Each author should be introduced by \author, followed by % \authornote
% (optional), \orcid (optional), \affiliation, and % \email.
% % An author may have multiple affiliations and/or emails; repeat the %
% appropriate command.
% % Many elements are not rendered, but should be provided for metadata %
% extraction tools.

% % Author with single affiliation.
% \author{First1 Last1} \authornote{with author1 note}          %% \authornote
% is optional; % can be repeated if necessary \orcid{nnnn-nnnn-nnnn-nnnn} %%
% \orcid is optional \affiliation{ \positition{Position1}
% \department{Department1} %% \department is recommended
% \institution{Institution1} %% \institution is required \streetaddress{Street1
% Address1} \city{City1} \state{State1} \posittcode{Post-Code1}
% \country{Country1}                    %% \country is recommended }
% \email{first1.last1@inst1.edu}          %% \email is recommended

\author{Solomon Maina}
\position{PhD Student}
\department{Computer Science}              %% \department is recommended
\institution{University of Pennsylvania}            %% \institution is required
\country{USA}                    %% \country is recommended }
\email{smaina@seas.upenn.edu}          %% \email is recommended

% % Abstract % Note: \begin{abstract}...\end{abstract} environment must come %
% before \maketitle command
\begin{abstract}
Many of the bidirectional (bx) programming languages that exist today focus on
restoring consistency between source and target data. Consequently, these languages often provide two guarantees: (1) that a transformation restores consistency when an
update is made to source or target data, and (2) that trivial updates to a the source result to trivial updates to the target and vice versa. Unfortunately, in situations
where there are many different ways of restoring consistency, these languages
do not constrain how a transformation chooses to do so. As a result, the transformations derived using these languages can lead to unexpected results. In this paper we present a formalization for bx transformations that requires a bx to provide guarantees on how it propagates updates and use this formalization to describe a bx language of {\em difference lenses} based on the basic lenses defined in the lens programming language Boomerang. Each difference lens will be shown to respect a ``difference'' measure that estimates how similar two pieces of data are on both sides of a bx; the fact that difference lenses have this property demonstrates that they  have stronger guarantees than consistency restoration. We will then turn our attention to Boomerang's matching lenses, where we will define an appropriate difference measure for data acted on by matching lenses, and show that matching lenses respect this refined measure.
\end{abstract}

%% Keywords
%% comma separated list
\keywords{bidirectional programming, lenses}  %% \keywords
% are mandatory in final camera-ready submission

%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle

\section{Introduction}
Many of the bidirectional (bx) programming languages that exist today focus on
restoring consistency between source and target data. Consequently, these languages often provide two guarantees: (1) a {\em correctness} guarantee that requires that a transformation restores consistency when an update is made to source or target data, and (2) a {\em hippocraticness} guarantee that requires that trivial updates to source data result is trivial updates to target data and vice versa. Unfortunately, in situations
where there are many different ways of restoring consistency, these languages
do not constrain how a transformation chooses to do so. As a result, the transformations derived using these languages can lead to unexpected results.

For example, assume that a source consists of a list of pairs of names, and that the target consists of a list of single names. Assume that $\ell$ is a bx which in the forward direction (i.e. the \get direction) simply discards the first of the two names:
$$\ell.\get \; [``Ada \; Lovelace", \; ``Alan \; Turing"] = [``Lovelace", \; ``Turing"]$$
If the order of the names in the target is reversed then a user might expect that in the backward direction (i.e. the \pput direction), the lens would simply restore the original names:
$$\ell.\pput \; [``Ada \; Lovelace", \; ``Alan \; Turing"] \; [``Turing", \; ``Lovelace"] = [``Ada \; Lovelace", \; ``Alan \; Turing"]$$
However, $\ell$ may not perform this alignment so that instead, the following result occurs:
$$\ell.\pput \; [``Ada \; Lovelace", \; ``Alan \; Turing"] \; [``Turing", \; ``Lovelace"] = [``Ada \; Turing", \; ``Alan \; Lovelace"]$$
Consider another example where both a source and a target consists of a list where every element on the list is a name and a year. Assume that $\ell$ is a bx which in the \get direction returns all elements of the source list that have year less than 1900:
\begin{align*}
&\ell.\get \; [``Ada \; Lovelace, \; 1915", \; ``Alan \; Turing, \; 1912", \; ``George \; Boole, \; 1815"] = [``George \; Boole, \; 1815"]
\end{align*}
Suppose that the entry $``Ada \; Lovelace, \; 1815"$ is then added to the target list. Should $\ell.\pput$ replace the old entry containing the name $``Ada \; Lovelace"$,
\begin{align*}
&\ell.\pput \; [``Ada \; Lovelace, \; 1915", \; ``Alan \; Turing, \; 1912", \; ``George \; Boole, \; 1815"]\\
&[``Alan \; Turing, \; 1912", \; ``Ada \; Lovelace, \; 1815"] \\
&= [``Ada \; Lovelace, \; 1815", \; ``Alan \; Turing, \; 1912", \; ``George \; Boole, \; 1815"]
\end{align*}
or should the \pput application retain both versions of $``Ada \; Lovelace"$?
\begin{align*}
&\ell.\pput \; [``Ada \; Lovelace, \; 1915", \; ``Alan \; Turing, \; 1912", \; ``George \; Boole, \; 1815"] \\
& [``Alan \; Turing, \; 1912", \; ``Ada \; Lovelace, \; 1815"]\\
&= [``Ada \; Lovelace, \; 1915", \; ``Alan \; Turing, \; 1912", \; ``George \; Boole, \; 1815", \; ``Ada \; Lovelace, \; 1815"]
\end{align*}
In both of these examples, there are multiple ways to restore consistency---that is, there are multiple ways to define $\ell.\pput \; s \; v$ in such a way that $\ell.\get \; (\ell.\pput \; s \; v) = v$---and the results from the different \pput applications may be vastly different from what a user expects. 

Various solutions have been proposed to address the issue of propagating updates in a ``minimal'' way, for example {\em matching lenses} that deal with the issue of alignment \cite{barbosa2010matching}, {\em edit lenses} \cite{hofmann2012edit} and {\em delta lenses} \cite{diskin2011asymmetric,diskin2011state,pacheco2012delta}
that explicitly propagate edits through the lens, and {\em least change
lenses} \cite{macedo2013composing} that require that the source value resulting from a \pput application is not only acceptable, but also one of closest to the original $s$ among the sources that share the same view $v$.

Each one of these solutions has significant shortcomings. While matching lenses successfully address the issue of alignment, they do not address the general issue of correct update propagation. Edit lenses and delta lenses all assume that the lens propagates a specific set of updates explicitly, which is unrealistic since since in general users do not update data using a small predetermined langauge of edits; instead they edit the data in any way, for example using text editors or IDEs, and present the updatad data to the bx wholesale. Finally, least change lenses are in general computationally intractable \cite{buneman2002propagation} and also lack a notion of composition---that is, the composition of two deterministic least change lenses is not always a least change lens\cite{macedo2013composing}.

We take the approach that instead of having a bx manually propagate a fixed set of edits, a bidirectional programming language should have explicit guarantees on how programs written in that language propagate updates; ideally these guarantees should be strictly stronger than hippocraticness. Consider again the first example that we presented, which is an instance of the alignment problem. In that example, the list
$[``Lovelace", \; ``Turing"]$ was updated to the list $[``Turing", \; ``Lovelace"]$. The programmer may wish to consider these two lists equivalent or not: if she does, then she should use a min-edit distance ``metric'' and demand that the source side respects this metric by applying the ``flip'' permutation applying the bx in reverse. On the other hand, if she wishes to use a positional metric to compare these two lists, then she should similarly demand that the source side respects this metric and use the identity permuation when applying the bx in reverse. In each case, the programmer does not care how the bx restores consistency; she cares only that the bx restores consistency and respects the appropriate metric.

In this paper, we present a general approach for describing update propapagtion guarantees for a bx without requiring that the bx manually handle updates. In particular, we will enhance a standard definition of bx transformations that only takes into account a consistency relation with a ``difference'' relation that describes the relationship between source updates and target updates. With this new formalization, a well behaved bx will not only be hippocratic, but will also be required to preserve the difference relation that is part of the bx.

In this paper we present a formalization for bx transformations that requires a bx to provide guarantees on how it propagates updates and use this formalization to describe a bx language of {\em difference lenses} based on the basic lenses defined in the lens programming language Boomerang. Each difference lens will be shown to respect a ``difference'' measure that measures how similar two pieces of data are on both sides of a bx. Intuitively, this means that if one starts with some source data, maps it into a target format using a difference lens, edits the target data, and then maps the updated data back into the old source, then the difference between the new and old source is at most the difference between the old and new targets. Difference lenses will have combinators that deal with {\em local alignment}; in particular, difference lenses will have positional, non-crossing, and min-edit distance iteration combinators that preserve positional, non-crossing, and min-edit distance differences respectively. 

We will then turn our attention to Boomerang's matching lenses, where we will define an appropriate difference measure for data acted on by matching lenses, and show that matching lenses respect this new measure. Matching lenses perform {\em global alignment} of data; for example, they can align data inside of an starred regular expression to data outside of a starred regular expression. The measure that we use for matching lenses will thus seperate the difference between aligned chunks and non-aligned chunks and compute the average of the two to get a final result.

The major technical contributions that we will make in this paper are the following:
\begin{enumerate}
\item
We present a formalization for bx transformations that requires a bx to provide guarantees on how it propagates updates. 
\item
We describe a bx language of {\em difference lenses} based on the basic lenses defined in the lens programming language Boomerang, and show that each difference lens respects a ``difference'' measure that estimates how similar two pieces of data are on both sides of a bx.
  \item
We define an appropriate difference measure for data acted on by {\em matching lenses} \cite{barbosa2010matching}, and show that matching lenses respect this refined measure.
\end{enumerate}
\section{Laying Down BX Laws}
\begin{definition}[Stevens \cite{stevens2010bidirectional}]
A bidirectional transformation (bx) $R : M \Leftrightarrow N$ comprises of 
\begin{enumerate}
\item
a consistency relation $R \subseteq M \times N$,
\item
restorers $\overrightarrow{R} : M \times N \rightarrow N$ and $\overleftarrow{R} : M \times N \longrightarrow
N$.
\end{enumerate}
\end{definition}

\begin{definition}
A bx $R : M \Leftrightarrow N$ is hippocratic if for all $m \in M$, $n \in N$, if $R(m, n)$ then $\overrightarrow{R}(m, n) = n$ and $\overleftarrow{R}(m,n) = m$. $R$ is {\em correct} if the consistency restorers do restore consistency: that is, for all $m \in M, n \in N$, we have $R(m, \overrightarrow{R}(m, n))$, and dually. $R$ is {\em well behaved} if it is correct and hippocratic.
\end{definition}
As we saw in the examples in the introduction, consistency restoration often times is too loose of a constrain to prevent a well-behaved bx from causing unexpected behaviour. What is missing from this model is how the bx handles non-trivial updates. The following definition factors in this missing piece, by relating updates on one side of a bx to updates on the other side of the bx.
\begin{definition}
A difference bidirectional transformation (diff-bx) $(R,S) : M \Leftrightarrow N$ comprises of 
\begin{enumerate}
\item
a consistency relation $R \subseteq M \times N$,
\item
a difference relation $S \subseteq (M \times M) \times (N \times N)$ such that for all $m, m' \in M$, $n, n' \in N$,
\begin{enumerate}
\item
if $(m, m') \stackrel{S}{\sim} (n, n)$ then $m = m'$,
\item
if $(m, m) \stackrel{S}{\sim} (n, n')$ then $n = n'$, and
\end{enumerate}
\item
restorers $\overrightarrow{R} : M \times N \rightarrow N$ and $\overleftarrow{R} : M \times N \longrightarrow
N$.
\end{enumerate}
\end{definition}
Intuitively, the relation $S$ relates differences on the $M$ side to differences on the $N$ side. The relation is required to send only trivial differences to trivial differences.
\begin{definition}
A diff-bx $(R,S) : M \Leftrightarrow N$ is {\em $S$-preserving} if for all $m \in M$, $n, n' \in N$, then if $R(m, n)$ then $(m, \overleftarrow{R}(m,n')) \stackrel{S}{\sim} (n, n')$
\end{definition}
\begin{fact}
If $(R,S) : M \Leftrightarrow N$ is $S$-preserving, then $R$ is hippocratic.
\end{fact}
\begin{definition}
A diff-bx $(R,S) : M \Leftrightarrow N$ is {\em well behaved} if $(R,S)$ is $S$-preserving and $R$ is correct.
\end{definition}
In the next section we describe a language for deriving well-behaved difference bidirectional transformations based on the {\em basic lenses} implemented in the lens programming language {\em Boomerang}.
\section{Difference Lenses}
\begin{definition}
A lens $\ell : S \Leftrightarrow V$ is a well behaved bx where the forward transformation $\overrightarrow{\ell} : S \times V \longrightarrow V$ does not depend on its $V$-argument, and where the consistency relation $\ell$ is given by $(s, v) \in R$ if and only if $\overrightarrow{\ell}(s) = v$

Equivalently, a lens $\ell : S \Leftrightarrow V$ is a pair of functions $\ell.\get : S \longrightarrow V$ and $\ell.\pput : S \longrightarrow V \longrightarrow V$ such that the following equations hold:
\begin{align*}
\ell.\get \; (\ell.\pput \; s \; v) &= v \tag{PUTGET}\\
\ell.\pput \; s \; (\ell.\get \; s) &= s \tag{GETPUT}
\end{align*}
\end{definition}
In order to strengthen hippocraticness (i.e. the GETPUT) law, we need to identify a difference relation $S$ that relates source updates to view updates. Our choice is relate the pair $(\ell.\pput \; s \; v, s)$ to the pair $(v, \ell.\get \; s)$ if and only if $\delta_S(\ell.\pput \; s \; v, s) \geq \delta_V(v, \ell.\get \; s)$ for some real-valued functions $\delta_S : S \times S \longrightarrow \mathbb{R}^{\geq 0}$ and $\delta_V : V \times V \longrightarrow \mathbb{R}^{\geq 0}$.

The functions $\delta_S$ and $\delta_V$ will depend only on $S$ and $V$, and will be designed to measure how similar two sources (or views) are to each other. More specifically, given a regular expression $R$ and strings $s, s' \in \mathcal{L}(R)$, we will define a number $\delta_R(s, s')$ inductively on $R$, with $0 \leq \delta_R(s, s') \leq 1$, and a high value of $\delta_R(s, s')$ indicates that $s$ and $s'$ are similar---in particular, if $s = s'$, then $\delta_R(s, s') = 1$, and if $s \neq s'$ and either $s = \varepsilon$ or $s' = \varepsilon$, then $\delta_R(s, s') = 0$. We will also expand our definition of the regular expression $R^*$, having three different variants $R^*_{POS}$, $R^*_{NC}$ and $R^*_{MED}$, where the differences are computed using positional, non-crossing and min-edit distance alignment strategies respectively, so that for all $s, s' \in \mathcal{L}(R^*)$, $\delta_{R^*_{MED}}(s, s') \geq \delta_{R^*_{NC}}(s, s') \geq \delta_{R^*_{MED}}(s, s')$.
\subsection{Difference Functions on Regular Languages}
\begin{definition}
Given a finite alphabet $\Sigma$, a {\em difference regular expression} is any expression generated by the following grammar,
$$R := s \; | \; R_1 \cdot R_2 \; | \; R_1 \cup R_2 \; | \; R^*_{POS} \; | \; R^*_{NC} \; | \; R^*_{MED}$$
where $s$ ranges over $\Sigma^*$ and $R$ ranges over regular expressions. The languages of $R^*_{POS}$, $R^*_{NC}$ and $R^*_{MED}$ are all the same, namely $\mathcal{L}(R^*)$.
\end{definition}
\begin{definition}
Given an unambiguous difference regular expression $R$, define $\delta_R : \mathcal{L}(R) \times \mathcal{L}(R) \longrightarrow \mathbb{R}^{\geq 0}$ inductively as follows:
\begin{align*}
\delta_s(t, t') &= 1\\
\delta_{R_1 \cdot R_2}(s_1 \cdot s_2, s'_1 \cdot s'_2) &= \frac{1}{2}(\delta_{R_1}(s_1, s'_1) + \delta_{R_2}(s_2, s'_2))\\
\delta_{R_1 \cup R_2}(s, s') &= 
\begin{cases}
\delta_{R_1}(s, s') & \text{if }s, s' \in \mathcal{L}(R_1) \\
\delta_{R_2}(s, s') & \text{if }s, s' \in \mathcal{L}(R_2)\\
0 & \text{otherwise }
\end{cases}\\
\delta_{R^*_{POS}}(s_1 \cdot \ldots \cdot s_m, t_1 \cdot \ldots \cdot t_n) &= 
\begin{cases}
1 & \text{if } m = 0, n = 0\\ 
0 & \text{if } m = 0, n \neq 0\\
0 & \text{if } m \neq 0, n = 0\\\max\limits_{\{\varphi : [m] \rightharpoonup [n] \; | \; \varphi(i) = i\}}\sum\limits_{i \in Dom(\varphi)}\ \frac{\delta_R(s_i, t_{\varphi(i)})}{\max(m,n)}& \text{otherwise}
\end{cases}\\
\delta_{R^*_{NC}}(s_1 \cdot \ldots \cdot s_m, t_1 \cdot \ldots \cdot t_n) &= 
\begin{cases}
1 & \text{if } m = 0, n = 0\\ 
0 & \text{if } m = 0, n \neq 0\\
0 & \text{if } m \neq 0, n = 0\\
\max\limits_{\{\varphi : [m] \rightharpoonup [n] \; | \; \varphi \text{ is str. increasing}\}}\sum\limits_{i \in Dom(\varphi)}\ \frac{\delta_R(s_i, t_{\varphi(i)})}{\max(m,n)}& \text{otherwise}
\end{cases}\\
\delta_{R^*_{MED}}(s_1 \cdot \ldots \cdot s_m, t_1 \cdot \ldots \cdot t_n) &= 
\begin{cases}
1 & \text{if } m = 0, n = 0\\ 
0 & \text{if } m = 0, n \neq 0\\
0 & \text{if } m \neq 0, n = 0\\\max\limits_{\{\varphi : [m] \rightharpoonup [n] \; | \; \varphi \text{ is injective}\}}\sum\limits_{i \in Dom(\varphi)}\ \frac{\delta_R(s_i, t_{\varphi(i)})}{\max(m,n)}& \text{otherwise }
\end{cases}
\end{align*}
\end{definition}
\begin{fact}
For any regular expression $R$ and $s, s' \in \mathcal{L}(R)$
\begin{enumerate}
\item
$0 \leq \delta_R(s, s') \leq 1$.
\item
$\delta_R(s, s) = 1$.
\item
$\delta_R(s, s') = \delta_R(s', s)$.
\item
For all $s, s' \in \mathcal{L}(R^*)$, $\delta_{R^*_{MED}}(s, s') \geq \delta_{R^*_{NC}}(s, s') \geq \delta_{R^*_{MED}}(s, s')$.
\end{enumerate}

\end{fact}
\subsection{Lens Combinators}
\begin{definition}
A lens $\ell : S \Leftrightarrow V$ is a {\em difference lens} if it satisfies the following equation:
\begin{equation}\label{difflenslaw}
\delta_S(\ell.\pput \; s \;v, s) \geq \delta_V(v, \ell.\get \; )
\end{equation}
\end{definition}
\cref{difflenslaw} can be expressed by a relation $S_{\ell} \subseteq (S \times S) \times (V \times V)$ by $(\ell.\pput \; s \;v, s)$ is related to $(v, \ell.\get \; s)$ if and only if \cref{difflenslaw} holds.

In the following part of the paper we describe a language for defining difference lenses on regular languages.
\subsubsection{Copy}
Let $R$ be any unambiguous difference regular expression. Define the lens $\ccopy(R) : R \Leftrightarrow R$ by
\begin{align}
\ccopy(R).\get \; s &= s\\
\ccopy(R).\pput \; s \; v &= v\\
\ccopy(R).\create \; v &= v
\end{align}
\begin{claim}
If $R$ is an unambiguous difference regular expression, then $\ccopy(R) : R \Leftrightarrow R$ is a difference lens.
\end{claim}
\begin{proof}
We need to show that $\delta_R(\ccopy(S).\pput
\; s \; v, s)) \geq \delta_R(v, \ccopy(S).\get \; s)$ which follows from the fact that $\delta_R(\ccopy(S).\pput \; s
\; v, s)) = \delta_R(v, s) = \delta_R(v, \ccopy(S).\get \; s) $.
\end{proof}
\subsubsection{Constant}
Let $R$ be any unambiguous difference regular expression and $c \in \Sigma^*$. Assume that $s' \in \mathcal{L}(R)$. Define the \const lens $\const(R, c) : R
\Leftrightarrow c$ by
\begin{align*}
\const.\get \; s &= c\\
\const.\pput \; s \; v &= s\\
\const.\create \; v &= s'
\end{align*}
\begin{claim}
If $R$ is an unabmbiguous difference regular expression, then $\const(R, c)$ is a difference lens.
\end{claim}
\begin{proof}
We need to show that $\delta_R(\const(R, c).\pput
\; s \; v, s)) \geq \delta_c(v, \const(R, c).\get \; s)$ which follows from the fact that $\delta_R(\const(R, c).\pput
\; s \; v, s)) = \delta_R(s, s) = 1 = \delta_c(c, c) = \delta_R(v, \const(R, c).\get \; s)$.
\end{proof}

\subsubsection{Default}
Let $\ell : S \Leftrightarrow V$ be a difference lens. Let $f :
V \longrightarrow S$ be any function. Define the lens $\default(\ell, f) :
S \Leftrightarrow V$ by
\begin{align*}
\default(\ell, f).\get \; s &= \ell.\get \; s\\
\default(\ell, f).\pput \; s \; v &= \ell.\pput \; s \; v\\
\default(\ell, f).\create \; v &= \ell.\pput \; (f \; v) \; v
\end{align*}
 
\begin{claim}
If $\ell : S \Leftrightarrow V$ is a difference lens and $f: S \longrightarrow V$, then $\default(\ell, f) : S \Leftrightarrow V$ is also a difference lens.
\end{claim}
\begin{proof}
Follows from the fact that $\ell$ is a difference lens.
\end{proof}
\subsubsection{Product}
Let $\ell_1 : S_1 \Leftrightarrow V_1$ and $\ell_2 : S_2 \Leftrightarrow V_2$ be difference
lenses. If $S_1 \cdot^{!} S_2$ and $V_1 \cdot^{!} V_2$, then define the lens $\ell_1 \cdot \ell_2 : S_1 \cdot S_2 \Leftrightarrow
V_1 \cdot V_2$ by
\begin{align*}
(\ell_1 \cdot \ell_2).\get \; (s_1 \cdot s_2) &= (\ell_1.\get \; s_1) \cdot (\ell_2.\get \; s_2)\\
(\ell_1 \cdot \ell_2).\pput \; (s_1 \cdot s_2) \; (v_1 \cdot v_2) &= (\ell_1.\pput \; s_1
\; v_1) \cdot (\ell_2.\pput \; s_2 \; v_2)\\
(\ell_1 \cdot \ell_2).\create \; (v_1 \cdot v_2) &= (\ell_1.\create \; v_1) \cdot (\ell_2.\create \; v_2)
\end{align*}
\begin{claim}\label{productislens}
If $\ell_1 :S_1 \Leftrightarrow V_1$ and $\ell_2 : S_2 \Leftrightarrow V_2$ are difference lenses with $S_1 \cdot^{!} S_2$ and $V_1 \cdot^{!} V_2$, then
$\ell_1 \cdot \ell_2  : S_1 \cdot S_2 \Leftrightarrow V_1 \cdot V_2$ is also a difference lens.
\end{claim}
\begin{proof}
We need to show that
$$\delta((\ell_1 \cdot
\ell_2).\pput \; (s_1 \cdot s_2) \; (v_1 \cdot v_2), (s_1, s_2))) = \delta((v_1 \cdot v_2),
(\ell_1 \cdot \ell_2).\get \; (s_1 \cdot s_2))$$ which follows from the fact that
\begin{align*}
\delta((\ell_1 \cdot
\ell_2).\pput \; (s_1 \cdot s_2) \; (v_1 \cdot v_2), (s_1 \cdot s_2))) &= \delta((\ell_1.\pput \; s_1 \; v_1) \cdot
(\ell_2.\pput \; s_2 \; v_2), (s_1 \cdot s_2)))  \\
&= \frac{1}{2}(\delta(\ell_1.\pput \; s_1 \; v_1, s_1) + \delta(\ell_1.\pput \; s_2 \; v_2, s_2))\\
&\geq \frac{1}{2}(\delta(v_1, \ell_1.\get \; s_1) + \delta(v_2, \ell.\get \; s_2))\\
&= \delta((v_1 \cdot v_2), (\ell_1.\get \; s_1) \cdot (\ell_2.\get \; s_2))\\
&= \delta((v_1 \cdot v_2),
(\ell_1 \cdot \ell_2).\get \; (s_1 \cdot s_2))
\end{align*}
\end{proof}
\subsubsection{Swap}
Let $\ell_1 : S_1 \Leftrightarrow V_1$ and $\ell_2 : S_2 \Leftrightarrow V_2$ be difference
lenses. If $S_1 \cdot^{!} S_2$ and $V_2 \cdot^{!} V_1$, then define the lens $\ell_1 \sim \ell_2 : S_1 \cdot S_2 \Leftrightarrow
V_2 \cdot V_1$ by
\begin{align*}
(\ell_1 \sim \ell_2).\get \; (s_1 \cdot s_2) &= (\ell_2.\get \; s_2) \cdot (\ell_1.\get \; s_1)\\
(\ell_1 \sim \ell_2).\pput \; (s_1 \cdot s_2) \; (v_2 \cdot v_1) &= (\ell_1.\pput \; s_1
\; v_1) \cdot (\ell_2.\pput \; s_2 \; v_2)\\
(\ell_1 \sim \ell_2).\create \; (v_2 \cdot v_1) &= (\ell_1.\create \; v_1) \cdot (\ell_2.\create \; v_2)
\end{align*}
\begin{claim}\label{productislens}
If $\ell_1 :S_1 \Leftrightarrow V_1$ and $\ell_2 : S_2 \Leftrightarrow V_2$ are difference lenses with $S_1 \cdot^{!} S_2$ and $V_2 \cdot^{!} V_1$, then
$\ell_1 \sim \ell_2  : S_1 \cdot S_2 \Leftrightarrow V_2 \cdot V_1$ is also a difference lens.
\end{claim}
\begin{proof}
The proof is similar to the concatenation case.
\end{proof}
\subsubsection{Sum}
Let $\ell_1 : S_1 \Leftrightarrow V_1$ and $\ell_2 : S_2 \Leftrightarrow V_2$ be
difference lenses with $\mathcal{L}(S_1) \cap \mathcal{L}(S_2) = \varnothing$ and $\mathcal{L}(V_1) \cap \mathcal{L}(V_2) = \varnothing$. Define the lens
$\ell_1 \cup \ell_2 :
S_1 \cup S_2 \Leftrightarrow V_1 \cup V_2$ by
\begin{align*}
(\ell_1 \cup \ell_2).\get \; s &=
\begin{cases}
\ell_1.\get \; s & \text{if } s \in S_1\\
\ell_2.\get \; s & \text{if } s \in S_2\\
\end{cases}\\
(\ell_1 \cup \ell_2).\pput \; s \; v&=
\begin{cases}
\ell_1.\pput \; s \; v& \text{if } s \in S_1, \; v \in V_1\\
\ell_2.\pput \; s \; v& \text{if } s \in S_2, \; v \in V_2\\
\ell_1.\create \; v & \text{if } s \in S_2, \; v \in V_1\\
\ell_2.\create \; v & \text{if } s \in S_1, \; v \in V_2\\
\end{cases}\\
(\ell_1 \cup \ell_2).\create \; v &=
\begin{cases}
\ell_1.\create \; v & \text{if } v \in V_1\\
\ell_2.\create \; v & \text{if } v \in V_2\\
\end{cases}
\end{align*}

\begin{claim}
If $\ell_1 : S_1 \Leftrightarrow V_1$ and $\ell_2 : S_2 \Leftrightarrow V_2$ are difference lenses, with $\mathcal{L}(S_1) \cap \mathcal{L}(S_2) = \varnothing$ and $\mathcal{L}(V_1) \cap \mathcal{L}(V_2) = \varnothing$ then $\ell_1 \cup \ell_2 :
S_1 \cup S_2 \Leftrightarrow V_1 \cup V_2$ is also a difference lens.
\end{claim}
\begin{proof}
If the source and the view are in $S_i$ and $V_i$ respectively for $i \in \{1,2\}$, then the result holds from the fact that $\ell_1$ and $\ell_2$ are difference lenses, otherwise the difference on both the source and view side are equal to 0, from which the result follows.
\end{proof}
\subsubsection{Iteration}
Let $\ell : S \Leftrightarrow V$ is a difference lens with $S^{!*}$ and $V^{!*}$. Let $s_1 \cdot \ldots \cdot s_m$ be a source, and $v_1 \cdot \ldots \cdot v_n$ a view. Let $\varphi : [n] \rightharpoonup [m]$ and define $ v \xhookrightarrow{\ell, \varphi} s = s'_1 \cdot \ldots \cdot s'_n$ by 
$$s'_i = \begin{cases}
\ell.\pput \; s_{\varphi(i)} \; v_i & \text{if } i \in Dom(\varphi)\\
\ell.\create \; v_i & \text{if } i \not \in Dom(\varphi)
\end{cases}$$

Using the notation $len(v)$ and $len(s)$ to mean $len(v) = n$ if $v = v_1 \cdot \ldots \cdot v_n$ and $len(s) = m$ if $s = s_1 \cdot \ldots \cdot s_m$, define the lenses $\ell^*_{POS} : S^*_{POS} \Leftrightarrow V^*_{POS}$, $\ell^*_{NC} : S^*_{NC} \Leftrightarrow V^*_{NC}$ and $\ell^*_{MED} : S^*_{MED} \Leftrightarrow V^*_{MED}$ by:
\begin{align*}
\ell^*_{POS}.\get \; (s_1 \cdot  \ldots \cdot s_n) &= (\ell.\get \; s_1)
\cdot \ldots \cdot (\ell.\get \; s_n)\\
\ell^*_{POS}.\pput \; s \; v
&= v \xhookrightarrow{\psi} s\\
\text{where } \psi &= 
\argmax \limits_{\{\varphi : [len(v)] \rightharpoonup [len(s)] \; | \; \varphi(i) = i\}} \delta_{S^*_{POS}}(v \xhookrightarrow{\ell, \varphi} s, s)\\
\ell^*_{POS}.\create \; (v_1, \ldots, v_n) &= (\ell.\create \;
v_1) \cdot \ldots \cdot (\ell.\create \; v_n)
\end{align*}
\begin{align*}
\ell^*_{NC}.\get \; (s_1 \cdot  \ldots \cdot s_n) &= (\ell.\get \; s_1)
\cdot \ldots \cdot (\ell.\get \; s_n)\\
\ell^*_{NC}.\pput \; s \; v
&= v \xhookrightarrow{\psi} s\\
\text{where } \psi &= 
\argmax \limits_{\{\varphi : [len(v)] \rightharpoonup [len(s)] \; | \; \varphi \text{ is str. increasing}\}} \delta_{S^*_{NC}}(v \xhookrightarrow{\ell, \varphi} s, s) \\
\ell^*_{NC}.\create \; (v_1, \ldots, v_n) &= (\ell.\create \;
v_1) \cdot \ldots \cdot (\ell.\create \; v_n)
\end{align*}
\begin{align*}
\ell^*_{MED}.\get \; (s_1 \cdot  \ldots \cdot s_n) &= (\ell.\get \; s_1)
\cdot \ldots \cdot (\ell.\get \; s_n)\\
\ell^*_{MED}.\pput \; s \; v
&= v \xhookrightarrow{\ell, \psi} s\\
\text{where } \psi &= 
\argmax \limits_{\{\varphi : [len(v)] \rightharpoonup [len(s)] \; | \; \varphi \text{ is injective}\}} \delta_{S^*_{MED}}(v \xhookrightarrow{\ell, \varphi} s, s)\\
\ell^*_{MED}.\create \; (v_1, \ldots, v_n) &= (\ell.\create \;
v_1) \cdot \ldots \cdot (\ell.\create \; v_n)
\end{align*}
\begin{claim}
If $\ell : S \Leftrightarrow V$ is a difference lens with $S^{!*}$ and $V^{!*}$, then $\ell^*_{POS}$, $\ell^*_{NC}$ and $\ell^*_{MED}$ are also difference lenses.
\end{claim}
\begin{proof}
We will show that $\ell^*_{MED}$ is a difference lens; the proof for each of the other lenses is similar.

We need to show that
$$\delta_{S^*_{MED}}(\ell^*_{MED}.\pput \; (s_1 \cdot \ldots \cdot s_m) \; (v_1 \cdot \ldots \cdot v_n), s_1 \cdot \ldots \cdot s_m) \geq \delta_{V^*_{MED}}(v_1 \cdot \ldots \cdot v_n, (\ell.\get \; s_1) \cdot \ldots (\ell.\get \; s_m))$$
An optimal min-edit distance alignment $\varphi : [n] \rightharpoonup [m]$ is used to compute the difference on the view side. Since $\ell$ is a difference lens, the following equation holds,
$$\delta_S(\ell.\pput \; s_{\varphi(i)} \; v_i, s_{\varphi(i)}) \geq \delta_V(v_i, \ell.\get \; s_{\varphi(i)})$$
from which it follows that
$$\delta_{S^*_{MED}}(v_1 \cdot \ldots v_n \xhookrightarrow{\ell, \varphi} s_1 \cdot \ldots \cdot s_m, s_1 \cdot \ldots \cdot s_m) \geq \delta_{V^*_{MED}}(v_1 \cdot \ldots \cdot v_n, (\ell.\get \; s_1) \cdot \ldots (\ell.\get \; s_m))$$
Since the \pput function of $\ell^*_{MED}$ uses an alignment $\psi$ that maximizes the min-edit distance over all injective alignments mapping $v$ into $s$, then
$$\delta_{S^*_{MED}}(v_1 \cdot \ldots v_n \xhookrightarrow{\ell, \psi} s_1 \cdot \ldots \cdot s_m, s_1 \cdot \ldots \cdot s_m) \geq \delta_{S^*_{MED}}(v_1 \cdot \ldots v_n \xhookrightarrow{\varphi} s_1 \cdot \ldots \cdot s_m, s_1 \cdot \ldots \cdot s_m)$$

It thus follows that,
$$\delta_{S^*_{MED}}(v_1 \cdot \ldots v_n \xhookrightarrow{\ell, \psi} s_1 \cdot \ldots \cdot s_m, s_1 \cdot \ldots \cdot s_m) \geq \delta_{V^*_{MED}}(v_1 \cdot \ldots \cdot v_n, (\ell.\get \; s_1) \cdot \ldots (\ell.\get \; s_m))$$
hence,
$$\delta_{S^*_{MED}}(\ell^*_{MED}.\pput \; (s_1 \cdot \ldots \cdot s_m) \; (v_1 \cdot \ldots \cdot v_n), s_1 \cdot \ldots \cdot s_m) \geq \delta_{V^*_{MED}}(v_1 \cdot \ldots \cdot v_n, (\ell.\get \; s_1) \cdot \ldots (\ell.\get \; s_m))$$
which is what we wanted to show.
\end{proof}
\subsubsection{Subtyping}
Consider a positional iteration lens $\ell^*_{POS} : S^*_{POS} \Leftrightarrow V^*_{POS}$. Since $\delta_{S^*_{NC}}(s, s') \geq \delta_{S^*_{POS}}(s, s')$ for all $s, s' \in \mathcal{L}(R)$, it follows $\ell^*_{POS} : S^*_{NC} \Leftrightarrow V^*_{POS}$ is also a valid typing judgement. This observation suggests a {\em subtyping} relation on unambiguous difference regular expressions.

We define the subtying relation $\leq$ on difference regular expressions as follows:
\begin{enumerate}
\item
If $R$ is unambiguous, then $R \leq R$.
\item
If $R^{!*}$, then $R^*_{POS} \leq R^*_{NC}$, $R^*_{POS} \leq R^*_{MED}$ and $R^*_{POS} \leq R^*_{NC}$.
\item $R \leq S$ and $S \leq T$ then $R \leq T$.
\item If $R_1 \leq S_1$ and $R_2 \leq S_2$ with $R_1 \cdot ^! R_2$ and $S_1 \cdot^! S_2$ then $R_1 \cdot R_2 \leq S_1 \cdot S_2$.
\item If $R_1 \leq S_1$ and $R_2 \leq S_2$ with $\mathcal{L}(R_1) \cap \mathcal{L}(R_2) = \varnothing$ and $\mathcal{L}(S_1) \cap \mathcal{L}(S_2) = \varnothing$ then $R_1 \cup R_2 \leq S_1 \cup S_2$.
\item
If $R \leq S$ with $R^{!*}$ and $S^{!*}$ then $R^*_{POS} \leq S^*_{POS}$, $R^*_{NC} \leq S^*_{NC}$ and $R^*_{MED} \leq S^*_{MED}$.
\end{enumerate}
\begin{claim}
\begin{enumerate}
\item
If $R \leq S$ then $\mathcal{L}(R) = \mathcal{L}(S)$.
\item
If $R \leq S$, then $\delta_R(s, s') \geq \delta_S(s, s')$ for all $s, s' \in \mathcal{L}(R) = \mathcal{L}(S)$.
\end{enumerate}
\begin{corollary}
If $\ell : S \Leftrightarrow V$ is a difference lens with $S' \leq S$ and $V \leq V'$, then $\ell : S' \Leftrightarrow V'$ is also a difference lens.
\end{corollary}
\end{claim}
\subsubsection{Composition}
Let $\ell_1 : S \Leftrightarrow U_1$ and $\ell_2 : U_2 \Leftrightarrow V$ be difference lenses with $U_1 \leq U_2$. Define the lens $\ell_1 \; ; \; \ell_2 : S \Leftrightarrow V$ by
\begin{align*}
(\ell_1 \; ; \; \ell_2).\get \; s &= \ell_2.\get \; (\ell_1.\get \; s)\\
(\ell_1 \; ; \; \ell_2).\pput \; s \; v &= \ell_1.\pput \; s \; (\ell_2.\pput \;
(\ell_1.\get \; s) \; v) \\
(\ell_1 \; ; \; \ell_2).\create \; v &= \ell_1.\create \; (\ell_2.\create \; v)
\end{align*}

\begin{claim}
If $\ell_1 : S  \Leftrightarrow U_1$ and $\ell_2 : U_2 \Leftrightarrow V$ are difference lenses with $U_1 \leq U_2$ then
$\ell_1 \; ; \; \ell_2 :  S \Leftrightarrow V$ is also a difference lens.
\end{claim}
\begin{proof}
We need to show that
$$
\delta_S(\ell_1 \; ; \; \ell_2).\pput \; s \; v, s) \geq \delta_V(v, (\ell_1 \; ; \; \ell_2).\get \; s)$$

This follows from the fact that
\begin{align*}
\delta_S(\ell_1 \; ; \; \ell_2).\pput \; s \; v, s) &=
\delta_S(\ell_1.\pput \; s \; (\ell_2.\pput \;
(\ell_1.\get \; s) \; v), s)\\
&\geq \delta_{U_1}(\ell_2.\pput \;
(\ell_1.\get \; s) \; v, \ell_1.\get \; s)\\
&\geq \delta_{U_2}(\ell_2.\pput \;
(\ell_1.\get \; s) \; v, \ell_1.\get \; s)\\
&\geq \delta_V(v, \ell_2.\get \; (\ell_1.\get \; s))\\
&= \delta_V(v, (\ell_1 \; ; \; \ell_2).\get \; s)
\end{align*}
\end{proof}
\subsubsection{Filter}
Let $R$ and $S$ be difference regular expressions. Assume that $\mathcal{L}(R) \cap \mathcal{L}(S) = \varnothing$, and that $(R \cup S)^{!*}$. Define the lens $\filter_{MED} \; R \; S : (R \cup S)^*_{MED} \Leftrightarrow R^*_{MED}$ by
\begin{align*}
(\filter \; R \; S).\get \; s &= \strfilter \; R \; s\\
(\filter \; R \; S).\pput \; s \; v &= \strunfilter \; S \; s \;v\\
(\filter \; R \; S).\create \; v &= v
\end{align*}
where \strfilter and \strunfilter are defined as follows:
\begin{lstlisting}[mathescape=true]
let rec $\strfilter \; R \; xs$ = 
match $xs$ with
$|$ $\varepsilon$ -> $\varepsilon$
$|$ $x \cdot xs'$ when $x \in R$ -> $x \cdot (\strfilter \; R \; xs')$
$|$ $x \cdot xs'$ when $x \not \in R$ -> $\strfilter \; R \; xs'$

let rec $\strunfilter \; S \; xs \; ys$ = 
match $xs, ys$ with
$|$ $\varepsilon$,_ -> $ys$
$|$ $x \cdot xs'$,_ when $x \in S$ -> $x \cdot (\strunfilter \; S \; xs' \; ys)$
$|$ $x \cdot xs',\varepsilon$ when $x \not \in S$ -> $\strunfilter \; R \; xs' \; \varepsilon$
$|$ $x \cdot xs',y \cdot ys'$ when $x \not \in S$ -> $y \cdot (\strunfilter \; R \; xs' \; ys')$
\end{lstlisting}
Given a source $s \in (R \cup S)^*$, the lens $\filter \; R \; S$ removes all elements that match $S$ in $s$ in the \get direction and restores them in the \pput direction.
\begin{claim}
Let $R$ and $S$ be difference regular expressions with $\mathcal{L}(R) \cap \mathcal{L}(S) = \varnothing$ and $(R \cup S)^{!*}$. Then $\filter_{POS} \; R \; S : (R \cup S)^*_{MED} \Leftrightarrow R^*_{MED}$ is a difference lens.
\end{claim}
\begin{proof}
We need to show that
$$
\delta_{(R \cup S)^*_{MED}} (\strunfilter \; S \; s \; v, s) \geq \delta_{R^*_{MED}}(v, \strfilter \; R \; s)$$
Observe that if $s = s_1 \cdot \ldots \cdot s_m$ with $s_{i_1}, \ldots, s_{i_p} \in R$ and $s_{j_1}, \ldots, s_{j_p} \in S$, then $\strfilter \; R \; s = s_{i_1} \cdot \ldots \cdot s_{i_n}$. Assume that $v = v_1 \cdot \ldots v_{n'}$. Then since $\delta_{R^*_{MED}}(v, \strfilter \; R \; s) \leq 1$, it follows that
$$
\delta_{(R \cup S)^*_{MED}} (\strunfilter \; S \; s \; v, s) = \frac{m + \delta_{R^*_{MED}}(v, \strfilter \; R \; s) * \max(n,n')}{m+\max(n,n')} \geq \delta_{R^*_{MED}}(v, \strfilter \; R \; s)
$$
which is what we wanted to show.
\end{proof}
\subsubsection{Merge}
If $R$ is a difference regular expression with $R \cdot^! R$, then define the \mergelens lens $\mergelens \; R : R \cdot R \Leftrightarrow R$ as follows:
\begin{align*}
(\mergelens \; R).\get \; (s \cdot s') &= s\\
(\mergelens \; R).\pput \; (s \cdot s') \; t &= 
\begin{cases}
t \cdot t & \text{if }s = s'\\
t \cdot s' & \text{otherwise}
\end{cases}\\
(\mergelens \; R).\create s &= s \cdot s
\end{align*}
\begin{claim}
If $R$ is a difference regular expression with $R \cdot^! R$, then $\mergelens \; R : R \cdot R \Leftrightarrow R$ is a difference lens.
\end{claim}
\begin{proof}
We need to show that
$$\delta_{R \cdot R}((\mergelens \; R).\pput \; (s \cdot s') \; t, (s \cdot s')) \geq \delta_R(t, s)$$
If $s = s'$, then we need to show that
$$\delta_{R \cdot R}(t \cdot t, s \cdot s) \geq \delta_R(t, s)$$
which follows from the fact that
$$\delta_{R \cdot R}(t \cdot t, s \cdot s) = \frac{1}{2}\left(\delta_R(t, s) + \delta_R(t, s)\right) = \delta_R(t, s)$$
If $s \neq s'$, then we need to show that
$$\delta_{R \cdot R}(t \cdot s', s \cdot s') = \frac{1}{2}\left(\delta_R(t, s) + \delta_R(s', s')\right) = \frac{1}{2}\left(\delta_R(t, s) + 1\right) \geq \delta_R(t, s)$$
which follows from the fact that $\delta_R(t, s) \leq 1$.
\end{proof}
\subsection{Matching Lenses}
Difference lenses provide three iteration combinators for dealing with the issue of {\em local alignment}. However, if the ``chunks'' that a programmer wishes to align do not occur underneath a star regular expression, then the difference lenses combinators will not align them. Consider for example the lens:
\begin{lstlisting}
let k : lens = (copy [A-Z]) . ([a-z]<->"")
let l : lens = k . (copy "," . k)*
\end{lstlisting}
If we try to put the view \lstinline|"Z,Y,W,X"| into the source \lstinline|"Xx,Yy,Zz"|, then using a min-edit distance iteration lens, we will get the result \lstinline|"Zx,Yy,Wz,Xa"|, because the view element $``Z"$, being out outside the star, will be put into $``Xx"$, and the iteration lens will align the chunks remaining in the star. What is needed in this example is a lens which performs a ``global alignment'' strategy.

Barbosa's {\em matching lenses} \cite{barbosa2010matching} do just this, by allowing a programmer to mark every chunk that they wish to align anywhere in a lens term. For example, to align all chunks handled using the lens \lstinline|k| in the following example, then we would wrap each occurrence of \lstinline|k| with the ``chunk'' annotation \lstinline|<>| and specify which alignment to use i.e. positional, non-crossing or min-edit distance, which leads to the following lens:  
\begin{lstlisting}
let k : lens = (copy [A-Z]) . ([a-z]<->"")
let l : lens = <best:k> . (copy "," . <best:k>)*
\end{lstlisting}
The \pput behaviour of this new lens is,
\begin{lstlisting}
l.put "Z,Y,W,X" into "Xx,Yy,Zz" = "Zz,Yy,Wa,XX"
\end{lstlisting}
Because matching lenses perform a ``global'' alignment of chunks i.e. an alignment which may match chunks in different positions of a regular expression, then the difference $\delta_R$ is not an appropriate measure to compare the difference between two sources or views. Instead, given a {\em chunk-annotated} regular expression, we will pull out all strings which match the annotated part of the regular expression and compute the difference of those separately from the parts of the regular expression that are not chunk annotated, and then take the average of the two.
\begin{definition}
Let $\Sigma$ be a finite alphabet. A {\em regular expression} is any term generated by the following grammar,
$$R := \varnothing \; | \; s \; | \; R \cdot R' \; | \; R \cup R' \; | \; R^*$$
where $R$ ranges over regular expressions and $s$ ranges over $\Sigma^*$.
\end{definition}
\begin{definition}
A {\em chunk-annotated regular expression} is any term generated by the following grammar,
$$A := R \; | \; <R,t> \; | \; A \cdot A' \; | \; A \cup A' \; | \; A^*$$
where $A$ ranges over chunk-annotated regular expressions $R$ ranges over regular expressions, and $t$ ranges over $\{POS,NC,MED\}$
\end{definition}
Let $A$ be an unambiguous chunk-annotated regular expression built from the alphabet $\Sigma$. Let $* \not \in \Sigma$ and $s \in \mathcal{L}(A)$. Define $S(A, s)$ and $L(A, s)$ inductively by
\begin{align*}
S(R, s) &= s\\
S(<R,t>, <s>) &= *\\
S(A \cdot A', s \cdot s') &= S(A, s) \cdot S(A', s')\\
S(A \cup A', s) &=
\begin{cases}
S(A, s) & \text{if } s \in \mathcal{L}(A)\\
S(A', s) & \text{if } s \in \mathcal{L}(A')
\end{cases}\\
S(A^*, s_1 \cdot \ldots \cdot s_n) &= S(A, s_1) \cdot \ldots \cdot T(A, s_n)\\
\\
L(R, s) &= []\\
L(<R,t>, <s>) &= [s]\\
L(A \cdot A', s \cdot s') &=  L(A,s) +\!\!+ L(A',s')\\
L(A \cup A', s) &=
\begin{cases}
L(A, s) & \text{if } s \in \mathcal{L}(A)\\
L(A', s) & \text{if } s \in \mathcal{L}(A')
\end{cases}\\
L(A^*, s_1 \cdot \ldots \cdot s_n) &= L(A, s_1) +\!\!+ \ldots +\!\!+ L(A, s_n)
\end{align*}
The string $S(A, s)$ is the ``skeleton'' of $s$ that matches the annotated regular expression $A$, while the list $L(A, s)$ is the list of strings inside $s$ that have been marked as chunks for alignment.

Define the function $pick : List(A \; option) \longrightarrow A \; option$ by
$$
pick \; [a_1, \ldots, a_n] =
\begin{cases}
Some \; a & \text{if } i > 0 \text{ and }a_i \neq None \text{ implies } a_i = a\\
None &\text{otherwise}
\end{cases}
$$
Given a chunk-annotated regular expression $A$, define $M(A)$ and $N(A)$ as follows:
\begin{align*}
M(R) &= R\\
M(<R,t>) &= *\\
M(A \cdot A') &= M(A) \cdot M(A')\\
M(A \cup A') &= M(A) \cup M(A')\\
M(A^*) &= M(A)^*\\
\\
N(R) &= None\\
N(<R, t>) &= Some \; (R, t)\\
N(A \cdot A') &= pick \; [N(A),N(A')]\\
N(A \cup A') &= pick \; [N(A),N(A')]\\
N(A^*) &= pick [M(A)]
\end{align*}
$M(A)$ is the skeletal part of a chunk-annotated regular expresion, whereas $N(A)$ is the regular expression inside $A$ that actually matches chunks to be aligned.

For any unambiguous regular expression $R$, let $List(R)$ be the set of all lists with elements in $\mathcal{L}(R)$, and observe that we can define three difference functions $\delta^{List(R)}_{POS}$ $\delta^{List(R)}_{NC}$ and $\delta^{List(R)}_{MED}$ on $List(R)$ in the same way that we define $\delta_{R^*_{POS}}$, $\delta_{R^*_{NC}}$ and $\delta_{R^*_{MED}}$. For example, define
$$
\delta^{List(R)}_{MED}([s_1, \ldots, s_m], [t_1, \ldots, t_n]) = 
\begin{cases}
1 & \text{if } m = 0, n = 0\\ 
0 & \text{if } m = 0, n \neq 0\\
0 & \text{if } m \neq 0, n = 0\\\max\limits_{\{\varphi : [m] \rightharpoonup [n] \; | \; \varphi \text{ is injective}\}}\sum\limits_{i=1}^{m}\ \frac{\delta_R(s_i, t_{\varphi(i)})}{\max(m,n)}& \text{otherwise}
\end{cases}
$$

\begin{definition}
If $A$ is a chunk-annotated unambiguous regular expression with $s,s' \in \mathcal{L}(A)$ and $N(A) = (R, t)$, define $\delta_A(s, s')$ by
$$
\delta_A(s, s) = 
\frac{1}{2} \left(\delta_{M(V)}(S(A,s), S(A,s')) + \delta^{List(R)}_{t}(L(A, s), L(A, s'))\right)
$$
\end{definition}
Having defined a way of measuring the difference between two chunk-annotated strings, we now give a brief summary of the design of a simplified version of matching lenses, and explain how a matching lens $\ell$ is used to define a basic lens $\lfloor \ell \rfloor$ that performs alignment of chunks in a chunk-annotated string. We will then prove that $\lfloor \ell \rfloor$ is a difference lens with respect to the measure $\delta_A$ that we defined for chunk-annotated regular expressions.
\begin{definition}
Given a basic lens $k : S_k \Leftrightarrow V_k$, sets $S$, $V$ that have chunks in $S_k$ and $V_k$ respectively, and a set $C$ of ``complements'', a matching lens $\ell : S \xLeftrightarrow{C, k} V$ comprises four functions:
\begin{align*}
\ell.\get &: S \longrightarrow V\\
\ell.\res &: S \longrightarrow (C \times (\mathbb{N} \rightharpoonup S_k))\\
\ell.\pput &: V \longrightarrow (C \times (\mathbb{N} \rightharpoonup S_k)) \longrightarrow S\\
\ell.\create &: V \longrightarrow (\mathbb{N} \rightharpoonup S_k) \longrightarrow S
\end{align*}
that satisfy the following laws,
\begin{align*}
\ell.\get \; (\ell.\pput \; v \; 
(c,r)) &= v \tag{PUTGET}\\
\ell.\pput \; (\ell.\get \; s) \; (\ell.\res \; s) &= s \tag{GETPUT}\\
\text{if } n \in (locations(v) \cap dom(r)) &\text{ then } (\ell.\pput \; v \; (c, r))[n] = k.\pput \; v[n] \; (r(n)) \tag{CHUNKPUT}\\
\text{if } n \not \in (locations(v) \cap dom(r)) &\text{ then } (\ell.\pput \; v \; (c, r))[n] = k.\create \; v[n] \tag{NOCHUNKPUT}
\end{align*}
where $locations(s)$ is the number of chunks in $s$. (Matching lenses are required to satisfy other laws as well, but these have been ommitted for brevity).
\end{definition}
The \pput function of a matching lens takes a complement $c$ and partial map $r$ from natural numbers to chunks of type $S_k$. Intuitively, when the lens encounters a the $n^{th}$ chunk inside of a string, it uses the basic lens $k$ by putting the $n^{th}$ chunk of $v$ into the $n^{th}$ chunk in $r$, and if $r$ does not contain any chunk at position $n$ then $r$ uses the \create function of $k$ to. Otherwise, the lens uses the complement $c$ in the ``skeletal'' parts of the string i.e. the parts of the string that are not marked as chunks.

Now let $\ell : S \xLeftrightarrow{C, k}$ be a matching lens with $k : S_k \Leftrightarrow V_k$.
Assume that $N(V) = Some \; (R, t)$, and define the basic lens $\lfloor \ell \rfloor : S \Leftrightarrow V$ by
\begin{align*}
\lfloor \ell \rfloor.\get \; s &= \ell.\get \; s\\
\lfloor \ell \rfloor.\pput \; s \; v&= \ell.\pput \; v \; (c, r \circ g)\\
\text{where } (c, r) &= \ell.\res \;s \\
\text{and } g &\text{ aligns } L(V, chunks(v)) \text{ to } L(V, chunks(\ell.\get \; s)),\\
&\text{ maximizing } \delta^{List(R)}_{t}(L(V, chunks(v)), L(V, chunks(\ell.\get \; s)))\\
\lfloor \ell \rfloor.\create \; v &= \ell.\create \; v \; \varnothing
\end{align*}
\begin{claim}
$\delta_S(\lfloor \ell \rfloor.\pput \; s \;v, s) \geq \delta_V(v, \lfloor \ell \rfloor.\get \; s)$
\end{claim}
\begin{proof}
Let $N(S) = Some \; (R', t)$. Since $$\delta_S(\lfloor \ell \rfloor.\pput \; s \;v, s) = \frac{1}{2} \left(\delta_{M(S)}(S(S,\lfloor \ell \rfloor.\pput \; s \;v), S(S,s)) + \delta^{List(R')}_{t}(L(S, \lfloor \ell \rfloor.\pput \; s \;v), L(S, s))\right)$$
and
$$\delta_V(v, \lfloor \ell \rfloor.\get \; s) = \frac{1}{2} \left(\delta_{M(V)}(S(V,v), S(V,\lfloor \ell \rfloor.\get \; s)) + \delta^{List(R)}_{t}(L(V, v), L(V, \lfloor \ell \rfloor.\get \; s))\right)$$
then it is enough to show that
$$\delta_{M(S)}(S(S,\lfloor \ell \rfloor.\pput \; s \;v), S(S,s)) \geq \delta_{M(V)}(S(V,v), S(V,\lfloor \ell \rfloor.\get \; s))$$
and that
$$\delta^{List(R')}_{t}(L(S, \lfloor \ell \rfloor.\pput \; s \;v), L(S, s)) \geq \delta^{List(R)}_{t}(L(V, v), L(V, \lfloor \ell \rfloor.\get \; s))$$
Both of these follow from the fact that $k$ and the skeleton of $\ell$ are both basic lenses.
\end{proof}
\iffalse
\section{Relational Lenses}
We define a {\em relation} $R$ of type $((T_1, \ldots, T_n), P, F)$ to be a
multiset $R$ where $T_i, P$ are sets satisfying $R \subseteq P \subseteq T_1
\times \ldots \times T_n$, $F \subseteq [n] \times [n]$, and if $i, j \in F$,
then for all $r, r' \in R$, if $r_i = r'_i$ then $r_j = r'_j$. We interpret the
$T_i$ to be a set of {\em attributes}, $R$ to be a set of {\em records} with
$dom(r) = (T_1, \ldots, T_n)$ for all $r \in R$, $P$ to be a {\em predicate}
such that the records in $R$ satisfy $P$, and $F$ to be a set of {\em
functional dependencies} on the attributes of the records in $R$.

Let $G(F)$ be the graph induced by $F$ on $T_1, \ldots, T_n$ i.e. there is an
edge from $T_i$ to $T_j$ if and only if $(i, j) \in F$. We say that $F$ is
in {\em tree form} if $G(F)$ is a DAG and every vertex has indegree at most 1;
following \cite{bohannon2006relational},we will always assume that $F$ is in
tree form from here on. Observe that every record $r$ is completely determined
by nodes of indegree 0 in $G(F)$: if $Roots(G(F)) = \{T_{i_1}, \ldots,
T_{i_k}\}$ is the set of nodes of indegree 0 and outdegree greater than 0 in
$G(F)$ and $Isolated(G(F)) = \{T_{j_1}, \ldots, T_{j_\ell}\}$ is the set of
nodes of indegree 0 and outdegree 0 in $G(F)$, then for any $r = (r_1, \ldots,
r_n)\in R$, then the map $((r_{i_1}, \ldots, r_{i_k}), (r_{j_1}, \ldots,
r_{j_\ell}))$ is a bijection since the $r_{i_1}, \ldots, r_{i_k}$ determine all
nodes of indegree greater than 0, which leaves just the nodes $r_{j_1}, \ldots,
r_{j_\ell}$.

In order to define lenses in relations, we first need to describe data
structures representing the relation; lenses will operate on the data
structures rather than on relations. Let $Outputs(F) = G(F) \setminus
(Roots(G(F)) \cup Isolated(G(F)))$. We choose to represent a relation with the
following data:
\begin{enumerate}
  \item
  A partial map $data : (T_{i_1} \times \ldots \times T_{i_k})
  \longrightarrow 2^{(T_{j_1} \times \ldots \times T_{j_{\ell}})}$ such that
  there exists a record $r \in R$ with $r[T_{i_1}, \ldots, T_{i_k}] =
  (t_{i_1}, \ldots, t_{i_k})$ if and only if
  $$data(t_{i_1}, \ldots, t_{i_k}) =  \{\{r[T_{j_1}, \ldots, T_{j_{\ell}}] \in
  R \; | \; r_{i_m} = t_{i_m} \text{ for }1 \leq m \leq k\}\}$$
  \item
  A map $dependencies : outputs(F) \longrightarrow \cup_{i,j} 2^{T_i \times
  T_j}$ such that $(p, q) \in dependencies(j)$ if and only if there exists a
  record $r \in R$ such that $r[T_i, T_j] = (p, q)$, where $i$ is such that
  $T_i \longrightarrow T_j \in F$ ($i$ is unique as $F$ is assumed to be in tree
  form).
\end{enumerate}
\subsection{Select}
We say that a predicate $P$ ignores a set of attributes $X$ if for all $r, r'
\in R$, if $r[dom(R) \setminus X] = r'[dom(R) \setminus X]$ implies that $r
\in P$ if and only if $r' \in P$.

The {\em select} lens on $R$ evaluates to a relation which is the same as $R$
but which satisfies a predicate $P$. The inferrence rule for deriving the select
lens is the following:
\begin{prooftree}
\AxiomC{$R : ((T_1, \ldots, T_2), Q, F)$}
\AxiomC{$S : ((T_1, \ldots, T_2), P \cap Q, F)$}
\AxiomC{$F$ is in tree form}
\AxiomC{$P$ ignores $Outputs(F)$}
\QuaternaryInfC{$(select \; from \; R\; where \; P \; as \; S) : R
\Leftrightarrow S$}
\end{prooftree}
In the get direction, the select lens simply restricts $R$ to $P$. Now consider
$put \; s \; r$. The select lens proceeds as follows:
\begin{enumerate}
  \item
  First, it computes $(data_s, dependencies_s)$ and $(data_r, dependencies_r)$.
  \item
  Next, it updates $dependencies_r$ using $dependencies_s$ to get
  $dependencies_r'$.
  \item
  Next it filters $data_r$ to contain only records not in $P$ to get $data_r'$.
  \item
  Next, it computes $(data_r' \cup data_s, dependencies_r')$.
  \item
  Finally, it deletes the records from $data_r' \cup data_s$ that would cause
  PUT-GET to fail.
\end{enumerate}
\fi
%% Acknowledgments
\begin{acks}                            %% acks environment is optional
%% contents suppressed with 'anonymous'
%% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
%% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
%% acknowledge financial support and will be used by metadata
%% extraction tools.
This material is based upon work supported by the
\grantsponsor{GS100000001}{National Science
Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
No.~\grantnum{GS100000001}{nnnnnnn} and Grant
No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
conclusions or recommendations expressed in this material are those
of the author and do not necessarily reflect the views of the
National Science Foundation.
\end{acks}

\bibliographystyle{plain}
\bibliography{local}
%% Appendix
%%\appendix
%%\section{Appendix}

\end{document}
