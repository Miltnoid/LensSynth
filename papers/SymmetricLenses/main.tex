\newif\ifdraft\drafttrue  % set true to show comments
%\newif\ifdraft\draftfalse  % set true to show comments
\newif\ifanon\anonfalse    % set true to suppress names, etc.
\newif\iffull\fullfalse   % set true for long version
\newif\ifappendices\appendicestrue

\PassOptionsToPackage{usenames,dvipsnames,svgnames,table}{xcolor}
\documentclass[acmsmall,screen,anonymous]{acmart}
\settopmatter{}

\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{bussproofs}
\usepackage{varwidth}
\usepackage{amsthm}
\usepackage{csvsimple}
\usepackage{thmtools,thm-restate}
\usepackage{changepage}
\usepackage{booktabs}
\usepackage{amssymb}
\usepackage[inline]{enumitem}
\usepackage{multirow,bigdelim}
\usepackage{multicol}
\usepackage{siunitx}
\usepackage{listings}
\usepackage{sansmath}
\usepackage{url}
\usepackage{flushend}
\usepackage{microtype}
\usepackage[utf8]{inputenc}
\usepackage{mathpartir}
\usepackage{empheq}
\usepackage{array}
\usepackage{pgfplots}
\usepackage{stmaryrd}
\usepackage{courier}
\usepackage{qtree}
\usepackage[normalem]{ulem}
\usepackage{relsize}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{textcomp}
\usepackage{tabularx}
\usepackage{stackengine}
\usepackage{caption}
\usepackage{wrapfig}
\usepackage{remreset}
\usepackage{tabulary}
\usepackage{xspace}

\usetikzlibrary{
  er,
  matrix,
  shapes,
  arrows,
  positioning,
  fit,
  calc,
  pgfplots.groupplots,
  arrows.meta
}
\tikzset{>={Latex}}

%%%% Hyperlinks â€“ must come late!
%\usepackage[pdftex,%
%            pdfpagelabels,%
%            linkcolor=blue,%
%            citecolor=blue,%
%            filecolor=blue,%
%            urlcolor=blue]
%           {hyperref}

\input{macros}

\clubpenalty = 10000
\widowpenalty = 10000
\displaywidowpenalty = 10000

%\setlength{\belowcaptionskip}{-5pt}
%\setlength{\textfloatsep}{15pt}

% Creates a display mode for code in sans serif font
\lstnewenvironment{sflisting}[1][]
  {\lstset{%
    mathescape,
    basicstyle=\small\sffamily,
    aboveskip=5pt,
    belowskip=5pt,
    columns=flexible,
    frame=,
    xleftmargin=1em,#1}\sansmath}
  {}
% end

% Macros
  \newcommand{\NameOf}[1]{\CF{#1}}

%%% If you see 'ACMUNKNOWN' in the 'setcopyright' statement below,
%%% please first submit your publishing-rights agreement with ACM (follow link on submission page).
%%% Then please update our instructions page and copy-and-paste the NEW commands into your article.
%%% Please contact us in case of questions; allow up to 10 min for the system to propagate the information.
%%%
%%% The following is specific to POPL'18 and the paper
%%% 'Synthesizing Bijective Lenses'
%%% by Anders Miltner, Kathleen Fisher, Benjamin C. Pierce, David Walker, and Steve Zdancewic.
%%%
  
\setcopyright{rightsretained}
\acmPrice{}
\acmDOI{10.1145/3158089}
\acmYear{2018}
\copyrightyear{2018}
\acmJournal{PACMPL}
\acmVolume{2}
\acmNumber{POPL}
\acmArticle{1}
\acmMonth{1}
\startPage{1}

\bibliographystyle{ACM-Reference-Format}
\citestyle{acmauthoryear}

  \begin{document}

  %%% The following is specific to POPL'18 and the paper
%%% 'Synthesizing Bijective Lenses'
%%% by Anders Miltner, Kathleen Fisher, Benjamin C. Pierce, David Walker, and Steve Zdancewic.
%%%

%\toappear{}

%\conferenceinfo{POPL '16}{January 20--22, 2016, St. Petersburg, FL, USA} 
%\copyrightyear{2016} 
%\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

%\titlebanner{DRAFT---do not distribute}        % These are ignored unless
%\preprintfooter{DRAFT---do not distribute}   % 'preprint' option specified.

\title{Synthesizing Symmetric Lenses}

\begin{abstract}
  Similar data is oftentimes represented and stored in different formats. Users
  commonly need to synchronize the data shared between formats, where edits to
  the data in one format gets propagated to the data in the other format.
  Manually writing these data synchronizers is tedious and error prone. To
  alleviate these difficulties, tools have been developed that automatically
  generate these synchronization functions by generating bidirectional lens
  programs from data format descriptors~\cite{optician,quotient-optician}.
  However, these tools only work when the two formats describe exactly the same
  data; it assumes that all important information present in one format is
  present in the other. This is often not the case.

  In this work, we automatically synthesize conversion functions between formats
  that each may contain information the other lacks. We define \emph{simple
    symmetric lenses}, a class of bidirectional programs for expressing these
  types of conversion functions, and we specify a language that expresses simple
  symmetric lenses that operate on string formats. We develop a type-directed
  synthesis algorithm for generating lenses in this language from regular
  expressions describing the data formats. A significant technical challenge in
  this work arises from the fact that our target language permits
  synchronization between formats that don't have exactly the same data -- data
  in one format need not be present in the other format. This gives the
  synthesis algorithm much more freedom, as data can be completely
  unsynchronized (edits in one format are never propagated), completely
  synchronized (the formats are in bijective correspondence), or anywhere in
  between. Under the assumption that users typically want to synchronize as much
  data as possible, we provide an information theoretic metric for how much data
  is left unsynchronized based on the theory of \emph{stochastic regular
    expressions}. Furthermore, we use this metric to develop a greedy synthesis
  algorithm that tries to minimize unsynchronized data. We experimentally
  demonstrate that despite addressing a much harder problem, our extension to
  Optician still maintains synthesis times competitive to Optician on Optician's
  bijective benchmark suite, while generalizing to benchmarks synchronizing data
  not in bijective correspondence.
\end{abstract}

\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011050.10011017</concept_id>
<concept_desc>Software and its engineering~Domain specific languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10011007.10011006.10011066.10011070</concept_id>
<concept_desc>Software and its engineering~Application specific development environments</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~Domain specific languages}
\ccsdesc[300]{Software and its engineering~Application specific development environments}

\ifanon
%\authorinfo{}
%           {}
%           {}
\maketitle
% \vspace*{-6cm}
\else
\author{Anders Miltner}
\affiliation{
  \institution{Princeton University}
  \country{USA}
}
\email{amiltner@cs.princeton.edu}

\author{Solomon Maina}
\affiliation{
  \institution{Princeton University}
  \country{USA}
}
\email{smaina@cis.upenn.edu}

\author{Kathleen Fisher}
\affiliation{
  \institution{Tufts University}
  \country{USA}
}
\email{kfisher@eecs.tufts.edu}

\author{Benjamin C. Pierce}
\affiliation{
  \institution{University of Pennsylvania}
  \country{USA}
}
\email{bcpierce@cis.upenn.edu}

\author{David Walker}
\affiliation{
  \institution{Princeton University}
  \country{USA}
}
\email{dpw@cs.princeton.edu}

\author{Steve Zdancewic}
\affiliation{
  \institution{University of Pennsylvania}
  \country{USA}
}
\email{stevez@cis.upenn.edu}

\keywords{Bidirectional Programming, Program Synthesis, Type-Directed Synthesis,
Type Systems}

\maketitle
\fi

% \category{D.3.1}
% {Programming Languages}
% {Formal Definitions and Theory}
% [Semantics]
\ifanon\else
\fi

% begin introduction
\section{Introduction}
% state of the world
Similar data can come in varieties of formats: scheduled jobs can be stored as
cron jobs for Linux or as Scheduled Tasks for Windows; web service resources can
be provided to clients in legacy or modern formats; calendar events can be
stored in CSV files or ICS files. Oftentimes, we want to synchronize files
across formats: when I edit a task to run more often on my Linux machine, I want
this task to run more often on my Windows machine; when I update data through a
legacy API, I want those changes to be reflected when I retrieve it through a
modern API; when I create a new calendar event in my ICS file, I want my CSV
calendar files to be updated to reflect this change.

Unfortunately, writing such synchronizers is tedious and error prone.
Bidirectional languages ease the difficulty of writing such synchronizers, as a
single, well-typed program expresses multiple conversion functions, and
guarantee these functions satisfy round-tripping laws. However, bidirectional
languages are difficult to program in as well -- often requiring users to
permute data in fiddly ways while satisfying the type system's complex
unambiguity constraints.

A better approach is to synthesize such conversion functions. Recent research
has gone into automatically synthesizing such conversion functions from
input-output examples and formal descriptions of the data
formats~\cite{optician,quotient-optician}. However, this work assumes that all
data fields present in one format are present in the other, but this is not
always true. Oftentimes, fields present in one format are not present in the
other: the commands scheduled to run on Linux machines are typically different
than the commands scheduled to run on Windows machines; updated APIs can expose
new information, or omit legacy information; ICS files contain a URL field that
Google Calendar CSV files do not expose. We aim to synthesize transformations
where the data fields are not necessarily in bijective correspondence, where
each data format can contain important information not present in the other
format.

We follow a similar approach to existing work on synthesizing conversion
functions; instead of synthesizing these functions individually, we synthesize
bidirectional programs. To this end, we develop a new formulation of
bidirectional programs, \emph{simple symmetric lenses}, which permit
synchronizations between formats not in bijective correspondence. We develop a
language for expressing simple symmetric lenses that operate on string data.
Terms in this language are typed between regular expressions, where the regular
expressions describe the synchronized data formats.

Our synthesis algorithm takes as input a suite of input-output examples and two
regular expressions describing the data formats. Our synthesis algorithm uses
type-directed synthesis on the two regular expressions to synthesize a lens that
is well-typed between the provided regular expressions and satisfies the
provided input-output examples.

A primary novel difficulty is that, unlike previous work where there are
relatively few well-typed lenses, there are a relatively many well-typed simple
symmetric lenses. As symmetric lenses permit data to be present in only one
format, for any data component there is now a choice: is this data only relevant
to this format and as such should be left unsynchronized, or is this data
present in both formats and as such should be synchronized.

We operate under the assumption that users wish to synchronize as much data as
possible, and try to synchronize as much data as the types and examples allow.
This task gets harder when there are more complex decisions involved. For
example, if I have two fields in one format, and one in the other, which field
on the left should be synchronized to the one of the right? Or would it be
better for the field on the right to be synchronized to a mish-mash of
subcomponents from each field? To answer these questions, we develop a cost
metric for reasoning about which lens synchronizes the most information.

As we wish to synchronize as much data as we can, our cost model gives higher
cost to those with more data is left unsynchronized. In particular, the cost of
a lens is the expected number of bits required to recover a string in one format
when a synchronized string in the other format is provided. In this model,
bijective lenses have zero cost, and as more information is left unsychronized,
the cost is increased.

Our model for this is based on \emph{stochastic regular expressions}~\cite{?}.
We represent a probability distribution for strings by a stochastic regular
expression, and find a way to syntactically infer the expected information
content (or \emph{entropy}) of an unambiguous regular expression. We use this
entropy to calculate the expected information content to recover a string, when
we are given a string it is synchronized to.

We develop an algorithm that synthesizes a low-cost lens. Our algorithm consists
of two communicating synthesizers, one that proposes candidate stochastic
regular expression pairs that it thinks will align well, and one that greedily
searches for a lens between those two regular expressions that minimizes cost
and involves no rewrites.

Our first algorithm, \TypeProp, proposes candidate stochastic regular
expressions. These candidate stochastic regular expressions are generated by
traversing \emph{star semiring} equivalences on stochastic regular expressions.
These proposed stochastic regular expression pairs have equivalent languages and
probability distributions as the original ones: we prove the star-semiring
rewrites this synthesizer applies are sound rewrites on stochastic regular
expression.

Our second algorithm, \GreedySynth, utilizes alternative languages for
stochastic regular expressions and lenses, \emph{stochastic DNF regular
  expressions} and \emph{symmetric DNF lenses}. While these languages are hard
to read and understand, they permit an efficient type-directed synthesis
algorithm. We develop our cost metric on DNF lenses, and provide a greedy
algorithm that tries to find a symmetric DNF lens of minimal cost.

We evaluate our algorithm on a benchmark suite consisting of the original
Optician benchmarks, as well as additional benchmarks consisting of
synchronization tasks where the data is not in bijective correspondence.

In summary, our contributions are:
\begin{enumerate}
\item We develop \emph{simple symmetric lenses} a new formulation for
  bidirectional programs that can project data from both sides~(\S\ref{sec:ssl}),
  and describe a language that expresses such lenses on string
  data~(\S\ref{sec:ssl-string}).
\item We develop a means to traverse stochastic regular expression equivalences,
  while preserving probability distributions and
  languages~(\S\ref{sec:stoch-rx}).
\item We develop stochastic DNF regular expressions and DNF lenses. We develop a
  sound algorithm for converting stochastic regular expressions to stochastic
  DNF regular expressions~(\S\ref{sec:dnf-regex-lens}), and a
  information-theoretic cost metric on DNF
  lenses~(\S\ref{sec:symmetric-dnf-lenses}).
\item We extended Boomerang with our simple symmetric lens combinators. We
  updated the Optician synthesis system to synthesize symmetric lenses with our
  new algorithm.
\item We evaluate our synthesis algorithm on Opticians benchmark suite as well
  as new, symmetric benchmarks, and find that we lose very little synthesis
  time, while gaining a large amount of expressivity (\S\ref{sec:evaluation}).
\end{enumerate}
% end introduction

% begin extended example
\section{Extended Example}
We motivate our problem with an extended example.  Consider the previously
described scenario of keeping Linux and Windows scheduled jobs synchronized.
% end extended example

% begin stoch-rx
\section{Stochastic Regular Expressions}
\label{sec:stoch-rx}
Important to our algorithm is finding the expected number of bits needed to
recover a string in one data source from a synchronized string in the other data
source. To do this, we must first develop a probability model for our language.
We do this with \emph{stochastic regular expressions}, regular expressions
annotated with probability information. With this, we can jointly express a
language and a probability distribution over that language.

\begin{center}
  \begin{tabular}{rcl}
    \Regex{},\RegexAlt{}
    & \GEq{} & $\String$ \\
    & \GBar{} & $\emptyset$ \\
    & \GBar{} & $\PRegexStar{\Regex}{p}$ \\
    & \GBar{} & $\RegexConcat{\Regex_1}{\Regex_2}$ \\
    & \GBar{} & $\PRegexOr{\Regex_1}{\Regex_2}{p}$
  \end{tabular}
\end{center}

The language is defined like the regular expression without probability
annotations would be.  The probabilities are defined as follows:

\begin{center}
  \begin{tabular}{rcl}
    $\ProbabilityOf{\String}{\String'}$
    & =
    & $\begin{cases*}1 & if $\String = \String'$\\ 0 & otherwise\end{cases*}$ \\
    
    $\ProbabilityOf{\emptyset}{\String}$
    & =
    & $0$ \\
    
    $\ProbabilityOf{\RegexConcat{\Regex_1}{\Regex_2}}{\Character_1 \ldots \Character_n}$

    & =
    & $\Sigma_{\String = \String_1\String_2}\ProbabilityOf{\Regex_1}{\String_1}*\ProbabilityOf{\Regex_2}{\String_2}$ \\
    
    $\ProbabilityOf{\PRegexOr{\Regex_1}{\Regex_2}{\Probability}}{\String}$
    & =
    & $\Probability * \ProbabilityOf{\Regex_1}{\String} +
      (1-\Probability) * \ProbabilityOf{\Regex_2}{\String}$\\
    
    $\ProbabilityOf{\PRegexStar{\Regex}{\Probability}}{\String}$
    & =
    & $\Sigma_{\String = \String_1 \ldots \String_n}\Probability^n*(1-\Probability)*\Pi_{i=1}^n\ProbabilityOf{\Regex}{\String_i}$\\
  \end{tabular}
\end{center}

Much like the synthesis algorithm for Optician, we need to apply rewrites to
handle equivalences on the provided stochastic regular expressions.  However, no
such equivalences have yet been defined.  We extend the \emph{star-semiring}
equivalences to stochastic regular expressions.

\begin{center}
  \begin{tabular}{@{}r@{\hspace{1em}}c@{\hspace{1em}}l@{}r@{}}
    \PRegexOr{\Regex}{\emptyset}{1} & $\SSREquiv$ & \Regex{} & \OrIdentityRule{} \\
    $\RegexConcat{\Regex}{\emptyset}$ & $\SSREquiv$ & $\emptyset$ & \EmptyProjectionRightRule{} \\
    $\RegexConcat{\emptyset}{\Regex}$ & $\SSREquiv$ & $\emptyset$ & \EmptyProjectionLeftRule{} \\
    \RegexConcat{(\RegexConcat{\Regex{}}{\Regex'})}{\Regex''} & $\SSREquiv$ & \RegexConcat{\Regex{}}{(\RegexConcat{\Regex'}{\Regex''})} & \ConcatAssocRule{}  \\
    \PRegexOr{(\PRegexOr{\Regex}{\Regex'}{\Probability_1})}{\Regex''}{\Probability_2} & $\SSREquiv$ & \PRegexOr{\Regex}{(\PRegexOr{\Regex'}{\Regex''}{(1-\Probability_1)*\Probability_2})}{\Probability_1*\Probability_2} & \OrAssociativityRule{}  \\
    \PRegexOr{\Regex{}}{\RegexAlt{}}{\Probability} & $\SSREquiv$ & \PRegexOr{\RegexAlt{}}{\Regex{}}{1-\Probability} & \OrCommutativityRule{}\\
    \RegexConcat{\Regex{}}{(\PRegexOr{\Regex{}'}{\Regex{}''}{\Probability})} & $\SSREquiv$ & \PRegexOr{(\RegexConcat{\Regex{}}{\Regex{}'})}{(\RegexConcat{\Regex{}}{\Regex{}''})}{\Probability} & \DistributivityLeftRule{} \\
    \RegexConcat{(\PRegexOr{\Regex{}'}{\Regex{}''}{\Probability})}{\Regex{}} & $\SSREquiv$ & \PRegexOr{(\RegexConcat{\Regex{}'}{\Regex{}})}{(\RegexConcat{\Regex{}''}{\Regex{}})}{\Probability} & \DistributivityRightRule{} \\
    \RegexConcat{\EmptyString{}}{\Regex{}} & $\SSREquiv$ & \Regex{} & \ConcatIdentityLeftRule{} \\
    \RegexConcat{\Regex{}}{\EmptyString{}} & $\SSREquiv$ & \Regex{} & \ConcatIdentityRightRule{} \\
    \PRegexStar{\Regex{}}{\Probability} & $\SSREquiv$ & \PRegexOr{\EmptyString{}}{(\RegexConcat{\Regex{}}{\PRegexStar{\Regex{}}{\Probability}})}{\Probability} & \UnrollstarLeftRule{} \\
    \PRegexStar{\Regex{}}{\Probability} & $\SSREquiv$ & \PRegexOr{\EmptyString{}}{(\RegexConcat{\PRegexStar{{\Regex{}}}{\Probability}}{\Regex{}})}{\Probability} & \UnrollstarRightRule{} 
  \end{tabular}
\end{center}
% \caption{Regular Expression Equivalences}
% \label{fig:regex-equivalence-rules}

\begin{theorem}
  If $\Regex \SSREquiv \RegexAlt$ then $\ProbabilityOf{\Regex}{\String} =
  \ProbabilityOf{\RegexAlt}{\String}$, for all strings $\String \in \LanguageOf{\Regex}$.
\end{theorem}
% end stoch-rx

\section{Simple Symmetric Lenses}
\label{sec:ssl}
Classically, asymmetric lenses comprise three functions, \Put{}, \Get{}, and
\Create{}. These lenses only allow information to be lost on one side. We
enhance this style of lens to symmetric lenses with \emph{simple
  symmetric lenses}. Like the classical formulation of asymmetric lenses, simple
symmetric lenses have no complement. Simple symmetric lenses comprise 4
functions, \CreateR, \CreateL, \PutR, and \PutL. These functions satisfy the
following round-tripping laws:
\begin{equation}
  \tag{\CreatePutRL}
  \PutLOf{(\CreateROf{x})}{x} = x
\end{equation}
\begin{equation}
  \tag{\CreatePutLR}
  \PutROf{(\CreateLOf{y})}{y} = y
\end{equation}
\begin{equation}
  \tag{\PutRL}
  \PutLOf{(\PutROf{x}{y})}{x} = x
\end{equation}
\begin{equation}
  \tag{\PutLR}
  \PutROf{(\PutLOf{y}{x})}{y} = y
\end{equation}

% begin simple symmetric string lenses
\section{Simple Symmetric String Lenses}
\label{sec:ssl-string}
While we have a theory for simple symmetric lenses, to integrate with Boomerang,
we need combinators to express these lenses.

\subsection{Identity}
The identity lens operates on a single regular expression.  It fully
synchronizes the data within that regular expression: if data gets changed in
the left, that change gets reflected in the right.

\subsection{Disconnect}
The disconnect lens performs the opposite function as the identity lens.  It
leave the two data formats provided separate.  If data gets changed on the left,
the right is left unaffected.  When the data is being newly added, default
behavior comes from one side or the other.

\subsection{Concat}
The concat lens combines two existing lenses, working on their concatenated
regular expressions.  It performs the left lens on the left portion of the
string, and the right lens on the right portion.  It requires unambiguity
constraints to break up the left and right portions.

\subsection{Swap}
The swap lens operates like the concat lens, but when going from one side to the
other, it swaps the order of the lenses.

\subsection{Compose}
The swap lens operates like the concat lens, but when going from one side to the
other, it swaps the order of the lenses.

\subsection{Iterate}
The iterate lens breaks the provided strings into chunks, and performs the
provided lens on those chunks, then concatenates them together.

\subsection{Or}
The or lens performs one lens or another, depending on the inputs to the lens.

\subsection{MergeL}
The mergel lens is used when the same piece of data on the left is synchronized
to data in potentially many different forms on the right. The first provided
lens is the one defaulted to on creates.

\subsection{MergeR}
The merger lens is symmetric to the mergel lens.

\subsection{Compose}
The compose lens applies one lens to go to an intermediary format, then applies
the other to go to the final format.
% end simple symmetric string lenses

% begin DNF regular expressions and lenses
\section{Stochastic DNF Regular Expressions}
\label{sec:dnf-regex-lens}
We extend stochastic regular expressions to stochastic DNF regular expressions.
\begin{center}
  \begin{tabular}{l@{\ }c@{\ }l@{\ }>{\itshape\/}r}
    % DNF_REGEX
    \Atom{},\AtomAlt{} & \GEq{} & \PRegexStar{\DNFRegex{}}{\Probability}
% & \StarAtomType{}
\\
    \Sequence{},\SequenceAlt{} & \GEq{} &
                                                       $\SequenceOf{\String_0\SeqSep\Atom_1\SeqSep\ldots\SeqSep\Atom_n\SeqSep\String_n}$ 
%& \MultiConcatSequenceType{} 
\\
    \DNFRegex{},\DNFRegexAlt{} & \GEq{} & $\DNFOf{(\Sequence_1,\Probability_1)\DNFSep\ldots\DNFSep(\Sequence_n,\Probability_n)}$ %& \MultiOrDNFRegexType{} 
  \end{tabular}
\end{center}

As before, DNF regular expressions are essentially regular expressions with all
concatenations fully distributed over all disjunctions.  As these DNF regular
expressions are \emph{stochastic}, they are annotated with probabilities to
express a probability distribution, in addition to a language.  This probability
distribution is defined below:

\begin{center}
  \begin{tabular}{rcl}
    $\ProbabilityOf{\PRegexStar{\DNFRegex}{\Probability}}{\String}$
    & =
    & $\Sigma_{\String = \String_1 \ldots \String_n}\Probability^n*(1-\Probability)*\Pi_{i=1}^n\ProbabilityOf{\DNFRegex}{\String_i}$\\
    
    $\ProbabilityOf{\SequenceOf{\String_0 \SeqSep \Atom_1 \SeqSep \ldots \SeqSep \Atom_n \SeqSep \String_n}}{\String'}$
    & =
    & $\Sigma_{\String' = \String_0\String_1'\ldots\String_n'\String_n}\Pi_{i = 1}^n\ProbabilityOf{\Atom_i}{\String_i'}$ \\
    
    $\ProbabilityOf{\DNFOf{(\Sequence_1,\Probability_1) \DNFSep \ldots \DNFSep (\Sequence_n,\Probability_n)}}{\String}$
    & =
    & $\Sigma_{i=1}^n\Probability_i * \ProbabilityOf{\Sequence_i}{\String}$\\
  \end{tabular}
\end{center}

\begin{figure}
  \raggedright
  $\ConcatSequence{} \OfType{} \ArrowTypeOf{\SequenceType{}}{\ArrowTypeOf{\SequenceType{}}{\SequenceType{}}}$\\
  $\ConcatSequenceOf{[\String_0\SeqSep\Atom_1\SeqSep\ldots\SeqSep\Atom_n\SeqSep\String_n]}{[\StringAlt_0\SeqSep\AtomAlt_1\SeqSep\ldots\SeqSep\AtomAlt_m\SeqSep\StringAlt_m]}=
  [\String_0\SeqSep\Atom_1\SeqSep\ldots\SeqSep\Atom_n\SeqSep\String_n\Concat\StringAlt_0\SeqSep\AtomAlt_1\SeqSep\ldots\SeqSep\AtomAlt_m\SeqSep\StringAlt_m]$\\

  \medskip
  
  $\ConcatDNF{} \OfType{} \ArrowTypeOf{\DNFRegexType{}}{\ArrowTypeOf{\DNFRegexType{}}{\DNFRegexType{}}}$\\
  $\ConcatDNFOf{\DNFOf{(\Sequence_1,\Probability_1)\DNFSep\ldots\DNFSep(\Sequence_n,\Probability_n)}}{\DNFOf{(\SequenceAlt_1,\ProbabilityAlt_1)\DNFSep\ldots\DNFSep(\SequenceAlt_m,\ProbabilityAlt_m)}}=$\\
      $\DNFLeft (\ConcatSequenceOf{\Sequence_1}{\SequenceAlt_1},\Probability_1*\ProbabilityAlt_1)\DNFSep \ldots
      \DNFSep
      (\ConcatSequenceOf{\Sequence_1}{\SequenceAlt_m},\Probability_1*\ProbabilityAlt_m)\DNFSep
      \ldots$\\
      $\DNFSep
      (\ConcatSequenceOf{\Sequence_n}{\SequenceAlt_1},\Probability_n*\ProbabilityAlt_1)\DNFSep
      \ldots \DNFSep
      (\ConcatSequenceOf{\Sequence_n}{\SequenceAlt_m},\Probability_n * \ProbabilityAlt_m) \DNFRight$
  
  \medskip
  
  $\OrDNF{}_{\Probability} \OfType{}
  \ArrowTypeOf{\DNFRegexType{}}{\ArrowTypeOf{\DNFRegexType{}}{\DNFRegexType{}}
  }$ \\
  $\OrDNFOf{\DNFOf{(\Sequence_1,\Probability_1)\DNFSep\ldots\DNFSep(\Sequence_n,\Probability_n)}}{\DNFOf{(\SequenceAlt_1,\ProbabilityAlt_1)\DNFSep\ldots\DNFSep(\SequenceAlt_m,\ProbabilityAlt_m)}}{\Probability} =$\\
  $\DNFOf{(\Sequence_1,\Probability_1*\Probability)\DNFSep\ldots\DNFSep(\Sequence_n,\Probability_n*\Probability)\DNFSep(\SequenceAlt_1,\ProbabilityAlt_1*(1-\Probability))\DNFSep\ldots\DNFSep(\SequenceAlt_m,\ProbabilityAlt_m*(1-\Probability))}$
  
  \medskip
  
  \AtomToDNF{} \OfType
  \ArrowTypeOf{\AtomType{}}{\DNFRegexType{}}\\
  $\AtomToDNFOf{\Atom} = \DNFOf{(\SequenceOf{\EmptyString \SeqSep \Atom \SeqSep
      \EmptyString},1)}$
  \caption{DNF Regular Expression Functions}
  \label{fig:dnf-regex-functions}
\end{figure}

We have a means of turning stochastic regular expressions into stochastic DNF
regular expressions.
The conversion algorithm itself, written $\ToDNFRegexOf{\Regex}$, is defined below.
\[
  \begin{array}{rcl}
    \ToDNFRegexOf{\String} & = & \DNFOf{(\SequenceOf{\String},1)}\\
    \ToDNFRegexOf{\emptyset} & = & \DNFOf{}\\
    \ToDNFRegexOf{(\PRegexStar{\Regex}{\Probability})} & = & \AtomToDNFOf{\PRegexStar{(\ToDNFRegexOf{\Regex})}{\Probability}}\\
    \ToDNFRegexOf{(\RegexConcat{\Regex_1}{\Regex_2})} & = & \ToDNFRegexOf{\Regex_1} \ConcatDNF \ToDNFRegexOf{\Regex_2}\\
    \ToDNFRegexOf{(\PRegexOr{\Regex_1}{\Regex_2}{\Probability})} & = & \ToDNFRegexOf{\Regex_1} \OrDNF_{\Probability} \ToDNFRegexOf{\Regex_2}\\
  \end{array}
\]
We have also proven an algorithm, demonstrating this conversion respects
probability distributions.

\begin{theorem}
  $\ProbabilityOf{\Regex}{\String} = \ProbabilityOf{\ToDNFRegex \Regex}{\String}$
\end{theorem}

Furthermore, in the situation where a DNF regular expression is unambiguous, we
have defined an efficient, syntactic means to find the entropy of the DNF
regular expression.

\begin{center}
  \begin{tabular}{rcl}
    $\EntropyOf{\PRegexStar{\DNFRegex}{\Probability}}$
    & =
    & $\frac{\Probability}{1-\Probability}(\EntropyOf{\DNFRegex} - \Log_2\Probability)
      - \Log_2(1-\Probability)
      $\\
    
    $\EntropyOf{\SequenceOf{\String_0 \SeqSep \Atom_1 \SeqSep \ldots \SeqSep \Atom_n \SeqSep \String_n}}{\String'}$
    & =
    & $\Sigma_{i = 1}^n\EntropyOf{\Atom_i}$ \\
    
    $\EntropyOf{\DNFOf{(\Sequence_1,\Probability_1) \DNFSep \ldots \DNFSep (\Sequence_n,\Probability_n)}}$
    & =
    & $\Sigma_{i=1}^n\Probability_i(\EntropyOf{\Sequence_i}+\Log_2\Probability_i)$\\
  \end{tabular}
\end{center}

\begin{theorem}
  $\EntropyOf{\DNFRegex}$ is the entropy of $P_{\DNFRegex}$.
\end{theorem}

This means we also have an algorithm for finding the entropy of an unambiguous
stochastic regular expression, as we can merely convert the regular expression
into DNF form, and find the entropy of it.
% end DNF regular expressions and lenses

% begin symmetric dnf lenses
\section{Symmetric DNF Lenses}
\label{sec:symmetric-dnf-lenses}
\subsection{Syntax}
Symmetric DNF Lenses are what we synthesize, and we then turn them into
Symmetric Lenses. The nonterminals $i$, $j$, $p$, $q$, $r$, $c$, and $d$ all
represent natural numbers. The nonterminals $\String$ and $\StringAlt$ represent
strings.

\begin{center}
  \begin{tabular}{@{}r@{\ }c@{}l@{}}
    % REGEX
    \SAtomLens{} & \GEq{} & $\IterateLensOf{\SDNFLens}$ \\
    \SSQLens{} & \GEq{} & $(\SSQLensOf{(i_1,j_1,\SAtomLens_1)\SeqLSep
                          \ldots\SeqLSep
                          (i_p,j_p,\SAtomLens_p)}
                          ,\ListOf{(\String_1,\Atom_1);\ldots;(\String_q,\Atom_q)}
                          ,\ListOf{\StringAlt_1;\ldots;\StringAlt_r})$ \\
    \SDNFLens{} & \GEq{} & $(\SDNFLensOf{(i_1,j_1,\SSQLens_1)\DNFLSep
                           \ldots\DNFLSep
                           (i_p,j_p,\SSQLens_p)}
                           ,\ListOf{c_1;\ldots;c_q}
                           ,\ListOf{d_1;\ldots;d_r})$ \\
  \end{tabular}
\end{center}

Lets go through these from bottom to top.

A DNF Lens \SDNFLens{} consists of three components. First is the mapping
component. The mapping component is a list of triples $(i,j,\SSQLens)$. In this,
$i$ and $j$ refer to sequence $i$ and sequence $j$ in the left and right DNF
regular expressions, respectively. The third component, \SSQLens{}, is a
sequence lens that maps between the two sequences specified by $i$ and $j$. The
second component is a list of integers $c$. The integer, $c_i$ at position $i$
states that when performing a $\CreateR$ on a string matching sequence
$\Sequence_i$, it will use the sequence lens that maps it to sequence
$\SequenceAlt_{c_i}$ on the right. The third component is a list of integers
$d$, and follows the same pattern as the second component, but maps from right
to left.

A Sequence lens \SSQLens{} consists of three components. First is the mapping
component. The mapping component is a list of triples $(i,j,\SAtomLens)$. In
this, $i$ and $j$ refer to atom $i$ and atom $j$ on the left and right
sequences, respectively. The third component, \SAtomLens{}, is an atom lens that
maps between the two atoms specified by $i$ and $j$. The second component is a
list of strings, $\String$. The string, $s_i$ at position $i$ states that when
performing a $\CreateL$ on a string matching atom $\Atom_i$, it will do one of
two things. If $\Atom_i$ is mapped to in the mapping component, then performing
the atom's $\CreateL$ will actually $\PutL$ into that string. If $\Atom_i$ is
not mapped to, then $\String_i$ will be created as a representative of
$\Atom_i$.

An atom lens \AtomLens{} is merely the iteration of a symmetric DNF Lens.


\subsection{Typing and Semantics}
Because these lenses only encode functions on well-typed programs, we introduce
the semantics alongside the typing rules.  The semantics are over typing
derivations, instead of over individual lenses.

\paragraph*{DNF Lenses}
The typing judgment is a 3-ary relation over a single DNF lens, and two DNF
regular expressions. If $\SDNFLens \OfType \DNFRegex \Leftrightarrow
\DNFRegexAlt$, then the $\SDNFLens.\CreateR$, $\SDNFLens.\CreateL$,
$\SDNFLens.\PutR$, and $\SDNFLens.\PutL$ functions form a symmetric lens.

The typing judgement has 3 components. The first is the sublens components,
confirming that the sequence lenses the DNF lens is comprised of are all
well-typed. The second guarantees that if each sequence on the left has a
sequence lens that can be used for \CreateR{}s and \PutR{}s. The last guarantees
the same for sequences on the right, with \CreateL{} and \PutL{}.

\[
  \inferrule*
  {
    \SSQLens_1 \OfType \Sequence_{i_1} \Leftrightarrow \SequenceAlt_{j_1}\\
    \ldots\\
    \SSQLens_p \OfType \Sequence_{i_p} \Leftrightarrow \SequenceAlt_{j_p}\\\\
    i_{c_1} = 1\\
    \ldots\\
    i_{c_q} = q\\\\
    j_{d_1} = 1\\
    \ldots\\
    j_{d_r} = r
  }
  {
    (\SDNFLensOf{(i_1,j_1,\SSQLens_1)\DNFLSep
      \ldots\DNFLSep
      (i_p,j_p,\SSQLens_p)}
    ,\ListOf{c_1;\ldots;c_q}
    ,\ListOf{d_1;\ldots;d_r})
    \OfType\\\\
    \DNFOf{(\Sequence_1,\Probability_1) \DNFSep \ldots \DNFSep (\Sequence_q,\Probability_q)}
    \Leftrightarrow
    \DNFOf{(\SequenceAlt_1,\ProbabilityAlt_1) \DNFSep \ldots \DNFSep (\SequenceAlt_r,\ProbabilityAlt_q)}
  }
\]

The \CreateR{} function looks for the sequence the provided string matches. If
the string matches sequence $\Sequence_x$, then the lens will look in the create
list at position $x$ to find which sequence lens to use. Then, the sequence lens
transforms the given string using that sequence lens.

The \PutR{} function finds what pairs sequences the input source and view
strings match.  If there that pair of sequences have a sequence lens between
them, then the DNF lens merely performs that sequence lens on the provided
strings.  If there isn't a pair of sequence lenses between them, then \CreateR{}
is performed on the source, with the view forgotten.

The \CreateL{} and \PutL{} functions are defined symmetrically.

\begin{tabular}{@{}r@{\ }c@{\ }l@{}}
  $\CreateR{} \App s$ & = & $\SSQLens_{c_x}.\CreateR{} \App s$ if $s \in \Sequence_x$\\
  $\CreateL{} \App v$ & = & $\SSQLens_{d_y}.\CreateL{} \App v$ if $v \in \SequenceAlt_y$\\
  $\PutR{} \App s \App v$ & = &
                               $\begin{cases*}
                                 \SSQLens_x.\PutR{} \App s \App v & if $s \in \Sequence_{i_x}$ and $v \in \SequenceAlt_{j_x}$\\
                                 \CreateR{} \App s & if $\nexists x.$ $s \in \Sequence_{i_x}$ and $v \in \SequenceAlt_{j_x}$
                               \end{cases*}$\\
  $\PutL{} \App v \App s$ & = &
                               $\begin{cases*}
                                 \SSQLens_y.\PutL{} \App v \App s & if $v \in \SequenceAlt_{j_y}$ and $s \in \Sequence_{i_y}$\\
                                 \CreateL{} \App v & if $\nexists y.$ $v \in \SequenceAlt_{j_y}$ and $s \in \Sequence_{i_y}$
                               \end{cases*}$
\end{tabular}

\paragraph*{Sequence Lenses}
The typing judgment is a 3-ary relation over a single Sequence lens, and two
sequences. If $\SSQLens \OfType \Sequence \Leftrightarrow \SequenceAlt$, then
the $\SSQLens.\CreateR$, $\SSQLens.\CreateL$, $\SSQLens.\PutR$, and
$\SSQLens.\PutL$ functions form a symmetric lens.

The typing judgement has 4 components. The first is the sublens components,
confirming that the atom lenses the sequence lens is comprised of all are
well-typed. The second guarantees that if each string that will be used for
\CreateR{}s are members of the correct atoms.  The third guarantees
the same for strings and atoms on the right, with \CreateL.  The last guarantees
that each atom is mapped by at most one atom lens.

\[
  \inferrule*
  {
    \SAtomLens_1 \OfType \Atom_{i_1} \Leftrightarrow \AtomAlt_{j_1}\\
    \ldots\\
    \SAtomLens_p \OfType \Atom_{i_p} \Leftrightarrow \AtomAlt_{j_p}\\\\
    \String_1 \in \Atom_1\\
    \ldots\\
    \String_q \in \Atom_q\\\\
    \StringAlt_1 \in \AtomAlt_1\\
    \ldots\\
    \StringAlt_r \in \AtomAlt_r\\\\
    i_x = i_y \BooleanImplies x = y\\
    j_x = j_y \BooleanImplies x = y
  }
  {
    (\SSQLensOf{(i_1,j_1,\SAtomLens_1)\SeqLSep
      \ldots\SeqLSep
      (i_p,j_p,\SAtomLens_p)}
    ,\ListOf{\String_1;\ldots;\String_q}
    ,\ListOf{\StringAlt_1;\ldots;\StringAlt_r})\\
    \OfType
    \SequenceOf{\String_0' \SeqSep \Atom_1 \SeqSep \ldots \SeqSep \Atom_q
      \SeqSep \String_q'}
    \Leftrightarrow
    \SequenceOf{\StringAlt_0' \SeqSep \AtomAlt_1 \SeqSep \ldots \SeqSep \AtomAlt_r \SeqSep \StringAlt_r'}
  }
\]

For each component of the string matching an atom, the \CreateR function looks
for the atom lens that maps on the atom. If there is such an atom lens,
\SAtomLens, then that the sequence lens puts the provided string into the
default string for the target atom. If there is no such atom lens, then the
sequence lens merely uses the default string.

For each component of the string matching an atom, the \PutR function looks
for the atom lens that maps on the atom. If there is such an atom lens,
\SAtomLens, then that the atom lens puts the provided string of the source atom into the
string of the target atom. If there is no such atom lens, then the
sequence lens merely recovers the target's string.

The \CreateL{} and \PutL{} functions are defined symmetrically.

\begin{tabular}{@{}r@{\ }c@{\ }l@{}}
  $\CreateR{} \App \String_0'\Concat \String_1'' \Concat \ldots \Concat \String_q'' \Concat \String_q'$
  & = 
  & $\StringAlt_0' \Concat \StringAlt_1'' \Concat \ldots \Concat
    \StringAlt_r'' \Concat \StringAlt_r'$\\
  & & where $\StringAlt_y'' =
    \begin{cases*}
      \SAtomLens_k.\PutRight \App \String_{i_k}'' \App \StringAlt_y & if $j_k = y$\\
      \StringAlt_y & if $\nexists k. j_k = y$\\
    \end{cases*}$\\
  $\CreateL{} \App \StringAlt_0'\Concat \StringAlt_1'' \Concat \ldots \Concat \StringAlt_q''
  \Concat \StringAlt_q'$
  & = 
  & $\String_0' \Concat \String_1'' \Concat \ldots \Concat
    \String_r'' \Concat \String_r'$\\
  & & where $\String_x'' =
    \begin{cases*}
      \SAtomLens_k.\PutRight \App \StringAlt_{j_k}'' \App \String_x & if $i_k = x$\\
      \String_x & if $\nexists k. i_k = x$\\
    \end{cases*}$\\
  $\PutR{} \App \String_0'\Concat \String_1'' \Concat \ldots \Concat \String_q'' \Concat \String_q' \App \StringAlt_0'\Concat \StringAlt_1'' \Concat \ldots \Concat \StringAlt_q'' \Concat \StringAlt_q'$
  & =
  & $\StringAlt_0'\Concat \StringAlt_1''' \Concat \ldots \Concat \StringAlt_q''' \Concat \StringAlt_q'$\\
  & & where
      $t_y''' =
      \begin{cases*}
        \SAtomLens_k.\PutRight \App \String_{i_k}'' \App \StringAlt_{y}'' & if $j_k = y$\\
        \StringAlt_y'' & if $\nexists k. j_k = y$\\
      \end{cases*}$\\
  $\PutL{} \App \StringAlt_0'\Concat \StringAlt_1'' \Concat \ldots \Concat \StringAlt_q'' \Concat \StringAlt_q' \App \String_0'\Concat \String_1'' \Concat \ldots \Concat \String_q'' \Concat \String_q'$
  & =
  & $\String_0'\Concat \String_1''' \Concat \ldots \Concat \String_r''' \Concat \String_r'$\\
  & & where
      $s_x''' =
      \begin{cases*}
        \SAtomLens_k.\PutLeft \App \StringAlt_{j_k}'' \App \String_{x}'' & if $i_k = x$\\
        \String_x'' & if $\nexists k. i_k = x$\\
      \end{cases*}$\\
\end{tabular}

\paragraph*{Atom Lenses}
The typing judgment is a 3-ary relation over a single atom lens, and two
atoms. If $\SAtomLens \OfType \Atom \Leftrightarrow \AtomAlt$, then
the $\SAtomLens.\CreateR$, $\SAtomLens.\CreateL$, $\SAtomLens.\PutR$, and
$\SAtomLens.\PutL$ functions form a symmetric lens.

The typing judgement just confirms that the DNF lens that comprises the
sequence lens is also well typed.

\[
  \inferrule*
  {
    \SDNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt
  }
  {
    \IterateLensOf{\SDNFLens}
    \OfType \PRegexStar{\DNFRegex}{\Probability}
    \Leftrightarrow \PRegexStar{\DNFRegexAlt}{\ProbabilityAlt}
  }
\]

For each component of the string matching an atom, the \CreateR function looks
for the atom lens that maps on the atom. If there is such an atom lens,
\SAtomLens, then that the sequence lens puts the provided string into the
default string for the target atom. If there is no such atom lens, then the
sequence lens merely uses the default string.

For each component of the string matching an atom, the \PutR function looks
for the atom lens that maps on the atom. If there is such an atom lens,
\SAtomLens, then that the atom lens puts the provided string of the source atom into the
string of the target atom. If there is no such atom lens, then the
sequence lens merely recovers the target's string.

The \CreateL{} and \PutL{} functions are defined symmetrically.

\begin{tabular}{@{}r@{\ }c@{\ }l@{}}
  $\CreateR{} \App \String_0 \Concat \ldots \Concat \String_n$
  & = 
  & $\StringAlt_1 \Concat \ldots \Concat \StringAlt_n$
  where $\StringAlt_i = \SDNFLens.\CreateR \App \String_i$\\
  $\CreateL{} \App \StringAlt_0 \Concat \ldots \Concat \StringAlt_m$
  & = 
  & $\String_1 \Concat \ldots \Concat \String_m$
  where $\String_i = \SDNFLens.\CreateL \App \StringAlt_i$\\
  $\PutR{} \App \String_0 \Concat \ldots \Concat \String_n \App
  \StringAlt_1 \Concat \ldots \Concat \StringAlt_m$
  & = 
  & $\StringAlt_1' \Concat \ldots \Concat \StringAlt_n'$
    where $\StringAlt_i' =
    \begin{cases*}
      \SDNFLens.\PutR \App \String_i \App \StringAlt_i & if $i \leq m$\\
      \SDNFLens.\CreateR \App \String_i & otherwise
    \end{cases*}$\\
  $\PutL{} \App \StringAlt_1 \Concat \ldots \Concat \StringAlt_m \App
  \String_0 \Concat \ldots \Concat \String_n$
  & = 
  & $\String_1' \Concat \ldots \Concat \String_m'$
    where $\String_i' =
    \begin{cases*}
      \SDNFLens.\PutL \App \StringAlt_i \App \String_i & if $i \leq n$\\
      \SDNFLens.\CreateL \App \StringAlt_i & otherwise
    \end{cases*}$\\
\end{tabular}

Now that we've developed symmetric DNF lenses, it's important to develop a means
to guage how bijective the lens is.

Instead of searching for \emph{any} term that satisfies the specification, we
search for the \emph{best} term that satisfies the specification. This begs the
question, by what metric do we use to determine which term is best. Intuitively,
we aim to synthesize the lens which is \emph{closest} to being a bijection.
Somewhat more formally, we aim to synthesize a lens which minimizes the expected
number of bits which must be used to recover the source from the target, and the
target from the source. The expected number of bits that are needed to encode
informatation from a data source is a well known concept in information theory,
and is known as the \emph{entropy} of the data source.

The entropy of $\DNFRegexAlt$ given $\DNFRegex$ and $\SDNFLens$,
$\EntropyOf{\DNFRegexAlt \Given \DNFRegex,\SDNFLens}$ is defined symmetrically.
With these $\operatorname*{argmin}_\theta$ terms defined, the ``best'' DNF lens
between $\DNFRegex$ and $\DNFRegexAlt$ is $\ArgminOver{\SetOf{\SDNFLens \SuchThat
    \SDNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt}}
\EntropyOf{\DNFRegex \Given \DNFRegexAlt,\SDNFLens} + \EntropyOf{\DNFRegexAlt
  \Given \DNFRegex,\SDNFLens}$.

\begin{centering}
  \[
    \begin{array}{rl}
      & \EntropyOf{\DNFOf{\Sequence_1 \DNFSep \ldots \DNFSep \Sequence_n}\\
      & \hspace*{1em}\Given
        \DNFOf{\SequenceAlt_1 \DNFSep \ldots \DNFSep \SequenceAlt_m}\\
      & \hspace*{1.21em},~(\SDNFLensOf{(i_1,j_1,\SSQLens_1)\DNFLSep
        \ldots\DNFLSep
        (i_p,j_p,\SSQLens_p)}
        ,\ListOf{c_1;\ldots;c_q}
        ,\ListOf{d_1;\ldots;d_r})}\\
      =\\
      & \frac{\Sigma_{j=1}^m(\frac{\Sigma_{k\SuchThat j_k = j}
        \EntropyOf{\Sequence_{i_k}\Given\SequenceAlt_j,\SequenceLens_k}}{\SizeOf{\SetOf{k\SuchThat
        j_k = j}}} + log_2\SizeOf{\SetOf{k\SuchThat j_k = j}})}{m}\\\\
      \\
      
      & \EntropyOf{
        \SequenceOf{\String_0,\Atom_1,\ldots,\Atom_n,\String_n}\\
      & \hspace*{1em}\Given
        \SequenceOf{\StringAlt_0,\AtomAlt_1,\ldots,\AtomAlt_m,\StringAlt_m}\\
      & \hspace*{1.21em},~
        (\SSQLensOf{(i_1,j_1,\SAtomLens_1)\SeqLSep
        \ldots\SeqLSep
        (i_p,j_p,\SAtomLens_p)}
        ,\ListOf{(k_1,\String_1);\ldots;(k_q,\String_q)}
        ,\ListOf{(l_1,\StringAlt_1);\ldots;(l_r,\StringAlt_r)})}\\
      =\\
      & \Sigma_{x=1}^p\EntropyOf{\Atom_{i_x} \Given \AtomAlt_{i_x},\AtomLens_x} +
        \Sigma_{x=1}^q\EntropyOf{\Atom_{k_x}}\\\\
      \\
      
      
      & \EntropyOf{\StarOf{\DNFRegex} \Given \StarOf{\DNFRegexAlt},\StarOf{\SDNFLens}}\\
      =\\
      & 4*\EntropyOf{\DNFRegex\Given\DNFRegexAlt,\SDNFLens}
    \end{array}
  \]
\end{centering}

% end symmetric dnf lenses


% begin synthesis
\section{Synthesis}
\label{sec:synthesis}
While examples can be used to tighten the
specification, a large number of well-constructed examples are required to
sufficiently constrain the search space.

Unfortunately, trying to find the best symmetric lens is a daunting task!
Unless we find a bijective lens (in which case the sum is zero), we can never be
sure if we will find a better lens than the one we found.
% end synthesis

% begin implementation
\section{Implementation}
\label{sec:implementation}
% end implementation

% begin evaluation
\section{Evaluation}
\label{sec:evaluation}
% end evaluation

% begin related-work
\section{Related Work}
\label{sec:related}
A \emph{symmetric lens} between $X$ and $Y$ is an element of the type
$\exists C.\{ \mathit{missing} :
C,\,get : X \times C \to Y \times C,\,put : Y \times C \to X \times C\}$
satisfying the following laws:
\begin{equation}
  \tag{\PutRL}
  \frac{\PutR(x,c) = (y,c')}{\PutL(y,c') = (x,c')}
\end{equation}
\begin{equation}
  \tag{\PutLR}
  \frac{\PutL(y,c) = (x,c')}{\PutR(x,c') = (y,c')}
\end{equation}

Given a lens $l \in X \leftrightarrow Y$, a \emph{put object} for $l$ is a
member of $X + Y$. Consider the function $apply$, which, given a lens and an
element of that lens's complement, is a function from sequences of put objects
to sequences of put objects. If $apply(\Lens,c,es) = es'$, then that means, starting
with complement $c$, after edit $es_i$, the lens $\Lens$ synchronizes the other
data to $es'_i$.
\[
  \inferrule
  {
  }
  {
    apply(\Lens,c,[]) = []
  }
\]
\[
  \inferrule
  {
    \Lens.putr(x,c) = (y,c')\\
    apply(\Lens,c',es) = es'
  }
  {
    apply(\Lens,c,(\InLOf{x})::es) = (\InROf{y})::es'
  }
\]
\[
  \inferrule
  {
    \Lens.putl(y,c) = (x,c')\\
    apply(\Lens,c',es) = es'
  }
  {
    apply(\Lens,c,(\InROf{y})::es) = (\InLOf{x})::es'
  }
\]

Two lenses, $\Lens_1$ and $\Lens_2$, are equivalent if
$apply(\Lens_1,\Lens_1.init,es) = apply(\Lens_2,\Lens_2.init,es)$ for all edit
sequences $es$.

Two simple symmetric lenses are equivalent if the four functions they comprise
are equivalent as functions. However, to formalize how these lenses work as
synchronization tools, we define an $apply$ function on them, much like we
define an $apply$ on symmetric lenses.

The function $apply$, given a symmetric lens and an optional pair of elements of
the source and target, is a function from sequences of put objects to sequences
of put objects.  If $apply(\Lens,\None,es,es')$, then that means, starting with
no prior data, after edit $es_i$, the lens \Lens synchronizes the other data to
$es_i'$.  If $apply(\Lens,\SomeOf{(x,y)},es,es')$, then that means, starting with
data $x$ and $y$ on the left and right, respectively, after edit $es_i$, the
lens \Lens synchronizes the other data to $es_i'$.

\[
  \inferrule
  {
  }
  {
    apply(\Lens,xyo,[]) = []
  }
\]
\[
  \inferrule
  {
    \Lens.\CreateROf{x} = y\\
    apply(\Lens,\SomeOf{(x,y)},es) = es'
  }
  {
    apply(l,\None,\InLOf{x}::es) = \InROf{y}::es'
  }
\]
\[
  \inferrule
  {
    \Lens.\CreateLOf{y} = x\\
    apply(\Lens,\SomeOf{(x,y)},es) = es'
  }
  {
    apply(l,\None,\InROf{y}::es) = \InLOf{x}::es'
  }
\]
\[
  \inferrule
  {
    \Lens.\PutROf{x'}{y}  = y'\\
    apply(\Lens,\SomeOf{(x',y')},es) = es'
  }
  {
    apply(l,\SomeOf{(x,y)},\InLOf{x'}::es) = \InROf{y'}::es'
  }
\]
\[
  \inferrule
  {
    \Lens.\PutLOf{y'}{x}  = x'\\
    apply(\Lens,\SomeOf{(x',y')},es) = es'
  }
  {
    apply(l,\SomeOf{(x,y)},\InROf{y'}::es) = \InLOf{x'}::es'
  }
\]

Furthermore, equivalence of the $apply$ function corresponds exactly with
equivalence of lenses.

\begin{theorem}
  $\Lens_1 \equiv \Lens_2$ if, and only if, for all sequences $es$,
  $apply(\Lens_1,\None,es) = apply(\Lens_2,\None,es)$.
\end{theorem}

We've reformulated symmetric lenses in a style similar to existing asymmetric
lens formulations. However, some symmetric lenses certainly are inexpressible in
the stateless symmetric lens formulation. We formalize which are expressible
with a restriction on symmetric lenses. We define \emph{forgetful symmetric
  lenses} to be symmetric lenses which satisfy the following additional laws:
\begin{equation}
  \tag{\ForgetfulRL}
  \begin{mathprooftree}
    \AxiomC{$\Lens.putr(x,c_1) = (\_,c_1')$}
    \def\extraVskip{.5pt}
    \noLine 
    \UnaryInfC{$\Lens.putr(x,c_2) = (\_,c_2')$}
    \AxiomC{$\Lens.putl(y,c_1') = (\_,c_1'')$}
    \def\extraVskip{.5pt}
    \noLine 
    \UnaryInfC{$\Lens.putl(y,c_2') = (\_,c_2'')$}
    \def\extraVskip{2pt}
    \singleLine
    \BinaryInfC{$c_1'' = c_2''$}
  \end{mathprooftree}
\end{equation}
\begin{equation}
  \tag{\ForgetfulLR}
  \begin{mathprooftree}
    \AxiomC{$\Lens.putl(y,c_1) = (\_,c_1')$}
    \def\extraVskip{.5pt}
    \noLine 
    \UnaryInfC{$\Lens.putl(y,c_2) = (\_,c_2')$}
    \AxiomC{$putr(x,c_1') = (\_,c_1'')$}
    \def\extraVskip{.5pt}
    \noLine 
    \UnaryInfC{$\Lens.putr(x,c_2') = (\_,c_2'')$}
    \def\extraVskip{2pt}
    \singleLine
    \BinaryInfC{$c_1'' = c_2''$}
  \end{mathprooftree}
\end{equation}

Intuitively, this says that the complements are uniquely determined by the most
recently input $x$ and $y$. This corresponds closely with simple symmetric
lenses, where all state is maintained by the current state of the $x$ and $y$
data. Forgetful symmetric lenses express exactly the same $apply$ function as
stateless symmetric lenses.

\begin{theorem}
  Let $\Lens$ be a symmetric lens. The lens $\Lens$ is equivalent to a forgetful
  lens if, and only if, there exists a simple symmetric lens $\Lens'$ where
  $apply(\Lens,\Lens.init,es) = apply(\Lens',\None,es)$, for all put sequences $es$.
\end{theorem}

Despite being less expressive than symmetric lenses, simple symmetric lenses are
strictly more expressive than classical asymmetric lenses.

\begin{theorem}
  Let $\Lens$ be an asymmetric lens. $\Lens$ is also a simple symmetric lens,
  where
  \begin{enumerate}
  \item $\Lens.creater \App x = \Lens.get \App x$
  \item $\Lens.createl \App y = \Lens.create \App y$
  \item $\Lens.putr \App x \App y = \Lens.get \App x$
  \item $\Lens.putl \App y \App x = \Lens.put \App y \App x$
  \end{enumerate}
\end{theorem}

% end related-work

% begin conclusion
\section{Conclusion}
\label{sec:conc}
% end conclusion

% begin acknowledgements
\begin{acks}
\end{acks}
% end acknowledgements

\ifanon\else
\fi

% We recommend abbrvnat bibliography style.

% The bibliography should be embedded for final submission.

\bibliography{local,bcp}

\appendix

\ifappendices

\onecolumn

\section{Forgetful Symmetric Lenses}

\begin{property}[Starting Forgetfulness RL]
  \label{prop:forget-rl}
  Let $\Lens$ be a forgetful symmetric lens.  If $(x_1',c_1') = \Lens.\PutL \App
  (y,\Snd \App (\Lens.\PutR \App (x,c_1)))$, and
  $(x_2',c_2') = \Lens.\PutL \App
  (y,\Snd \App (\Lens.\PutR \App (x,c_2)))$, then $x_1' = x_2'$.
\end{property}
\begin{proof}
  By \ForgetfulRL, $c_1' = c_2'$. We know $(y,c_1') = \Lens.\PutR \App
  (x_1',c_1')$ and $(y,c_1') = \Lens.\PutR \App (x_2',c_1')$ by \PutLR. By
  \PutRL, we know $(x_1' = \Lens.\PutL \App (y,c_1'))$ and $(x_2' = \Lens.\PutL
  \App (y,c_1')))$. Therefore, by transitivity of equality, $x_1' = x_2'$.
\end{proof}

\begin{property}[Starting Forgetfulness LR]
  \label{prop:forget-lr}
  Let $\Lens$ be a forgetful symmetric lens.  If $(y_1',c_1') = \Lens.\PutR \App
  (x,\Snd \App (\Lens.\PutL \App (y,c_1)))$, and
  $(x_2',c_2') = \Lens.\PutL \App
  (x,\Snd \App (\Lens.\PutR \App (y,c_2)))$,
  then $x_1' = x_2'$.
\end{property}
\begin{proof}
  Symmetric to Starting Forgetfulness RL.
\end{proof}

\begin{definition}[S]
  Let $\Lens$ be a forgetful lens.

  Consider the following four functions $S(\Lens)$, that we wish to satisfy the
  simple symmetric lens laws.

  \begin{centering}
    \begin{tabular}{@{}r@{\ }c@{\ }l@{}}
      $\CreateR{} \App s$
      & =
      & $\Fst \App (\Lens.\PutR{} \App (s,\Lens.init))$\\
      
      $\CreateL{} \App v$
      & =
      & $\Fst \App (\Lens.\PutL{} \App (v,\Lens.init))$\\
      
      $\PutR{} \App s \App v$
      & =
      & $\LetIn{(\_,c)}{\Lens.\PutL \App (v,\Lens.init)}$\\
      &
      & $\LetIn{(s',\_)}{\Lens.\PutR \App (s,c)}$\\
      &
      & $s'$\\
      
      $\PutL{} \App v \App s$
      & =
      & $\LetIn{(\_,c)}{\Lens.\PutR \App (s,\Lens.init)}$\\
      &
      & $\LetIn{(y',\_)}{\Lens.\PutL \App (v,c)}$\\
      &
      & $y'$\\
    \end{tabular}
  \end{centering}
\end{definition}

\begin{mylemma}
  If $\Lens$ is a forgetful symmetric lens, then $S(\Lens)$ is a simple symmetric
  lens.
\end{mylemma}
\begin{proof}
  
  \CreatePutRL{}:
  
  \begin{centering}
    \begin{tabular}{@{}r@{\ }c@{\ }l@{\ }l}
      $S(\Lens).\PutLOf{(S(\Lens).\CreateROf{x})}{x}$
      & =
      & $S(\Lens).\PutLOf{(\Fst \App (\Lens.\PutR{(x,\Lens.init)}))}{x}$
      & By unfolding definitions
      \\
      
      & =
      & $\LetIn{(\_,c)}{\Lens.\PutR \App (x,\Lens.init)}$\\
      &
      & $\LetIn{(y',\_)}{\Lens.\PutL \App (\Fst \App (\Lens.\PutR{(x,\Lens.init)}),c)}$\\
      &
      & $y'$
      & By unfolding definitions\\
      
      & =
      & $\LetIn{(y',\_)}{\Lens.\PutL \App (\Lens.\PutR \App (x,\Lens.init))}$\\
      &
      & $y'$
      & By tuple harmony \\
      
      & =
      & $x$
      & By \PutRL \\
    \end{tabular}
  \end{centering}

  \CreatePutLR{}:  Symmetric to \CreatePutRL{}

  \PutRL{}:

  \begin{centering}
    \begin{tabular}{@{}r@{\ }c@{\ }l@{\ }l}
      $S(\Lens).\PutLOf{(S(\Lens).\PutROf{x}{y})}{x}$
      & =
      & $\LetIn{(\_,c)}{\Lens.\PutL \App (y,\Lens.init)}$\\
      & & $\LetIn{(y',c')}{\Lens.\PutR \App (x,c)}$\\
      & & $S(\Lens).\PutLOf{y'}{x}$
      & By unfolding definitions
      \\
      
      & =
      & $\LetIn{(\_,c)}{\Lens.\PutL \App (y,\Lens.init)}$\\
      & & $\LetIn{(y',c')}{\Lens.\PutR \App (x,c)}$\\
      & & $\LetIn{(\_,c'')}{\Lens.\PutR \App (x,\Lens.init)}$\\
      & & $\LetIn{(x',c''')}{\Lens.\PutL \App (y',c'')}$\\
      & & $x'$
      & By unfolding definitions
    \end{tabular}
  \end{centering}

  At this point, we know from \PutRL that $(x,c') = \Lens.\PutL \App (y',c')$.
  By Property~\ref{prop:forget-rl}, this means that $x' = x$, as desired.

  \PutLR{}:  Symmetric to \PutRL{}
\end{proof}

\begin{definition}
  Fix a symmetric lens $\Lens$ beteween $X$ and $Y$. Consider the
  function, $\SingleApp_{\Lens} \OfType (X + Y) \times \Lens.C
  \rightarrow ((X + Y) \times \Lens.C)$, defined as:

  \begin{tabular}{@{}r@{\ }c@{\ }l@{\ }l}
    $\SingleApp_{\Lens}(\InLOf{x},c)$
    & =
    & $\LetIn{(y,c')}{\Lens.\PutRight \App (x,c)}$\\
    &
    & $(\InROf{y},c')$\\
    
    $\SingleApp_{\Lens}(\InROf{y},c)$
    & =
    & $\LetIn{(x,c')}{\Lens.\PutLeft \App (y,c)}$\\
    &
    & $(\InLOf{x},\SomeOf{(x,y)})$
  \end{tabular}
\end{definition}

\begin{definition}
  Fix a simple symmetric lens $\Lens$ beteween $X$ and $Y$. Consider the
  function, $\SingleApp_{\Lens} \OfType ((X + Y) \times \OptionOf{(X \times Y)})
  \rightarrow ((X + Y) \times \OptionOf{(X \times Y)})$, defined as:

  \begin{tabular}{@{}r@{\ }c@{\ }l@{\ }l}
    $\SingleApp_{\Lens}(\InLOf{x},\None)$
    & =
    & $\LetIn{y}{\Lens.\CreateROf{x}}$\\
    &
    & $(\InROf{y},\SomeOf{(x,y)})$\\
    
    $\SingleApp_{\Lens}(\InROf{y},\None)$
    & =
    & $\LetIn{x}{\Lens.\CreateLOf{y}}$\\
    &
    & $(\InLOf{x},\SomeOf{(x,y)})$\\
    
    $\SingleApp_{\Lens}(\InLOf{x'},\SomeOf{(x,y)})$
    & =
    & $\LetIn{y'}{\Lens.\PutROf{x'}{y}}$\\
    &
    & $(\InROf{y'},\SomeOf{(x',y')})$\\
    
    $\SingleApp_{\Lens}(\InROf{y'},\SomeOf{(x,y)})$
    & =
    & $\LetIn{x'}{\Lens.\PutLOf{y'}{x}}$\\
    &
    & $(\InROf{x'},\SomeOf{(x',y')})$\\
  \end{tabular}
\end{definition}

\begin{definition}
  Fix a symmetric lens \Lens over $X$ and $Y$. We define the relation $R_\Lens$
  over $\Lens.C$ and $\OptionOf{(X \times Y)}$ as the largest relation such
  that:
  \begin{enumerate}
  \item $R_\Lens(c,None) \BooleanImplies c = \Lens.init$
  \item $R_\Lens(c,Some (x,y)) \BooleanImplies
    \Lens.\PutRight \App (x,c) = (y,c) \BooleanAnd
    \Lens.\PutLeft  \App (y,c) = (x,c)$
  \end{enumerate}
\end{definition}

\begin{mylemma}
  \label{lem:s-equiv}
  Let $\Lens$ be a symmetric lens.  Let $c \in \Lens.C$ be a complement, and
  $xyo \in \OptionOf{(X \times Y)}$.  If $R_{\Lens}(c,xyo)$, then
  $apply(\Lens,c,es) = apply(S(\Lens),xyo,es)$.
\end{mylemma}
\begin{proof}
  By induction on the derivation the application of $apply(S(\Lens),xyo,es)$
  \begin{case}[empty list]
    So by the case, $apply(S(\Lens),xyo,[]) = []$. Furthermore,
    $apply(\Lens,c,[]) = []$, as desired.
  \end{case}
  \begin{case}[first edit is a create right]
    So by the case, $apply(S(l),\None,\InLOf{x}::es) = \InROf{y}::es'$, where
    $S(\Lens).\CreateROf{x} = y$ and $apply(S(\Lens),\SomeOf{(x,y)},es) = es'$.

    As $R_{\Lens}(None,c)$, $c = \Lens.init$. So, performing $apply$ on
    $\Lens.init$, we get $apply(\Lens,\Lens.init,(\InLOf{x})::es) =
    (\InROf{y'})::es''$ where $\Lens.putr(x,c) = (y',c')$ and $apply(\Lens,c',es)
    = es'$.

    So, by definition, $S(\Lens).\CreateROf{x} = \Fst \App (\Lens.\PutRight \App
    (x,\Lens.init))$, so $y = y'$.

    Furthermore, by \PutRL, $\Lens.\PutLeft \App (y,c') = (x,c')$, and by another
    application of \PutLR, $\Lens.\PutRight \App (x,c') = (y,c')$.  This means
    that $R_{\Lens}(c',Some (x,y))$.

    So, by induction assumption, $apply(\Lens,c',es) = apply(S(\Lens),xyo,es)$, so
    $es' = es''$.  This means, $apply(S(l),\None,\InLOf{x}::es) =
    \InROf{y}::es'$ and $apply(\Lens,\Lens.init,(\InLOf{x})::es) =
    (\InROf{y})::es'$, so they are equal, as desired.
  \end{case}
  \begin{case}[first edit is a create left]
    Symmetric to previous case
  \end{case}
  \begin{case}[first edit is a put right]
    So by the case, $apply(S(\Lens),\SomeOf{(x,y)},\InLOf{x'}::es) = \InROf{y'}::es'$, where
    $S(\Lens).\PutROf{x}{y} = y'$ and $apply(S(\Lens),\SomeOf{(x',y')},es) = es'$.

    Performing $apply$ on $c$, we get $apply(\Lens,c,(\InLOf{x'})::es) =
    (\InROf{y'})::es''$ where $\Lens.\PutRight \App (x',c) = (y',c')$ and
    $apply(\Lens,c',es) = es''$.

    So, by definition, $S(\Lens).\PutROf{x}{y} = \Fst \App (\Lens.\PutRight \App
    (x,c''))$, where $c'' = \Snd \App (\Lens.\PutLeft \App (y,\Lens.init))$.

    By assumption, $R_{\Lens}(c,\SomeOf{(x,y)})$, so $\Lens.\PutLeft \App (y,c)
    = (x,c)$.  So, by Property~\ref{prop:forget-lr}, we know $y' = y''$.

    Furthermore, by \PutRL, $\Lens.\PutLeft \App (y',c') = (x',c')$, and by another
    application of \PutLR, $\Lens.\PutRight \App (x',c') = (y',c')$.  This means
    that $R_{\Lens}(c',Some (x',y'))$.

    So, by induction assumption, $apply(\Lens,c',es) = apply(S(\Lens),xyo,es)$, so
    $es' = es''$.  This means, $apply(S(l),\SomeOf{(x,y)},\InLOf{x'}::es) =
    \InROf{y'}::es'$ and $apply(\Lens,c,(\InLOf{x'})::es) =
    (\InROf{y'})::es'$, so they are equal, as desired.
  \end{case}
  \begin{case}[first edit is a put left]
    Symmetric to previous case
  \end{case}
\end{proof}

\begin{definition}[F]
  Let $\Lens$ be a simple symmetric lens between $X$ and $Y$.

  Consider the following set $C$, distinguished element of that set, $init$, and
  pair of functions $\PutRight$ and $\PutLeft$, that we wish to satisfy the
  symmetric lens laws, and that we also wish to be forgetful.

  \begin{centering}
    \begin{tabular}{@{}r@{\ }c@{\ }l@{}}
      $C$
      & =
      & $\OptionOf{(X \times Y)}$\\
      
      $init$
      & =
      & $\None$\\
      
      $\PutRight \App (x,c)$
      & =
      & $(y,\SomeOf{(x,y)})$ where $y = \begin{cases*}
        \Lens.\CreateROf{x} & if $c = \None$\\
        \Lens.\PutROf{x}{y'} & if $c = \SomeOf{(x',y')}$\\
        \end{cases*}$\\
      
      $\PutLeft \App (y,c)$
      & =
      & $(x,\SomeOf{(x,y)})$ where $x = \begin{cases*}
        \Lens.\CreateLOf{y} & if $c = \None$\\
        \Lens.\PutLOf{y}{x'} & if $c = \Some{(x',y')}$\\
        \end{cases*}$\\
    \end{tabular}
  \end{centering}
\end{definition}

\begin{mylemma}
  \label{lem:f-sym}
  If $\Lens$ is a simple symmetric lens, then $F(\Lens)$ is a symmetric lens.
\end{mylemma}
\begin{proof}
  \PutRL: There are two cases, $c = \None$, and $c = \SomeOf{(x,y)}$.

  \begin{case}[c = \None]
    Let $(y',c') = F(\Lens).\PutRight \App (x',\None)$. This means that $y' =
    \Lens.\CreateROf{x'}$, and $c' = \SomeOf{(x',y')}$.
    
    Now, consider $(x'',c'') = F(\Lens).\PutLeft \App (y',\SomeOf{(x',y')})$. By
    unfolding definitions, $x'' = \Lens.\PutLOf{y'}{x'}$. By \CreatePutRL, $x''
    = x'$, meaning $c'' = \SomeOf{(x',y')}$. This means $(x',c') =
    F(\Lens).\PutLeft \App (y',\SomeOf{(x',y')})$, as desired.
  \end{case}

  \begin{case}[c = \SomeOf{(x,y)}]
    Let $(y',c') = F(\Lens).\PutRight \App (x',\SomeOf{(x,y)})$. This means that $y' =
    \Lens.\PutROf{x'}{y}$, and $c' = \SomeOf{(x',y')}$.
    
    Now, consider $(x'',c'') = F(\Lens).\PutLeft \App (y',\SomeOf{(x',y')})$. By
    unfolding definitions, $x'' = \Lens.\PutLOf{y'}{x'}$. By \PutRL, $x''
    = x'$, meaning $c'' = \SomeOf{(x',y')}$. This means $(x',c') =
    F(\Lens).\PutLeft \App (y',\SomeOf{(x',y')})$, as desired.
  \end{case}

  The second requirement, \PutLR, is symmetric.
\end{proof}


\begin{mylemma}
  If $\Lens$ is a simple symmetric lens, then $F(\Lens)$ is a forgetful symmetric lens.
\end{mylemma}
\begin{proof}
  By Lemma~\ref{lem:f-sym}, we know $F(\Lens)$ is symmetric, so we merely need
  to show it is forgetful.  We will tackle merely \ForgetfulRL, as the proof for
  \ForgetfulLR is symmetric.

  Let $c_1$ and $c_2$ be two arbitrary complements, and $x$ and $y$ two
  arbitrary values of $X$ and $Y$, respectively.
  
  We know that $c_1' = \Snd \App (F(\Lens).\PutRight \App (x,c_1))$ and $c_2' =
  \Snd \App (F(\Lens).\PutRight \App (x,c_2))$.  Now, by inversion on
  $F(\Lens).\PutRight$, we know that both $c_1' = Some(x,y_1')$ and $c_2' =
  Some(x,y_2')$ for some values of $y_1$ and $y_2$ (though we don't actually
  care about the values of $y_1$ and $y_2$).

  Now by unfolding definitions we know, $\Snd \App (F(\Lens).\PutLeft \App
  (y,\SomeOf{(x,y_1')})) = \SomeOf(\Lens.\PutLeftOf{x}{y},y) = c_1''$.  Similarly, we
  know $\Snd \App (F(\Lens).\PutLeft \App
  (y,\SomeOf{(x,y_2')})) = \SomeOf(\Lens.\PutLeftOf{x}{y},y) = c_2''$, so $c_1''
  = c_2''$, as intended.
\end{proof}

\begin{mylemma}
\label{lem:f-equiv}
  If $\Lens$ be a simple symmetric lens, then $apply(\Lens,xyo,es) =
  apply(F(\Lens),xyo,es)$.
\end{mylemma}
\begin{proof}
  By induction on the derivation of $apply$ on $\Lens$!

  \begin{case}[empty list]
    So by the case, $apply(S(\Lens),xyo,[]) = []$. Furthermore,
    $apply(\Lens,xyo,[]) = []$, as desired.
  \end{case}

  \begin{case}[first edit is a create right]
    So by the case, $apply(\Lens,\None,\InLOf{x}::es) = \InROf{y}::es'$, where
    $\Lens.\CreateROf{x} = y$ and $apply(\Lens,\SomeOf{(x,y)},es) = es'$.

    Performing $apply$ on
    $\None$, we get $apply(F(\Lens),\None,(\InLOf{x})::es) =
    (\InROf{y'})::es''$ where $F(\Lens).putr(x,\None) = (y',c)$ and $apply(\Lens,c,es)
    = es'$.

    Unfolding definitions, $F(\Lens).putr(x,\None) = \Lens.\CreateROf{x} =
    (y,\SomeOf{(x,y)})$, so $c = \SomeOf{(x,y)}$ and $y = y'$

    So, by induction assumption, $apply(\Lens,\SomeOf{(x,y)},es) = apply(F(\Lens),\SomeOf{(x,y)},es)$, so
    $es' = es''$.  This means, $apply(\Lens,\None,\InLOf{x}::es) =
    \InROf{y}::es'$ and $apply(F(\Lens),\None,(\InLOf{x})::es) =
    (\InROf{y})::es'$, so they are equal, as desired.
  \end{case}

  \begin{case}[first edit is a create left]
    Symmetric to previous case
  \end{case}

  \begin{case}[first edit is a put right]
    So by the case, $apply(\Lens,\SomeOf{(x,y)},\InLOf{x'}::es) = \InROf{y'}::es'$, where
    $\Lens.\PutROf{x}{y} = y'$ and $apply(\Lens,\SomeOf{(x',y')},es) = es'$.

    Performing $apply$ on $F(\Lens)$, we get
    $apply(F(\Lens),\SomeOf{(x,y)},(\InLOf{x'})::es) = (\InROf{y'})::es''$ where
    $F(\Lens).\PutRight \App (x',\SomeOf{(x,y)}) = (y'',\SomeOf{(x',y'')})$ and
    $apply(\Lens,c',es) = es''$.
    
    So, by definition, $\Fst \App (F(\Lens).\PutRight \App (x',\SomeOf{(x,y)}))
    = \Lens.PutROf{x'}{y'}$, so also by definition, $c' = \SomeOf{(x',y')}$.

    So, by induction assumption, $apply(\Lens,\SomeOf{(x',y')},es) =
    apply(F(\Lens),\SomeOf{(x',y')},es)$, so $es' = es''$. This means,
    $apply(\Lens,\SomeOf{(x,y)},\InLOf{x'}::es) = \InROf{y'}::es'$ and
    $apply(F(\Lens),\SomeOf{(x,y)},(\InLOf{x'})::es) = (\InROf{y'})::es'$, so
    they are equal, as desired.
  \end{case}

  \begin{case}[first edit is a put left]
    Symmetric to previous case
  \end{case}
\end{proof}

\begin{theorem}
  Let $\Lens$ be a symmetric lens. The lens $\Lens$ is equivalent to a forgetful
  lens if, and only if, there exists a simple symmetric lens $\Lens'$ where
  $apply(\Lens,\Lens.init,es) = apply(\Lens',\None,es)$, for all put sequences
  $es$.
\end{theorem}

\begin{proof}
  \begin{case}[$\Rightarrow$]
    Let $\Lens$ be equivalent to a forgetful lens $\Lens'$.  Consider the
    simple symmetric lens, $S(\Lens')$.  By Lemma~\ref{lem:s-equiv},
    $apply(\Lens',\Lens'.init,es) = apply(S(\Lens'),\None,es)$.  As $\Lens$ is
    equivalent to $\Lens'$, $apply(\Lens,\Lens.init,es) =
    apply(\Lens',\Lens'.init,es)$.  So, by transitivity,
    $apply(\Lens,\Lens.init,es) = apply(S(\Lens),\None,es)$.
  \end{case}

  \begin{case}[$\Leftarrow$]
    Let $\Lens'$ be a simple symmetric lens where $apply(\Lens,\Lens.init,es) =
    apply(\Lens',\None,es)$, for all put sequences $es$.

    Consider $F(\Lens')$, a forgetful symmetric lens where $apply(\Lens',\None,es) =
    apply(F(\Lens'),\Lens'.init,es)$, for all put sequences $es$, as
    $\Lens'.init = \None$, by Lemma~\ref{lem:f-equiv}.  By transitivity, $apply(\Lens,\Lens.init,es) =
    apply(\Lens',\Lens'.init,es)$, so $\Lens$ and $\Lens'$ are equivalent.
  \end{case}
    
\end{proof}

\fi

\end{document}



%%% Local Variables:
%%% TeX-master: "main"
%%% End:
