\newif\ifdraft\drafttrue  % set true to show comments

\documentclass{svproc}

\usepackage{amsmath, amssymb, verbatim, enumerate, 
graphicx, centernot, tikz, array, tikz-cd, extarrows, cleveref,
mathrsfs, mathtools, bussproofs, stmaryrd, enumitem, stackengine}

%%%%%
% Macros
% Colors
\definecolor{dkblue}{rgb}{0,0.1,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{dkred}{rgb}{0.6,0,0}
\definecolor{dkpurple}{rgb}{0.7,0,0.4}
\definecolor{olive}{rgb}{0.4, 0.4, 0.0}
\definecolor{teal}{rgb}{0.0,0.5,0.5}
\definecolor{orange}{rgb}{0.9,0.6,0.2}
\definecolor{lightyellow}{RGB}{255, 255, 179}
\definecolor{lightgreen}{RGB}{170, 255, 220}
\definecolor{teal}{RGB}{141,211,199}
\definecolor{darkbrown}{RGB}{121,37,0}

\newcommand{\FINISH}[3]{\ifdraft\textcolor{#1}{[#2: #3]}\fi}
\newcommand{\bcp}[1]{\FINISH{dkred}{B}{#1}}
\newcommand{\BCP}[1]{\FINISH{dkred}{B}{\bf #1}}
\newcommand{\afm}[1]{\FINISH{dkgreen}{A}{#1}}
\newcommand{\dpw}[1]{\FINISH{dkblue}{D}{#1}}
\newcommand{\saz}[1]{\FINISH{orange}{SZ}{#1}}
\newcommand{\ksf}[1]{\FINISH{teal}{K}{#1}}
\newcommand{\sam}[1]{\FINISH{dkpurple}{SM}{#1}}

% FOR Regular Expression names
\newcommand{\re}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\squash}[3]{\ensuremath{\mathit{squash}(#1, #2, #3)}}
\newcommand{\perm}[2]{\ensuremath{\mathit{perm}(#1)\; \mathit{with}\; #2}}
\newcommand{\normalize}[3]{\ensuremath{\mathit{normalize}(#1, #2, #3)}}
\newcommand{\sep}{\ensuremath{\; | \;}}


\begin{document}
\mainmatter              % start of a contribution
%
\title{Synthesizing Quotient Lenses}
%
\titlerunning{Synthesizing Quotient Lenses}  % abbreviated title (for running
% head)                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{}
%
\authorrunning{} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
\tocauthor{}
%
\institute{}

\maketitle              % typeset the title of the contribution

\begin{abstract}

\keywords{quotient lenses, quotient regular expressions, synthesis}
\end{abstract}

\section{Introduction}
Lense programming languages such as Boomerang enable a programmer to express a
transformation that maps some input data to some output data, as well as a
transformation that maps the output data back into the input data in a single
program. For instance, lenses enable a programmer to write a program which
enables a doctor to acquire a summary of a patient's data, and also allows the
doctor to reflect updates made to the patient's record back into the main
database.

Lenses therefore enable the  programmer to kill two birds in one
stone by allowing the programmer to express two different data transformations
in one program. Also, when lenses are appropriately constrained, they offer
guarantees about how the two transformations interact with each other. Lenses
have therefore been used effectively as a solution to the \textit{view update
problem}, a classical problem in the database community in which the
programmer wishes to write a program which provides a \textit{view} of data
derived from a \textit{source} to a client, as well as a program which enables
the client to reflect changes made in the view back into the source without
corrupting the source.

However, the constraints that are imposed on lenses are often too strict.
For instance, the programmer may wish to ignore updates to the data that only
change the order of fields, or add whitespace characters that in reality are not
part of the data. Foster et al therefore proposed \textit{quotient lenses} as a
solution to this problem. Quotient lenses enable a programmer to write lenses
which transform data that is quotiented out by an equivalence relation, so that
records which are equivalent to each other modulo this relation are considered
the same by the underlying lens.

This paper addresses two main challenges that arise when programming quotient
lenses. The first challenge is tied directly to the programming of quotient
lenses in Boomerang, a string lens programming language where the source and
view types are given by regular expressions. While Boomerang enables the
programmer to express a rich set of quotient lenses, the syntax for writing
these lenses is often too verbose and cumbersome. This makes writing quotient
lenses in Boomerang rather difficult.

For example, suppose that the programmer wishes to convert citation records
stored in \textsc{Bib}\TeX{} format to a representation of the same data in the
EndNote format. The programmer wishes to ``quotient'' away unnecessary
whitespace characters in between the various fields in each record, while also
ignoring the order in which these fields occur in the recore. For instance, the
quotient lens which the programmer wishes to derive should convert this
\textsc{Bib}\TeX{} record:

\begin{verbatim}
@Book {conway,
  Author = {Conway, J. H.},
  Title = {Regular Algebra and Finite Machines},
  Publisher = {Printed in GB by William Clowes & Sons Ltd},
  Year = {1971}
}
\end{verbatim}

to this EndNote record

\begin{verbatim}
%0 Book
%T Regular Algebra and Finite Machines
%A Conway, J. H.
%D 1971
%I Printed in GB by William Clowes & Sons Ltd
%F conway
\end{verbatim}

\noindent while allowing for this equivalent representation of the \textsc{Bib}\TeX{}
entry, which rearranges the fields and uses different whitespace conventions:

\begin{verbatim}
@Book{conway, 
    Publisher = {Printed in GB by William Clowes & Sons Ltd},
        Title = {Regular Algebra and Finite Machines},

         Year = {1971},
       Author = {Conway, J. H.},
}
\end{verbatim}

While Boomerang enables the programmer to write a lens which exhibits this
behaviour, the syntax tree for the program is large and complicated.  

\saz{It might be a good idea to show what this would look like in all its gory
detail, just to make the problem very concrete. Perhaps in a figure?}
  
In this paper, we introduce the formalism of Quotient Regular Expressions (or
QREs) to address this issue. QREs enable the programmer to express
a rich set of equivalence relations on regular expressions at the level of
syntax. QREs therefore enable the programmer to express more equivalence
relations with less effort. Also, since QREs are defined at the level of
syntax on regular expressions, QREs give the programmer more control over where
the quotienting occurs.

The second challenge that we address in this paper is the synthesis of
\textit{bijective} quotient lenses. These are quotient lenses which match the
equivalance classes of the source data to the equivalence classes of the view
data bijectively as in the \textsc{Bib}\TeX{} to EndNote example above. 
Building on our prior work~\cite{popl18} where we showed how to synthesize
(ordinary?) bijective lenses, we show how to synthesize bijective quotient
lenses given a synthesis task described by a pair of QREs and a set of
examples. To our knowledge this is the first time that this has been done.

Our plan for this paper is as follows:
\begin{enumerate}
  \item
  We introduce the language of Quotient Regular Expressions (QREs) which enables
  us to express a set of equivalence relations on regular languages using a
  compact, easy-to-use syntax.
  \item
  We describe a class $\mathcal{Q}$ of quotient lenses whose types are given by
  QREs. We derive a normal form for quotient lenses in $\mathcal{Q}$, and
  demonstrate that elements of $\mathcal{Q}$ that are in this normal form are
  closed under left quotienting, right quotienting, composition and regular
  operators.
  \item
  Using the normal form for quotient lenses in $\mathcal{Q}$, we reduce the
  synthesis of quotient lenses in $\mathcal{Q}$ to the synthesis of bijective
  lenses between regular languages. 
  \item
  We describe an implementation of QREs, the language $\mathcal{Q}$ of quotient
  lenses, and an algorithm for synthesizing quotient lenses in $\mathcal{Q}$ in
  the Boomerang language.
  \item
  We assess the usabibility of the QRE synthesis via a case study in which we
  selected several data formats used by data.gov and synthesized quotient lenses
  between them.
\end{enumerate}

\section{Quotient Regular Expressions}
This section introduces Quotient Regular Expressions or QREs. QREs are regular
expressions augmented with syntax that lets them simultaneously express an
equivalence relation on the language described by the regular expression.

\sam{More explanation here?}

  \subsection{Syntax of QREs}
The language of Quotient Regular Expressions (QREs) is given by the following
grammar:
\begin{align*}
q := \; &R \sep R \mapsto s \sep \squash{R}{R'}{f} \sep
\perm{q_1, \ldots, q_n}{q} \;  | \; \normalize{R}{R'}{f}\\
&q' \circ q \sep q \cdot q' \sep (q \sep q') \sep q^*,
\end{align*}
where $R$ ranges over regular expressions, $f$ ranges over functions between
regular languages, and $s$ ranges over character strings.

Each QRE $q$ enables us to express
\begin{enumerate}
  \item a regular expression $W(q)$ (the ``whole'' of $q$),
  \item an equivalence relation $EqRel(q)$ on $\mathcal{L}(W(q))$,
  \item a regular expression $K(q)$ (the ``kernel'' of $q$)
  such that $\mathcal{L}(K(q))$ forms a complete set of representatives for
  $EqRel(q)$, and
  \item a ``canonizing'' function $Canonizer(q):\mathcal{L}(W(q))
  \longrightarrow \mathcal{L}(K(q))$ which given any $w \in \mathcal{L}(W(q))$,
  computes $Canonizer(q)(w)$ as the unique $k$ in $\mathcal{L}(K(q))$ such that
  $k$ is equivalent to $w$ mod $EqRel(q)$
  \end{enumerate}
  Observe that since $Canonizer(q)$ computes $Canonizer(q)(w)$ as the unique $k$
  in $\mathcal{L}(K(q))$ such that $w$ is equivalent to $k$ mod $EqRel(q)$,
  then the equivalence classes of $EqRel(q)$ are the same as the fibres of
  $Canonizer(q)$.
  \subsection{Meaning and Example Usages for QREs}
  \begin{enumerate}
    \item 
    Every regular expression is a QRE. When a regular expression $R$ is used as
    a QRE, then $\mathcal{L}(R)$ is assumed to be quotiented by the equality
    equivalence relation on $\mathcal{L}(R)$.
    \item
    For the QRE $R \mapsto s$, the data is described by $\mathcal{L}(R)$, but
    all members of $R$ are considered equivalent to each other, with $s \in
    \mathcal{L}(R)$ as the choice of representative. This construct is useful
    when the programmer simply wishes to ignore unnecessary characters such as
    excess whitespace e.g. 
    $$FIRST\_NAME \cdot (WHITESPACE^* \mapsto `` \quad ") \cdot LAST\_NAME$$
    \item
    $\squash{R}{R'}{f}$ enables the programmer to use one of two different
    representations of the data if they can provide a way of mapping the first
    representation to the second. For instance, the first representation may be
    $$FIRST\_NAME \cdot `` \quad " \cdot LAST\_NAME$$
    while the second representation may be
    $$FIRST\_NAME \cdot ``," \cdot LAST\_NAME$$
    The mapping that maps the first representation to the second simply converts
    the space between the first and last name to a comma.
    \item
    The $\perm{q_1, \ldots, q_n}{q}$ construct enables the programmer to
    consider all permutations of some data that are interspersed with a
    separator the same. For instance, in the \textsc{Bib}\TeX{} to EndNote
    example, the programmer may use this construct as follows:
    $$\perm{\re{REF}, \re{AUTHOR}, \re{TITLE}, \re{PUBLISHER},
    \re{YEAR}}{(\re{WSP}^* \mapsto \string \n)}$$
 where $\re{REF}, \re{AUTHOR}, \re{TITLE}, \re{PUBLISHER},$ and $\re{YEAR}$ are
regular expressions describing the respective \textsc{Bib}\TeX\; fields of the
same name, and $WSP$ is a regular expression describing whitespace characters.
\item
The constructs $q \cdot q'$, $q \sep q'$ and $q^*$ are similar to the respective
regular expression constructs. However, the regular constructs for QREs are more
restrictive for QREs since the data should match the whole language $W(q)$ and
the kernel language $K(q)$ unambiguosly so as to make transformations
deterministic.
\item
The $\normalize{R}{R'}{f}$ construct allows the programmer to choose how to
canonize $\mathcal{L}(R)$ into $\mathcal{L}(R')$ be providing the canonizing
function $f$ themselves. This constuct is useful when the desired equivalence
relation cannot easily be expressed by any of the other constructs.
  \end{enumerate}

\saz{Every regular expression $R$ is a QRE.  The main new syntactic
forms are:
$R \mapsto s$, which }

\saz{Would it be simpler to include atoms and $\epsilon$ in $q$ rather than $R$?  That is, $R$ is
  just a subset of $QRE$ built from atoms, $\cdot$ $|$ and ${}^*$.  We could
  reserve $R$ as a metavariable that ranges over $q$'s such that $q$ is a
  regular expression.}

\saz{Need to introduce $\mathcal{L}(R)$ notation.}

\iffalse
Quotient Regular Expressions (or QREs) enable us to give richer specifications
for data formats than ordinary regular expressions. More concretely,
  All data to be transformed must match $W(q)$, the ``whole'' regular
  expression of $q$. However, before transforming the using a lens, the data
  will be quotiented out by the equivalence relation $EqRel(q)$ which has $K(q)$
  as a complete set of representatives. That is, for each string $w \in
  W(q)$, there is a unique $k \in K(q)$ such that $w \; EqRel(q) \; k$). This
  unique representative $k$ is chosen using the ``canonizing'' function
  $Canonizer(q)$.
  \fi
  
\subsection{Semantics of QREs}
\subsubsection{Preliminaries}
As we mentioned earlier, when applying the regular constructs $\cdot
\; | \;  *$ to QREs, we require that the regular languages
described by QREs match the data in only one way so as to make transformations
deterministic. Consequently, we require that regular expressions used
by QREs be \textit{strongly unambiguous}, a condition which ensures that if a
string $s$ matches a regular expression $R$, then $s$ matches $R$ uniquely.

To this end, we say that regular expressions $R$ and $S$ are
\textit{unambiguosly concatenable}, written $R \cdot^! S$ if for all strings
$r, r' \in \mathcal{L}(R)$ and $s, s' \in \mathcal{L}(S)$, if $r \cdot s = r'
\cdot s'$, then $r = r'$ and $s = s'$. We say that a regular expression $R$ is
\textit{unambiguosly iterable}, written $R^{*!}$ if for all strings $r_1,
\ldots, r_m$ and $r'_1, \ldots, r'_n \in \mathcal{L}(R)$, if $r_1 \cdot \ldots
\cdot r_m = r'_1 \cdot \ldots \cdot r'_n$, then $m = n$ and $r_i = r'_i$.

We say that a regular expression $R$ is \textit{strongly unambiguous} if and
only if (1) $R = \varnothing$, or (2) $R = S_1 \cdot S_2$ with $S_1, S_2$
strongly unambiguous and $S_1 \cdot^! S_n$, or (3) $R = S_1 \sep S_2$ with
$S_1, S_2$ strongly unambiguous and $\mathcal{L}(S_1) \cap \mathcal{L}(S_2) =
\varnothing$, or (4) $R = S^*$ with $S$ strongly unambiguous and $S^{*!}$.

The semantics for QREs that formally define the whole language $W(q)$, the
kernel language $K(q)$, the equivalence relation $EqRel(q)$ and the
canonizing function $Canonizer(q)$ are given in Figures ~\ref{fig:wk},
~\ref{fig:relations} and ~\ref{fig:canonizers}.
\begin{figure}[t]
  \centering
  \[
    \begin{array}{r@{\quad}c@{\quad}cc}
   
      q & W(q) & K(q) \\ \hline
      R & R & R \\
      R \mapsto s & W(q) & s \\
      \squash{R}{R'}{f} & R \sep R' & R' \\
      \normalize{R}{R'}{f} & R & R' \\
      q_1 \circ  q_2 & W(q_2) & K(q_1) \\
      q_1 \cdot q_2 & W(q_1) \cdot W(q_2) & K(q_1) \cdot K(q_2) \\
      q_1 \sep q_2 & W(q_1) \sep W(q_2) & K(q_1) \sep K(q_2) \\
      q^* & W(q)^* & K(q)^* \\
    \end{array}
  \]
\[
\begin{array}{r@{\quad}l}
W( \perm{(q_1, \ldots, q_n)}{q} ) = &
\bigcup \limits_{\sigma \in S_n} W(q_{\sigma(1)}) \cdot W(q) \cdot \ldots \cdot \cdot W(q) \cdot W(q_{\sigma(n)})
\\
K( \perm{(q_1, \ldots, q_n)}{q} ) = &
 K(q_1) \cdot K(q_1) \cdot \ldots \cdot \cdot K(q) \cdot K(q_n) 
\end{array}
\]
  \caption{Whole and Kernel Regular Expressions.}
  \label{fig:wk}
\end{figure}

\begin{figure}[t]
  \begin{center}
\[
    \begin{array}{l@{\quad}l} 
      q & EqRel(q)  \\ \hline
      R & w \; \equiv_R \; w' \iff w = w \\
      R \mapsto s & w \; \equiv_{R \mapsto s} \; w' \text{ for all }w, w'\\
      \squash{R}{R'}{f} & w \; \equiv_{\squash{R}{R'}{f}} \; w' \iff f(w) = w'
      \text{ or } w = w' \\
      \normalize{R}{R'}{f} & w \; \equiv_{\normalize{R}{R'}{f}} \; w' \iff
      f(w)=f(w') \text{ or }w = w'\\
      q_2 \circ  q_1 &  w \; \equiv_{q_2 \circ q_1} \; w' \iff \exists k, k' \in
  \mathcal{L}(K(q_2)) \text{ such that } w \; \equiv_{q_1} \; k, \; w' \;
  \equiv_{q_1} \; k', \text{ and } k \; \equiv_{q_2} \; k'\\
      q_1 \cdot q_2 &  w \; \equiv_{q_1 \cdot q_2} \; w'  \iff w = r_1
      \cdot r_2, \; w' = {r'}_1 \cdot {r'}_2 \text{ with } r_1 \; \equiv_{q_1}
      \; {r'}_1, \; r_2 \; \equiv{q_n} \; {r'}_2\\
      q_1 \sep q_2 &  w \; \equiv_{q' \sep q} \; w' \iff w \; \equiv_{q_1} \; w'
      \text{ or } \; w \; \equiv_{q_2} \; w'\\
      q^* &  w \; \equiv_{q*} \; w' \iff w = r_1 \cdot \ldots \cdot r_n, \; w'
      = {r'}_1 \cdot \ldots \cdot {r'}_n \text{ and } r_i \equiv_{q} \; {r'}_i
      \text{ for all } 1 \leq i \leq n\\
    \end{array}
    \]
    \end{center}
    $w \; \equiv_{\perm{(q_1, \ldots, q_n)}{q}} \; w' $ if and only if
    
    $w = r_{\sigma(1)} \cdot s_1 \cdot \ldots \cdot s_{n-1} \cdot r_{\sigma(n)}
    \text{ and } w' = {r'}_{\theta(1)} \cdot s'_1 \cdot \ldots \cdot s'_{n-1}
    \cdot {r'}_{\theta(n)}$ for some $\sigma, \theta \in S_n$, with $r_i \;
    \equiv_{q_i} \; r'_i$ and $s_k \; \equiv_{q} \; s'_{k}$.
  \caption{QRE Equivalence Relations}
  \label{fig:relations}
\end{figure}
\begin{figure}[t]
  \begin{center}
\[
    \begin{array}{l@{\quad}l} 
      q & Canonizer(q)  \\ \hline
      R & Canonizer(R) = id_{\mathcal{L}(R)} \\
      R \mapsto s & Canonizer(R \mapsto s)(w) = s\\
      \squash{R}{R'}{f} & Canonizer(\squash{R}{R'}{f})(w) = 
\begin{cases}
f(w) & \text{if } w \in \mathcal{L}(R)\\
w & \text{otherwise}
\end{cases}\\
      \normalize{R}{R'}{f} & Canonizer(\normalize{R}{R'}{f}) = f\\
      \perm{(q_1, \ldots, q_n)}{q} & \\
      q_2 \circ  q_1 & Canonizer(q' \circ q) = Canonizer(q') \circ Canonizer(q)\\
      q_1 \cdot q_2 & Canonizer(q' \cdot q) = Canonizer(q') \cdot Canonizer(q)\\
      q_1 \sep q_2 &  Canonizer(q_1 \sep q_2)(w) = 
\begin{cases}
Canonizer(q_1)(w) & \text{if } w \in \mathcal{L}(W(q_1))\\
Canonizer(q_2)(w) & \text{if } w \in \mathcal{L}(W(q_2))\\
\end{cases}\\
      q^* &  Canonizer(q^*) = Canonizer(q)^* \\
    \end{array}
    \]
    \end{center}
    $Canonizer(\perm{(q_1, \ldots, q_n)}{q})(r_{\sigma(1)}
\cdot s_1 \cdot \ldots \cdot s_{n-1} \cdot r_{\sigma(n)}) \newline
= (Canonizer(q_1)(r_1)) \cdot (Canonizer(q)(s_1)) \cdot \ldots \cdot
(Canonizer(q_n)(r_n))$
  \caption{QRE Canonizers}
  \label{fig:canonizers}
\end{figure}
\begin{figure}[t]
\centering
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$R$ is well formed}
\end{prooftree}

\begin{prooftree}
\AxiomC{$s \in W(q)$}
\UnaryInfC{$R \mapsto s$ is well formed}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\mathcal{L}(R) \cap \mathcal{L}(R') = \varnothing$}
\AxiomC{$f : \mathcal{L}(R) \longrightarrow \mathcal{L}(R')$}
\BinaryInfC{$squash(R, R', f)$ is well formed}
\end{prooftree}

\begin{prooftree}
\AxiomC{${\substack{\forall \sigma \neq \theta, \; W(q_{\sigma(1)}) \cdot W(q)
\cdot \ldots \cdot W(q_{\sigma(n)})\\ \cap W(q_{\theta(1)}) \cdot W(q)
\cdot \ldots \cdot W(q_{\theta(n)}) =\varnothing}}$}
\AxiomC{$q_i, q$ are well formed}
\AxiomC{$\forall \sigma, \; K(q_{\sigma(1)}) \cdot^! K(q) \cdot^! \ldots 
\cdot^! K(q_{\sigma(n)})$}
\TrinaryInfC{$\perm{q_1, \ldots, q_n}{q}$ is well formed}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\mathcal{L}(R') \subseteq \mathcal{L}(R)$}
\AxiomC{$f : \mathcal{L}(R) \longrightarrow \mathcal{L}(R')$}
\AxiomC{$f$ is surjective}
\AxiomC{$f = f^2$}
\QuaternaryInfC{$normalize \; (R,R', f)$ is well formed}
\end{prooftree}

\begin{prooftree}
\AxiomC{$q$ is well formed}
\AxiomC{$q'$ is well formed}
\AxiomC{$K(q) = W(q')$}
\TrinaryInfC{$q' \circ q$ is well formed}
\end{prooftree}

\begin{prooftree}
\AxiomC{$q$ is well formed}
\AxiomC{$q'$ is well formed}
\AxiomC{$W(q) \cdot^! W(q')$}
\AxiomC{$K(q) \cdot^! K(q')$}
\QuaternaryInfC{$q \cdot q$ is well formed}
\end{prooftree}

\begin{prooftree}
\AxiomC{$q$ is well formed}
\AxiomC{$q'$ is well formed}
\AxiomC{$W(q) \cap W(q') = \varnothing$}
\TrinaryInfC{$q \cdot q$ is well formed}
\end{prooftree}

\begin{prooftree}
\AxiomC{$q$ is well formed}
\AxiomC{$W(q)^{*!}$}
\AxiomC{$K(q)^{*!}$}
\TrinaryInfC{$q^*$ is well formed}
\end{prooftree}
  \caption{QRE Inference Rules}
  \label{fig:qrerules}
\end{figure}
The theorem below confirms that the semantics of QREs are consistent with their
intended meaning:
\begin{theorem}
If $q$ is a well formed QRE, then
\begin{enumerate}
  \item $W(q)$ and $K(q)$ are well defined regular expressions,
  \item  $EqRel(q)$ is an equivalence relation on $\mathcal{L}(W(q))$,
  \item  $\mathcal{L}(K(q))$ forms a complete set of representatives for
  $EqRel(q)$,
  \item $Canonizer(q):\mathcal{L}(W(q)) \longrightarrow \mathcal{L}(K(q))$ is a
  well-defined function, and
  \item  given any $w \in \mathcal{L}(W(q))$, $Canonizer(q)(w)$ is the unique
  $k$ in $\mathcal{L}(K(q))$ such that $k$ is equivalent to $w$ modulo
  $EqRel(q)$.
  \end{enumerate}
\end{theorem}
\section{Using QREs to Express Quotient Lenses}
Given regular expressions $R, S$ and equivalence relations $\sim_R, \sim_S$ are
defined on $\mathcal{L}(R)$ and $\mathcal{L}(S)$ respectively, a
\textit{quotient lens} $q :
R/{\sim_R}{\Longleftrightarrow} S/{\sim_S}$ from $R$ to $S$ is
a pair of functions $q.get:
\mathcal{L}(R) \longrightarrow \mathcal{L}(S)$ and $q.put : \mathcal{L}(S)
\longrightarrow \mathcal{L}(R)$ such that
\begin{align*}
q.put \; (q.get \; r) &\sim_R r\\
q.get \; (q.put \; s) &\sim_S s
\end{align*}
Additionally the components of $q$ must respect $\sim_R$ and $\sim_S$ i.e.
if $r \sim_R r'$ and $s \sim_S s'$ then $q.get \; r \; \sim_S q.get \; r'$
and $q.put \; s \sim_R q.put \; s' \; s'$.\\
Now let $c, c'$ be QREs. Since $K(c)$ and $K(c')$ form a complete set of
representatives for $W(c)$ modulo $EqRel(c)$ and $W(c')$ modulo $EqRel(c')$
respectively, then given a bijection $\ell : K(c) \Leftrightarrow K(c')$, we
may define a quotient lens $q : W(c)/EqRel(c) \Leftrightarrow
W(c')/EqRel(c')$ by 
\begin{align*}
q.get &= \ell \circ Canonizer(c)\\
q.put &= \ell^{-1} \circ Canonizer(c')
\end{align*}
Define the class of \textit{bijective
lenses} to be the set of bijections between regular languages created from Boomerang lens combinators.
The syntax for the language of bijective lenses is given by
$$\ell := R \sep const(s, s') \sep  swap(\ell,
\ell) \sep \ell \cdot \ell' \; |  \; (\ell \sep \ell') \sep \ell^* \;
| \; \ell \circ \ell',$$ where $R$ ranges over regular expressions and $s$
ranges over character strings.\\
The denotation of a bijective lens $\ell$ is a function from 
$\llbracket e \rrbracket$ of a bijective lens $\ell$ is defined
inductively by
\begin{align*}
\llbracket R \rrbracket &= \{(r, r) \sep r \in \mathcal{L}(R)\}\\
\llbracket swap(\ell, \ell') \rrbracket &= \{(s \cdot t, t' \cdot s') \sep
(s, s') \in \llbracket \ell \rrbracket \text{ and } (t, t') \in \llbracket
\ell' \rrbracket\}\\
\llbracket \ell \cdot \ell' \rrbracket &= \{(s \cdot t, s' \cdot t) \sep
(s, s') \in \llbracket \ell \rrbracket \text{ and } (t, t') \in \llbracket
\ell' \rrbracket\}\\
\llbracket \ell \sep \ell' \rrbracket &= \{(s \cdot t) \sep
(s, t) \in \llbracket \ell \rrbracket \text{ or } (s, t) \in \llbracket
\ell' \rrbracket\}\\
\llbracket \ell^* \rrbracket &= \{(s_1 \cdot \ldots \cdot s_n, t_1 \cdot \ldots
\cdot t_n) \sep (s_i, t_i) \in \llbracket \ell \rrbracket \text{ for } 1
\leq i \leq n\}
\end{align*}
\textcolor{red}{[More explanation needed esp. inference rules for bijective
lenses]}\\
Having described the class of bijective lenses, we now define the class
$\mathcal{Q}$ of quotient lenses, whose language is defined inductively by the
following grammar:
$$ q := id(\ell) \sep lquot(q, \ell) \sep rquot(\ell, q) \sep q
\cdot q_2 \sep (q \sep q') \sep q^* \sep q \circ q',$$
where $\ell$ ranges over bijective lenses 
\subsection{Semantics of $\mathcal{Q}$}
Every element in $\mathcal{Q}$ has a type $q :
c \Longleftrightarrow c'$ where $c$ and $c'$ are QREs. The denotation
$\llbracket q \rrbracket$ of an element $q : c \Longleftrightarrow c'$ is a
quotient lens $\llbracket q \rrbracket :
W(c)/{EqRel(c)} \Longleftrightarrow W(c')/{EqRel(c')}$.\\
\textcolor{red}{[Informal Meaning/Usages Needed]}\\We now give the
semantics of $\mathcal{Q}$, as well as inference rules that may be used to
derive elements of $\mathcal{Q}$:
\begin{enumerate}
  \item
  if $q = id(\ell)$, then
  \begin{prooftree}
\AxiomC{$\ell : R \Leftrightarrow S$}
\UnaryInfC{$id(\ell): R \Leftrightarrow id(S)$}
\end{prooftree}
  \begin{align*}
  \llbracket q \rrbracket.get &=  \llbracket \ell \rrbracket, \text{ and }\\
  \llbracket q \rrbracket.put &= \llbracket \ell \rrbracket^{-1}
  \end{align*}
 
  \item if $q = lquot(c, q')$, then
\begin{prooftree}
\AxiomC{$q' : c'  \Leftrightarrow c''$}
\AxiomC{$c$ is well formed}
\AxiomC{$K(c) = W(c')$}
\TrinaryInfC{$lquot(c, q'): c' \circ c \Leftrightarrow c''$}
\end{prooftree}
  \begin{align*}
  \llbracket q \rrbracket.get  &= \llbracket q'
  \rrbracket.get \circ Canonizer(c)\\
  \llbracket q \rrbracket.put &= \llbracket q' \rrbracket.put
  \end{align*}
  \item
  if $q = rquot(q', c'')$, then
  \begin{prooftree}
  \AxiomC{$q' : c \Leftrightarrow c'$}
  \AxiomC{$c''$ is well formed}
  
\AxiomC{$K(c'') = W(c')$}
\TrinaryInfC{$rquot(q', c):c \Leftrightarrow c'' \circ c'$}
\end{prooftree}
  \begin{align*}
  \llbracket q \rrbracket.get &= \llbracket q'
  \rrbracket.get\\
  \llbracket q \rrbracket.put &= \llbracket q'
  \rrbracket.put \circ Canonizer(c'')
  \end{align*}
  
  \item
  $q = q_2 \circ q_1$, then
  \begin{prooftree}
\AxiomC{$q_1 : c \Leftrightarrow c'$}
\AxiomC{$q_2 : c' \Leftrightarrow c''$}
\BinaryInfC{$q_2 \circ q_1: c \Leftrightarrow c''$}
\end{prooftree}
  \begin{align*}
  \llbracket q \rrbracket.get &= \llbracket q_2 \rrbracket.get\circ \llbracket
  q_1 \rrbracket.get, \text{ and }\\
  \llbracket q \rrbracket.put &= \llbracket q_1 \rrbracket.put \circ \llbracket
  q_2 \rrbracket.put
  \end{align*}
  \item
  $q = {q'}^*$, then
    \begin{prooftree}
\AxiomC{$q' : c \Leftrightarrow c'$}
\AxiomC{$W(c)^{*!}$ and $W(c')^{*!}$}
\AxiomC{$K(c)^{*!}$ and $K(c')^{*!}$}
\TrinaryInfC{${q'}^* : c^* \Leftrightarrow {c'}^*$}
\end{prooftree}
  \begin{align*}
  \llbracket q \rrbracket.get &= (\llbracket q' \rrbracket.get)^*, \text{
  and }\\
  \llbracket q \rrbracket.put &= (\llbracket q' \rrbracket.put)^*
  \end{align*}

  \item
  $q = q_1 \cdot q_2$, then
    \begin{prooftree}
\AxiomC{$q_1 : c_1 \Leftrightarrow d_1 $}
\AxiomC{$q_2 : c_2 \Leftrightarrow d_2$}
\AxiomC{${\substack{W(c_1) \cdot^! W(c_2)\\ K(c_1) \cdot^! K(c_2)}}$}
\AxiomC{${\substack{W(d_1) \cdot^! W(d_2)\\ K(d_1) \cdot^! K(d_2)}}$}
\QuaternaryInfC{$q_1 \cdot q_2: c_1 \cdot c_2
\Leftrightarrow d_1 \cdot d_2$}
\end{prooftree}
  \begin{align*}
  \llbracket q \rrbracket.get &= \llbracket q_1 \rrbracket.get \cdot \llbracket
  q_2 \rrbracket.get, \text{ and }\\
  \llbracket q \rrbracket.put &= \llbracket q_1 \rrbracket.put \cdot \llbracket
  q_2 \rrbracket.put
  \end{align*}

  \item
  $q = q_1 \sep q_2$, then
      \begin{prooftree}
\AxiomC{$q_1 : c_1 \Leftrightarrow d_1 $}
\AxiomC{$q_2 : c_2 \Leftrightarrow d_2$}
\AxiomC{$\mathcal{L}(W(c_1)) \cap \mathcal{L}(W(c_2)) = \varnothing$}
\AxiomC{$\mathcal{L}(W(d_1)) \cap \mathcal{L}(W(d_2)) = \varnothing$}
\QuaternaryInfC{$q_1 \sep q_2: (c_1 \sep c_2)
\Leftrightarrow (d_1 \sep d_2)$}
\end{prooftree}
  $$
  \llbracket q_1 \sep q_2 \rrbracket.get(s) = 
  \begin{cases}
  \llbracket q_1 \rrbracket.get (s) & \text{if } s \in \mathcal{L}(W(c_1))\\
  \llbracket q_2 \rrbracket.get (s) & \text{if } s \in \mathcal{L}(W(c_2))\\
  \end{cases}$$
  $$\llbracket q_1 \sep q_2 \rrbracket.put(s) = 
  \begin{cases}
  \llbracket q_1 \rrbracket.put (s) & \text{if } s \in \mathcal{L}(W(d_1))\\
  \llbracket q_2 \rrbracket.put (s) & \text{if } s \in \mathcal{L}(W(d_2))\\
  \end{cases}
  $$
\end{enumerate}

\begin{claim}
If there exists a derivation $q:c \Leftrightarrow c'$ then
$\llbracket q \rrbracket$ is a quotient lens from $R$ to $S$.
\end{claim}

\subsection{Normal Forms for Quotient Lenses in $\mathcal{Q}$}
\begin{theorem}\label{normal form}
If there is a derivation $q : c \Leftrightarrow c'$ in
$\mathcal{Q}$ then there exists a bijective lens $\ell : K(c) \Leftrightarrow
K(c')$ such that
\begin{align*}
\llbracket q \rrbracket.get &= \llbracket \ell \rrbracket\circ Canonizer(c)\\
\llbracket q \rrbracket.put &= \llbracket \ell \rrbracket^{-1} \circ
Canonizer(c')
\end{align*}
\end{theorem}
\begin{proof}
Assume that $q : c \Leftrightarrow c'$. We proceed by induction over the
derivation $q : c \Leftrightarrow c'$.
\begin{enumerate}
  \item
  $id(\ell): R \Leftrightarrow id(S)$ where $\ell : R \Leftrightarrow
S$. Then
  \begin{align*}
  \llbracket id(\ell) \rrbracket.get &=  \llbracket \ell \rrbracket = \llbracket \ell \rrbracket \circ
  id_{\mathcal{L}(R)} = \llbracket \ell \rrbracket \circ Canonizer(R), \text{ and }\\
  \llbracket id(\ell) \rrbracket.put &= \llbracket \ell \rrbracket^{-1} = \llbracket \ell \rrbracket^{-1} \circ
  id_{\mathcal{L}(S)} = \llbracket \ell \rrbracket^{-1} \circ Canonizer(id(S))
  \end{align*}
  \item
  $lquot(c, q'): c' \circ c \Leftrightarrow c''$ where $q' : c' 
  \Leftrightarrow c''$, $c$ is well formed and $K(c) = W(c')$. Then
\begin{align*}
  \llbracket q \rrbracket.get  &= \llbracket q'
  \rrbracket.get \circ Canonizer(c)\\
  \llbracket q \rrbracket.put &= \llbracket q' \rrbracket.put
  \end{align*}
  By the induction hypothesis, there exists a bijective lens $\ell :
  K(c') \Leftrightarrow K(c'')$ such that 
  \begin{align*}
\llbracket q' \rrbracket.get &= \llbracket \ell \rrbracket \circ Canonizer(c')\\
\llbracket q' \rrbracket.put &= \llbracket \ell \rrbracket^{-1} \circ
Canonize(c'')
\end{align*}
Consequently
\begin{align*}
  \llbracket q \rrbracket.get  &= (\llbracket \ell \rrbracket \circ
  Canonizer(c')) \circ Canonizer(c) = \llbracket \ell \rrbracket \circ
  (Canonizer(c' \circ c))\\
  \llbracket q \rrbracket.put &= \llbracket \ell \rrbracket^{-1} \circ
  Canonize(c'')
  \end{align*}

  \item
  $rquot(q', c''):c \Leftrightarrow c'' \circ c'$ where $q' : c \Leftrightarrow
  c'$, $c''$ is well formed and $K(c'') = W(c')$. Proceed as in the previous
  case.
\item
$q_2 \circ q_1: c \Leftrightarrow c''$ where $q_1 : c \Leftrightarrow c'$ and
$q_2 : c' \Leftrightarrow c''$. Then
  \begin{align*}
  \llbracket q \rrbracket.get &= \llbracket q_2 \rrbracket.get\circ \llbracket
  q_1 \rrbracket.get, \text{ and }\\
  \llbracket q \rrbracket.put &= \llbracket q_1 \rrbracket.put \circ \llbracket
  q_2 \rrbracket.put
  \end{align*}
  By the induction hypothesis, there exist bijective lenses
  $\ell_1 :
  K(c) \Leftrightarrow K(c')$ and $\ell_2 : K(c') \Leftrightarrow K(c'')$ such
  that
  \begin{align*}
\llbracket q_1 \rrbracket.get &= \llbracket \ell_1 \rrbracket \circ
Canonizer(c)\\
\llbracket q_1 \rrbracket.put &= {\llbracket \ell_1 \rrbracket}^{-1} \circ
Canonizer(c')
\end{align*}
and
\begin{align*}
\llbracket q_2 \rrbracket.get &= \llbracket \ell_2 \rrbracket \circ
Canonize(c')\\
\llbracket q_2 \rrbracket.put &= {\llbracket \ell_2 \rrbracket}^{-1} \circ
Canonize(c'')
\end{align*}
Consequently,
\begin{align*}
\llbracket q_2 \rrbracket.get \circ \llbracket q_1 \rrbracket.get &=
(\llbracket \ell_2 \rrbracket \circ Canonizer(c')) \circ (\llbracket \ell_1
\rrbracket \circ Canonizer(c))\\
&= \llbracket \ell_2 \rrbracket \circ (Canonizer(c') \circ \llbracket \ell_1
\rrbracket) \circ Canonizer(c)\\
&= (\llbracket \ell_2 \rrbracket \circ \llbracket \ell_1 \rrbracket) \circ
Canonizer(c)\\
&= \llbracket \ell_2  \circ  \ell_1 \rrbracket \circ
Canonizer(c)
\end{align*} 
A similar argument shows that 
$$\llbracket q_1 \rrbracket.put \circ \llbracket q_2 \rrbracket.put =
\llbracket \ell_2  \circ  \ell_1 \rrbracket^{-1} \circ
Canonizer(c)$$
\item  
${q'}^* : c^* \Leftrightarrow {c'}^*$ where $q' : c \Leftrightarrow c'$,
$W(c)^{*!}$ and $W(c')^{*!}$ and $K(c)^{*!}$ and $K(c')^{*!}$. Then
  \begin{align*}
  \llbracket {q'}^* \rrbracket.get &= (\llbracket q' \rrbracket.get)^*, \text{
  and }\\
  \llbracket {q'}^* \rrbracket.put &= (\llbracket q' \rrbracket.put)^*
  \end{align*}
  By the induction hypothesis there exists a bijective lens $\ell : K(c)
  \Leftrightarrow K(c')$ such that 
   that
  \begin{align*}
\llbracket q' \rrbracket.get &= \llbracket \ell \rrbracket \circ
Canonizer(c)\\
\llbracket q' \rrbracket.put &= {\llbracket \ell \rrbracket}^{-1} \circ
Canonizer(c')
\end{align*}
Consequentlty
\begin{align*}
\llbracket {q'}^* \rrbracket.get &= (\llbracket \ell \rrbracket \circ
Canonizer(c))^* = \llbracket \ell \rrbracket^* \circ
Canonizer(c)^* = \llbracket \ell^* \rrbracket \circ
Canonizer(c^*)\\
\llbracket {q'}^* \rrbracket.put &= (\llbracket \ell \rrbracket^{-1} \circ
Canonizer(c'))^* = (\llbracket \ell \rrbracket^{-1})^* \circ
Canonizer(c')^* = \llbracket \ell^* \rrbracket^{-1} \circ
Canonizer(c'^*)\\
\end{align*}
\item
  $q_1 \cdot q_2: c_1 \cdot c_2 \Leftrightarrow d_1 \cdot d_2$, where $q_1 : c_1
  \Leftrightarrow d_1 $,  $q_2 : c_2 \Leftrightarrow d_2$, $W(c_1)
  \cdot^! W(c_2)$, $K(c_1) \cdot^! K(c_2)$, $W(d_1) \cdot^! W(d_2)$ and $
  K(d_1) \cdot^! K(d_2)$. Then
  \begin{align*}
  \llbracket q \rrbracket.get &= \llbracket q_1 \rrbracket.get \cdot \llbracket
  q_2 \rrbracket.get, \text{ and }\\
  \llbracket q \rrbracket.put &= \llbracket q_1 \rrbracket.put \cdot \llbracket
  q_2 \rrbracket.put
  \end{align*}
By the induction hypothesis, there exist bijective lenses $\ell_1 : K(c_1)
\Leftrightarrow K(d_1)$ and $\ell_2 : K(c_2) \Leftrightarrow K(d_2)$ such that
\begin{align*}
\llbracket q_1 \rrbracket.get &= \llbracket \ell_1 \rrbracket \circ
Canonizer(c_1)\\
\llbracket q_1 \rrbracket.put &= {\llbracket \ell_1 \rrbracket}^{-1} \circ
Canonizer(d_1)
\end{align*}
and
\begin{align*}
\llbracket q_2 \rrbracket.get &= \llbracket \ell_2 \rrbracket \circ
Canonizer(c_2)\\
\llbracket q_2 \rrbracket.put &= {\llbracket \ell_2 \rrbracket}^{-1} \circ
Canonizer(d_2)
\end{align*}
Consequently,
\begin{align*}
  \llbracket q \rrbracket.get &= (\llbracket \ell_1 \rrbracket \circ
Canonizer(c_1)) \cdot  (\llbracket \ell_2 \rrbracket \circ
Canonizer(c_2))\\
&= (\llbracket \ell_1 \rrbracket \cdot \llbracket \ell_2
\rrbracket) \circ (Canonizer(c_1) \cdot Canonizer(c_2))\\
&= \llbracket \ell_1 \cdot  \ell_2 \rrbracket \circ Canonizer(c_1 \cdot c_2)
\end{align*}
Similarly
$$
  \llbracket q \rrbracket.put = \llbracket \ell_1 \cdot  \ell_2 \rrbracket^{-1}
  \circ Canonizer(d_1 \cdot d_2) $$
  \item
  $q = q_1 \sep q_2$ where $q_1 : c_1 \Leftrightarrow d_1 $, $q_2 : c_2
  \Leftrightarrow d_2$, $\mathcal{L}(W(c_1)) \cap \mathcal{L}(W(c_2)) =
  \varnothing$ and $\mathcal{L}(W(d_1)) \cap \mathcal{L}(W(d_2)) = \varnothing$.
  Then
  $$
  \llbracket q_1 \sep q_2 \rrbracket.get(s) = 
  \begin{cases}
  \llbracket q_1 \rrbracket.get (s) & \text{if } s \in \mathcal{L}(W(c_1))\\
  \llbracket q_2 \rrbracket.get (s) & \text{if } s \in \mathcal{L}(W(c_2))\\
  \end{cases}$$
  $$\llbracket q_1 \sep q_2 \rrbracket.put(s) = 
  \begin{cases}
  \llbracket q_1 \rrbracket.put (s) & \text{if } s \in \mathcal{L}(W(d_1))\\
  \llbracket q_2 \rrbracket.put (s) & \text{if } s \in \mathcal{L}(W(d_2))\\
  \end{cases}
  $$
By the induction hypothesis, there exist bijective lenses $\ell_1 : K(c_1)
\Leftrightarrow K(d_1)$ and $\ell_2 : K(c_2) \Leftrightarrow K(d_2)$ such that
\begin{align*}
\llbracket q_1 \rrbracket.get &= \llbracket \ell_1 \rrbracket \circ
Canonizer(c_1)\\
\llbracket q_1 \rrbracket.put &= {\llbracket \ell_1 \rrbracket}^{-1} \circ
Canonizer(d_1)
\end{align*}
and
\begin{align*}
\llbracket q_2 \rrbracket.get &= \llbracket \ell_2 \rrbracket \circ
Canonizer(c_2)\\
\llbracket q_2 \rrbracket.put &= {\llbracket \ell_2 \rrbracket}^{-1} \circ
Canonizer(d_2)
\end{align*}
Consequently,
$$
  \llbracket q_1 \sep q_2 \rrbracket.get(s) = 
  \begin{cases}
  \llbracket \ell_1 \rrbracket \circ
Canonizer(c_1) (s) & \text{if } s \in \mathcal{L}(W(c_1))\\
  \llbracket \ell_2 \rrbracket \circ
Canonizer(c_2) (s) & \text{if } s \in \mathcal{L}(W(c_2)),\\
  \end{cases}$$
  so $\llbracket q_1 \sep q_2 \rrbracket.get = \llbracket \ell_1 \sep
  \ell_2 \rrbracket \circ Canonizer(c_1 \sep c_2)$. A similar argument shows
  that $\llbracket q_1 \sep q_2 \rrbracket.put = \llbracket \ell_1 \sep
  \ell_2 \rrbracket^{-1} \circ Canonizer(d_1 \sep d_2)$.\\
  This completes the proof.
\end{enumerate}
\end{proof}
\section{Synthesizing Quotient Lenses}
By \cref{normal form}, if there is a derivation $q : c \Leftrightarrow c'$ in
$\mathcal{Q}$ then there exists a bijective lens $\ell : K(c) \Leftrightarrow
K(c')$ such that
\begin{align*}
\llbracket q \rrbracket.get &= \llbracket \ell \rrbracket\circ Canonizer(c)\\
\llbracket q \rrbracket.put &= \llbracket \ell \rrbracket^{-1} \circ
Canonizer(c')
\end{align*}
In other words, every quotient lens in $\mathcal{Q}$ is the same as an ordinary
bijective lens with canonizers at the ends.\\
Therefore, in order to synthesize a quotient lens $q: c \Leftrightarrow c'$
where $c, c'$ are QREs, it suffices to synthesize a bijective lens $\ell : K(c)
\Leftrightarrow K(c')$.\\
\textcolor{red}{[Citation Needed!]} has already shown that if there
exists a derivation $\ell : R \Leftrightarrow S$, then there exist
regular expressions $R', S'$ and a synthesizable \\
\textcolor{red}{[Explain and make explicit the meaning
of synthesizable]} \\
bijective lens $\ell' :
R' \Leftrightarrow S'$ such that $\mathcal{L}(R) = \mathcal{L}(R')$,
$\mathcal{L}(S) = \mathcal{L}(S')$ and $\llbracket \ell \rrbracket =
\llbracket \ell' \rrbracket$. This immediately implies that if there is a
derivation $q : c \Leftrightarrow c'$ as well as a derivation $\ell : K(c)
\Leftrightarrow K(c')$, then $q$ is synthesizable.
\textcolor{red}{[More Needed?]}
\section{Implementation and Evaluation}
\section{Related Work}

\section{Conclusion}

\end{document}
