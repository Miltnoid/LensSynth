\newif\ifdraft\drafttrue  % set true to show comments

\documentclass{svproc}

\usepackage{amsmath, amssymb, verbatim, enumerate, 
graphicx, centernot, tikz, array, tikz-cd, extarrows, cleveref,
mathrsfs, mathtools, bussproofs, stmaryrd, enumitem, stackengine}

%%%%%
% Macros
% Colors
\definecolor{dkblue}{rgb}{0,0.1,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{dkred}{rgb}{0.6,0,0}
\definecolor{dkpurple}{rgb}{0.7,0,0.4}
\definecolor{olive}{rgb}{0.4, 0.4, 0.0}
\definecolor{teal}{rgb}{0.0,0.5,0.5}
\definecolor{orange}{rgb}{0.9,0.6,0.2}
\definecolor{lightyellow}{RGB}{255, 255, 179}
\definecolor{lightgreen}{RGB}{170, 255, 220}
\definecolor{teal}{RGB}{141,211,199}
\definecolor{darkbrown}{RGB}{121,37,0}

\newcommand{\FINISH}[3]{\ifdraft\textcolor{#1}{[#2: #3]}\fi}
\newcommand{\bcp}[1]{\FINISH{dkred}{B}{#1}}
\newcommand{\BCP}[1]{\FINISH{dkred}{B}{\bf #1}}
\newcommand{\afm}[1]{\FINISH{dkgreen}{A}{#1}}
\newcommand{\dpw}[1]{\FINISH{dkblue}{D}{#1}} % Toronto Maple Leafs Blue :-)
\newcommand{\saz}[1]{\FINISH{orange}{SZ}{#1}}
\newcommand{\ksf}[1]{\FINISH{teal}{K}{#1}}
\newcommand{\sam}[1]{\FINISH{dkpurple}{SM}{#1}}

% FOR Regular Expression names
\newcommand{\re}[1]{\ensuremath{\mathtt{#1}}}
\newcommand{\squash}[3]{\ensuremath{\mathit{squash} \; (#1, #2, #3)}}
\newcommand{\perm}[2]{\ensuremath{\mathit{perm}\; (#1)\; \mathit{with}\; #2}}
\newcommand{\normalize}[3]{\ensuremath{\mathit{normalize} \; (#1, #2, #3)}}
\newcommand{\sep}{\ensuremath{\; | \;}}
\newcommand{\canonizer}{\ensuremath{\mathit{Canonizer}}}
\newcommand{\bibtex}{\textsc{Bib}\TeX{}}
\newcommand{\get}{\ensuremath{\mathit{get}}}
\newcommand{\lput}{\ensuremath{\mathit{put}}}
\newcommand{\create}{\ensuremath{\mathit{create}}}
\newcommand{\eqrel}[1]{\ensuremath{\equiv_{#1}}}

% Evaluation AST Metrics
\newcommand{\QRESize}{\textbf{QS}}
\newcommand{\CanonizerAndSpecSize}{\textbf{TCS}}
\newcommand{\LensAndSpecSize}{\textbf{TLS}}

% Evaluation Runtime Metrics
\newcommand{\SystemOnBenchmarks}{\textbf{MM}}
\newcommand{\SystemOnOptician}{\textbf{MO}}
\newcommand{\OpticianRuntime}{\textbf{OO}}

\newcommand{\Name}{Optometrist}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\mainmatter              % start of a contribution
%
\title{Synthesizing Quotient Lenses}
%
\titlerunning{Synthesizing Quotient Lenses}  % abbreviated title (for running
% head)                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{}
%
\authorrunning{} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
\tocauthor{}
%
\institute{}

\maketitle              % typeset the title of the contribution

\begin{abstract} 

  {\em Quotient lenses} express bidirectional transformations between data
  formats, where the inputs to the transformation are considered modulo some
  equivalence relation.  Such lenses save the programmer from having to write
  two expressions and satisfy strong ``lens laws'' that ensure that the forward
  and backward transformations interact well.  The use of quotients allows the
  programmer to ignore ``inessential'' differences in the data, such as the
  amount whitespace or the ordering of fields.

  However, quotient lenses are often difficult to program.  The programmer has
  to give a specification for the data on each side of the lens and a separate
  specification for the equivalence relations defined on the data. The
  programmer must also manually implement a lens program that maps between the
  specifications while respecting the equivalence relations---this is itself a
  challenging task thanks to the restrictions on how lenses can be combined
  while still satisfying the lens laws.

This paper addresses both of these challenges. First, we propose the
language of {\em Quotient Regular Expressions}, or QREs, which 
define a broad class of equivalence relations
directly on regular languages using a compact and convenient notation. This
eliminates the need to specify the data and the equivalence relation on the data
separately. We then define {\em QRE lenses}, a class of quotient
lenses that are typed using QREs, and show how to {\em synthesize} QRE lenses
from their QRE types and a set of input-output examples. Finally, we
demonstrate the applicability of this approach by synthesizing QRE lenses
between several real-world data formats from the {\tt data.gov} database.
\end{abstract}

\section{Introduction}
{\em Bidirectional programming languages} such as
Boomerang~\cite{boomerang}, Augeas~\cite{augeas}, XSugar~\cite{xsugar},
biXid~\cite{bixid} and X/Inv~\cite{xinv}enable a programmer to express a
transformation that maps some input data to some output data, as well as a
transformation that maps the output data back into the input data in a single
expression. An example of a {\em bidirectional transformation} which we shall
revisit severally in this paper is a program which converts citation records
such as
\begin{verbatim}
@Book {conway,
  Author = {Conway, J. H.},
  Title = {Regular Algebra and Finite Machines},
}
\end{verbatim}

\noindent stored in the \bibtex{} format to their equivalent representation 
\begin{verbatim}
%0 Book
%T Regular Algebra and Finite Machines
%A Conway, J. H.
%F conway
\end{verbatim}

\noindent in the EndNote format, and vice versa.

Bidirectional programs have also been called {\em lenses}. Formally, Foster et
al~\cite{foster} defined a lens $\ell$ that maps between an ``abstract" {\em
source} $S$ and a ``concrete" {\em view} $V$ to be a triple of functions
\begin{align*}
\ell.get &: S \longrightarrow V\\
\ell.put &: V \longrightarrow S \longrightarrow S\\
\ell.create &: S \longrightarrow V
\end{align*} 

\noindent satisfying the equations
\begin{align*}
\ell.\lput \; (\ell.\get \; s) \; s &= s\\
\ell.\get \; (\ell.\lput \; v \; s) &= v\\
\ell.\lput \; (\ell.\create \; v) &= v\\
\end{align*}

The $\get$ function presents a view of the data from the source, the
$\lput$ function enables an updated view to be folded back into the source, and
the $\create$ component produces a copy of the source from a view, using
defaults to fill in information that may have been discarded by the $\get$
function in producing the view. The first law states that the $\lput$ function
must restore all the information discarded by $\get$ when its arguments are an
abstract structure and a concrete structure that generates the very same
abstract structure. The second and third laws state that $\lput$ and $\create$
must propagate all of the information contained in their abstract arguments to
the concrete structure they produce. These laws express fundamental expectations
about how the components of a lens should work together.

However, the constraints that are imposed by the lens laws are sometimes too
strict. For instance, the programmer may wish to ignore updates to the data
that only change the order of fields, or add whitespace characters that in
reality are not part of the data. Foster et al therefore proposed
\textit{quotient lenses} ~\cite{quotient} as a solution to this problem
Quotient lenses, which are implemented as a refinement of the bidirectional
string processing language Boomerang, enable a programmer to write lenses which
transform data that is quotiented out by an equivalence relation, so that
records which are equivalent to each other modulo this relation are considered
the same by the underlying lens.

\sam{Go over quotient lens laws?}

Unfortunately, quotient lenses are sometimes difficult to program in Boomerang,
firstly because the programmer has to give a specification for the data as well
as give a separate specification for the equivalence relations defined on the
data. For example, suppose that the programmer wants to program the \bibtex{} to
EndNote transformation in such a way that the program allows for any of two
representations of the authors name (e.g. ``Conway, J. H." and ``Conway J. H"),
ignores the order in which the author and title fields occur in each record,
and allows for arbitrary amounts of whitespace in between the author and title
fields. These rules allow for these two \bibtex{} citation records to be
considered the same,

\begin{verbatim}
@Book {conway,
  Author = {Conway, J. H.},
  Title = {Regular Algebra and Finite Machines},
}

@Book{conway,
    Title = {Regular Algebra and Finite Machines},
        
    Author = {Conway J. H.},
}
\end{verbatim}

with the EndNote records having a similar equivalence relation defined on them.

In Boomerang, equivalence relations are expressed using {\em canonizers}
which are functions that map each element of a regular language to a
canonical representation of that element. Therefore, in order for the programmer
to give a specification for the \bibtex{} records, then the programmer
has to write a regular expression which matches all possible representations of
\bibtex{} records, and then program a set of canonizers which does the job of
quotienting the data. This often makes the code verbose and error-prone.

\sam{TODO: PUT BOOMERANG CANONIZERS HERE!}

To address this issue, we propose the language of {\em Quotient Regular
Expressions} or QREs, which enables the programmer to explicitly define a broad
class of equivalence relations directly on regular languages using a compact
and convenient notation, and hence negates the need to specify the data and the
equivalence relation on the data separately. For example, a QRE which
specifies the equivalence relation on the \bibtex{} citation records is as
follows:

\begin{verbatim}
let bib_author  = 
"author = {" . squash bib_space_names -> bib_comma_names using 
(get (synth bib_space_names <=> bib_comma_names)) . "}"

let bib_ignore_wsp =  project ("," . [ \n\t\r]* ) -> ",\n"

let bib_perm : canonizer = perm (label, bib_author, bib_title) with
bib_ignore_wsp

let bibtex  = "@book{" . bib_perm . "}"
\end{verbatim}

\sam{Should we have a special construct like squash-synth(R, R') in addition to
squash(R, R', l), or maybe even just have only squash-synth(R, R')?}

The first expression specifies the author field as
having one of two representations (\verb!bib_space_names! and
\verb!bib_comma_names!), with the \verb!bib_comma_names! being the
canonical representation and the expression 

\noindent \verb!(get (synth bib_space_names <=> bib_comma_names))! giving the
function which converts names described by \verb!bib_space_names! to their canonical
form described  by \verb!bib_comma_names!.

The second expression specifies the regular language which is a comma followed
by arbitrary occurences of whitespace characters quotiented by the equivalence
relation which makes all members of this language equivalent, with the canonical
representation being a comma followed by a newline character.

The third expression specifies that the label, title and author fields
are can occur in any order, with each of these fields separated by a comma and
arbitrary amounts of whitespace. The canonical representaion is that in which
the label, author and title fields occur in that order, separated by a comma and
a newline.

However, even though QREs enable the programmer to specify the data as well as
the equivalence relation on the data in the same expression, the programmer
still has to manually program the underlying lens which maps the equivalence
classes of the \bibtex{} records to the equivalence classes of the EndNote
records

\sam{TODO: PUT BIJECTIVE LENS HERE!},

\noindent task which is itself challenging and erro-prone.

Therefore, to address this challenge we demonstrate how to {\em synthesize}
quotient lenses from a pair of QREs and a set of input-output example pairs. Our
key insight is to reduce the problem of synthesizing QRE lenses to the problem
of synthesizing {\em bijective lenses}, a problem which we solved in out prior
work ~\cite{popl18}.

Our approach is to define a class of {\em QRE lenses} which are the same as
bijective lenses with canonizers at the ends. That is, a QRE lens uses the
source QRE to compute a unique representative for the data modulo the
equivalence relation defined by the QRE before applying a bijective lens to
this representative in the forward direction, and operates similarly same in the
backward direction, but using the view QRE.

\sam{TODO: PUT LENS WITH CANONIZERS ON THE EDGE DIAGRAM HERE!}

One potential pitfall with QRE lenses is that the composition of QRE lenses may
not have the normal form of a bijective lens with canonizers on the ends:

\sam{TODO: PUT COMPOSITION DIAGRAM HERE!}

Our main technical contribution in this paper is a proof that QRE lenses are
closed under left quotienting, right quotienting, composition, and regular
combinators. This proof will allow justify our approach for synthesizing
quotient lenses so that the programmer can simply type

$$\mathit{synth} \; \verb!bibtex! \; \verb!endnote!$$

to derive a quotient lens that does the \bibtex{} to EndNote transformation.

In summary, our main contributions are:
\begin{enumerate}
\item We introduce a novel language of {\em Quotient Regular Expressions}
(QREs) that provide compact, convenient notation for a natural and useful
class of equivalence relations on regular languages (Section~\ref{QRE}).
\item We define a language of {\em QRE lenses}, a form of quotient lenses
whose types are given by QREs.  Our main technical contribution is a normal
form for QRE lenses and a proof that QRE lenses in normal form are closed
under left quotienting, right quotienting, composition, and regular
operators (Section~\ref{QRE-lenses}).
\item Using this normal form, we reduce the problem of {\em synthesizing}
  QRE lenses from their QRE types and a set of examples to the previously studied
  problem of synthesizing bijective lenses between regular languages 
  (Section~\ref{synth}).
\item We extend the Boomerang {\em implementation} with QREs, QRE lens operators,
  and QRE lens synthesis and demonstrate its applicability by using it to
  synthesize QRE lenses between several real-world data formats from the
  {\tt data.gov} database (Section~\ref{impl}).
\end{enumerate}
Sections~\ref{relwork} and~\ref{concl} discuss related and future work.

\section{Quotient Regular Expressions}
\label{QRE}

This section introduces Quotient Regular Expressions or QREs. QREs are regular
expressions augmented with syntax that lets them simultaneously express an
equivalence relation on the language described by the regular expression.

For example, suppose that the programmer wishes to write a regular expression
which describes \bibtex{} citation records such as:
\begin{verbatim}
@Book {conway,
  Author = {Conway, J. H.},
  Title = {Regular Algebra and Finite Machines},
}
\end{verbatim}

Each record may be represented in many different ways. Firstly, the author's
name can have the last name followed by a comma, and then the
first and second names separated by a space, or the last name, first name and
second name separated by spaces in between them. For example, each of these
\bibtex{} records is equivalent to the other:
\begin{verbatim}
@Book {conway,
  Author = {Conway, J. H.},
  Title = {Regular Algebra and Finite Machines},
}
\end{verbatim}
\begin{verbatim}
@Book {conway,
  Author = {Conway J. H.},
  Title = {Regular Algebra and Finite Machines},
}
\end{verbatim}

Secondly, the author and title fields may occur in either order:
\begin{verbatim}
@Book {conway,
  Author = {Conway, J. H.},
  Title = {Regular Algebra and Finite Machines},
}
\end{verbatim}
\begin{verbatim}
@Book {conway,
  Title = {Regular Algebra and Finite Machines},
  Author = {Conway, J. H.},
}
\end{verbatim}
Thirdly, the title and author records can be separated by arbitrary amounts of
whitespace characters. For example, if the title field occurs first, then the
author field may occur not on the line immediately below the title field, but
instead on the second line below the title field:
\begin{verbatim}
@Book {conway,
  Title = {Regular Algebra and Finite Machines},
  
  Author = {Conway, J. H.},
}
\end{verbatim}
In the example above, a \bibtex{} record may have different
representations for three different reasons. The first reason
is that the author's name can have the last name followed by a comma and then
the first and second names separated by a space, or the last name, first name and
second name separated by spaces in between them. The $\squash{R}{R'}{f}$ QRE
enables the programmer to choose between the representations described by $R$
and $R$', provided that they can provide a function $f$ that maps data stored in
the first format to data stored in the second format. In this example we have
the two regular expressions

\begin{align*}
  \mathtt{COMMA\_NAME} &= \mathtt{NAME} \cdot ``," \cdot \mathtt{NAME} \cdot ``
                         \quad " \cdot \mathtt{NAME}\\
  \mathtt{SPACE\_NAME} &= \mathtt{NAME} \cdot ``," \cdot \mathtt{NAME} \cdot ``
                         \quad " \cdot \mathtt{NAME}\\
\end{align*}

and the bijective lens 
$$ \ell = (\mathit{copy} \; \mathtt{COMMA\_NAME}) \cdot (\mathit{ins} \; ``,")
\cdot (\mathit{del} \; `` \quad") \cdot (\mathit{copy} \; \mathtt{COMMA\_NAME})
\cdot (\mathit{copy} \; \mathtt{COMMA\_NAME})$$
therefore the QRE
$$\mathtt{AUTHOR}
=
``\text{Author
  = \{}" \cdot \squash{\mathtt{COMMA\_NAME}}{\mathtt{SPACE\_NAME}}{\ell.get}
\cdot ``\}"$$ enables the programmer to express the fact that the two different
representations of the author's name are equivalent, with the
$\mathtt{COMMA\_NAME}$ representation chosen as the canonical representation,
and the function $\ell.get$ giving the ``canonizing'' function which converts
data in the $\mathtt{SPACE\_NAME}$ format to its $\mathtt{COMMA\_NAME}$
representation. The $\squash{R}{R'}{f}$ has the added advantage that if the
transformation from $R$ to $R'$ can be expressed by a bijective lens,
then the programmer may attempt to \textit{synthesize} the lens from $R$ to $R'$
because of our previous work where we demonstrated how to synthesize bijective
lenses from a pair of regular expressions and a set of input-output example
pairs:
$$\mathtt{AUTHOR}
=
``\text{Author
  = \{}" \cdot \squash{\mathtt{COMMA\_NAME}}{\mathtt{SPACE\_NAME}}{\mathit{synth}
  \; \mathtt{COMMA\_NAME} \; \mathtt{SPACE\_NAME}} \cdot ``\}"$$

The second reason that a record may have two different representations is that
the author and title fields may occur in a different order, and the third
reason is that the author and title fields may have arbitrary occurences of
whitespace characters in between them. The $R \mapsto s$ and $\perm{q_1,
  \ldots, q_n}{q}$ QREs enable the programmer to handle each of these cases:
$$\perm{\re{AUTHOR}, \re{TITLE}}{((``," \cdot \re{WHITESPACE}^*) \mapsto \string
  ``, \backslash n")}$$
This QRE enables the programmer to consider any permutation of the author and
title fields interspersed with a comma and arbitrary whitespace as equivalent.
The $((``," \cdot \re{WHITESPACE}^*) \mapsto \string ``, \backslash n")$
subexpression is itself a QRE that denotes that all string $s$ which consists
of a comma $``,"$ followed by any number of whitespace should be considered
equivalent, with the canonical representative being the string $\string ``,
\backslash n"$. The canonical representation of \bibtex{} records is that in
which the author field occurs the title field with a comma then a newline
character separating the two.

The regular combinators for QREs i.e. $\cdot$ (concatenation), $|$ (union) and
$*$ (iteration) behave like the regular combinators for regular languages. For
instance, if the QRE for matching a \bibtex{} \; record is named
$\mathtt{RECORD}$, then the QRE for matching two records is $\mathtt{RECORD}
\cdot \mathtt{RECORD}$, the QRE for matching one or two records is $\mathtt{RECORD}
\sep (\mathtt{RECORD} \cdot \mathtt{RECORD})$ and the QRE for matching any
number of QRE records in $\mathtt{RECORD}^*$.

The $\normalize{R}{R'}{f}$ QRE is the most general QRE in that for each of the
the other QREs $q$, there exist regular expressions $R, R'$ and a surjective,
idempotent function $f:\mathcal{L}(R) \longrightarrow \mathcal{L}(R')$ such that
$q$ $\normalize{R}{R'}{f}$ each denote the same equivalence relation on the
same regular language. $\normalize{R}{R'}{f}$ enables the programmer to
provide a canonizing function from $\mathcal{L}(R)$ to $\mathcal{L}(R')$,
with the equivalence class on $\mathcal{L}(R)$ being the equivalence relation
defined by the {\em fibres} of $f$ (i.e. $r \sim r'$ if and only if $f(r) =
f(r'))$. The canonizing function is required to be surjective and idempotent.
The $\normalize{R}{R'}{f}$ combinator therefore enables the programmer to express
equivalence relations which are difficult to express, or which cannot be
expressed using the other combinators.

In summary each QRE $q$ enables us to express
\begin{enumerate}
\item a regular expression $W(q)$ (the ``whole'' of $q$),
\item an equivalence relation $\eqrel{q}$ on $\mathcal{L}(W(q))$,
\item a regular expression $K(q)$ (the ``kernel'' of $q$)
  such that $\mathcal{L}(K(q))$ forms a complete set of representatives for
  $\eqrel{q}$, and
\item a ``canonizing'' function $\canonizer(q):\mathcal{L}(W(q))
  \longrightarrow \mathcal{L}(K(q))$ which given any $w \in \mathcal{L}(W(q))$,
  computes $\canonizer(q)(w)$ as the unique $k$ in $\mathcal{L}(K(q))$ such that
  $k$ is equivalent to $w$ mod $\eqrel{q}$
\end{enumerate}
Observe that since $\canonizer(q)$ computes $\canonizer(q)(w)$ as the unique
$k$ in $\mathcal{L}(K(q))$ such that $w$ is equivalent to $k$ mod $\eqrel{q}$,
then the equivalence classes of $\eqrel{q}$ are the same as the fibres of
$\canonizer(q)$.
\subsection{Syntax of QREs}
The language of Quotient Regular Expressions (QREs) is given by the following
grammar:
\begin{align*}
  q := \; &R \sep R \mapsto s \sep \squash{R}{R'}{f} \sep
            \perm{q_1, \ldots, q_n}{q} \;  | \; \normalize{R}{R'}{f}\\
          &q' \circ q \sep q \cdot q' \sep (q \sep q') \sep q^*,
\end{align*}
where $R$ ranges over regular expressions, $f$ ranges over functions between
regular languages, and $s$ ranges over character strings.

\subsection{Semantics of QREs}
\subsubsection{Preliminaries}
Let $q, q'$ be QREs. When applying the regular combinators to QREs, we require
that if a string $s$ matches any of the regular expressions $W(q) \cdot W(q')$,
$W(q) \sep W(q')$, $W(q)^*$, $K(q) \cdot K(q')$,
$K(q) \sep K(q')$, $K(q)^*$, then $s$ matches that regular expression in
only one way. This unambiguity condition is called {\em strong unambiguity},
and is necessary, firstly because it ensures that the canonizing function of a
QRE is well-defined. For example if $\mathtt{RECORD}$ is the QRE for a \bibtex
record in our \bibtex{} to and $W(\mathtt{ENDNOTE} \cdot \mathtt{ENDNOTE})$ is not
unambiguous, that is there is a string $s$ such that $s = s_1 \cdot s_2 =
{s_1}' \cdot {s_2}'$ with $s_1, s_2, {s_1}', {s_2}' \in W(\mathtt{ENDNOTE} \cdot
\mathtt{ENDNOTE})$, then the canonizer $f$ for $\mathtt{ENDNOTE} \cdot
\mathtt{ENDNOTE}$ may not be well defined since we are not guaranteed that
$f(s_1) \cdot f(s_2) = f({s_1}') \cdot f({s_2}')$. We also require that the
regular combinators applied to the kernels are unambiguous since the underlying
lenses will end up operating on the kernels, and these lenses impose the same
restrictions for similar reasons.

To this end, we say that regular expressions $R$ and $S$ are
\textit{unambiguosly concatenable}, written $R \cdot^! S$ if for all strings
$r, r' \in \mathcal{L}(R)$ and $s, s' \in \mathcal{L}(S)$, if $r \cdot s = r'
\cdot s'$, then $r = r'$ and $s = s'$. We say that a regular expression $R$ is
\textit{unambiguosly iterable}, written $R^{*!}$ if for all strings $r_1,
\ldots, r_m$ and $r'_1, \ldots, r'_n \in \mathcal{L}(R)$, if $r_1 \cdot \ldots
\cdot r_m = r'_1 \cdot \ldots \cdot r'_n$, then $m = n$ and $r_i = r'_i$.

We say that a regular expression $R$ is \textit{strongly unambiguous} if and
only if (1) $R = \varnothing$, or (2) $R = S_1 \cdot S_2$ with $S_1, S_2$
strongly unambiguous and $S_1 \cdot^! S_n$, or (3) $R = S_1 \sep S_2$ with
$S_1, S_2$ strongly unambiguous and $\mathcal{L}(S_1) \cap \mathcal{L}(S_2) =
\varnothing$, or (4) $R = S^*$ with $S$ strongly unambiguous and $S^{*!}$.

The semantics for QREs that formally define the whole language $W(q)$, the
kernel language $K(q)$, the equivalence relation $\eqrel{q}$ and the
canonizing function $\canonizer(q)$ are given in
Figures~\ref{fig:wk},~\ref{fig:relations} and~\ref{fig:canonizers}.
\begin{figure}[t]
  \centering
  \[
    \begin{array}{l@{\quad}l@{\quad}l}
      
      q & W(q) & K(q) \\ \hline
      R & R & R \\
      R \mapsto s & W(q) & s \\
      \squash{R}{R'}{f} & R \sep R' & R' \\
      \normalize{R}{R'}{f} & R & R' \\
      q_1 \circ  q_2 & W(q_2) & K(q_1) \\
      q_1 \cdot q_2 & W(q_1) \cdot W(q_2) & K(q_1) \cdot K(q_2) \\
      q_1 \sep q_2 & W(q_1) \sep W(q_2) & K(q_1) \sep K(q_2) \\
      q^* & W(q)^* & K(q)^* \\
    \end{array}
  \]
  \[
    \begin{array}{r@{\quad}l}
      W( \perm{q_1, \ldots, q_n}{q} ) = &
                                          \bigcup \limits_{\sigma \in S_n} W(q_{\sigma(1)}) \cdot W(q) \cdot \ldots \cdot
                                          W(q) \cdot W(q_{\sigma(n)})
      \\
      K( \perm{q_1, \ldots, q_n}{q} ) = &
                                          K(q_1) \cdot K(q) \cdot \ldots \cdot K(q) \cdot K(q_n) 
    \end{array}
  \]
  \caption{Whole and Kernel Regular Expressions\bcp{left-justify columns,
      and try putting the last two clauses into the same format as the
      others (using $\mathit{qq} = ...$ and maybe reducing spacing around
      cdots, etc.)}}
  \label{fig:wk}
\end{figure}

\begin{figure}[t]
  \centering
  \[
    \begin{array}{l@{\quad}l@{\quad}l} 
      w \; \equiv_R \; w' &\iff& w = w \\
      w \; \equiv_{R \mapsto s} \; w' \text{ for all }w, w'\\
      w \; \equiv_{\squash{R}{R'}{f}} \; w' &\iff& f(w) = w'
                                                   \text{ or } w = w' \\
      w \; \equiv_{\normalize{R}{R'}{f}} \; w' &\iff&
                                                      f(w)=f(w') \text{ or }w = w'\\
      w \; \equiv_{q_2 \circ q_1} \; w' &\iff& \exists k, k' \in
                                               \mathcal{L}(K(q_2)) \text{ such that } w \; \equiv_{q_1} \; k, \; w' \;
                                               \equiv_{q_1} \; k', \text{ and } k \; \equiv_{q_2} \; k'\\
      w \; \equiv_{q_1 \cdot q_2} \; w'  &\iff& w = r_1
                                                \cdot r_2, \; w' = {r'}_1 \cdot {r'}_2 \text{ with } r_1 \; \equiv_{q_1}
                                                \; {r'}_1, \; r_2 \; \equiv{q_n} \; {r'}_2\\
      w \; \equiv_{q' \sep q} \; w' &\iff& w \; \equiv_{q_1} \; w'
                                           \text{ or } \; w \; \equiv_{q_2} \; w'\\
      w \; \equiv_{q*} \; w' &\iff& w = r_1 \cdot \ldots \cdot r_n, \; w'
                                    = {r'}_1 \cdot \ldots \cdot {r'}_n \text{ and } r_i \equiv_{q} \; {r'}_i
      \\
      w \; \equiv_{\perm{q_1, \ldots, q_n}{q}} \; w' &\iff& w = r_{\sigma(1)}
                                                            \cdot s_1 \cdot \ldots \cdot s_{n-1} \cdot r_{\sigma(n)}, \;
                                                            w' = {r'}_{\theta(1)} \cdot s'_1 \cdot \ldots \cdot s'_{n-1}
                                                            \cdot {r'}_{\theta(n)} \\
                          & & \text{ for some } \sigma, \theta \in S_n, \text{ with } r_i \;
                              \equiv_{q_i} \; r'_i \text{ and } s_k \; \equiv_{q} \; s'_{k}
    \end{array}
  \]
  \caption{QRE Equivalence Relations}
  \label{fig:relations}
\end{figure}
\begin{figure}[t]
  \begin{center}
    \[
      \begin{array}{l@\quad l @\quad l} 
        \canonizer(R) &=& id_{\mathcal{L}(R)} \\
        \canonizer(R \mapsto s)(w) &=& s\\
        \canonizer(\squash{R}{R'}{f})(w) &=& 
                                             \begin{cases}
                                               f(w) & \text{if } w \in \mathcal{L}(R)\\
                                               w & \text{otherwise}
                                             \end{cases}\\
        \canonizer(\normalize{R}{R'}{f}) &=& f\\
        \canonizer(q' \circ q) &=& \canonizer(q') \circ \canonizer(q)\\
        \canonizer(q' \cdot q) &=& \canonizer(q') \cdot \canonizer(q)\\
        \canonizer(q_1 \sep q_2)(w) &=& 
                                        \begin{cases}
                                          \canonizer(q_1)(w) & \text{if } w \in \mathcal{L}(W(q_1))\\
                                          \canonizer(q_2)(w) & \text{if } w \in \mathcal{L}(W(q_2))\\
                                        \end{cases}\\
        \canonizer(q^*) &=& \canonizer(q)^* \\
      \end{array}
    \]
  \end{center}
  $\canonizer(\perm{q_1, \ldots, q_n}{q})(r_{\sigma(1)}
  \cdot s_1 \cdot \ldots \cdot s_{n-1} \cdot r_{\sigma(n)}) \newline
  = (\canonizer(q_1)(r_1)) \cdot (\canonizer(q)(s_1)) \cdot \ldots \cdot
  (\canonizer(q_n)(r_n))$
  \caption{QRE canonizers}
  \label{fig:canonizers}
\end{figure}
\begin{figure}[t]
  \centering
  \begin{prooftree}
    \AxiomC{$R$ is strongly unambiguous}
    \UnaryInfC{$\mathit{id}(R)$ is well formed}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{$s \in W(q)$}
    \UnaryInfC{$R \mapsto s$ is well formed}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{$\mathcal{L}(R) \cap \mathcal{L}(R') = \varnothing$}
    \AxiomC{$f : \mathcal{L}(R) \longrightarrow \mathcal{L}(R')$}
    \BinaryInfC{$squash(R, R', f)$ is well formed}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{${\substack{\forall \sigma \neq \theta, \; W(q_{\sigma(1)}) \cdot W(q)
          \cdot \ldots \cdot W(q_{\sigma(n)})\\ \cap W(q_{\theta(1)}) \cdot W(q)
          \cdot \ldots \cdot W(q_{\theta(n)}) =\varnothing}}$}
    \AxiomC{$q_i, q$ are well formed}
    \AxiomC{$\forall \sigma, \; K(q_{\sigma(1)}) \cdot^! K(q) \cdot^! \ldots 
      \cdot^! K(q_{\sigma(n)})$}
    \TrinaryInfC{$\perm{q_1, \ldots, q_n}{q}$ is well formed}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{$\mathcal{L}(R') \subseteq \mathcal{L}(R)$}
    \AxiomC{$f : \mathcal{L}(R) \longrightarrow \mathcal{L}(R')$}
    \AxiomC{$f$ is surjective}
    \AxiomC{$f = f^2$}
    \QuaternaryInfC{$normalize \; (R,R', f)$ is well formed}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{$q$ is well formed}
    \AxiomC{$q'$ is well formed}
    \AxiomC{$K(q) = W(q')$}
    \TrinaryInfC{$q' \circ q$ is well formed}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{$q$ is well formed}
    \AxiomC{$q'$ is well formed}
    \AxiomC{$W(q) \cdot^! W(q')$}
    \AxiomC{$K(q) \cdot^! K(q')$}
    \QuaternaryInfC{$q \cdot q$ is well formed}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{$q$ is well formed}
    \AxiomC{$q'$ is well formed}
    \AxiomC{$W(q) \cap W(q') = \varnothing$}
    \TrinaryInfC{$q \cdot q$ is well formed}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{$q$ is well formed}
    \AxiomC{$W(q)^{*!}$}
    \AxiomC{$K(q)^{*!}$}
    \TrinaryInfC{$q^*$ is well formed}
  \end{prooftree}
  \caption{QRE Inference Rules\bcp{Maybe some or all of these can be
      suppressed in the ``short version'' of the paper}\bcp{No, cancel
      that.  These are important.  And we need to comment about the decidability
      issues involving normalize.  (And a note that we don't really use
      normalize, but rather introduce more specialized instances.)}}
  \label{fig:qrerules}
\end{figure}
The theorem below confirms that the semantics of QREs are consistent with their
intended behaviour:
\begin{theorem}
  If $q$ is a well formed QRE, then
  \begin{enumerate}
  \item $W(q)$ and $K(q)$ are well defined regular expressions,
  \item  $\eqrel{q}$ is an equivalence relation on $\mathcal{L}(W(q))$,
  \item  $\mathcal{L}(K(q))$ forms a complete set of representatives for
    $\eqrel{q}$,
  \item $\canonizer(q):\mathcal{L}(W(q)) \longrightarrow \mathcal{L}(K(q))$ is a
    well-defined function, and
  \item  given any $w \in \mathcal{L}(W(q))$, $\canonizer(q)(w)$ is the unique
    $k$ in $\mathcal{L}(K(q))$ such that $k$ is equivalent to $w$ modulo
    $\eqrel{q}$.
  \end{enumerate}
\end{theorem}

\section{QRE Lenses}
\label{QRE-lenses} 
As we have seen, QREs enable the programmer to express a regular expression $R$
as well as an equivalence relation on $\mathcal{L}(R)$. QREs are therefore a
good \textit{specification} language for quotient lenses. In this section of the
paper, we introduce \textit{QRE Lenses}. QRE lenses are quotient lenses based on
the Boomerang quotient lens combinators, but which use QREs to describe their
source and view types.

Our approach in defining QRE lenses is as follows. Let $c, c'$ be QREs. Given a
bijection $\ell : K(c) \Leftrightarrow K(c')$, we may define a quotient lens $q
: W(c)/\eqrel{c} \Leftrightarrow W(c')/\eqrel{c'}$ by
\begin{equation}\label{normalform}
  q.get = \ell \circ \canonizer(c) \text{ and } q.put = \ell^{-1} \circ
  \canonizer(c'),
\end{equation}

A potential problem with this approach is that quotient lenses of this form may
not necessarily be closed under the action of the lens combinators. For
example, given two lenses $q$ and $q'$, the composition of $q' \circ q$ may not
be of this form.

Consequently, in order to define quotient lenses, we need to choose a class of
bijections that has just the right properties with respect to the quotient
lens combinators. Our choice is to use the class of \textit{bijective
  lenses} which we identified and studied in our previous work~\cite{popl18}.
Bijective lenses, which we briefly discuss in the next subsection, possess
the properties needed to ensure that all QRE lenses have the normal form
suggested in \cref{normalform}.

\subsection{Bijective Lenses}
Given regular expressions $R, S$ and equivalence
relations $\sim_R, \sim_S$ defined on $\mathcal{L}(R)$ and $\mathcal{L}(S)$
respectively, a \textit{bijective quotient lens} $q :
R/{\sim_R}{\Longleftrightarrow} S/{\sim_S}$ from $R$ to $S$ is
a pair of functions $q.get:
\mathcal{L}(R) \longrightarrow \mathcal{L}(S)$ and $q.put : \mathcal{L}(S)
\longrightarrow \mathcal{L}(R)$ such that
\begin{align*}
  q.put \; (q.get \; r) &\sim_R r\\
  q.get \; (q.put \; s) &\sim_S s
\end{align*}
Additionally the components of $q$ must respect $\sim_R$ and $\sim_S$ i.e.
if $r \sim_R r'$ and $s \sim_S s'$ then $q.get \; r \; \sim_S q.get \; r'$
and $q.put \; s \sim_R q.put \; s' \; s'$.

We define the set of \textit{bijective lenses} to be the set of bijections
between regular languages created from Boomerang lens combinators.
The syntax for the language of bijective lenses is given by
$$\ell := \mathit{id} \; (R) \sep const(s, s') \sep  swap(\ell,
\ell) \sep \ell \cdot \ell' \; |  \; (\ell \sep \ell') \sep \ell^* \;
| \; \ell \circ \ell',$$ where $R$ ranges over regular expressions and $s$
ranges over character strings.

The denotation of a lens $\ell$ is $\llbracket \ell \rrbracket \subseteq
\mathit{String} \times \mathit{String}$. If $(s_1, s_2) \in \llbracket \ell
\rrbracket$, then $\ell$ maps between $s_1$ and $s_2$.

\begin{align*}
  \llbracket R \rrbracket &= \{(r, r) \sep r \in \mathcal{L}(R)\}\\
  \llbracket swap(\ell, \ell') \rrbracket &= \{(s \cdot t, t' \cdot s') \sep
                                            (s, s') \in \llbracket \ell \rrbracket \text{ and } (t, t') \in \llbracket
                                            \ell' \rrbracket\}\\
  \llbracket \ell \cdot \ell' \rrbracket &= \{(s \cdot t, s' \cdot t) \sep
                                           (s, s') \in \llbracket \ell \rrbracket \text{ and } (t, t') \in \llbracket
                                           \ell' \rrbracket\}\\
  \llbracket \ell \sep \ell' \rrbracket &= \{(s \cdot t) \sep
                                          (s, t) \in \llbracket \ell \rrbracket \text{ or } (s, t) \in \llbracket
                                          \ell' \rrbracket\}\\
  \llbracket \ell^* \rrbracket &= \{(s_1 \cdot \ldots \cdot s_n, t_1 \cdot \ldots
                                 \cdot t_n) \sep (s_i, t_i) \in \llbracket \ell \rrbracket \text{ for } 1
                                 \leq i \leq n\}
\end{align*}

The $\mathit{const}(s, t)$ lens replaces the string $s$ with $t$ in the source
data in the forward direction, and $t$ with $s$ in the view data in the backward
direction. $\mathit{id}(R)$ applies the identity function to the source and view
in $\mathcal{L}(R)$ in both directions. The composition lens $\ell' \circ \ell$
applies $\ell$ followed by then $\ell'$ to the source in the forward direction,
and applies $\ell'$ followed by $\ell$ to the view in the backward direction.
The lens $\ell \cdot \ell'$ first splits the string $s$ into $s_1$ and $s_2$,
applies $\ell$ and $\ell'$ to $s_1$ and $s_2$ to get $t_1$ and $t_2$
respectively, then concatenates $t_1$ and $t_2$ and returns $t_1 \cdot t_2$ as
the final result in the forward direction. $\ell \cdot \ell'$ operates
similarly in the backward direction, but with $s, s_1$ and $s_2$ substituted
for $t, t_1$ and $t_2$. The $\mathit{swap} \; (\ell, \ell')$ lens operates
like $\ell \cdot \ell'$, except that it swaps $t_1$ and $t_2$ before
concatenating the two for a final result of $t_2 \cdot t_1$ in the forward
direction. In the backward direction, $\mathit{swap}(\ell, \ell')$ first undoes
the swap, then proceeds as expected. The $\ell \; | \; \ell'$ lens
chooses to apply $\ell$ or $\ell'$ depending on whether the source
(resp. view) data is matched by $\ell$ or $\ell'$ in the forward (resp.
backward direction. The $\ell^*$ lens splits the string $s$ into strings $s_1,
\ldots, s_n$, applies $\ell$ to each $s_i$ to get $t_i$, and then concatenates
each of the $t_i$'s for a final result of $t_1 \cdot \ldots \cdot t_n$ in the
forward direction. $\ell^*$ operates similarly in the backward direction, but
with $s, s_i$ substituted for $t, t_i$.

Each bijective lens $\ell$ has a type $\ell : R \Leftrightarrow S$ where $R$ and
$S$ are regular expressions. If $\ell : R \Leftrightarrow S$, then the source
type of $\ell$ is $\mathcal{L}(R)$ and the view type of $\ell$ is
$\mathcal{L}(S)$. Interestingly, with the bijective lens type system, a lens
$\ell : R \Leftrightarrow S$ can also be considered to be of type $\ell : R'
\Leftrightarrow S'$ provided that $R$ (resp. $S$) can be proven to be
equivalent to $R'$ (resp. $S$) from the star-semiring axioms. The typing rules
for bijective lenses are given in Figure~\ref{fig:lensrules}. 

\begin{figure}[t]
  \begin{prooftree}
    \AxiomC{$s_1 \in \Sigma^*$}
    \AxiomC{$s_2 \in \Sigma^*$}
    \BinaryInfC{$\mathit{const} \; (s_1, s_t): s_1 \Leftrightarrow s_2$}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{$R$ is strongly unambiguous}
    \UnaryInfC{$\mathit{id} \; (R): R \Leftrightarrow R$}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{$\ell_1 : R_1 \Leftrightarrow S_1$}
    \AxiomC{$\ell_2 : R_2 \Leftrightarrow S_2$}
    \AxiomC{$R_1 \cdot^! R_2$}
    \AxiomC{$S_1 \cdot^! S_2$}
    \QuaternaryInfC{$\ell_1 \cdot \ell_2: R_1 \cdot R_2 \Leftrightarrow S_1 \cdot
      S_2$}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{$\ell_1 : R_1 \Leftrightarrow R_2$}
    \AxiomC{$\ell_2 : R_2 \Leftrightarrow R_3$}
    \BinaryInfC{$\ell_2 \circ \ell_1: R_1 \Leftrightarrow R_3$}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{$\ell_1 : R_1 \Leftrightarrow S_1$}
    \AxiomC{$\ell_2 : R_2 \Leftrightarrow S_2$}
    \AxiomC{$R_1 \cdot^! R_2$}
    \AxiomC{$S_2 \cdot^! S_1$}
    \QuaternaryInfC{$\mathit{swap} \; (\ell_1, \ell_2): R_1 \cdot R_2
      \Leftrightarrow S_2 \cdot S_1$}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{$\ell_1 : R_1 \Leftrightarrow S_1$}
    \AxiomC{$\ell_2 : R_2 \Leftrightarrow S_2$}
    \AxiomC{$\mathcal{L}(R_1) \cap \mathcal{L}(R_2) = \varnothing$}
    \AxiomC{$\mathcal{L}(S_1) \cap \mathcal{L}(S_2) = \varnothing$}
    \QuaternaryInfC{$\ell_1 \sep \ell_2: R_1 \sep R_2 \Leftrightarrow S_1 \sep S_2$}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{$\ell : R \Leftrightarrow S$}
    \AxiomC{$R^{*!}$}
    \AxiomC{$S^{*!}$}
    \TrinaryInfC{$\ell^*: R \Leftrightarrow S$}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{$\ell : R \Leftrightarrow S$}
    \AxiomC{$R \equiv R'$}
    \AxiomC{$S \equiv S'$}
    \TrinaryInfC{$\ell : R' \Leftrightarrow S'$}
  \end{prooftree}
  \caption{Bijective Lens Typing Rules}
  \label{fig:lensrules}
\end{figure}

\subsection{Syntax of QRE Lenses}
Having given a brief overview of the class of bijective lenses, we now introduce
the class of QRE lenses, whose language is given by following grammar:
$$ q := \mathit{lift}(\ell) \sep \mathit{lquot}(q, \ell) \sep
\mathit{rquot}(\ell, q) \sep q \cdot q' \sep (q \sep q') \sep q^* \sep q \circ q',$$
where $\ell$ ranges over bijective lenses.

The QRE lens combinators are inspired by the Boomerang lens combinators of the
same name. The $\mathit{lift}(\ell)$ quotient lens enables a bijective lens
$\ell$ to be considered a quotient lens where the equivalence relation applied
to the source and view types is the equality relation. The $\mathit{lquot}(c,
q)$ combinator takes a quotient lens $q$ and quotients the source data using
$c$, assuming that the source data forms a complete set of representatives for
the equivalence relation $\eqrel{c}$. The $\mathit{lquot}(q, c)$ does the same
but on the view data. The regular combinators $\cdot \; * \; |$ exhibit the
expected behaviour. \sam{Examples needed?}

The difference between QRE lenses and Boomerang quotient lenses is the typing
judgements. More concretely, each QRE lens $q$ has a type $q : c \Leftrightarrow
c'$ where $c, c'$ are QREs. In contrast, the approach used to type quotient
lenses in Boomerang is to classify equivalences according to whether they are
or are not the equality relation. This type system is based on two
observations: first, that most quotient lenses originate as lifted basic
lenses, and therefore have types whose equivalence relations are both equality;
and second, that equality is preserved by many of the quotient lens
combinators. Foster et al also discuss a second possible approach to typing
quotient lenses, where equivalence relations are represented by rational
functions that induce them. While this second approach is more refined than the
first, Boomerang favours the first approach since the second appears to be too
expensive to be useful in practice~\cite{quotientlenses}.

\subsection{Semantics of QRE Lenses}
As we mentioned earlier, every quotient lens $q$ has a type $q :
c \Longleftrightarrow c'$ where $c$ and $c'$ are QREs. The denotation
$\llbracket q \rrbracket$ of a QRE lens $q:c \Leftrightarrow c'$ is a quotient
lens $\llbracket q \rrbracket : W(c)/{\eqrel{c}} \Longleftrightarrow
W(c')/{\eqrel{c'}}$. The typing rules and denotation of QRE lenses are given in
Figure~\ref{fig:qlenssemantics}. The following theorem confirms that QRE lenses
exhibit the intended behaviour.

\begin{theorem}
  If there is a derivation $q:c \Leftrightarrow c'$ then
  $\llbracket q \rrbracket : W(c)/\eqrel{c} \Leftrightarrow W(c')/\eqrel{c'}$ is a
  well-defined quotient lens.
\end{theorem}

\begin{figure}[t]
  \centering
  \begin{prooftree}
    \AxiomC{$\ell : R \Leftrightarrow S$}
    \UnaryInfC{$\mathit{lift}(\ell): R \Leftrightarrow id(S)$}
  \end{prooftree}
  \begin{align*}
    \llbracket q \rrbracket.get &=  \llbracket \ell \rrbracket, \text{ and }\\
    \llbracket q \rrbracket.put &= \llbracket \ell \rrbracket^{-1}
  \end{align*}
  
  \begin{prooftree}
    \AxiomC{$q' : c'  \Leftrightarrow c''$}
    \AxiomC{$c$ is well formed}
    \AxiomC{$K(c) = W(c')$}
    \TrinaryInfC{$\mathit{lquot}(c, q'): c' \circ c \Leftrightarrow c''$}
  \end{prooftree}
  \begin{align*}
    \llbracket q \rrbracket.get  &= \llbracket q'
                                   \rrbracket.get \circ \canonizer(c)\\
    \llbracket q \rrbracket.put &= \llbracket q' \rrbracket.put
  \end{align*}

  \begin{prooftree}
    \AxiomC{$q' : c \Leftrightarrow c'$}
    \AxiomC{$c''$ is well formed}
    
    \AxiomC{$K(c'') = W(c')$}
    \TrinaryInfC{$\mathit{rquot}(q', c):c \Leftrightarrow c'' \circ c'$}
  \end{prooftree}
  \begin{align*}
    \llbracket q \rrbracket.get &= \llbracket q'
                                  \rrbracket.get\\
    \llbracket q \rrbracket.put &= \llbracket q'
                                  \rrbracket.put \circ \canonizer(c'')
  \end{align*}
  
  \begin{prooftree}
    \AxiomC{$q_1 : c \Leftrightarrow c'$}
    \AxiomC{$q_2 : c' \Leftrightarrow c''$}
    \BinaryInfC{$q_2 \circ q_1: c \Leftrightarrow c''$}
  \end{prooftree}
  \begin{align*}
    \llbracket q \rrbracket.get &= \llbracket q_2 \rrbracket.get\circ \llbracket
                                  q_1 \rrbracket.get, \text{ and }\\
    \llbracket q \rrbracket.put &= \llbracket q_1 \rrbracket.put \circ \llbracket
                                  q_2 \rrbracket.put
  \end{align*}

  \begin{prooftree}
    \AxiomC{$q' : c \Leftrightarrow c'$}
    \AxiomC{$W(c)^{*!}$ and $W(c')^{*!}$}
    \AxiomC{$K(c)^{*!}$ and $K(c')^{*!}$}
    \TrinaryInfC{${q'}^* : c^* \Leftrightarrow {c'}^*$}
  \end{prooftree}
  \begin{align*}
    \llbracket q \rrbracket.get &= (\llbracket q' \rrbracket.get)^*, \text{
                                  and }\\
    \llbracket q \rrbracket.put &= (\llbracket q' \rrbracket.put)^*
  \end{align*}

  \begin{prooftree}
    \AxiomC{$q_1 : c_1 \Leftrightarrow d_1 $}
    \AxiomC{$q_2 : c_2 \Leftrightarrow d_2$}
    \AxiomC{${\substack{W(c_1) \cdot^! W(c_2)\\ K(c_1) \cdot^! K(c_2)}}$}
    \AxiomC{${\substack{W(d_1) \cdot^! W(d_2)\\ K(d_1) \cdot^! K(d_2)}}$}
    \QuaternaryInfC{$q_1 \cdot q_2: c_1 \cdot c_2
      \Leftrightarrow d_1 \cdot d_2$}
  \end{prooftree}
  \begin{align*}
    \llbracket q \rrbracket.get &= \llbracket q_1 \rrbracket.get \cdot \llbracket
                                  q_2 \rrbracket.get, \text{ and }\\
    \llbracket q \rrbracket.put &= \llbracket q_1 \rrbracket.put \cdot \llbracket
                                  q_2 \rrbracket.put
  \end{align*}

  \begin{prooftree}
    \AxiomC{$q_1 : c_1 \Leftrightarrow d_1 $}
    \AxiomC{$q_2 : c_2 \Leftrightarrow d_2$}
    \AxiomC{$\mathcal{L}(W(c_1)) \cap \mathcal{L}(W(c_2)) = \varnothing$}
    \AxiomC{$\mathcal{L}(W(d_1)) \cap \mathcal{L}(W(d_2)) = \varnothing$}
    \QuaternaryInfC{$q_1 \sep q_2: (c_1 \sep c_2)
      \Leftrightarrow (d_1 \sep d_2)$}
  \end{prooftree}
  $$
  \llbracket q_1 \sep q_2 \rrbracket.get(s) = 
  \begin{cases}
    \llbracket q_1 \rrbracket.get (s) & \text{if } s \in \mathcal{L}(W(c_1))\\
    \llbracket q_2 \rrbracket.get (s) & \text{if } s \in \mathcal{L}(W(c_2))\\
  \end{cases}$$
  $$\llbracket q_1 \sep q_2 \rrbracket.put(s) = 
  \begin{cases}
    \llbracket q_1 \rrbracket.put (s) & \text{if } s \in \mathcal{L}(W(d_1))\\
    \llbracket q_2 \rrbracket.put (s) & \text{if } s \in \mathcal{L}(W(d_2))\\
  \end{cases}
  $$
  \caption{Denotation and Typing Rules for QRE Lenses}
  \label{fig:qlenssemantics}
\end{figure}

\subsection{Normal Forms of QRE Lenses}
Recall that our approach in defining QRE lenses is to have each QRE lens $q: c
\Leftrightarrow c'$ be such that 
\begin{align*}
  \llbracket q \rrbracket.get &= \ell \circ \canonizer(c)\\
  \llbracket q \rrbracket.put &= \ell^{-1} \circ
                                \canonizer(c')
\end{align*}
for some bijective lens $\ell$. We now provide a proof that all QRE lenses are
of this form.
\begin{theorem}\label{normal form}
  If there is a derivation $q : c \Leftrightarrow c'$, then there exists a
  bijective lens $\ell : K(c) \Leftrightarrow K(c')$ such that
  \begin{align*}
    \llbracket q \rrbracket.get &= \llbracket \ell \rrbracket\circ \canonizer(c)\\
    \llbracket q \rrbracket.put &= \llbracket \ell \rrbracket^{-1} \circ
                                  \canonizer(c')
  \end{align*}
\end{theorem}
\begin{proof}
  Assume that $q : c \Leftrightarrow c'$. We proceed by induction over the
  derivation $q : c \Leftrightarrow c'$.
  \begin{enumerate}
  \item
    $\mathit{lift}(\ell): R/\mathit{id}(R) \Leftrightarrow S/\mathit{id}(S)$ where
    $\ell :
    R \Leftrightarrow S$. Then
    \begin{align*}
      \llbracket \mathit{lift}(\ell) \rrbracket.get &=  \llbracket \ell \rrbracket
                                                      = \llbracket \ell \rrbracket \circ id_{\mathcal{L}(R)} =
                                                      \llbracket \ell \rrbracket \circ \canonizer(\mathit{id}(R)), \text{ and }\\
      \llbracket \mathit{lift}(\ell) \rrbracket.put &= \llbracket \ell
                                                      \rrbracket^{-1} = \llbracket \ell \rrbracket^{-1} \circ id_{\mathcal{L}(S)} =
                                                      \llbracket \ell \rrbracket^{-1} \circ \canonizer(id(S))
    \end{align*}
  \item
    $\mathit{lquot}(c, q'): c' \circ c \Leftrightarrow c''$ where $q' : c' 
    \Leftrightarrow c''$, $c$ is well formed and $K(c) = W(c')$. Then
    \begin{align*}
      \llbracket q \rrbracket.get  &= \llbracket q'
                                     \rrbracket.get \circ \canonizer(c)\\
      \llbracket q \rrbracket.put &= \llbracket q' \rrbracket.put
    \end{align*}
    By the induction hypothesis, there exists a bijective lens $\ell :
    K(c') \Leftrightarrow K(c'')$ such that 
    \begin{align*}
      \llbracket q' \rrbracket.get &= \llbracket \ell \rrbracket \circ \canonizer(c')\\
      \llbracket q' \rrbracket.put &= \llbracket \ell \rrbracket^{-1} \circ
                                     Canonize(c'')
    \end{align*}
    Consequently
    \begin{align*}
      \llbracket q \rrbracket.get  &= (\llbracket \ell \rrbracket \circ
                                     \canonizer(c')) \circ \canonizer(c) = \llbracket \ell \rrbracket \circ
                                     (\canonizer(c' \circ c))\\
      \llbracket q \rrbracket.put &= \llbracket \ell \rrbracket^{-1} \circ
                                    Canonize(c'')
    \end{align*}

  \item
    $\mathit{rquot}(q', c''):c \Leftrightarrow c'' \circ c'$ where $q' : c \Leftrightarrow
    c'$, $c''$ is well formed and $K(c'') = W(c')$. Proceed as in the previous
    case.
  \item
    $q_2 \circ q_1: c \Leftrightarrow c''$ where $q_1 : c \Leftrightarrow c'$ and
    $q_2 : c' \Leftrightarrow c''$. Then
    \begin{align*}
      \llbracket q \rrbracket.get &= \llbracket q_2 \rrbracket.get\circ \llbracket
                                    q_1 \rrbracket.get, \text{ and }\\
      \llbracket q \rrbracket.put &= \llbracket q_1 \rrbracket.put \circ \llbracket
                                    q_2 \rrbracket.put
    \end{align*}
    By the induction hypothesis, there exist bijective lenses
    $\ell_1 :
    K(c) \Leftrightarrow K(c')$ and $\ell_2 : K(c') \Leftrightarrow K(c'')$ such
    that
    \begin{align*}
      \llbracket q_1 \rrbracket.get &= \llbracket \ell_1 \rrbracket \circ
                                      \canonizer(c)\\
      \llbracket q_1 \rrbracket.put &= {\llbracket \ell_1 \rrbracket}^{-1} \circ
                                      \canonizer(c')
    \end{align*}
    and
    \begin{align*}
      \llbracket q_2 \rrbracket.get &= \llbracket \ell_2 \rrbracket \circ
                                      Canonize(c')\\
      \llbracket q_2 \rrbracket.put &= {\llbracket \ell_2 \rrbracket}^{-1} \circ
                                      Canonize(c'')
    \end{align*}
    Consequently,
    \begin{align*}
      \llbracket q_2 \rrbracket.get \circ \llbracket q_1 \rrbracket.get &=
                                                                          (\llbracket \ell_2 \rrbracket \circ \canonizer(c')) \circ (\llbracket \ell_1
                                                                          \rrbracket \circ \canonizer(c))\\
                                                                        &= \llbracket \ell_2 \rrbracket \circ (\canonizer(c') \circ \llbracket \ell_1
                                                                          \rrbracket) \circ \canonizer(c)\\
                                                                        &= (\llbracket \ell_2 \rrbracket \circ \llbracket \ell_1 \rrbracket) \circ
                                                                          \canonizer(c)\\
                                                                        &= \llbracket \ell_2  \circ  \ell_1 \rrbracket \circ
                                                                          \canonizer(c)
    \end{align*} 
    A similar argument shows that 
    $$\llbracket q_1 \rrbracket.put \circ \llbracket q_2 \rrbracket.put =
    \llbracket \ell_2  \circ  \ell_1 \rrbracket^{-1} \circ
    \canonizer(c)$$
  \item  
    ${q'}^* : c^* \Leftrightarrow {c'}^*$ where $q' : c \Leftrightarrow c'$,
    $W(c)^{*!}$ and $W(c')^{*!}$ and $K(c)^{*!}$ and $K(c')^{*!}$. Then
    \begin{align*}
      \llbracket {q'}^* \rrbracket.get &= (\llbracket q' \rrbracket.get)^*, \text{
                                         and }\\
      \llbracket {q'}^* \rrbracket.put &= (\llbracket q' \rrbracket.put)^*
    \end{align*}
    By the induction hypothesis there exists a bijective lens $\ell : K(c)
    \Leftrightarrow K(c')$ such that 
    that
    \begin{align*}
      \llbracket q' \rrbracket.get &= \llbracket \ell \rrbracket \circ
                                     \canonizer(c)\\
      \llbracket q' \rrbracket.put &= {\llbracket \ell \rrbracket}^{-1} \circ
                                     \canonizer(c')
    \end{align*}
    Consequentlty
    \begin{align*}
      \llbracket {q'}^* \rrbracket.get &= (\llbracket \ell \rrbracket \circ
                                         \canonizer(c))^* = \llbracket \ell \rrbracket^* \circ
                                         \canonizer(c)^* = \llbracket \ell^* \rrbracket \circ
                                         \canonizer(c^*)\\
      \llbracket {q'}^* \rrbracket.put &= (\llbracket \ell \rrbracket^{-1} \circ
                                         \canonizer(c'))^* = (\llbracket \ell \rrbracket^{-1})^* \circ
                                         \canonizer(c')^* = \llbracket \ell^* \rrbracket^{-1} \circ
                                         \canonizer(c'^*)\\
    \end{align*}
  \item
    $q_1 \cdot q_2: c_1 \cdot c_2 \Leftrightarrow d_1 \cdot d_2$, where $q_1 : c_1
    \Leftrightarrow d_1 $,  $q_2 : c_2 \Leftrightarrow d_2$, $W(c_1)
    \cdot^! W(c_2)$, $K(c_1) \cdot^! K(c_2)$, $W(d_1) \cdot^! W(d_2)$ and $
    K(d_1) \cdot^! K(d_2)$. Then
    \begin{align*}
      \llbracket q \rrbracket.get &= \llbracket q_1 \rrbracket.get \cdot \llbracket
                                    q_2 \rrbracket.get, \text{ and }\\
      \llbracket q \rrbracket.put &= \llbracket q_1 \rrbracket.put \cdot \llbracket
                                    q_2 \rrbracket.put
    \end{align*}
    By the induction hypothesis, there exist bijective lenses $\ell_1 : K(c_1)
    \Leftrightarrow K(d_1)$ and $\ell_2 : K(c_2) \Leftrightarrow K(d_2)$ such that
    \begin{align*}
      \llbracket q_1 \rrbracket.get &= \llbracket \ell_1 \rrbracket \circ
                                      \canonizer(c_1)\\
      \llbracket q_1 \rrbracket.put &= {\llbracket \ell_1 \rrbracket}^{-1} \circ
                                      \canonizer(d_1)
    \end{align*}
    and
    \begin{align*}
      \llbracket q_2 \rrbracket.get &= \llbracket \ell_2 \rrbracket \circ
                                      \canonizer(c_2)\\
      \llbracket q_2 \rrbracket.put &= {\llbracket \ell_2 \rrbracket}^{-1} \circ
                                      \canonizer(d_2)
    \end{align*}
    Consequently,
    \begin{align*}
      \llbracket q \rrbracket.get &= (\llbracket \ell_1 \rrbracket \circ
                                    \canonizer(c_1)) \cdot  (\llbracket \ell_2 \rrbracket \circ
                                    \canonizer(c_2))\\
                                  &= (\llbracket \ell_1 \rrbracket \cdot \llbracket \ell_2
                                    \rrbracket) \circ (\canonizer(c_1) \cdot \canonizer(c_2))\\
                                  &= \llbracket \ell_1 \cdot  \ell_2 \rrbracket \circ \canonizer(c_1 \cdot c_2)
    \end{align*}
    Similarly
    $$
    \llbracket q \rrbracket.put = \llbracket \ell_1 \cdot  \ell_2 \rrbracket^{-1}
    \circ \canonizer(d_1 \cdot d_2) $$
  \item
    $q = q_1 \sep q_2$ where $q_1 : c_1 \Leftrightarrow d_1 $, $q_2 : c_2
    \Leftrightarrow d_2$, $\mathcal{L}(W(c_1)) \cap \mathcal{L}(W(c_2)) =
    \varnothing$ and $\mathcal{L}(W(d_1)) \cap \mathcal{L}(W(d_2)) = \varnothing$.
    Then
    $$
    \llbracket q_1 \sep q_2 \rrbracket.get(s) = 
    \begin{cases}
      \llbracket q_1 \rrbracket.get (s) & \text{if } s \in \mathcal{L}(W(c_1))\\
      \llbracket q_2 \rrbracket.get (s) & \text{if } s \in \mathcal{L}(W(c_2))\\
    \end{cases}$$
    $$\llbracket q_1 \sep q_2 \rrbracket.put(s) = 
    \begin{cases}
      \llbracket q_1 \rrbracket.put (s) & \text{if } s \in \mathcal{L}(W(d_1))\\
      \llbracket q_2 \rrbracket.put (s) & \text{if } s \in \mathcal{L}(W(d_2))\\
    \end{cases}
    $$
    By the induction hypothesis, there exist bijective lenses $\ell_1 : K(c_1)
    \Leftrightarrow K(d_1)$ and $\ell_2 : K(c_2) \Leftrightarrow K(d_2)$ such that
    \begin{align*}
      \llbracket q_1 \rrbracket.get &= \llbracket \ell_1 \rrbracket \circ
                                      \canonizer(c_1)\\
      \llbracket q_1 \rrbracket.put &= {\llbracket \ell_1 \rrbracket}^{-1} \circ
                                      \canonizer(d_1)
    \end{align*}
    and
    \begin{align*}
      \llbracket q_2 \rrbracket.get &= \llbracket \ell_2 \rrbracket \circ
                                      \canonizer(c_2)\\
      \llbracket q_2 \rrbracket.put &= {\llbracket \ell_2 \rrbracket}^{-1} \circ
                                      \canonizer(d_2)
    \end{align*}
    Consequently,
    $$
    \llbracket q_1 \sep q_2 \rrbracket.get(s) = 
    \begin{cases}
      \llbracket \ell_1 \rrbracket \circ
      \canonizer(c_1) (s) & \text{if } s \in \mathcal{L}(W(c_1))\\
      \llbracket \ell_2 \rrbracket \circ
      \canonizer(c_2) (s) & \text{if } s \in \mathcal{L}(W(c_2)),\\
    \end{cases}$$
    so $\llbracket q_1 \sep q_2 \rrbracket.get = \llbracket \ell_1 \sep
    \ell_2 \rrbracket \circ \canonizer(c_1 \sep c_2)$. A similar argument shows
    that $\llbracket q_1 \sep q_2 \rrbracket.put = \llbracket \ell_1 \sep
    \ell_2 \rrbracket^{-1} \circ \canonizer(d_1 \sep d_2)$.\\
    This completes the proof.
  \end{enumerate}
\end{proof}

\section{Synthesizing QRE Lenses}
\label{synth}
By Theorem~\ref{normal form}, if there is a derivation $q : c \Leftrightarrow
c'$ of a QRE lens, then there exists a bijective lens $\ell : K(c)
\Leftrightarrow K(c')$ such that
\begin{align*}
  \llbracket q \rrbracket.get &= \llbracket \ell \rrbracket\circ \canonizer(c)\\
  \llbracket q \rrbracket.put &= \llbracket \ell \rrbracket^{-1} \circ
                                \canonizer(c')
\end{align*}


Now suppose that we wish to synthesize a quotient lens $q$ of type $q: c
\Leftrightarrow c'$ that maps a specified set of input strings to a
specified set of output strings and vice versa.

For example, in the \textsc{Bib}\TeX\ to EndNote problem, the programmer wishes
to synthesize a QRE lens $q$ which maps the QRE
$$\perm{\re{REF}, \re{AUTHOR}, \re{TITLE}, \re{PUBLISHER},
  \re{YEAR}}{(\re{WHITESPACE}^* \mapsto \string \n)}$$ 
to the QRE
$$\perm{\re{REF'}, \re{AUTHOR'}, \re{TITLE'}, \re{PUBLISHER'},
  \re{YEAR'}}{(\re{WHITESPACE}^* \mapsto \string \n)}$$
where $\re{REF}, \re{AUTHOR}, \re{TITLE}, \re{PUBLISHER},$ and $\re{YEAR}$
(resp. $\re{REF'}, \re{AUTHOR'}, \re{TITLE'}, \re{PUBLISHER'},$ and
$\re{YEAR'}$) are regular expressions describing the respective
\textsc{Bib}\TeX\; (resp. EndNote\bcp{Don't like this ``resp.''
  construction---saves space, but not reader energy}) fields of the same
name, and 
$\re{WHITESPACE}$ is a regular expression describing whitespace
characters. Morever, the synthesized lens should map the equivalence
class of this \textsc{Bib}\TeX{} record
\begin{verbatim}
@Book {conway,
  Author = {Conway, J. H.},
  Title = {Regular Algebra and Finite Machines},
  Publisher = {Printed in GB by William Clowes & Sons Ltd},
  Year = {1971}
}
\end{verbatim}
\noindent to the equivalence class of this EndNote entry:
\begin{verbatim}
% 0 Book
% T Regular Algebra and Finite Machines
% A Conway, J. H.
% D 1971
% I Printed in GB by William Clowes & Sons Ltd
% F conway
\end{verbatim}

In our previous work, we showed that given regular expressions $R, S$ and a set
of input-output pairs $\{(r_1, s_1), \ldots, (r_n, s_n)\}$, if there is a
derivation $\ell :, R \Leftrightarrow S$ of a bijective lens that maps $r_i$ to
$s_i$ in the forward direction and $s_i$ to $r_i$ in the backward direction,
then there is an algorithm that computes a bijective lens $\ell' : R'
\Leftrightarrow S'$ such that $R \equiv R'$, $S \equiv S'$, $\ell'$ maps $r_i$
to $s_i$ in the forward direction and $s_i$ to $r_i$ in the backward
direction, and $\llbracket \ell \rrbracket = \llbracket \ell'
\rrbracket$~\cite{popl18}.

\section{Implementation and Evaluation}
\label{impl}

We have integrated QREs and quotient lens synthesis into Boomerang with an
additional \afm{loc} lines of OCaml code. 

All evaluations were performed on a 2.5 GHz Intel Core i7 processor with 16 GB
of 1600 MHz DDR3 running macOS Sierra.

Our evaluations serve to answer the following questions:
\begin{enumerate}
\item Does synthesizing quotient lenses from QREs permit for an easier
  development process than existing approaches.

\item Are QREs sufficiently expressive that more lenses can be synthesized
  without modifications to the format. 

\item Is our synthesis algorithm competitive with existing lens synthesis
  tools.
\end{enumerate}

\subsection{Benchmark Suite Construction} 
Our benchmarks were constructed from two sources:
\begin{enumerate}
\item \afm{39} of our benchmarks were derived from the Optician system.  These
  benchmarks were a combination of custom benchmarks, benchmarks derived from
  FlashFill, and benchmarks derived from Augeas.  Many of the formats mapped
  between had to be modified to work with the bijectivity constraints
  Optician required.  Commonly, one format had whitespace where the other did
  not allow for whitespace.  To address the bijectivity issues surrounding this,
  we added whitespace to the format that typically did not have whitespace.  We
  were able to remove these alterations in adopting these benchmarks to our
  system.

\item \afm{10} of our benchmarks were derived from data.gov.  Data.gov contains
  many transformations between formats.  In addition to the formats previously
  adopted for Optician, we synthesized transformers between these formats.
\end{enumerate}

\subsection{Easing the Development Process}

To test if our tool eases the development process, we compare the following
number of AST nodes.
%
\begin{itemize}
\item[\QRESize{}] \QRESize{} is the number of AST nodes in the QRE
  specifications involved in QRE lens synthesis task.
\item[\CanonizerAndSpecSize{}] \CanonizerAndSpecSize{} is the number of
  AST nodes in $W(q)$ summed with the number of AST nodes in $\canonizer(q)$,
  for each QRE used in QRE lens synthesis task.
\item[\LensAndSpecSize{}] \LensAndSpecSize{} is the number of AST nodes
  in $W(q)$ summed with the number of AST nodes in the synthesized QRE lens.
\end{itemize}

The value of \QRESize{} represents the difficulty in writing our benchmarks.

The value of \CanonizerAndSpecSize{} represents the difficulty in writing our
benchmarks without QREs.  This is only an approximation, as both $W(q)$ and
$\canonizer(q)$ are automatically generated from the QRE.  In our
experience, these automatically generated regular expressions and canonizers are
the ones we would naturally write.

The value of \LensAndSpecSize{} represents the difficulty in writing our benchmarks
with neither QREs nor synthesis.  This is also an approximation, as $W(q)$ and
$\canonizer(q)$ and the bijective lens are all automatically generated.
We have found that the generated bijective lens is fairly similar in size to the
one we would manually write, though it is typically less modular.

Figure~\ref{?} shows the number of benchmarks written with at most a given
number of AST nodes.  We found that \QRESize{} was consistently smaller than
\CanonizerAndSpecSize{} and \LensAndSpecSize{}, demonstrating that introducing
QREs saves programmers programming effort compared to both Optician and basic
Boomerang.

\subsection{Increase of Expressivity}

Optician was only able to synthesize fully bijective data transformations.
\Name loosens that restriction, and is able to synthesize data which is
bijective when put in canonical form.
To determine the increase of expressivity, we analyzed:
\begin{enumerate}
\item How many data formats in Optician's benchmark suite required modifications
  to be bijective.
\item How many data formats in Optician's benchmark suite required modifications
  to be bijective when put in canonical form.
\end{enumerate}

We found that \afm{35} of Opticians 39 benchmarks required modifications to be
bijective when put in canonical form. We found that \afm{25} of Optician's 39
benchmarks required modifications to be in bijective correspondence when in
canonical form.  Furthermore, we found that \afm{all} of the data.gov examples
required no modifications to be in canonical form.  While we did not put the
data.gov examples into a form suitable for Optician, we found only \afm{1} of
the \afm{5} data.gov examples did not require canonization, so making suitable
for Optician would have required a modification of \afm{4} of the data.gov
examples.

\subsection{Competitive Performance}

While we expanded on the Optician system, we found it important to validate
performance did not degrade in this expansion.  To validate this, we tested:
\begin{itemize}
\item[\OpticianRuntime{}] Optician runs on its own benchmarks.
\item[\SystemOnOptician{}] \Name{} runs on Optician's benchmarks.
\item[\SystemOnBenchmarks{}] \Name{} runs on its own benchmarks.
\end{itemize}

We summarize the results of these experiments in Figure~\ref{?}.  \Name{} was
able to synthesize all of Optician's benchmarks at a competitive speed with
Optician.  Furthermore, adopting these tasks to use QREs actually sped up
tasks!  After canonization, the regular expressions sent to synthesis are
\emph{smaller} than before canonization - making the bijective lens synthesis
portion of these tasks easier.

\section{Related Work}
\label{relwork}

\bcp{Make sure to list/discuss:
  \begin{itemize}
  \item Seminar papers on lenses (to which we can refer readers for further
    reading about connections to view updates, etc.) and quotient lenses.
  \item Discuss what other lens-like programming languages (besides
    boomerang) do about quotienting.  E.g., Augeas, XSugar, ...
  \item How quotient lenses are used in Boomerang.
  \item Search for papers that cite the quotient lens paper and see if they
    extend the ideas there.
  \end{itemize}
}

\section{Conclusion and Future Work}
\label{concl}

\end{document}
