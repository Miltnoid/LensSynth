\section{Synthesis with Refinements}
\label{sec:refinements}

\subsection{Examples are Refinements}

Until now, we have thought of examples as distinct from types.  Together, we stated,
these two components form the specification for a type-directed synthesis problem.
Here, we observe that examples can be integrated into the type system.

Consider the statement \Refines[x][2], where \HasType[x][\mathsf{nat}].  Put another way, we mean
that $x$ is any inhabitant of \textsf{nat}~so long as $x$ = 2.  Gathering the example and type
information into a single statement, we might put a predicate on the type of $x$ and say that
$\{x \in \mathsf{nat}~|~x = 2\}$.  This kind of type is hardly esoteric;
to the contrary, it is an instance of a \emph{singleton refinement type}
~\cite{pfenning-refinements}.

Refinements represent predicates on the structure of inhabitants of a type. 
In their simplest, singleton form, refinements constrain the type of an expression
to a single value as in the example above.  Refinements can express more general predicates,
such as the type for a non-empty list, $\mathsf{\HasType[\Refines[ls][Cons(natlist, nat)]][natlist]}$
(alternatively written as the predicate
$\{ls \in \mathsf{natlist}~|~ls = \mathsf{Cons(natlist, nat)}\}$).

The example grammar from Figure \ref{fig:grammar1} is already a refinement system.  Every
first-order example is a singleton refinement type.  Function examples are refinements
that partially constrain a type without necessarily restricting it to a single inhabitant.
Intersection refinements allow us to express the conjunction of predicates, which is useful for
combining function refinements.

\subsection{Refinements are more than Examples}

We can exploit the insight that examples are refinements to build a far richer synthesis
specification language than that in the original type-directed synthesis system. 
Here, we introduce two new refinements: union and base refinements
(Figure \ref{fig:grammar2}).  In Section \ref{sec:negation}, we discuss negation.

Union refinements are the dual of intersections: they allow a user to express that one of several
predicates holds on a value.  For example, where the refinement \TAnds[\TFunc{0}{1}, \TFunc{1}{2}]
describes a function that maps 0 to 1 and 1 to 2, \TOrs[\TFunc{0}{1}, \TFunc{1}{2}] refers to a
function that obeys at least one (but not necessarily both) of the two mappings.
Base refinements express the seemingly weak predicate that an expression
is some inhabitant of that base type.  They are most potent when combined with other refinements like
constructors, which enable us to express predicates on, for example, all non-empty lists.

As an example, consider a possible specification for the unary
decrement function, which subtracts one from all numbers except zero.
The function maps anything described
by the refinement \TOrs[0, 1] to 0, so a partial specification includes the refinement
\TFunc{\TOrs[0, 1]}{0}.  On any other input $\mathsf{S~(S~nat)}$, the result should be
$\mathsf{S~nat}$.  Combining these disparate parts of the specification into a single
refinement, we could describe decrement with the statement
\TAnds[\TFunc{\TOrs[0, 1]}{0}, \TFunc{\mathsf{S~(S~nat)}}{\mathsf{S~nat}}].

\subsection{Synthesis with Refinements}

Refinement types introduce an additional complication into the synthesis process: subsumption.
While the original type-directed synthesis system lacked any form of subtyping, the richer
refinement language forces us to consider the interaction between subsumption and synthesis.
For example, an expression \HasType[\Refines[\DExp][\mathsf{S~(S~nat)}]][\mathsf{nat}] can be
used in any context where we expect an expression
\HasType[\Refines[\DExp'][\mathsf{S~nat}]][\mathsf{nat}].

As a prerequisite for formalizing the subtyping relations between refinements, we present
the denotational semantics of refinement types as sets of their inhabitants in Figure
\ref{fig:denotation1}.  This set-theoretic denotation clarifies the relationships between
refinements that become concrete in the subtyping judgments in Figure \ref{fig:subsumption1}.

The denotations of each type are in the top section of Figure \ref{fig:denotation1}.  Unit type
denotes the set containing only the unit value.
Any base type denotes the set of all of its inhabitants.
Product type denotes the cartesian product of the denotations of its constituents.
Function type denotes the set of total functions over the input and output types,
where each function is a set of input-output pairs.

The middle section of Figure \ref{fig:denotation1} contains the denotations of refinements,
which only have meaning in relation to the types that they refine.  The unit and base refinement
denotations are identical to those of their synonymous types.  Intersection and union refinements
denote the set intersection and union operators.  Cartesian product and function refinements
have the same denotations as their types over the more restrictive domains of their constituent
refinements.  Finally, in the bottom section of Figure \ref{fig:denotation1}, the subtype
relation denotes the subset operator.

Using these denotational semantics, we can give meaning to the subtyping rules for the refinement
system (Figure \ref{fig:subsumption1}).  Most rules are standard, with special unfolding
rules are necessary for recursive base types.  Note that these subtyping rules apply to refinements
rather than the types themselves.
That is, every rule requires that the elements on both sides of the
subsumption relation are refinements of the same type.  In this system, no subtyping relation
exists between different types.

Finally, we are prepared to update the synthesis system (Figure \ref{fig:rules2}).
New union rules mirror those for intersection
types.  When the goal type is a union, we need only synthesize a program that satisfies one
of the union's constituents.  When an expression in the context is of union type, we must synthesize
a program that handles every constituent of the union.  Base type unfolding rules serve
a purpose similar to those in subsumption.  The \textsc{Synth-Ctx} no longer looks for
an exact match between refinements in the context and in goal position.  Instead, subtypes
are also acceptable.