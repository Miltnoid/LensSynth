\section{Proofs}

%\begin{lemma}[Inversion lemma for regular expressions]
%\label{lem:regex-inversion}
%\leavevmode
%\begin{enumerate}
%
%\item If $\RegexContext \DerivesStringRegex \String \OfType \RegexConcat{\Regex_1}{\Regex_2}$,
%then for some $\String_1$, $\String_2$,
%$\RegexContext \DerivesStringRegex \String_1 \OfType \Regex{}_1$,
%$\RegexContext \DerivesStringRegex \String_2 \OfType \Regex{}_2$,
%and $\String = \StringConcat{\String_1}{\String_2}$.
%
%\item If $\RegexContext \DerivesStringRegex \String \OfType \RegexOr{\Regex_1}{\Regex_2}$,
%then $\RegexContext \DerivesStringRegex \String \OfType \Regex{}_1$
%or $\RegexContext \DerivesStringRegex \String \OfType \Regex{}_2$.
%
%\item If $\RegexContext \DerivesStringRegex \String \OfType \Star{\Regex}$,
%then $\String=\EmptyString$ or
%$\RegexContext \DerivesStringRegex \String_1 \OfType \Regex$,
%$\RegexContext \DerivesStringRegex \String_2 \OfType \Star{\Regex}$,
%and $\String=\StringConcat{\String_1}{\String_2}$.
%
%\item If $\RegexContext \DerivesStringRegex \String' \OfType \String$,
%then $\String'=\String$.
%
%\item If $\RegexContext \DerivesStringRegex \String \OfType \RegexVariable$,
%then there there exists a $\RegexContext'$ and $\Regex$ such that
%$\RegexContext' \DerivesStringRegex \String \OfType \Regex$ and
%$\RegexContext'\cup(\RegexVariable,\Regex)=\RegexContext$.
%\end{enumerate}
%\end{lemma}
%
%\begin{lemma}[Set Based Semantics For Regular Expressions]
%\label{lem:set-regex}
%\leavevmode
%\begin{enumerate}
%\item $\LanguageOf{\RegexContext}{\String}=\{\String\}$
%\item $\LanguageOf{\RegexContext}{\RegexConcat{\Regex_1}{\Regex_2}} =
%\{\StringConcat{\String_1}{\String_2} | \String_1\in\LanguageOf{\RegexContext}{\Regex_1} \wedge \String_2\in\LanguageOf{\RegexContext}{\Regex_2}\}$
%\item $\LanguageOf{\RegexContext}{\RegexOr{\Regex_1}{\Regex_2}} =
%\{\String | \String\in\LanguageOf{\RegexContext}{\Regex_1} \vee \String\in\LanguageOf{\RegexContext}{\Regex_2}\}$
%\item $\LanguageOf{\RegexContext}{\Star{\Regex}} =
%\{\String_1\Concat\ldots\Concat\String_n | n\in\Nats \wedge \String_i\in\LanguageOf{\RegexContext}{\Regex}\}$
%\item If $(\RegexVariable,\Regex)\in\RegexContext$ for some $\Regex$, $\LanguageOf{\RegexContext}{\RegexVariable}=\LanguageOf{\RegexContext\setminus(\RegexVariable,\Regex)}{\Regex}$.
%\item If there does not exist a \Regex{} such that $(\RegexVariable,\Regex)\in\RegexContext$, then
%$\LanguageOf{\RegexContext}{\RegexVariable}=\emptyset$
%\end{enumerate}
%\end{lemma}

\ecrc*
\begin{proof}
We do induction on the dictionary ordering on the size of \RegexContext{},
and the structure of \Regex{}.

If $\RegexContext=\emptyset$, then $\LanguageOf{\RegexContext}{\Regex} =
\LanguageOf{\emptyset}{\Regex}$.

If $\Regex=\String$, then $\LanguageOf{\RegexContext}{\String} = \String =
\LanguageOf{\emptyset}{\String}$.

If $\Regex=\RegexConcat{\Regex_1}{\Regex_2}$, then by induction, there exists
$\Regex_1'$ and $\Regex_2'$ such that
$\LanguageOf{\emptyset}{\Regex_1'}=\LanguageOf{\RegexContext}{\Regex_1}$
and $\LanguageOf{\emptyset}{\Regex_2'}=\LanguageOf{\RegexContext}{\Regex_2}$.
By definition of \Language{},
$\LanguageOf{\emptyset}{\RegexConcat{\Regex_1'}{\Regex_2'}}=
\{\StringConcat{\String_1}{\String_2} | \String_1\in\LanguageOf{\emptyset}{\Regex_1'} \wedge \String_2\in\LanguageOf{\emptyset}{\Regex_2'}\}=
\{\StringConcat{\String_1}{\String_2} | \String_1\in\LanguageOf{\RegexContext}{\Regex_1} \wedge \String_2\in\LanguageOf{\RegexContext}{\Regex_2}\}=
\LanguageOf{\RegexContext}{\RegexConcat{\Regex_1}{\Regex_2}}$

If $\Regex=\RegexOr{\Regex_1}{\Regex_2}$, then by induction, there exists
$\Regex_1'$ and $\Regex_2'$ such that
$\LanguageOf{\emptyset}{\Regex_1'}=\LanguageOf{\RegexContext}{\Regex_1}$
and $\LanguageOf{\emptyset}{\Regex_2'}=\LanguageOf{\RegexContext}{\Regex_2}$.
By definition of \Language{},
$\LanguageOf{\emptyset}{\RegexOr{\Regex_1'}{\Regex_2'}}=
\{\String | \String\in\LanguageOf{\emptyset}{\Regex_1'} \vee \String\in\LanguageOf{\emptyset}{\Regex_2'}\}=
\{\String | \String\in\LanguageOf{\RegexContext}{\Regex_1} \vee \String\in\LanguageOf{\RegexContext}{\Regex_2}\}=
\LanguageOf{\RegexContext}{\RegexOr{\Regex_1}{\Regex_2}}$

If $\Regex=\Star{\RegexAlt}$, then by induction, there exists a
$\RegexAlt'$ such that
$\LanguageOf{\emptyset}{\RegexAlt'}=\LanguageOf{\RegexContext}{\RegexAlt}$.
By definition of \Language{},
$\LanguageOf{\emptyset}{\Star{\RegexAlt'}}=
\{\String_1\Concat\ldots\Concat\String_n | n\in\Nats \wedge \String_i\in\LanguageOf{\emptyset}{\RegexAlt'}\}=
\{\String_1\Concat\ldots\Concat\String_n | n\in\Nats \wedge \String_i\in\LanguageOf{\RegexContext}{\RegexAlt}\}=
\LanguageOf{\RegexContext}{\Star{\RegexAlt}}$

If $\Regex=\RegexVariable$, and $(\RegexVariable,\RegexAlt)\in\RegexContext$ for
some unique \RegexAlt{}.
By induction, there exists a $\RegexAlt'$ such that
$\LanguageOf{\emptyset}{\RegexAlt'}=\LanguageOf{\RegexContext\setminus(\RegexVariable,\RegexAlt)}{\RegexAlt}$.
By definition of \Language{}, $\LanguageOf{\RegexContext\setminus(\RegexVariable,\RegexAlt)}{\RegexAlt}=\LanguageOf{\RegexContext}{\RegexVariable}$, so 
$\LanguageOf{\emptyset}{\RegexAlt'}=\LanguageOf{\RegexContext}{\RegexVariable}$

If $\Regex=\RegexVariable$, and there does not exist a unique $\RegexAlt$ such that
$(\RegexVariable,\RegexAlt)\in\RegexContext$, then
$\LanguageOf{\RegexContext}{\RegexVariable}=\emptyset=\LanguageOf{\emptyset}{\RegexVariable}$
\end{proof}

\bls*
\begin{proof}
By structural induction\\
\begin{mathpar}
\inferrule[Constant Lens]
{
\String_1 \in \Star{\Sigma}\\
\String_2 \in \Star{\Sigma}\\
}
{
\FullContext \vdash \ConstLens{\String_1}{\String_2} : \String_1 \Leftrightarrow \String_2 \HasSemantics \lambda \String. \String_2 , \lambda \String. \String_1
}
\end{mathpar}
The constant lens sends the set with one element to the set with one element.


\begin{mathpar}
\inferrule[Identity Lens]
{
}
{
\FullContext \vdash \IdentityLens : \Regex \Leftrightarrow \Regex \HasSemantics \lambda \String.\String, \lambda \String . \String
}
\end{mathpar}
The identity mapping is a bijection between the same set.


\begin{mathpar}
\inferrule[Iterate Lens]
{
\FullContext \vdash \Lens : \Regex \Leftrightarrow \RegexAlt \HasSemantics \PutRight , \PutLeft \\
\UnambigIt{\LanguageOf{\Delta}{\Regex}}\\
\UnambigIt{\LanguageOf{\Delta}{\RegexAlt}}\\
}
{
\FullContext \vdash \IterateLens{\Lens} : \Star{\Regex} \Leftrightarrow \Star{\RegexAlt} \HasSemantics\\\\
\lambda \String.\LetWhereIn{\String_1\Concat\ldots\Concat\String_n}{\String}{\String_i\in\LanguageOf{\Delta}{\Regex}} (\PutRight\Apply\String_1)\Concat\ldots\Concat(\PutRight\Apply\String_n),\\\\
\lambda \String.\LetWhereIn{\String_1\Concat\ldots\Concat\String_n}{\String}{\String_i\in\LanguageOf{\Delta}{\RegexAlt}} (\PutLeft\Apply\String_1)\Concat\ldots\Concat(\PutLeft\Apply\String_n)
}
\end{mathpar}
It suffices to show that $\lambda s.\PutRight\Compose\PutLeft\Apply s=\lambda s.s$ and $\lambda s.\PutLeft\Compose\PutRight\Apply s=\lambda s.s$.

$\lambda \String'.\lambda \String.\LetWhereIn{\String_1\Concat\ldots\Concat\String_n}{\String}{\String_i\in\LanguageOf{\Delta}{\Regex}} (\PutRight\Apply\String_1)\Concat\ldots\Concat(\PutRight\Apply\String_n)\Compose
(\lambda \String.\LetWhereIn{\String_1\Concat\ldots\Concat\String_n}{\String}{\String_i\in\LanguageOf{\Delta}{\RegexAlt}} (\PutLeft\Apply\String_1)\Concat\ldots\Concat(\PutLeft\Apply\String_n))
\Apply\String'$=


$\lambda \String'.\lambda \String.\LetWhereIn{\String_1\Concat\ldots\Concat\String_n}{\String}{\String_i\in\LanguageOf{\Delta}{\Regex}} (\PutRight\Apply\String_1)\Concat\ldots\Concat(\PutRight\Apply\String_n)\Apply
(\PutLeft\Apply\String_1')\Concat\ldots\Concat(\PutLeft\Apply\String_n')$
where $\String_1'\Concat\ldots\Concat\String_n'=\String'$=


$\lambda \String'.(\PutRight\Apply(\PutLeft\Apply\String_1'))\Concat\ldots\Concat(\PutRight\Apply(\PutLeft\Apply\String_n'))$
where $\String_1'\Concat\ldots\Concat\String_n'=\String'$=

$\lambda \String'.\String_1'\Concat\ldots\Concat\String_n'$
where $\String_1'\Concat\ldots\Concat\String_n'=\String'$=


$\lambda \String'.\String'$\\

Analogously for $\lambda s.\PutLeft\Compose\PutRight\Apply s$.


\begin{mathpar}
\inferrule[Concat Lens]
{
\FullContext \vdash \Lens_1 : \Regex_1 \Leftrightarrow \RegexAlt_1 \HasSemantics \PutRight_1, \PutLeft_1\\
\FullContext \vdash \Lens_2 : \Regex_2 \Leftrightarrow \RegexAlt_2 \HasSemantics \PutRight_2, \PutLeft_2\\\\
\UnambigConcat{\LanguageOf{\Delta}{\Regex_1}}{\LanguageOf{\Delta}{\Regex_2}}\\
\UnambigConcat{\LanguageOf{\Delta}{\RegexAlt_1}}{\LanguageOf{\Delta}{\RegexAlt_2}}
}
{
\FullContext \vdash \ConcatLens{\Lens_1}{\Lens_2} : \Regex_1\Regex_2 \Leftrightarrow \RegexAlt_1\RegexAlt_2 \HasSemantics\\\\
\lambda \String.\LetWhereIn{\String_1\Concat\String_2}{\String}{\String_i\in\LanguageOf{\Delta}{\Regex_i}} (\PutRight_1\Apply\String_1)\Concat(\PutRight_2\Apply\String_2),\\\\
\lambda \String.\LetWhereIn{\String_1\Concat\String_2}{\String}{\String_i\in\LanguageOf{\Delta}{\RegexAlt_i}} (\PutLeft_1\Apply\String_1)\Concat(\PutLeft_2\Apply\String_2)
}
\end{mathpar}


\begin{mathpar}
\inferrule[Compose Lens]
{
\FullContext \vdash \Lens_1 : \Regex_1 \Leftrightarrow \Regex_2 \HasSemantics \PutRight_1,\PutLeft_1\\
\FullContext \vdash \Lens_2 : \Regex_2 \Leftrightarrow \Regex_3 \HasSemantics \PutRight_2,\PutLeft_2\\
}
{
\FullContext \vdash \ComposeLens{\Lens_2}{\Lens_1} : \Regex_1 \Leftrightarrow \Regex_3 \HasSemantics
\PutRight_2\Compose\PutRight_1,\PutLeft_2\Compose\PutLeft_1
}
\end{mathpar}
The composition of two bijective functions is bijective, and $\InverseOf{(f\Compose g)}=\InverseOf{g}\Compose\InverseOf{f}$

\end{proof}

\blic*
\begin{proof}
First prove pumping lemma for regular expression bijective lenses,
which is for all
$\FullContext \vdash \Lens \Regex \Leftrightarrow \RegexAlt \HasSemantics \PutRight,\PutLeft$,
there exists a constant $p$,
such that for every $\String\in\LanguageOf{\Delta}{\Regex}$,
$\StringAlt\in\LanguageOf{\Delta}{\RegexAlt}$,
such that $\PutRight \Apply \String = \StringAlt$.
where the length of $\String$ is greater than $p$,
then there exists a split $\String = xyz$ and $\StringAlt = abc$
with $y$ nonempty and the length of $xy$ less than, or equal to $p$,
such that for all $i\in\Nats$, $\PutRight \Apply xy^iz = ab^ic$

TODO: prove, unfortunately need dnf lens machinery

We want to prove that there does not exist a lens $\Lens$, such that
$\emptyset,\emptyset \vdash \Lens \Star{a} \Leftrightarrow \Star{a} \HasSemantics f,g$
where $f = \lambda s.\LetIn{i}{\mathit{length} \Apply s}
\LetIn{n}{\CeilOf{(-1+(8i+1)^{.5})/2}}
\LetIn{k}{n(n-1)/2}
k+(i+1)\mathit{mod}(n)$, and $g=\InverseOf{f}$.
Intuitively what this function does, is send $a^0$ and $a^1$ to themselves.
It creates a cycle of 2 of $a^2$ and $a^3$.  Next is a cycle of 3 with the next 3 $a^i$s.
This is continued with increasingly large cycles.

Let the pumping constant be $p$.  Let $m$ be a number greater than $p$.  Consider
the cycle of $m$ elements.

\end{proof}
\begin{proof}
Consider the set of bijections between
$\LanguageOf{\emptyset}{\Star{a}}$ and $\LanguageOf{\emptyset}{\Star{a}}$.
There are an infinite number of elements in $\LanguageOf{\emptyset}{\Star{a}}$,
$a^i$ for all $i\in\Nats$.
The number of bijections between two infinite sets is always uncountable, so there
are an uncountable number of bijections from $\LanguageOf{\emptyset}{\Star{a}}$
to $\LanguageOf{\emptyset}{\Star{a}}$.
However, our language only expresses a countable number of bijections,
so we do not express all bijections.
\end{proof}

\eclc*
\begin{proof}
For the rules that contain no use of \RegexContext{} or \LensContext{},
Iterate Lens, Concat Lens, Swap Lens, Or Lens, and Compose Lens.
the induction is very straightforward.
\end{proof}


\subsection{Completeness}

\subsection{Soundness}

\begin{lemma}[Creation of Lens from Identity Perm Clause Lens]
\label{lem:id-clause}
If $\Delta \vdash ([(\String_0,\StringAlt_0);\AtomLens_1 ; \ldots ; \AtomLens_n;(\String_n,\StringAlt_n)],id) : [\String_0 ; \Atom_1 ; \ldots ; \Atom_n; \String_n] \Leftrightarrow [\StringAlt_0 ; \AtomAlt_1 ; \ldots ; \AtomAlt_n ; \StringAlt_n]$,
and for each $\AtomLens_i : \Atom_i \Leftrightarrow \AtomAlt_i$,
there exists a $\Delta \vdash \Lens_i : \Regex_i \Leftrightarrow \RegexAlt_i$ such that
$\LanguageOf{\Delta}{\Atom_i}=\LanguageOf{\Delta}{\Regex_i}$, and $\Lens_i.putr = \ClauseLens_i.putr$,
then there exists a $\Lens : \Regex \Leftrightarrow \RegexAlt$ such that $\Lens.putr = ([\AtomLens_1 ; \ldots ; \AtomLens_n],id).putr$, $\LanguageOf{\Delta}{[\String_0 ; \Atom_1 ; \ldots ; \Clause_n ; \String_n]}$ = $\LanguageOf{\Delta}{\Regex}$,
and $\LanguageOf{\Delta}{[\StringAlt_0 ; \AtomAlt_1 ; \ldots ; \AtomAlt_n ; \StringAlt_n]}$ = $\LanguageOf{\Delta}{\RegexAlt}$.
\begin{proof}
Base case: $\FullContext \vdash [(\String_0,\StringAlt_0)] : [\String_0] \Leftrightarrow [\StringAlt_0]$.
Then consider $\Lens$ = $\ConstLens{\String_0}{\StringAlt_0}$, $\Regex = \String$, $\RegexAlt = \StringAlt$.
$\LanguageOf{\Delta}{[\String_0]} = \String_0 = \LanguageOf{\Delta}{\String_0}$ by definition.\\
$\LanguageOf{\Delta}{[\StringAlt_0]} = \StringAlt_0 = \LanguageOf{\Delta}{\String_0}$ by definition.\\
$\PutRightOf{[(\String_0,\StringAlt_0)]}(\String_0)=\StringAlt_0=\PutRightOf{\ConstLens{\String}{\StringAlt}}(\String_0)$.
\\\\\\

By induction assumption, I know
there exists a $\Lens : \Regex \Leftrightarrow \RegexAlt$ such that
$\Lens.putr = ([(\String_0,\StringAlt_0);\AtomLens_1 ; \ldots ; \AtomLens_n;(\String_n,\StringAlt_n)],id).putr$,
$\LanguageOf{\Delta}{[\String_0 ; \Atom_1 ; \ldots ; \Atom_n ; \String_n]}$ =
$\LanguageOf{\Delta}{\Regex}$,
and $\LanguageOf{\Delta}{[\StringAlt_0 ; \AtomAlt_1 ; \ldots ; \Atom_n ; \StringAlt_n]}$ = $\LanguageOf{\Delta}{\RegexAlt}$.\\
By assumption, I know that there exists a $\Delta \vdash \Lens_{n+1} : \Regex_{n+1} \Leftrightarrow \RegexAlt_{n+1}$ such that $\LanguageOf{\Delta}{\Regex_{n+1}}=\LanguageOf{\Delta}{\Atom_{n+1}}$
and $\LanguageOf{\Delta}{\RegexAlt_{n+1}}=\LanguageOf{\Delta}{\AtomAlt_{n+1}}$, where $\Lens_{n+1}.putr=\AtomLens_{n+1}$.\\
Consider the lens $\FullContext \vdash \ConcatLens{\Lens}{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}} : \RegexConcat{\Regex}{\RegexConcat{\Regex_{n+1}}{\String_{n+1}}} \Leftrightarrow \RegexConcat{\RegexAlt}{\RegexConcat{\RegexAlt_{n+1}}{\StringAlt_{n+1}}}$.\\
$\LanguageOf{\Delta}{\RegexConcat{\Regex}{\RegexConcat{\Regex_{n+1}}{\String_{n+1}}}}
= \LanguageOf{\Delta}{\Regex}\Concat\LanguageOf{\Delta}{\Regex_{n+1}}\Concat\{\String_{n+1}\}$
by definition\\
$\LanguageOf{\Delta}{\RegexConcat{\Regex}{\RegexConcat{\Regex_{n+1}}{\String_{n+1}}}}
= \LanguageOf{\Delta}{[\String_0;\Atom_1; \ldots ; \Atom_n;\String_n]}
\Concat\LanguageOf{\Delta}{\Regex_{n+1}}\Concat\{\String_{n+1}\}$ by induction assumption.\\
$\LanguageOf{\Delta}{\RegexConcat{\Regex}{\RegexConcat{\Regex_{n+1}}{\String_{n+1}}}}
= \{\String_0\}\Concat\LanguageOf{\Delta}{\Atom_1}\Concat\ldots\Concat\LanguageOf{\Delta}{\Atom_n}\Concat\{\String_n\}
\Concat\LanguageOf{\Delta}{\Regex_{n+1}}\Concat\{\String_{n+1}\}$ by definition.\\
$\LanguageOf{\Delta}{\RegexConcat{\Regex}{\RegexConcat{\Regex_{n+1}}{\String_{n+1}}}}
= \{\String_0\}\Concat\LanguageOf{\Delta}{\Atom_1}\Concat\ldots\Concat\LanguageOf{\Delta}{\Atom_n}\Concat\{\String_n\}
\Concat\LanguageOf{\Delta}{\Atom_{n+1}}\Concat\{\String_{n+1}\}$ by problem assumption.\\
$\LanguageOf{\Delta}{\RegexConcat{\Regex}{\RegexConcat{\Regex_{n+1}}{\String_{n+1}}}}
= \LanguageOf{\Delta}{[\String_0;\Atom_0;\ldots;\Atom_{n+1};\String_{n+1}]}$ by definition.\\

Similarly for
$\LanguageOf{\Delta}{\RegexConcat{\RegexAlt}{\RegexConcat{\RegexAlt_{n+1}}{\StringAlt_{n+1}}}}
= \LanguageOf{\Delta}{[\StringAlt_0;\AtomAlt_0;\ldots;\AtomAlt_{n+1};\StringAlt_{n+1}]}$
 TODO, split into lemma?.\\
\\
$\PutRightOf{\ConcatLens{\Lens}{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}}}
(\String_0\String_1'\ldots\String_{n+1}'\String_{n+1}) =$\\
$\PutRightOf{\Lens}(\String_0\String_1'\ldots\String_n'\String_n)\PutRightOf{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}}(\String_{n+1}'\String_{n+1})$ by definition\\
\\
$\PutRightOf{\ConcatLens{\Lens}{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}}}
(\String_0\String_1'\ldots\String_{n+1}'\String_{n+1}) =$\\
$\PutRightOf{\Lens}(\String_0\String_1'\ldots\String_n'\String_n)\PutRightOf{\Lens_{n+1}}(\String_{n+1}')\PutRightOf{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}(\String_{n+1})$ by definition\\
\\
$\PutRightOf{\ConcatLens{\Lens}{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}}}
(\String_0\String_1'\ldots\String_{n+1}'\String_{n+1}) =$\\
$\PutRightOf{[(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)]}(\String_0\String_1'\ldots\String_n'\String_n)\PutRightOf{\Lens_{n+1}}(\String_{n+1}')\PutRightOf{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}(\String_{n+1})$ by induction assumption\\
\\
$\PutRightOf{\ConcatLens{\Lens}{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}}}
(\String_0\String_1'\ldots\String_{n+1}'\String_{n+1}) =$\\
$\PutRightOf{[(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)]}(\String_0\String_1'\ldots\String_n'\String_n)\PutRightOf{\AtomLens_{n+1}}(\String_{n+1}')\PutRightOf{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}(\String_{n+1})$ by problem assumption\\
\\
$\PutRightOf{\ConcatLens{\Lens}{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}}}
(\String_0\String_1'\ldots\String_{n+1}'\String_{n+1}) =$\\
$\StringAlt_0\Concat\PutRightOf{\AtomLens_1}(\String_1')\Concat\ldots\Concat\PutRightOf{\AtomLens_n}(\String_n')\Concat\StringAlt_n\Concat\PutRightOf{\AtomLens_{n+1}}(\String_{n+1}')\Concat\StringAlt_{n+1}$ by definition\\
\\
$\PutRightOf{\ConcatLens{\Lens}{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}}}
(\String_0\String_1'\ldots\String_{n+1}'\String_{n+1}) =$\\
$\PutRightOf{[(\String_0,\StringAlt_0);\AtomLens_0;\ldots;\AtomLens_{n+1};(\String_{n+1},\StringAlt_{n+1})]}(\String_0\String_0'\ldots\String_{n+1}'\String_{n+1})$ by definition
\end{proof}
\end{lemma}

\begin{definition}[Adjacent Swapping Permutation]
Let $\sigma_{i} \in S_n$ be the permutation where
$\sigma_{i}(i) = i+1$, $\sigma_{i}(i+1) = i$, $\sigma_{i,j}(k\neq i,i+1) = k$
\end{definition}

\begin{definition}[Clause Permuting Bijection]
Let $[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]$ be a clause, let $\sigma$ be a permutation, and let $\RegexContext$ be a regular expression context.
Define
$f_{\sigma,\RegexContext,[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]}$ as:
$f_{\sigma,\RegexContext,[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]}: \LanguageOf{\Delta}{[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]}\rightarrow\LanguageOf{\Delta}{[\String_0;\Atom_{\sigma(1)};\ldots;\Atom_{\sigma(n)};\String_n]}$, where $\String_0\String_1'\ldots\String_n'\String_n\mapsto\String_0\String_{\sigma(1)}'\ldots\String_{\sigma(n)}'\String_n$.
\end{definition}

\begin{lemma}[Expressibility of Adjacent Swapping Permutation Lens]
Let $\sigma_i$ be an adjacent element swapping permutation, $[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]$ be a clause, $\RegexContext$ be a regular expression context, and $\LensContext$ be a lens context.
There exists regular expressions $\Regex$ and $\RegexAlt$, and a lens $\Lens$,
such that $\LanguageOf{\Delta}{\Regex}=\LanguageOf{\Delta}{[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]}$,
$\LanguageOf{\Delta}{\RegexAlt}=\LanguageOf{\Delta}{[\String_0;\Atom_{\sigma(1)};\ldots;\Atom_{\sigma(n)};\String_n]}$, and
$\FullContext \vdash \Lens : \Regex \Leftrightarrow \RegexAlt \HasSemantics f_{\sigma,\RegexContext,[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]}, f_{\sigma,\RegexContext,[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]}^{-1}$
\begin{proof}
By the soundness of regular expressions, there exists
a regular expressions $\Regex_1, \Regex_2, \Regex_3, \Regex_4$ such that
$\LanguageOf{\Delta}{\Regex_1}=\LanguageOf{\Delta}{[\String_1;\Atom_1;\ldots;\Atom_{i-1};\String_{i-1}]}$,
$\LanguageOf{\Delta}{\Regex_2}=\LanguageOf{\Delta}{\Atom_i}$,
$\LanguageOf{\Delta}{\Regex_3}=\LanguageOf{\Delta}{\Atom_{i+1}}$, and
$\LanguageOf{\Delta}{\Regex_4}=\LanguageOf{\Delta}{[\String_i;\Atom_{i+1};\ldots;\Atom_{n};\String_n]}$.
Consider the following deduction
\begin{mathpar}
\inferrule*
{
\inferrule*
{
\inferrule*
{
}
{
\FullContext \vdash \IdentityLens : \Regex_1 \Leftrightarrow \Regex_1 \HasSemantics id, id\\
}
\inferrule*
{
\inferrule*
{
}
{
\FullContext \vdash \Lens : \Regex_2 \Leftrightarrow \Regex_2 \HasSemantics id, id\\
}
\inferrule*
{
\inferrule*
{
}
{
\FullContext \vdash \Lens : \String_i \Leftrightarrow \String_i \HasSemantics id, id\\
}
\inferrule*
{
}
{
\FullContext \vdash \Lens : \Regex_3 \Leftrightarrow \Regex_3 \HasSemantics id, id\\
}
}
{
\FullContext \vdash \Lens : \String_i\Concat\Regex_3 \Leftrightarrow \Regex_3\Concat\String_i \HasSemantics swap(id,id), swap(id,id)\\
}
}
{
\FullContext \vdash \Lens : \Regex_2\Concat\String_i\Concat\Regex_3 \Leftrightarrow \Regex_3\Concat\String_i\Concat\Regex_2 \HasSemantics id, id^{-1}\\
}
}
{
\FullContext \vdash \Lens : \Regex_1\Concat\Regex_2\Concat\String_i\Concat\Regex_3 \Leftrightarrow \Regex_1\Concat\Regex_3\Concat\String_i\Concat\Regex_2 \HasSemantics id, id^{-1}\\
}
\inferrule*
{
}
{
\FullContext \vdash \Lens : \Regex_4 \Leftrightarrow \Regex_4 \HasSemantics id, id
}
}
{
\FullContext \vdash \Lens : \Regex_1\Concat\Regex_2\Concat\String_i\Concat\Regex_3\Concat\Regex_4 \Leftrightarrow \Regex_1\Concat\Regex_3\Concat\String_i\Concat\Regex_2\Concat\Regex_4 \HasSemantics f_{\sigma,\RegexContext,[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]}, f_{\sigma,\RegexContext,[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]}^{-1}
}
\end{mathpar}


Consider the regular expressions $repregex([\String_1;\Atom_1; \ldots;\String_i])$ $(repregex(\Atom_i) (\String_{i+1} repregex(\Atom_{i+1})))$ $repregex([\String_{i+2} ; \ldots ; \Atom_{n} ; \String_{n+1}])$ and 
$repregex([\String_{1,2};\Atom_{1,2}; \ldots;\String_{i,1}])$ $((\Atom_{i+1,1} \String_{i+1,1})\Atom_{i,1})$ $repregex([\String_{i+2,1} ; \ldots ; \Atom_{n} ; \String_{n+1}])$
Consider the lens between them\\ $\ConcatLens{\ConcatLens{\IdentityLens}{\SwapLens{\IdentityLens}{\SwapLens{\IdentityLens}{\IdentityLens}}}}{\IdentityLens}$
By inspection, this lens is equivalent to the adjacent swapping permutation.
\end{proof}
\end{lemma}

\begin{lemma}[Expressibility of Permutation]
\label{lem:perm-exp}
The language of lenses can express $([(\String_1,\String_1) ; \IdentityLens ; \ldots ; \IdentityLens ; (\String_n,\String_n)], \sigma)$
for any permutation $\sigma$.
\begin{proof}
Let $\sigma$ be a permutation.
Consider the clause lens $([(\String_1,\String_1) ; \IdentityLens ; \ldots ; \IdentityLens ; (\String_n,\String_n)], \sigma_{i})$.
From algebra, we know that the group of permutations is generated by all
adjacent swaps $\sigma_i = (i,i+1)$.
So there exists an adjacency swap decomposition of $\sigma = \sigma_{i_1}\ldots\sigma_{i_m}$.
Consider the dnf lens $([(\String_1,\String_1) ; \IdentityLens ; \ldots ; \IdentityLens ; (\String_n,\String_n)], \sigma_{i_j})$ for each $\sigma_{i_j}$.
By the above lemma, there exists a $\Lens_j$ for each of these adjacency swaps.
Consider the lens $\Lens = \ComposeLens{\Lens_{i_1}}{\ComposeLens{\Lens_{i_2}}{\ldots \ComposeLens{}{\Lens_{i_m}}}}$
By the semantics, they are the same.

\end{proof}
\end{lemma}

\begin{definition}[well-founded relation on DNF Lenses, Clauses, and Atoms]
The well founded relation is the transitive closure of
DO I NEED TO DO THIS FORMALLY?
\begin{itemize}
\item $([\ClauseLens],id \in S_1) \prec \ClauseLens$
\item $\lambda i:\RangeIncInc{1}{n}.\ClauseLens_i$
\end{itemize}
\end{definition}

\begin{definition}[replens]
We define a representative lens for a dnf lens, a clause lens, and an atom lens as follows:
\begin{itemize}
\item $replens([\ClauseLens],id\in S_1) = replens(\ClauseLens)$
\item $replens(\lambda i:\RangeIncInc{1}{n}.\ClauseLens_i,id\in S_n) =$\\
$\OrLens{replens(\lambda i:\RangeIncInc{1}{n-1}.\ClauseLens_i, id\in S_{n-1})}{replens(\ClauseLens_n)}$
\item $replens(\lambda i:\RangeIncInc{1}{n}.\ClauseLens_i,\sigma\in S_n) =$\\
$replens(\lambda i:\RangeIncInc{1}{n}.\ClauseLens_i,id\in S_n)$
\item $replens([(\String_i,\StringAlt_i)],id\in S_0)=\ConstLens{\String_i}{\StringAlt_i}$
\item $replens(\lambda i:\RangeIncInc{1}{n}.\AtomLens_i,\lambda i:\RangeIncInc{0}{n}.(\String_i,\StringAlt_i),id\in S_n)=$\\
$\ConcatLens{\ConcatLens{replens(\lambda i:\RangeIncInc{1}{n-1}.\AtomLens_i,\lambda i:\RangeIncInc{0}{n-1}.(\String_i,\StringAlt_i),id\in S_{n-1})}{replens(\AtomLens_i)}}{\ConstLens{\String_n}{\StringAlt_n}}$
\item $replens(\lambda i:\RangeIncInc{1}{n}.\AtomLens_i,\lambda i:\RangeIncInc{0}{n}.(\String_i,\StringAlt_i),\sigma \in S_n)=$\\
$\ComposeLens{permlens(\lambda i:\RangeIncInc{0}{n} \StringAlt_i,\sigma \in S_n)}{replens(\lambda i:\RangeIncInc{1}{n}.\AtomLens_i,\lambda i:\RangeIncInc{0}{n}.(\String_i,\StringAlt_i),id \in S_n)}$
\item $replens(\IdentityLens)=\IdentityLens$
\item $replens(\IterateLens{\DNFLens})=\IterateLens{replens(\DNFLens)}$
\end{itemize}
\end{definition}

\begin{lemma}[Denotational Equivalence of $replens$]\leavevmode
\begin{enumerate}
\item For a DNF Lens $\DNFLens$, $\denot{\DNFLens}=\denot{replens(\DNFLens)}$
\item For a Clause Lens $\ClauseLens$, $\denot{\ClauseLens}=\denot{replens(\ClauseLens)}$
\item For a DNF Lens $\DNFLens$, $\denot{\DNFLens}=\denot{replens(\DNFLens)}$
\end{enumerate}
By induction on the well-founded relation underlying the 
\end{lemma}

\begin{lemma}[Creation of Lens from Identity Perm DNF Lens]
\label{lem:id-dnf}
If $\Delta \vdash ([\ClauseLens_1 ; \ldots ; \ClauseLens_n],id) : [\Clause_1 ; \ldots ; \Clause_n] \Leftrightarrow [\ClauseAlt_1 ; \ldots ; \ClauseAlt_n]$,
and for each $\ClauseLens_i : \Clause_i \Leftrightarrow \ClauseAlt_i$,
there exists a $\Delta \vdash \Lens_i : \Regex_i \Leftrightarrow \RegexAlt_i$ such that
$\LanguageOf{\Delta}{\Clause_i}=\LanguageOf{\Delta}{\Regex_i}$, and $\Lens_i.putr = \ClauseLens_i.putr$,
then there exists a $\Lens : \Regex \Leftrightarrow \RegexAlt$ such that $\Lens.putr = ([\ClauseLens_1 ; \ldots ; \ClauseLens_n],id).putr$, $\LanguageOf{\Delta}{[\Clause_1 ; \ldots ; \Clause_n]}$ = $\LanguageOf{\Delta}{\Regex}$,
and $\LanguageOf{\Delta}{[\ClauseAlt_1 ; \ldots ; \ClauseAlt_n]}$ = $\LanguageOf{\Delta}{\RegexAlt}$.
\begin{proof}
Base case: $\FullContext \vdash [\ClauseLens_1] : [\Clause_1] \Leftrightarrow [\ClauseAlt_1]$.  Then consider $\Lens$ = $\Lens_1$, $\Regex = \Regex_1$, $\RegexAlt = \RegexAlt_1$.
$\LanguageOf{\Delta}{[\Clause_1]} = \LanguageOf{\Delta}{\Clause_1}$ by definition.\\
$\LanguageOf{\Delta}{[\Clause_1]} = \LanguageOf{\Delta}{\Regex_1}$ by problem assumption.

Symmetrically for $\LanguageOf{\Delta}{[\ClauseAlt_1]}$.\\
$\PutRightOf{[\ClauseLens]} = \PutRightOf{\ClauseLens}$ by definition\\
$\PutRightOf{[\ClauseLens]} = \PutRightOf{\Lens_1}$ by problem assumption.
\\\\\\



By induction assumption, I know
there exists a $\Lens : \Regex \Leftrightarrow \RegexAlt$ such that
$\Lens.putr = ([\ClauseLens_1 ; \ldots ; \ClauseLens_n],id).putr$,
$\LanguageOf{\Delta}{[\Clause_1 ; \ldots ; \Clause_n]}$ =
$\LanguageOf{\Delta}{\Regex}$,
and $\LanguageOf{\Delta}{[\ClauseAlt_1 ; \ldots ; \ClauseAlt_n}$ = $\LanguageOf{\Delta}{\RegexAlt}$.\\
By assumption, I know that there exists a $\Delta \vdash \Lens_{n+1} : \Regex_{n+1} \Leftrightarrow \RegexAlt_{n+1}$ such that $\LanguageOf{\Delta}{\Regex_{n+1}}=\LanguageOf{\Delta}{\Clause_{n+1}}$
and $\LanguageOf{\Delta}{\RegexAlt_{n+1}}=\LanguageOf{\Delta}{\ClauseAlt_{n+1}}$, where $\Lens_{n+1}.putr=\ClauseLens_{n+1}$.\\
Consider the lens $\FullContext \vdash \OrLens{\Lens}{\Lens_{n+1}} : \RegexOr{\Regex}{\Regex_{n+1}} \Leftrightarrow \RegexOr{\RegexAlt}{\RegexAlt_{n+1}}$.\\
$\LanguageOf{\Delta}{\RegexOr{\Regex}{\Regex_{n+1}}}
= \LanguageOf{\Delta}{\Regex}\cup\LanguageOf{\Delta}{\Regex_{n+1}}$
by definition\\
$\LanguageOf{\Delta}{\RegexOr{\Regex}{\Regex_{n+1}}}
= \LanguageOf{\Delta}{[\Clause_1; \ldots ; \Clause_n]}
\cup\LanguageOf{\Delta}{\Regex_{n+1}}$ by induction assumption.\\
$\LanguageOf{\Delta}{\RegexOr{\Regex}{\Regex_{n+1}}}
= \bigcup_{i=1\ldots n}\LanguageOf{\Delta}{\Clause_i}
\cup\LanguageOf{\Delta}{\Regex_{n+1}}$ by definition.\\
$\LanguageOf{\Delta}{\RegexOr{\Regex}{\Regex_{n+1}}}
= \bigcup_{i=1\ldots n}\LanguageOf{\Delta}{\Clause_i}
\cup\LanguageOf{\Delta}{\Clause_{n+1}}$ by problem assumption.\\
$\LanguageOf{\Delta}{\RegexOr{\Regex}{\Regex_{n+1}}}
= \bigcup_{i=1\ldots n+1}\LanguageOf{\Delta}{\Clause_i}$ by distributivity of $\cup$.\\
$\LanguageOf{\Delta}{\RegexOr{\Regex}{\Regex_{n+1}}}
= \LanguageOf{\Delta}{[\Clause_1; \ldots ; \Clause_n]}$ by definition.

Similarly for
$\LanguageOf{\Delta}{\RegexOr{\RegexAlt}{\RegexAlt_{n+1}}}
= \LanguageOf{\Delta}{[\ClauseAlt_1; \ldots ; \ClauseAlt_n]}$ TODO, split into lemma?.\\
\[
\PutRightOf{\OrLens{\Lens}{\Lens_{n+1}}}(\String) =
  \begin{cases}
    \PutRightOf{\Lens}(\String)& \text{if } \String \in \LanguageOf{\Delta}{\Regex}\\
    \Lens_{n+1}.putr(\String)& \text{if } \String \in \LanguageOf{\Delta}{\Regex_{n+1}}
  \end{cases}
\] by definition.\\
\[
\PutRightOf{\OrLens{\Lens}{\Lens_{n+1}}}(\String) =
  \begin{cases}
    \PutRightOf{[\ClauseLens_1;\ldots;\ClauseLens_n}(\String)& \text{if } \String \in \LanguageOf{[\Clause_1 ; \ldots ; \Clause_n]}{\Regex}\\
    \Lens_{n+1}.putr(\String)& \text{if } \String \in \LanguageOf{\Delta}{\Regex_{n+1}}
  \end{cases}
\] by induction assumption.\\
\[
\PutRightOf{\OrLens{\Lens}{\Lens_{n+1}}}(\String) =
  \begin{cases}
    \PutRightOf{\ClauseLens_1}(\String)& \text{if } \String \in \LanguageOf{\Delta}{\Clause_1}\\
\ldots \\
    \PutRightOf{\ClauseLens_n(\String)}& \text{if } \String \in \LanguageOf{\Delta}{\Clause_n}\\
    \Lens_{n+1}.putr(\String)& \text{if } \String \in \LanguageOf{\Delta}{\Regex_{n+1}}
  \end{cases}
\] by definition of putr.\\
\[
\PutRightOf{\OrLens{\Lens}{\Lens_{n+1}}}(\String) =
  \begin{cases}
    \PutRightOf{\ClauseLens_1}(\String)& \text{if } \String \in \LanguageOf{\Delta}{\Clause_1}\\
\ldots \\
    \PutRightOf{\ClauseLens_n(\String)}& \text{if } \String \in \LanguageOf{\Delta}{\Clause_n}\\
    \Clause_{n+1}.putr(\String)& \text{if } \String \in \LanguageOf{\Delta}{\Clause_{n+1}}
  \end{cases}
\] by problem assumption.\\
$\PutRightOf{\OrLens{\Lens}{\Lens_{n+1}}}(\String) =
\PutRightOf{[\ClauseLens_1; \ldots ; \ClauseLens_{n+1}]}(\String)$ by definition of putr.\\
\end{proof}
\end{lemma}

\begin{lemma}[Soundness of DNF Lenses, Clauses, and Atoms]\leavevmode
\begin{enumerate}
\item Let \DNFRegex{} and \DNFRegexAlt{} be two dnf regular expressions, and $\FullContext \vdash \DNFLens : \DNFRegex \Leftrightarrow \DNFRegexAlt$.  Then there exists a \Lens{}, \Regex{}, and \RegexAlt{} such that $\FullContext \vdash \Lens : \Regex \Leftrightarrow \RegexAlt$, \PutRightOf{\Lens}=\PutRightOf{\DNFLens}, \LanguageOf{\Delta}{\Regex}=\LanguageOf{\Delta}{\DNFRegex}, and \LanguageOf{\Delta}{\RegexAlt}=\LanguageOf{\Delta}{\DNFRegexAlt}.  \LanguageOf{\Delta{}}{\Regex{}} = \LanguageOf{\Delta{}}{\DNFRegex{}} and
\LanguageOf{\Delta{}}{\RegexAlt{}} = \LanguageOf{\Delta{}}{\DNFRegexAlt{}}

\item Let \Clause{} and \ClauseAlt{} be two clauses, and $\FullContext \vdash \ClauseLens : \Clause \Leftrightarrow \ClauseAlt$.  Then there exists a \Lens{}, \Regex{}, and \RegexAlt{} such that $\FullContext \vdash \Lens : \Regex \Leftrightarrow \RegexAlt$, \PutRightOf{\Lens}=\PutRightOf{\ClauseLens}, \LanguageOf{\Delta}{\Regex}=\LanguageOf{\Delta}{\Clause}, and \LanguageOf{\Delta}{\RegexAlt}=\LanguageOf{\Delta}{\ClauseAlt}.  \LanguageOf{\Delta{}}{\Regex{}} = \LanguageOf{\Delta{}}{\Clause{}} and
\LanguageOf{\Delta{}}{\RegexAlt{}} = \LanguageOf{\Delta{}}{\ClauseAlt{}}

\item Let \Atom{} and \AtomAlt{} be two atoms, and $\FullContext \vdash \AtomLens : \Atom \Leftrightarrow \AtomAlt$.  Then there exists a \Lens{}, \Regex{}, and \RegexAlt{} such that $\FullContext \vdash \Lens : \Regex \Leftrightarrow \RegexAlt$, \PutRightOf{\Lens}=\PutRightOf{\AtomLens}, \LanguageOf{\Delta}{\Regex}=\LanguageOf{\Delta}{\Atom}, and \LanguageOf{\Delta}{\RegexAlt}=\LanguageOf{\Delta}{\AtomAlt}.  \LanguageOf{\Delta{}}{\Regex{}} = \LanguageOf{\Delta{}}{\Atom{}} and
\LanguageOf{\Delta{}}{\RegexAlt{}} = \LanguageOf{\Delta{}}{\AtomAlt{}}
\end{enumerate}
\begin{proof}
\begin{itemize}\leavevmode\\
\item $\FullContext \vdash ([\ClauseLens_1;\ldots;\ClauseLens_n],\sigma) : [\Clause_1;\ldots;\Clause_n] \Leftrightarrow [\ClauseAlt_{\sigma(1)};\ldots;\ClauseAlt_{\sigma(n)}]$\\
By Induction assumption, for each $\FullContext \vdash \ClauseLens_i : \Clause_i \Leftrightarrow \ClauseAlt_i$ there exists a $\FullContext \vdash \Lens_i : \Regex_i \Leftrightarrow \RegexAlt_i$.\\
By Lemma~\ref{lem:id-dnf} there exists a $\FullContext \vdash \Lens : \Regex \Leftrightarrow \RegexAlt$ such that $\PutRightOf{\Lens}=\PutRightOf{([\ClauseLens_1;\ldots\ClauseLens_n],id)}$,
$\LanguageOf{\Delta}{\Regex}=\LanguageOf{\Delta}{[\Clause_1;\ldots;\Clause_n]}$, and
$\LanguageOf{\Delta}{\RegexAlt}=\LanguageOf{\Delta}{[\ClauseAlt_1;\ldots;\ClauseAlt_n]}$.\\
By Lemma TODO, $\PutRightOf{([\ClauseLens_1;\ldots\ClauseLens_n],id)}=\PutRightOf{([\ClauseLens_1;\ldots\ClauseLens_n],\sigma)}$.\\
By Lemma TODO, $\LanguageOf{\Delta}{[\ClauseAlt_1;\ldots;\ClauseAlt_n]}=\LanguageOf{\Delta}{[\ClauseAlt_{\sigma(1)};\ldots;\ClauseAlt_{\sigma(n)}]}$.\\
As such, $\PutRightOf{\Lens}=\PutRightOf{([\ClauseLens_1;\ldots\ClauseLens_n],\sigma)}$,
$\LanguageOf{\Delta}{\Regex}=\LanguageOf{\Delta}{[\Clause_1;\ldots;\Clause_n]}$,
and $\LanguageOf{\Delta}{\RegexAlt}=\LanguageOf{\Delta}{[\ClauseAlt_{\sigma(1)};\ldots;\ClauseAlt_{\sigma(n)}]}$.\\

\item$\FullContext \vdash ([(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)],\sigma \in S_n) : [\String_0 ; \Atom_1 ; \ldots ; \Atom_n ; \String_n] \Leftrightarrow [\StringAlt_0; \AtomAlt_{\sigma(1)} ; \ldots ; \AtomAlt_{\sigma(n)} ; \StringAlt_n]$\\
From induction assumption, I know for each $\FullContext \vdash \AtomLens_i : \Atom_i \Leftrightarrow \AtomAlt_i$, there exists a $\FullContext \vdash \Lens_i : \Regex_i \Leftrightarrow \RegexAlt_i$ such that $\PutRightOf{\AtomLens_i}=\PutRightOf{\Lens_i}$,
and $\LanguageOf{\Delta}{\Regex_i}=\LanguageOf{\Delta}{\Atom_i}$ and $\LanguageOf{\Delta}{\RegexAlt_i}=\LanguageOf{\Delta}{\AtomAlt_i}$.\\
By Lemma~\ref{lem:id-clause}, there exists a $\FullContext \vdash \Lens : \Regex \Leftrightarrow \RegexAlt$ such that $\PutRightOf{\Lens}=\PutRightOf{([(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)],id)}$,
$\LanguageOf{\Delta}{\Regex}=\LanguageOf{\Delta}{[\String_0;\Clause_1;\ldots;\Clause_n;\String_{n+1}]}$,
$\LanguageOf{\Delta}{\RegexAlt}=\LanguageOf{\Delta}{[\StringAlt_0;\ClauseAlt_1;\ldots;\ClauseAlt_n;\StringAlt_{n+1}]}$.\\
By Lemma~\ref{lem:perm-exp} there exists a $\FullContext \vdash \Lens_{\sigma} : \Regex' \Leftrightarrow \RegexAlt'$,
such that $\PutRightOf{\Lens_{\sigma}}(\StringAlt_0;\StringAlt_1';\StringAlt_1;\ldots;\StringAlt_n'\StringAlt_n)=\StringAlt_0;\StringAlt_{\sigma(1)}';\StringAlt_1;\ldots;\StringAlt_{\sigma(n)}'\StringAlt_n$,
$\LanguageOf{\Delta}{\Regex'}=\LanguageOf{\Delta}{[\String_0;\Clause_1;\ldots;\Clause_n;\String_{n+1}]}$, and
$\LanguageOf{\Delta}{\RegexAlt'}=\LanguageOf{\Delta}{[\String_0;\Clause_{\sigma(1)};\ldots;\Clause_{\sigma(n)}\String_{n+1}]}$.\\
Consider the lens $\Delta \vdash \ComposeLens{\Lens_{\sigma}}{\Lens} : \Regex \Leftrightarrow \RegexAlt'$.\\
$\PutRightOf{\ComposeLens{\Lens_{\sigma}}{\Lens}}(\String_0\String_1'\ldots\String_n'\String_n)=\PutRightOf{\Lens_{\sigma}}(\PutRightOf{\Lens}(\String_0\String_1'\ldots\String_n'\String_n))$ by definition of compose\\
$\PutRightOf{\ComposeLens{\Lens_{\sigma}}{\Lens}}(\String_0\String_1'\ldots\String_n'\String_n)=\PutRightOf{\Lens_{\sigma}}(\StringAlt_1\PutRightOf{\AtomLens_1}(\String_1')\ldots\PutRightOf{\AtomLens_n}(\String_n')\StringAlt_n)$ by definition of \Lens{}\\
$\PutRightOf{\ComposeLens{\Lens_{\sigma}}{\Lens}}(\String_0\String_1'\ldots\String_n'\String_n)=\StringAlt_1\PutRightOf{\AtomLens_{\sigma(1)}}(\String_{\sigma(1)}')\ldots\PutRightOf{\AtomLens_{\sigma(n)}}(\String_{\sigma(n)}')\StringAlt_n$ by definition of $\Lens_{\sigma}$\\
$\PutRightOf{\ComposeLens{\Lens_{\sigma}}{\Lens}}(\String_0\String_1'\ldots\String_n'\String_n)=([(\String_0,\StringAlt_0);\AtomLens_0;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)],\sigma)(\String_0\String_1'\ldots\String_n'\String_n)$ by definition of clause lens\\
\\
\item$\FullContext \vdash \IterateLens{\DNFLens} : \Star{\DNFRegex} \Leftrightarrow \Star{\DNFRegexAlt}$\\
From induction assumption, I know that there exists $\FullContext \vdash \Lens : \Regex \Leftrightarrow \RegexAlt$, such that
$\PutRightOf{\DNFLens}=\PutRightOf{\Lens}$,
\LanguageOf{\RegexContext}{\Regex}=\LanguageOf{\RegexContext}{\DNFRegex}, and
$\LanguageOf{\Delta}{\RegexAlt}=\LanguageOf{\Delta}{\DNFRegexAlt}$.\\
Consider $\FullContext \vdash \IterateLens{\Lens} : \Star{\Regex} \Leftrightarrow \Star{\RegexAlt}$.\\
$\LanguageOf{\Delta}{\Star{\Regex}} = \String_0\ldots\String_n$ such that $\String_i \in \LanguageOf{\Delta}{\Regex}$ by definition of \LanguageOf{\Delta}{\Star{\Regex}}.\\
$\LanguageOf{\Delta}{\Star{\Regex}} = \String_0\ldots\String_n$ such that $\String_i \in \LanguageOf{\Delta}{\DNFRegex}$ as $\LanguageOf{\Delta}{\DNFRegex}=\LanguageOf{\Delta}{\Regex}$.\\
$\LanguageOf{\RegexContext}{\Star{\Regex}} = \LanguageOf{\RegexContext}{\Star{\DNFRegex}}$ by definition of \LanguageOf{\RegexContext}{\Star{\DNFRegex}}.

Similarly for \LanguageOf{\RegexContext}{\Star{\RegexAlt}}\\\\
$\PutRightOf{\IterateLens{\Lens}}(\String_0\ldots\String_n)=\PutRightOf{\Lens}(\String_0)\ldots\PutRightOf{\Lens}(\String_n)$ by definition of $\PutRightOf{\IterateLens{\Lens}}$.\\
$\PutRightOf{\IterateLens{\Lens}}(\String_0\ldots\String_n)=\PutRightOf{\DNFLens}(\String_0)\ldots\PutRightOf{\DNFLens}(\String_n)$ as \PutRightOf{\DNFLens}=\PutRightOf{\Lens}.\\
$\PutRightOf{\IterateLens{\Lens}}(\String_0\ldots\String_n)=\PutRightOf{\IterateLens{\DNFLens}}(\String_0\ldots\String_n)$ by definition of $\PutRightOf{\IterateLens{\DNFLens}}$.\\
\\
\item$\FullContext \vdash \IdentityLens : \RegexVariable \Leftrightarrow \RegexVariable$\\
Consider $\FullContext \vdash \IdentityLens : \RegexVariable \Leftrightarrow \RegexVariable$\\
$\PutRightOf{\IdentityLens}(\String)=\String$ by definition of dnf \PutRightOf{\IdentityLens{}}.\\
$\PutRightOf{\IdentityLens}(\String)=\PutRightOf{\IdentityLens}(\String)$ by definition of normal $\PutRightOf{\IdentityLens{}}$.
\end{itemize}
\end{proof}
\end{lemma}

\begin{theorem}[Soundness]
Let \Regex{} and \RegexAlt{} be two regular expressions, and \DNFRegex{} and \DNFRegexAlt{} be two dnf regular expressions.
If \LanguageOf{\Delta}{\Regex{}} = \LanguageOf{\Delta}{\DNFRegex{}} and \LanguageOf{\Delta}{\RegexAlt} = \LanguageOf{\Delta}{\DNFRegexAlt{}},
then if there exists a dnf lens $\DNFLens : \DNFRegex \Leftrightarrow \DNFRegexAlt$,
then there exists a lens $\Lens : \Regex \Leftrightarrow \RegexAlt$ such that
$\DNFLens.putr = \Lens.putr$.
\begin{proof}
By mutual induction on the typing \DNFLens{}, the typing of \ClauseLens{}, and the typing of \AtomLens{}.
\begin{enumerate}
\item[DNF Lens Intro] Let $\Delta \vdash ([\ClauseLens_1 ; \ldots ; \ClauseLens_n],\sigma) : [\Clause_{1,1}, \ldots, \Clause_{n,1}] \Leftrightarrow [\Clause_{\sigma(1),2}, \ldots, \Clause_{\sigma(n),2}]$.
This comes from the derivations that $\Delta \vdash \ClauseLens_i : \Clause_{i,1} \Leftrightarrow \Clause_{i,2}$ for all $i$.
Consider instead the lens $\DNFLens' = \Delta \vdash ([\ClauseLens_1 ; \ldots ; \ClauseLens_n],\sigma_id) : [\Clause_{1,1}, \ldots, \Clause_{n,1}] \Leftrightarrow[\Clause_{1,2}, \ldots, \Clause_{n,2}]$.
By Lemma (TODO: this lemma), these two lenses are semantically equivalent.
By Lemma (TODO: this lemma), $\Delta \vdash repregex(\DNFLens') : repregex(\DNFRegex_1) \Leftrightarrow repregex(\DNFRegex_2')$, with $repregex(\DNFLens)$ semantically equivalent to $\DNFLens$.
So $repregex(\DNFLens')$ is semantically equivalent to $\DNFLens'$, and $DNFLens'$ is semantically equivalent $\DNFLens$, so $repregex(\DNFLens')$ is
semantically equivalent to $\DNFLens$.  Merely adding in a retyping rule at
the end of $repregex(\DNFLens')$ (as they have the same type), completes this case.
\item[Clause Lens Intro] Let $\Delta \vdash ([(\String_{1,1},\String_{1,2}) ; \AtomLens_1 ; \ldots ; \AtomLens_n ; (\String_{n+1,1},\String_{n+1,2})],\sigma) : [\String_{1,1};\Atom_{1,1}; \ldots ; \Atom_{1,n} ; \String_{1,n+1}] \Leftrightarrow [\String_{1,2};\Atom_{\sigma(1),2}; \ldots ; \Atom_{\sigma(n),2} ; \String_{n+1,2}]$.
Consider two lenses, $\Delta \vdash ([(\String_{1,1},\String_{1,2}) ; \AtomLens_1 ; \ldots ; \AtomLens_n ; (\String_{n+1,1},\String_{n+1,2})],\sigma_id) : [\String_{1,1};\Atom_{1,1}; \ldots ; \Atom_{1,n} ; \String_{1,n+1}] \Leftrightarrow [\String_{1,2};\Atom_{1,2}; \ldots ; \Atom_{n,2} ; \String_{n+1,2}]$,
and $\Delta \vdash ([(\String_{1,2},\String_{1,2});identitylens(\Atom_{1,2}); \ldots ; identitylens(\Atom_{n,2}) ; (\String_{n+1,2},\String_{n+1,2})],\sigma) : [\String_{1,2};\Atom_{1,2}; \ldots ; \Atom_{n,2} ; \String_{n+1,2}] \Leftrightarrow [\String_{1,2};\Atom_{\sigma(1),2}; \ldots ; \Atom_{\sigma(n),2} ; \String_{n+1,2}]$.
By Lemma (TODO:), there exists a lens equivalent to the first one, call it $\Lens_{transform}$.
By Lemma (TODO:), there exists a lens equivalent to the second one, call it $\Lens_{\sigma}$.
Consider $\ComposeLens{\Lens_{\sigma}}{\Lens_{transform}}$.  Go through semantics, oh look they are equivalent.

\end{enumerate}
\end{proof}
\end{theorem}

