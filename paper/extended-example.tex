\section{Lens Synthesis by Example}

In order to explain the major components of our synthesis algorithm,
we will consider a running example involving conversion between citations given
in highly simplified BibTex and EndNote formats.  Our BibTex format
consists entirely of specifying a list of authors on a single line as follows.
\begin{lstlisting}
author={Conway, John and Kleene, Stephen Cole}
\end{lstlisting}
Our EndNote format contains the same information, but uses different separators,
rearranges the order of first and last names, and uses a separate line for each
author. 
\begin{lstlisting}
%A John Conway
%A Stephen Cole Kleene
\end{lstlisting}

\begin{figure}
\begin{lstlisting}
Name = [A-Z][a-z]*
Names = (" " Name)*

BNames = Name ", " Name Names
Bib = ""
    | "author={" BNames (" and " BNames)* "},"

ENames = Name Names " " Name
End = ("%A " ENames "\n")*

BibEnd : Bib <=> End = {
"author={Conway, John and Kleene, Stephen Cole}"
<-> "%A John Conway\n%A Stephen Cole Kleene" }
\end{lstlisting}
\caption{Synthesis Problem Definition: Idealized Bibtex to EndNote}
\label{fig:bibend-spec}
\end{figure}

Figure~\ref{fig:bibend-spec} presents
the user's specification of such a problem.  In general, such specifications are
given by defining the source and target data formats~\footnote{Lenses
operate both left-to-right and right-to-left, so both formats are sometimes
sources and sometimes targets. Nevertheless, we will often call the
format on the left, the ``source,'' and the format on the right, 
the ``target.''} as well as some examples.  In this case, the lens
we wish to synthesize is \CF{BibEnd}.  It converts between 
the formats \CF{Bib} and \CF{End}.
Such formats are defined using a standard syntax for regular expressions.
Intermediate regular expressions are named in order to facilitate
construction of complex formats.

\subsection{Regular Bijective Lenses}
\afm{I'm not sure how necessary this section is.  While I want to give users a
  bit of idea about how things map between one another, I think this section
  might go into too much detail.  How would I be able to give the intuition of
  finding parts that map to each other, without just describing lenses (assuming
  that's the right sort of thing to do)?}
Once we have a synthesis specification, we need to find a lens that
will convert back and forth between formats and that satisfies the
given examples.  In this paper, we begin our work with a simple and 
relatively standard language of bijective string lens combinators.
In order to guarantee the functions generated by these combinators
form proper bijections between source and target, they are given types using
regular expressions.  We typically write
$\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ to indicate that a lens $\Lens$
converts back and forth between data belonging
to the languages of regular expressions
$\Regex$ and $\RegexAlt$.

The simplest lens in the combinator language is the identity lens 
at type $R$,
$\IdentityLensOf{R}$, which copies data matching regular expression $R$
from source to target, and vice versa.  The
constant lens $\ConstLensOf{\String_1}{\String_2}$, when operated left-to-right, 
replaces string $\String_1$ with $\String_2$, and when operated right-to-left,
replaces string $\String_2$ with $\String_1$.

Each of the other lenses manipulate structured data.  For instance,
$\ConcatLensOf{\Lens_1}{\Lens_2}$ operates by applying $\Lens_1$ to the left
portion of a string, and $\Lens_2$ to the right, and concatenating the results.
$\SwapLensOf{\Lens_1}{\Lens_2}$ does the same as $\ConcatLensOf{\Lens_1}{\Lens_2}$
but it swaps the results before concatenating.
$\OrLensOf{\Lens_1}{\Lens_2}$ operates by applying either $\Lens_1$ or $\Lens_2$
to the string.  $\IterateLensOf{\Lens}$ operates by repeatedly applying $\Lens$
to subparts of a string.

\paragraph*{Step 1:  Inlining Definitions.}

\begin{figure}
  \Tree[.\textcolor{dkred}{\sout{\CF{Bib}}}
    [.\textcolor{dkred}{\sout{\CF{BNames}}}
      \CF{Name}
      [.\CF{Names}
        \CF{Name} ]]]
  \Tree[.\textcolor{dkred}{\sout{\CF{End}}}
    [.\textcolor{dkred}{\sout{\CF{ENames}}}
      \CF{Name}
      [.\CF{Names}
        \CF{Name} ]]]
\caption{
Trees of user defined regular expressions,
with those that must be replaced by their definitions crossed out.
}
\label{fig:expanded-defs}
\end{figure}

There is no lens that goes between \BibTex{} and \EndNote{}, so one of them must
be expanded.
Indeed, both of them must be expanded, as \BibTex{} will never be able to be
the source of any lens in this problem, nor will \EndNote{} be able to be the
target.
This can be generalized for the sub-expressions of \BibTex{} and \EndNote{},  
If, any user defined data type does not exist in the possible types of the
other side, it must be expanded, shown in Figure~\ref{fig:expanded-defs}.

\begin{figure}
\begin{lstlisting}
Bib':
  "" 
  | ("author={" Name ", " Name Names
    (" and " (Name ", " Name Names))* "},")

End':
  ("%A " (Name Names " " Name) "\n")*
\end{lstlisting}
\label{fig:examples-expanded}
\caption{
  \CF{Bib} and \CF{End} with necessary name replacements preformed.
}
\end{figure}
After completing these necessary expansions, the problem becomes synthesizing a
lens between the regular expressions \CF{Bib'} and \CF{End'} shown in
Figure~\ref{fig:examples-expanded}.

A basic type directed synthesis approach from here will quickly fail.
Both \CF{Bib'}
and \CF{End'} are of the form $\Regex_1\Concat\Regex_2$, but there is
not a lens between \CF{"\%0"} and
\CF{("@inproceedings" | "@article" | "@book")}.

\begin{figure}
\begin{lstlisting}
DNFBib':
  ""
  | "author={" Name ", " Name "" Names ""
    (" and " Name ", " Name "" Names "")* "},"

DNFEnd':
  "" ("%A " Name "" Names " " Name "\n")* ""
\end{lstlisting}
\label{fig:examples-expanded-normalized}
\caption{
  \CF{Bib'} and \CF{End'} put into a semi-normal form.
}
\end{figure}

These issues can be handled by normalizing the regular expressions slightly.
We put them in a form that normalizes away the equivalences involving
associativity, distributivity, and \EmptyString{}, shown in
Figure~\ref{fig:examples-expanded-normalized}


With those equivalences handled, one might think it is now possible to
synthesize the lens.
Unfortunately, we are still unable to preform any synthesis because the types
on the left and right are quite different, and the lens connectives require
similar types of the left and right.
For example, as \CF{DNFBib'} has an outer $\Or$, we know an or lens must be
synthesized.
However, an or lens requires an outer $\Or$ on both sides, and \CF{DNFEnd'} does
not have any outer $\Or$.

\begin{figure}
\begin{lstlisting}
DNFEndUnroll:
  ""
  | "%A " Name "" Names " " Name "\n"
    ("%A " Name "" Names " " Name "\n")* ""

DNFEndMod2:
  ""
      ("%A " Name "" Names " " Name
        "\n%A " Name "" Names " " Name "\n")* ""
  | "%A " Name "" Names " " Name "\n"
      ("%A " Name "" Names " " Name
        "\n%A " Name "" Names " " Name "\n")* ""
  
\end{lstlisting}
\label{fig:examples-star-equivalenced}
\caption{
  \CF{DNFEnd'} with some star equivalences preformed.
}
\end{figure}

\paragraph*{Step 2:  Traversing Equivalences.}
While, with normalization, certain equivalences have been handled, there are
still many equivalences that haven't been handled.
For example, the equivalences $\StarOf{A}=\EmptyString \Or A\StarOf{A}$ and
$\StarOf{A}=(\EmptyString \Or A)\StarOf{(AA)}$ can be applied to the star in
\CF{End'}, resulting in \CF{DNFEndUnroll} and \CF{DNFEndMod2}, shown in
Figure~\ref{fig:examples-star-equivalenced}.

However, now a single problem of finding a lens between regular expression has
become two problems!  This can be solved by using a priority queue, where the
elements in the queue are regular expression specifications.  The priority of
each specification is a combination of how many expansions have been preformed,
and how different the two regular expressions in the specification are.
\CF{DNFEndUnroll} and \CF{DNFBib'} are very similar, in that they have the same
number of instances of \CF{Name} and \CF{Names}.  However, \CF{DNFEndMod2} is
very different, with a different number of \CF{Name}, \CF{Names}, and a
different number of $\Star$s.  Because of this large difference, the
specification of \CF{DNFBib' <=> DNFEndUnroll} would get popped, instead of the
specification of \CF{DNFBib' <=> DNFEndMod2}.

\paragraph*{Step 3: Creating Lenses.}
Because the regular expressions of  \CF{DNFBib'} and \CF{DNFEndUnroll} are so
similar, type directed synthesis can now happen between them.
Following the types, the outer \CF{""}s
would get mapped to each other, and the sides of the disjunct with $\Star$s
would get mapped to each other.  Within that side, \CF{Name} would map to
\CF{Name}, \CF{Names} would map to \CF{Names} and the $\Star$s would map to the
$\Star$s.

In doing this though, some ambiguity is introduced.  There are two
instances of \CF{Name} present outside a star, so which one should get mapped to
which?  The basic solution would be to map the first to the first, and the
second to the second.  This is not correct, however, as the generated lens for
this will not match the examples.  We can determine which maps to which, as they
must each match the same substrings.  The first \CF{Name} in \CF{DNFBib'}
matches \CF{"Conway"} and the second matches \CF{"John"}.  The first \CF{Name} in
\CF{DNFEndUnroll} matches \CF{"John"} and the second matches \CF{"Conway"}.
This means that the first \CF{Name} in \CF{DNFBib'} must map to the second
\CF{Name} in \CF{DNFEndUnroll}, and vice-versa.  Doing this will generate a lens
that satisfies the type and the examples.


%%% Local Variables:
%%% TeX-master: "main"
%%% End: