\section{Background}

\subsubsection{Languages and Alphabets}

A \textit{character}, denoted \Character{} or \CharacterAlt{}, is a symbol.
An \textit{alphabet}, denoted \Alphabet{}, is set of characters.
A \textit{string}, denoted \String{} or \StringAlt{}, is a sequence of characters.
The empty sequence is denoted \EmptyString{}.
The set of all strings is denoted \StarOf{\Alphabet}.
A \textit{language}, denoted \Language{}, is a subset of \StarOf{\Alphabet}.

If \String{} and \StringAlt{} are strings, with
$\String=\Character_1\ldots\Character_n$,
and $\StringAlt=\CharacterAlt_1\ldots\CharacterAlt_m$,
then the \textit{concatenation} of \String{} and \StringAlt{},
denoted \String{}\Concat\StringAlt{}, is defined as
$\Character_1\ldots\Character_n\CharacterAlt_1\ldots\CharacterAlt_m$.

If $\Language_1$ and $\Language_2$ are languages, where
for all strings $\String_1,\StringAlt_1\in\Language_1$ and
$\String_2,\StringAlt_2\in\Language_2$,
$\String_1\Concat\String_2=\StringAlt_1\Concat\StringAlt_2$ implies
$\String_1=\StringAlt_1$ and $\String_2=\StringAlt_2$, then
$\Language_1$ and $\Language_2$ are \textit{unambiguously concatenable},
denoted $\Language_1\UnambigConcat\Language_2$.
If $\Language_1\ldots\Language_n$ is a sequence of languages, where
if $\String_i,\StringAlt_i\in\Language_i$ for all $i$, then
$\String_1\Concat\ldots\Concat\String_n=\StringAlt_1\Concat\ldots\Concat\StringAlt_n$
implies $\String_i=\StringAlt_i$ for all $i$, then
the sequence of languages is \textit{unambiguously concatenable},
denoted $\UnambigConcat\SequenceOf{\Language_1;\ldots;\Language_n}$,

If $\Language$ is a language, where
for all $n\in\Nats$ and for all strings
$\String_1,\StringAlt_1,\ldots,\String_n,\StringAlt_n\in\Language$,
$\String_1\Concat\ldots\Concat\String_n=\StringAlt_1\Concat\ldots\Concat\StringAlt_n$
implies $\String_i=\StringAlt_i$ for all $i$,
that language is \textit{unambiguously iterable},
denoted $\UnambigItOf{\Language}$.

\subsubsection{Regular Expressions}

% fig:regex-syntax
\begin{figure}
\centering
\begin{tabular}{l@{\hspace*{5mm}}l@{\ }c@{\ }l@{\hspace*{5mm}}>{\itshape\/}l}

(Strings)& \String{},\StringAlt{} & \GEq{} & $\String\in\StarOf{\Sigma}$ \\
(Regexs)& \Regex{},\RegexAlt{} & \GEq{} & s & Base \\
& & & \GBar{} $\emptyset$ & Empty \\
& & & \GBar{} \Regex{}* & Star \\
& & & \GBar{} $\RegexConcat{\Regex_1}{\Regex_2}$ & Concat \\
& & & \GBar{} $\RegexOr{\Regex_1}{\Regex_2}$ & Or \\
\end{tabular}
\caption{Regular Expression Syntax}
\label{fig:regex-syntax}
\end{figure}

% fig:regex-semantics
\begin{figure}
\[
\begin{array}{lcl}
\LanguageOf{\String} &=& \{\String\}\\
\LanguageOf{\emptyset} &=& \{\}\\
\LanguageOf{\RegexConcat{\Regex_1}{\Regex_2}} &=&
\{\StringConcat{\String_1}{\String_2} \SuchThat
\String_1\in\LanguageOf{\Regex_1} \BooleanAnd \String_2\in\LanguageOf{\Regex_2}\}\\
\LanguageOf{\RegexOr{\Regex_1}{\Regex_2}} &=&
\{\String \SuchThat
\String\in\LanguageOf{\Regex_1} \BooleanOr \String\in\LanguageOf{\Regex_2}\}\\
\LanguageOf{\StarOf{\Regex}} &=&
\{\String_1\Concat\ldots\Concat\String_n \SuchThat
n\in\Nats \wedge \String_i\in\LanguageOf{\Regex}\}
\end{array}
\]
\caption{Regex Semantics}
\label{fig:regex-semantics}
\end{figure}

The syntax for regular expressions is given in Figure~\ref{fig:regex-syntax}.
These regular expressions have an underlying semantics to express languages,
formalized in Figure~\ref{fig:regex-semantics}.

% fig:regex-equivalence-rules
\begin{figure}
\centering
\begin{tabular}{@{}r@{\hspace{1em}}c@{\hspace{1em}}l@{}r@{}}
\Regex{} & $\equiv$ & \Regex{} & \EqualityRule{}  \\
\RegexOr{\Regex}{\emptyset} & $\equiv$ & \Regex{} & \OrIdentityRule{} \\
$\RegexConcat{\Regex}{\emptyset}$ & $\equiv$ & $\emptyset$ & \EmptyProjectionRuleRightRule{} \\
$\RegexConcat{\emptyset}{\Regex}$ & $\equiv$ & $\emptyset$ & \EmptyProjectionRuleLeftRule{}\SubLeft{} \\
\RegexConcat{(\RegexConcat{\Regex{}}{\Regex'})}{\Regex''} & $\equiv$ & \RegexConcat{\Regex{}}{(\RegexConcat{\Regex'}{\Regex''})} & \ConcatAssocRule{}  \\
\RegexOr{(\RegexOr{\Regex}{\Regex'})}{\Regex''} & $\equiv$ & \RegexOr{\Regex}{(\RegexOr{\Regex'}{\Regex''})} & \OrAssociativityRule{}  \\
\RegexOr{\Regex{}}{\RegexAlt{}} & $\equiv$ & \RegexOr{\RegexAlt{}}{\Regex{}} & \OrCommutativityRule{}\\
\RegexConcat{\Regex{}}{(\RegexOr{\Regex{}'}{\Regex{}''})} & $\equiv$ & \RegexOr{(\RegexConcat{\Regex{}}{\Regex{}'})}{(\RegexConcat{\Regex{}}{\Regex{}''})} & \DistributivityLeftRule{} \\
\RegexConcat{(\RegexOr{\Regex{}'}{\Regex{}''})}{\Regex{}} & $\equiv$ & \RegexOr{(\RegexConcat{\Regex{}'}{\Regex{}})}{(\RegexConcat{\Regex{}''}{\Regex{}})} & \DistributivityRightRule{} \\
\RegexConcat{\Regex{}}{\EmptyString{}} & $\equiv$ & \Regex{} & \ConcatIdentityRule{} \\
\StarOf{(\RegexOr{\Regex{}}{\RegexAlt{}})} & $\equiv$ & \RegexConcat{\StarOf{(\RegexConcat{\StarOf{\Regex{}}}{\RegexAlt{}})}}{\StarOf{\Regex{}}} & \SumstarRule{}\\
\StarOf{(\RegexConcat{\Regex{}}{\RegexAlt{}})} & $\equiv$ & \RegexOr{\EmptyString{}}{(\RegexConcat{\RegexConcat{\Regex{}}{\StarOf{(\RegexConcat{\RegexAlt{}}{\Regex{}})}}}{\RegexAlt{}})} & \ProductstarRule{} \\
${(\Regex{}^*)}^*$ & $\equiv$ & \StarOf{\Regex{}} & \StarstarRule{} \\
\StarOf{(\RegexOr{\Regex}{\RegexAlt})} & $\equiv$ & $\StarOf{(\RegexConcat{(\RegexOr{\Regex}{\RegexAlt})}{\RegexOr{\RegexAlt}{\RegexConcat{{(\RegexConcat{\Regex}{\StarOf{\RegexAlt}})}^n}{\Regex}}})}\Concat$ & \DicyclicityRule{}\\
& & $(\EmptyString\Or(\RegexOr{\Regex}{\RegexAlt})\Concat$\\
& & $({(\RegexConcat{\Regex}{\StarOf{\RegexAlt}})}^0\Or\ldots\Or{(\RegexConcat{\Regex}{\StarOf{\RegexAlt}})}^n))$
\end{tabular}
\caption{Regular Expression Equivalences}
\label{fig:regex-equivalence-rules}
\end{figure}

If, for two regular expressions, $\Regex_1$ and $\Regex_2$,
$\LanguageOf{\Regex_1}=\LanguageOf{\Regex_2}$, those two regular expressions
are called \textit{equivalent}, denoted $\Regex_1\equiv\Regex_2$.
There exists an equational theory for determining if two regular expressions are equivalent,
presented by Conway \cite{conway}, and proven complete by Krob \cite{Krob},
shown in Figure~\ref{fig:regex-equivalence-rules}.

\subsubsection{Bijective Lenses}

% fig:lens-syntax
\begin{figure}
\centering
\begin{tabular}{l@{\ }l@{\ }c@{\ }l@{\ }>{\itshape\/}r}
% REGEX
(Lenses)& \Lens{} & \GEq{} & $\ConstLens{s_1 \in \StarOf{\Alphabet}}{s_2 \in \StarOf{\Alphabet}}$ & Const \\
& & & \GBar{} $\IdentityLensOf{\Regex}$ & Identity\\
& & & \GBar{} $\IterateLens{\Lens}$ & Iterate \\
& & & \GBar{} $\ConcatLens{\Lens_1}{\Lens_2}$ & Concat \\
& & & \GBar{} $\SwapLens{\Lens_1}{\Lens_2}$ & Swap\\
& & & \GBar{} $\OrLens{\Lens_1}{\Lens_2}$ & Or\\
& & & \GBar{} $\ComposeLens{\Lens_1}{\Lens_2}$ & Compose\\
\end{tabular}
\caption{Lens Syntax}
\label{fig:lens-syntax}
\end{figure}

% fig:lens-semantics
\begin{figure}
\[
\begin{array}{rcl}
\SemanticsOf{const(\String_1,\String_2)} &=& \SetOf{(\String_1,\String_2)}\\

\SemanticsOf{\IdentityLensOf{\Regex}} &=& \SetOf{(\String,\String)\SuchThat\String\in\LanguageOf{\Regex}}\\

\SemanticsOf{\IterateLens{\Lens}} &=& \SetOf{(\String_1\Concat\ldots\Concat\String_n,
\StringAlt_1\Concat\ldots\Concat\StringAlt_n)\SuchThat
(\String_i,\StringAlt_i)\in\SemanticsOf{\Lens}}\\

\SemanticsOf{\ConcatLens{\Lens_1}{\Lens_2}} &=&
\SetOf{(\String_1\Concat\String_2,\StringAlt_1\Concat\StringAlt_2)\SuchThat\\
& & \hspace*{2em}(\String_1,\StringAlt_1)\in\SemanticsOf{\Lens_1}\BooleanAnd
(\String_2,\StringAlt_2)\in\SemanticsOf{\Lens_2}}\\

\SemanticsOf{\SwapLens{\Lens_1}{\Lens_2}} &=&
\SetOf{(\String_1\Concat\String_2,\StringAlt_2\Concat\StringAlt_1)\SuchThat\\
& & \hspace*{2em}(\String_1,\StringAlt_1)\in\SemanticsOf{\Lens_1}\BooleanAnd
(\String_2,\StringAlt_2)\in\SemanticsOf{\Lens_2}}\\

\SemanticsOf{\OrLens{\Lens_1}{\Lens_2}} &=&
\SetOf{(\String,\StringAlt)
\SuchThat(\String,\StringAlt)\in\SemanticsOf{\Lens_1}
\BooleanOr(\String,\StringAlt)\in\SemanticsOf{\Lens_2}}\\

\SemanticsOf{\ComposeLens{\Lens_1}{\Lens_2}} &=&
\SetOf{(\String_1,\String_3)\SuchThat\exists\String_2\\
& & \hspace*{2em}(\String_1,\String_2)\in\SemanticsOf{\Lens_1}\BooleanAnd
(\String_2,\String_3)\in\SemanticsOf{\Lens_2}}
\end{array}
\]
\caption{Lens Semantics}
\label{fig:lens-semantics}
\end{figure}

% fig:lens-semantics
\begin{figure}
\centering
\begin{mathpar}
\inferrule[\ConstantLensRule{}]
{
\String_1 \in \StarOf{\Sigma}\\
\String_2 \in \StarOf{\Sigma}
}
{
\ConstLens{\String_1}{\String_2} \OfType \String_1 \Leftrightarrow \String_2
}

\inferrule[\IdentityLensRule{}]
{
}
{
\IdentityLensOf{\Regex} \OfType \Regex \Leftrightarrow \Regex
}

\inferrule[\IterateLensRule{}]
{
\Lens \OfType \Regex \Leftrightarrow \RegexAlt\\
\UnambigItOf{\LanguageOf{\Regex}}\\
\UnambigItOf{\LanguageOf{\RegexAlt}}
}
{
\IterateLens{\Lens} \OfType \StarOf{\Regex} \Leftrightarrow \StarOf{\RegexAlt}
}

\inferrule[\ConcatLensRule{}]
{
\Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1\\
\Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2\\\\
\UnambigConcatOf{\LanguageOf{\Regex_1}}{\LanguageOf{\Regex_2}}\\
\UnambigConcatOf{\LanguageOf{\RegexAlt_1}}{\LanguageOf{\RegexAlt_2}}
}
{
\ConcatLens{\Lens_1}{\Lens_2} \OfType \Regex_1\Regex_2 \Leftrightarrow \RegexAlt_1\RegexAlt_2
}

\inferrule[\SwapLensRule{}]
{
\Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1\\
\Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2\\\\
\UnambigConcatOf{\LanguageOf{\Regex_1}}{\LanguageOf{\Regex_2}}\\
\UnambigConcatOf{\LanguageOf{\RegexAlt_2}}{\LanguageOf{\RegexAlt_1}}
}
{
\SwapLens{\Lens_1}{\Lens_2} \OfType \Regex_1\Regex_2 \Leftrightarrow \RegexAlt_2\RegexAlt_1
}

\inferrule[\OrLensRule{}]
{
\Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1\\
\Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2\\\\
\UnambigOrOf{\LanguageOf{\Regex_1}}{\LanguageOf{\Regex_2}}\\ \UnambigOrOf{\LanguageOf{\RegexAlt_1}}{\LanguageOf{\RegexAlt_2}}
}
{
\OrLens{\Lens_1}{\Lens_2} \OfType \Regex_1 | \RegexAlt_1 \Leftrightarrow \Regex_2 | \RegexAlt_2
}

\inferrule[\ComposeLensRule{}]
{
\Lens_1 \OfType \Regex_1 \Leftrightarrow \Regex_2\\
\Lens_2 \OfType \Regex_2 \Leftrightarrow \Regex_3\\
}
{
\ComposeLens{\Lens_2}{\Lens_1} \OfType \Regex_1 \Leftrightarrow \Regex_3
}

\inferrule[\RewriteRegexLensRule{}]
{
\Lens \OfType \Regex_1 \Leftrightarrow \Regex_2\\
\Regex_1 \equiv \Regex_1'\\
\Regex_2 \equiv \Regex_2'
}
{
\Lens \OfType \Regex_1' \Leftrightarrow \Regex_2'
}
\end{mathpar}

\caption{Lens Typing}
\label{fig:lens-typing}
\end{figure}

Bijective lenses are a certain class of lenses which define bijective functions
between the languages of regular expressions.
The syntax for these bijective lenses is provided in Figure~\ref{fig:lens-syntax}.
The semantics and for these lenses are defined in Figure~\ref{fig:lens-semantics},
and the typing is given in Figure~\ref{fig:lens-typing}, where a well
typed program provides a bijection between the language of the regular expressions
of its type.

\begin{theorem}[Bijections Between Well-Typed Lenses]
If there exists a typing $\Lens\OfType\Regex\Leftrightarrow\RegexAlt$, then
for all $\String\in\LanguageOf{\Regex}$, there exists a unique
$\StringAlt\in\LanguageOf{\RegexAlt}$ such that
$(\String,\StringAlt)\in\SemanticsOf{\Lens}$.
\end{theorem}

The semantics is only defined alongside the typing, as the functions are only
well defined when the term is well typed.

These lenses can be synthesized from types and examples through an enumeration
of programs of the desired typing.
We would like to enumerate all of the lenses that satisfy the desired typing
until we find one that satisfies the examples.
Through enumeration of the programs that satisfy the desired typing, eventually
one that satisfies the examples will be found.
The strict typing of these programs allows for enumeration by creating
subproblems based on typing rules.

For example, given the type $\RegexConcat{\Regex_1}{\Regex_2}\Leftrightarrow\RegexConcat{\RegexAlt_1}{\RegexAlt_2}$.
A lens of this type can be created from a Concat Lens rule,
which would create the subproblems of finding a lens of type $\Regex_1\Leftrightarrow\RegexAlt_1$
and a lens of type $\Regex_2\Leftrightarrow\RegexAlt_2$.

\section{DNF Regular Expressions}

% fig:dnf-regex-syntax
\begin{figure}
\begin{tabular}{l@{\ }l@{\ }c@{\ }l@{\ }>{\itshape\/}r}

% DNF_REGEX
(Atoms)& \Atom{},\AtomAlt{} & \GEq{} & \StarOf{\DNFRegex{}} & Iterate\\
(Sequences)& \Sequence{},\SequenceAlt{} & \GEq{} &
$\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}$ & MultiConcat\\
(DNF Regexes)& \DNFRegex{},\DNFRegexAlt{} & \GEq{} & $\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}$ & MultiOr\\
\end{tabular}
\caption{DNF Regex Syntax} 
\label{fig:dnf-regex-syntax}
\end{figure}

% fig:dnf-regex-semantics
\begin{figure}
\begin{tabular}{R@{}L}
\LanguageOf{\StarOf{\DNFRegex}} = &
\{\String_1\Concat\ldots\Concat\String_n \SuchThat n\in\Nats \wedge \String_i\in\LanguageOf{\DNFRegex}\}\\
\LanguageOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}}= &
\{\String_0\Concat\StringAlt_1\Concat\ldots\Concat\StringAlt_n\Concat\String_n \SuchThat \StringAlt_i\in\LanguageOf{\Atom_i}\}\\
\LanguageOf{\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}}= &
\{\String \SuchThat \String \in \LanguageOf{\Sequence_i} \text{ for some $i\in\RangeIncInc{1}{n}$}\}
\end{tabular}
\caption{DNF Regex Semantics}
\label{fig:dnf-regex-semantics}
\end{figure}

When attempting to synthesize a lens, one would be able to synthesize the lens
in a type directed fashion, were it not for \RewriteRegexLensRule{}.
Because of that, the job of synthesis is made easier if there is less of a use
for \RewriteRegexLensRule{}.
A good way to minimize the impact of this rule is to make more
regular expressions equivalent.  This is done by putting the regular expressions
into a normal form called DNF regular expressions.
A DNF regular expression is, intuitively, a regular expression with
distributivity applied wherever possible, causing outer layer of \Or{} operations,
with a sequences of \Concat{} operations being operated on by the \Or{} operations.
Furthermore, because of the associativity of \Or{} and \Concat{}, we
remove associativity information through a list representation.
Furthermore, we can further simplify by requiring the
and with base string regular expressions to always appear at fixed locations,
utilizing the fact that $\EmptyString{}$ is the $\Concat$ identity, and
the ability to combine strings.
The syntax of the language of DNF regular expressions is formalized in Figure~\ref{fig:dnf-regex-syntax}.
The shorthand $\DNFOf{\SequenceOf{\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n}}$
stands for
$\DNFOf{\SequenceOf{\EmptyString\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\EmptyString}}$.

The outermost layer is a list of sequences.
This layer intuitively corresponds to the choices involved in regular expression matching, and so represents where the Ors of normal regular expressions exist.
The second layer is a list of alternating strings and stars.
After the choice has been made about what will be expressed,
the base strings and iterated portions remains to be expressed.
This is kept in a normal form by requiring a (possibly empty) string between
each clause.
The clause corresponds to the concatenated data, and is a concatenation of the
fixed data of base strings, and the iterated data of stars.
Finally is the atom, which is a star.
The iteration in atoms correspond to the iteration that takes place in normal stars.
There is no fixed way to break the choices of the iteration into the clause,
as there is an arbitrarily large number of choices made in the stars, proceed
in the iteration to stop iteration.
This intuition is formalized by the semantics, given in
Figure~\ref{fig:dnf-regex-semantics}.

% fig:dnf-regex-functions
\begin{figure}
\ConcatSequence{} \OfType{} \ArrowTypeOf{\SequenceType{}}{\ArrowTypeOf{\SequenceType{}}{\SequenceType{}}}\\
$\ConcatSequenceOf{[\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n]}{[\StringAlt_0\SequenceSep\AtomAlt_1\SequenceSep\ldots\SequenceSep\AtomAlt_m\SequenceSep\StringAlt_m]}=$\\
\hspace*{2ex}$[\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n\Concat\StringAlt_0\SequenceSep\AtomAlt_1\SequenceSep\ldots\SequenceSep\AtomAlt_m\SequenceSep\StringAlt_m]$\\
\\
\ConcatDNF{} \OfType{} \ArrowTypeOf{\DNFRegexType{}}{\ArrowTypeOf{\DNFRegexType{}}{\DNFRegexType{}}}\\
$\ConcatDNFOf{\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}}{\DNFOf{\SequenceAlt_1\DNFSep\ldots\DNFSep\SequenceAlt_m}}=$
\[
\begin{array}{rcccl}
\DNFLeft & \ConcatSequenceOf{\Sequence_1}{\SequenceAlt_1}\DNFSep & \cdots & \ConcatSequenceOf{\Sequence_1}{\SequenceAlt_m}\DNFSep \\
& & \cdots & \\
& \ConcatSequenceOf{\Sequence_n}{\SequenceAlt_1}\DNFSep & \cdots & \ConcatSequenceOf{\Sequence_n}{\SequenceAlt_m} & \DNFRight
\end{array}
\]
\\
\OrDNF{} \OfType{} \ArrowTypeOf{\DNFRegexType{}}{\DNFRegexType{}}\\
$\OrDNFOf{\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}}{\DNFOf{\SequenceAlt_1\DNFSep\ldots\DNFSep\SequenceAlt_m}}$=\\
\hspace*{2ex}$\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n\DNFSep\SequenceAlt_1\DNFSep\ldots\DNFSep\SequenceAlt_m}$\\
\\
(-)\RepeatDNFOfTimes{n} \OfType{} \ArrowTypeOf{\DNFRegexType{}}{\DNFRegexType{}}\\
$\RepeatDNFOf{0}{\DNFRegex}=\DNFOf{\SequenceOf{\EmptyString}}$\\
$\RepeatDNFOf{n}{\DNFRegex}=\ConcatDNFOf{\DNFRegex}{\RepeatDNFOf{n-1}{\DNFRegex}}$\\
\caption{DNF Regex Functions} 
\label{fig:dnf-regex-functions}
\end{figure}

A DNF regular expression can be created from a regular expression through repeated
application of the distributivity rule, and through removal of association information.
To create a DNF regular expresion from a regular expression,
some functions need to be defined on DNF regular expressions,
which are defined in Figure~\ref{fig:dnf-regex-functions}.
From these functions, \ToDNFRegex{}, a function which converts a regular expression into
an equivalent DNF regular expression, can be defined.

\begin{definition}
\leavevmode
\[
\begin{array}{rcl}
\ToDNFRegex(\String) & = & \DNFOf{\SequenceOf{\String}}\\
\ToDNFRegex(\emptyset) & = & \DNFOf{}\\
\ToDNFRegex(\StarOf{(\Regex)}) & = & \DNFOf{\SequenceOf{(\StarOf{\ToDNFRegex(\Regex)})}}\\
\ToDNFRegex(\RegexConcat{\Regex_1}{\Regex_2}) & = & \ToDNFRegex(\Regex_1) \ConcatDNF \ToDNFRegex(\Regex_2)\\
\ToDNFRegex(\RegexOr{\Regex_1}{\Regex_2}) & = & \ToDNFRegex(\Regex_1) \OrDNF \ToDNFRegex(\Regex_2)\\
\end{array}
\]
\end{definition}
This transformation is a valid transformation.
\begin{restatable}[Completeness of DNF Regexs]{theorem}{dnfrc}
\label{thm:completeness-dnf-lenses}
For all regular expressions \Regex{},
\LanguageOf{\ToDNFRegex(\Regex)}=\LanguageOf{\Regex{}}.
\end{restatable}
%proof-dnfrc start
First we will prove some lemmas.
\begin{lemma}[Equivalence of \ConcatSequence{} and \Concat{}]
If $\LanguageOf{\Regex}=\LanguageOf{\Sequence}$,
and $\LanguageOf{\RegexAlt}=\LanguageOf{\SequenceAlt}$,
then $\LanguageOf{\RegexConcat{\Regex}{\RegexAlt}}=\LanguageOf{\ConcatSequenceOf{\Sequence}{\SequenceAlt}}$.
\end{lemma}
\begin{proof}
Let $\Sequence=\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
\SequenceSep\Atom_n\SequenceSep\String_n}$, and
let\\ $\SequenceAlt=[\StringAlt_0\SequenceSep\AtomAlt_1\SequenceSep\ldots
\SequenceSep\AtomAlt_m\SequenceSep\StringAlt_m]$\\
\begin{tabular}{@{}L@{}L@{}}
\LanguageOf{\ConcatSequenceOf{\Sequence}{\SequenceAlt}} & = 
\LanguageOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
\SequenceSep\Atom_n\SequenceSep\String_n\Concat\StringAlt_0\SequenceSep{}
\AtomAlt_1\SequenceSep\ldots\SequenceSep\AtomAlt_m\SequenceSep\StringAlt_m}} \\
& = 
\{\String_0\Concat\String_1'\Concat\ldots\Concat\String_n'\Concat\String_n
\Concat\StringAlt_0\Concat\StringAlt_1'\Concat\ldots
\Concat\StringAlt_m'\Concat\StringAlt_m \\
& \hspace{5em} \SuchThat{} \String_i'\in\LanguageOf{\Atom_i} \BooleanAnd{}
\StringAlt_i'\in\LanguageOf{\AtomAlt_i}\}\\
& = 
\{\String\Concat\StringAlt{} \SuchThat{} \String\in\LanguageOf{\Sequence}
\BooleanAnd{} \StringAlt\in\LanguageOf{\SequenceAlt}\}\\
& =
\{\String\Concat\StringAlt{} \SuchThat{} \String\in\LanguageOf{\Regex}
\BooleanAnd{} \StringAlt\in\LanguageOf{\RegexAlt}\}\\
& =
\LanguageOf{\RegexConcat{\Regex}{\RegexAlt}}
\end{tabular}
\end{proof}

\begin{lemma}[Equivalence of \ConcatDNF{} and \Concat{}]
\label{lem:cdnfeq}
If $\LanguageOf{\Regex}=\LanguageOf{\DNFRegex}$,
and $\LanguageOf{\RegexAlt}=\LanguageOf{\DNFRegexAlt}$,
then $\LanguageOf{\RegexConcat{\Regex}{\RegexAlt}}=
\LanguageOf{\ConcatDNFOf{\DNFRegex}{\DNFRegexAlt}}$.
\end{lemma}
\begin{proof}
Let $\DNFRegex=\DNFOf{\Sequence_0\DNFSep\ldots\DNFSep\Sequence_n}$, and
let $\DNFRegexAlt=\DNFOf{\SequenceAlt_0\DNFSep\ldots\DNFSep\SequenceAlt_m}$
\begin{tabular}{@{}L@{}L@{}}
\LanguageOf{\ConcatDNFOf{\DNFRegex}{\DNFRegexAlt}} & = 
\LanguageOf{\DNFOf{\ConcatSequenceOf{\Sequence_i}{\SequenceAlt_j}
\text{ for $i\in\RangeIncInc{1}{n}$, $j\in\RangeIncInc{1}{m}$}}} \\
& = 
\{\String\SuchThat \String\in\ConcatSequenceOf{\Sequence_i}{\SequenceAlt_j}\\
& \hspace{5em}
\text{ where $i\in\RangeIncInc{1}{n}$, $j\in\RangeIncInc{1}{m}$}\}\\
& = 
\{\String\Concat\StringAlt{} \SuchThat{} \String\in\LanguageOf{\Sequence_i}
\BooleanAnd{} \StringAlt\in\LanguageOf{\SequenceAlt_j}\}\\
& \hspace{5em}
\text{ where $i\in\RangeIncInc{1}{n}$, $j\in\RangeIncInc{1}{m}$}\}\\
& =
\{\String\Concat\StringAlt{} \SuchThat{} \String\in\LanguageOf{\DNFRegex}
\BooleanAnd{} \StringAlt\in\LanguageOf{\DNFRegexAlt}\}\\
& =
\{\String\Concat\StringAlt{} \SuchThat{} \String\in\LanguageOf{\Regex}
\BooleanAnd{} \StringAlt\in\LanguageOf{\RegexAlt}\}\\
& =
\LanguageOf{\RegexConcat{\Regex}{\RegexAlt}}
\end{tabular}
\end{proof}

\begin{lemma}[Equivalence of \OrDNF{} and \Or{}]
\label{lem:odnfeq}
If $\LanguageOf{\Regex}=\LanguageOf{\DNFRegex}$,
and $\LanguageOf{\RegexAlt}=\LanguageOf{\DNFRegexAlt}$,
then $\LanguageOf{\RegexOr{\Regex}{\RegexAlt}}=
\LanguageOf{\OrDNFOf{\DNFRegex}{\DNFRegexAlt}}$.
\end{lemma}
\begin{proof}
Let $\DNFRegex=\DNFOf{\Sequence_0\DNFSep\ldots\DNFSep\Sequence_n}$, and
let $\DNFRegexAlt=\DNFOf{\SequenceAlt_0\DNFSep\ldots\DNFSep\SequenceAlt_m}$
\begin{tabular}{@{}L@{}L@{}}
\LanguageOf{\OrDNFOf{\DNFRegex}{\DNFRegexAlt}} & = 
\LanguageOf{\DNFOf{\Sequence_0\DNFSep\ldots\DNFSep\Sequence_n\DNFSep
\SequenceAlt_1\DNFSep\ldots\DNFSep\SequenceAlt_m}}\\
& = 
\{\String\SuchThat{} \String\in\Sequence_i\vee\String\in\SequenceAlt_j\\
& \hspace{5em}
\text{ where $i\in\RangeIncInc{1}{n}$, $j\in\RangeIncInc{1}{m}$}\}\\
& = 
\{\String{} \SuchThat{} \String\in\LanguageOf{\DNFRegex}
\BooleanOr{} \String\in\LanguageOf{\DNFRegexAlt}\}\\
& =
\{\String \SuchThat{} \String\in\LanguageOf{\Regex}
\BooleanOr{} \String\in\LanguageOf{\RegexAlt}\}\\
& =
\LanguageOf{\RegexOr{\Regex}{\RegexAlt}}
\end{tabular}\\
\end{proof}

\begin{proof}
By structural induction.

Let $\Regex=\String$.
$\LanguageOf{\ToDNFRegex(\String)}=\LanguageOf{\DNFOf{\SequenceOf{\String}}}=
\{\String\}=\LanguageOf{\String}$

Let $\Regex=\emptyset$.
$\LanguageOf{\ToDNFRegex(\emptyset)}=\LanguageOf{\DNFOf{}} =
\{\} = \LanguageOf{\emptyset}$.

Let $\Regex=\StarOf{\Regex'}$.
By induction assumption, $\LanguageOf{\ToDNFRegex(\Regex')}=
\LanguageOf{\Regex'}$.\\
\begin{tabular}{@{}L@{}L@{}}
\LanguageOf{\ToDNFRegex(\StarOf{\DNFRegex'})} & =
\LanguageOf{\DNFOf{\SequenceOf{\StarOf{\ToDNFRegex(\Regex')}}}}\\
& =
\{\String\SuchThat\String\in
\LanguageOf{\SequenceOf{\StarOf{\ToDNFRegex(\Regex')}}}\}\\
& = 
\{\String\SuchThat{} \String\in\LanguageOf{\StarOf{\ToDNFRegex(\Regex')}}\}\\
& =
\{\String_1\Concat\ldots\Concat\String_n\SuchThat{}
n\in\Nats\\
& \hspace*{3em}\BooleanAnd\String_i\in\LanguageOf{\ToDNFRegex(\Regex')}\}\\
& =
\{\String_1\Concat\ldots\Concat\String_n\SuchThat{}
n\in\Nats\BooleanAnd\String_i\in\LanguageOf{\Regex'}\}\\
& = \LanguageOf{\StarOf{\Regex'}}
\end{tabular}

Let $\Regex=\RegexConcat{\Regex_1}{\Regex_2}$.
By induction assumption,
$\LanguageOf{\ToDNFRegex(\Regex_1)}=\LanguageOf{\Regex_1}$, and
$\LanguageOf{\ToDNFRegex(\Regex_2)}=\LanguageOf{\Regex_2}$.
$\ToDNFRegex(\RegexConcat{\Regex_1}{\Regex_2})=
\ConcatDNFOf{\ToDNFRegex(\Regex_1)}{\ToDNFRegex(\Regex_2)}$.
By Lemma~\ref{lem:cdnfeq},
$\RegexConcat{\Regex_1}{\Regex_2}=
\ConcatDNFOf{\ToDNFRegex(\Regex_1)}{\ToDNFRegex(\Regex_2)}$.

Let $\Regex=\RegexOr{\Regex_1}{\Regex_2}$.
By induction assumption,
$\LanguageOf{\ToDNFRegex(\Regex_1)}=\LanguageOf{\Regex_1}$, and
$\LanguageOf{\ToDNFRegex(\Regex_2)}=\LanguageOf{\Regex_2}$.
$\ToDNFRegex(\RegexOr{\Regex_1}{\Regex_2})=
\OrDNFOf{\ToDNFRegex(\Regex_1)}{\ToDNFRegex(\Regex_2)}$.
By Lemma~\ref{lem:odnfeq},
$\RegexOr{\Regex_1}{\Regex_2}=
\OrDNFOf{\ToDNFRegex(\Regex_1)}{\ToDNFRegex(\Regex_2)}$.
\end{proof}
%proof-dnfrc end

Furthermore, we can use prove that language of DNF regular expressions is sound,
and that \ToDNFRegex{} is surjective, by providing a right inverse.

\begin{definition}\leavevmode\\
$\ToRegex(\StarOf{\DNFRegex}) = \StarOf{\ToRegex(\DNFRegex})$\\
$\ToRegex(\SequenceOf{\String_0}) = \String_0$\\
$\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
\SequenceSep\Atom_n\SequenceSep\String_n}) =\\
\hspace*{2em}\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\SequenceSep\Atom_{n-1}\SequenceSep\String_{n-1}})
\Concat \ToRegex(\Atom_n) \Concat \String_{n+1}$\\
$\ToRegex(\DNFOf{})=\emptyset$\\
$\ToRegex(\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n})=\\
\hspace*{2em}\ToRegex(\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{n-1}})
\Or \ToRegex(\Sequence_n)$
\end{definition}

\begin{restatable}[Soundness of DNF Regexs]{theorem}{dnfrs}\leavevmode\\
\label{thm:soundness-dnf-lenses}
$\ToDNFRegex(\ToRegex(\DNFRegex)) = \DNFRegex$
\end{restatable}
%proof-dnfrs start
First we will prove some lemmas.
\begin{lemma}
\label{lem:sequence-rx}
Let $\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_n\SequenceSep\String_n}$ be a sequence,
and\\
$\ToDNFRegex(\ToRegex(\Atom_i))=\DNFOf{\SequenceOf{\Atom_i}}$.
Then,\\$\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_n\SequenceSep\String_n}))=$\\
$\DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_n\SequenceSep\String_n}}$.
\end{lemma}
\begin{proof}
By induction on $n$.

Let $n=0$.
$\Sequence=\SequenceOf{\String_0}$.\\
$\ToDNFRegex(\ToRegex(\SequenceOf{\String_0}))=
\ToDNFRegex(\String_0)=\DNFOf{\SequenceOf{\String_0}}$

Let $n>0$,
$\Sequence=\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_n\SequenceSep\String_n}$.\\
$\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_n\SequenceSep\String_n}))$\\
$\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_{n-1}\SequenceSep\String_{n-1}})\Concat\ToRegex(\Atom_n)
\Concat\String_n)$=\\
$\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_{n-1}\SequenceSep\String_{n-1}}))
\ConcatDNF\\
\ToDNFRegex(\ToRegex(\Atom_n))
\ConcatDNF\\
\ToDNFRegex(\String_{n-1})$=
$\DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_{n-1}\SequenceSep\String_{n-1}}}
\ConcatDNF\\
\DNFOf{\SequenceOf{\Atom_n}}
\ConcatDNF
\DNFOf{\SequenceOf{\String_n}}$=
$\DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_n\SequenceSep\String_n}}$.
\end{proof}



\begin{lemma}
\label{lem:dnf-rx}
Let $\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}$ be a sequence,
and\\ $\ToDNFRegex(\ToRegex(\Sequence_i))=\DNFOf{\Sequence_i}$.
Then,\\ $\ToDNFRegex(\ToRegex(\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}))=
\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}$.
\end{lemma}
\begin{proof}

By induction on $n$.

Let $n=0$
$\ToDNFRegex(\ToRegex(\DNFOf{}))=\ToDNFRegex(\emptyset)=\DNFOf{}$.

Let $n>0$
$\ToDNFRegex(\ToRegex(\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_n}))=
\ToDNFRegex(\ToRegex(\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_{n-1}})
\Concat\ToRegex(\Sequence_n))$=
$\ToDNFRegex(\ToRegex(\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_{n-1}}))
\ConcatDNF\\\ToDNFRegex(\ToRegex(\Sequence_n))$=
$\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_n}$
\end{proof}

\begin{lemma}[Elimination of $\ToDNFRegex\Compose\ToRegex$]\leavevmode
\begin{enumerate}
\item $\ToDNFRegex(\ToRegex(\Atom))=\DNFOf{\SequenceOf{\Atom}}$
\item $\ToDNFRegex(\ToRegex(\Sequence))=\DNFOf{\Sequence}$
\item $\ToDNFRegex(\ToRegex(\DNFRegex))=\DNFRegex$
\end{enumerate}
\end{lemma}
\begin{proof}
By mutual induction

Let $\StarOf{\DNFRegex}$ be an atom.
$\ToDNFRegex(\ToRegex(\StarOf{\DNFRegex}))=
\ToDNFRegex(\StarOf{\ToRegex(\DNFRegex)})=
\DNFOf{\SequenceOf{\StarOf{\ToDNFRegex(\ToRegex(\DNFRegex))}}}=
\DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}$

Let $\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
\SequenceSep\Atom_n\SequenceSep\String_n}$ be a sequence.
$\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
\SequenceSep\Atom_n\SequenceSep\String_n}))$.
By induction assumption, for each $\Atom_i$,
$\ToDNFRegex(\ToRegex(\Atom_i))=\DNFOf{\SequenceOf{\Atom_i}}$.
By Lemma~\ref{lem:sequence-rx},
$\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
\SequenceSep\Atom_n\SequenceSep\String_n}))=
\DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
\SequenceSep\Atom_n\SequenceSep\String_n}}$.

Let $\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_n}$ be a DNF
regular expression.
By induction assumption, for each $\Sequence_i$,
$\ToDNFRegex(\ToRegex(\Sequence_i))=\DNFOf{\Sequence_i}$.
By Lemma~\ref{lem:dnf-rx},
$\ToDNFRegex(\ToRegex(\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_n}))=
\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_n}$.

\end{proof}
%proof-dnfrs end

A reasonable approach to further normalizing a DNF regular expression is to attempt to minimize the
regular expression as much as possible, using the star laws.
Unfortunately, this strategy doesn't work
well for finding lenses.  For example, there is clearly a lens of type
$\MapsBetweenTypeOf{\RegexOr{\EmptyString}{(\RegexConcat{a}{\StarOf{a}})}}{\RegexOr{b}{(\RegexConcat{c}{\StarOf{d}})}}$,
namely $\OrLens{\ConstLens{\EmptyString}{a}}{\ConcatLens{\ConstLens{a}{b}}{\IterateLens{\ConstLens{a}{d}}}}$.
However, if one simplifies as much as possible, then they will have to find a lens
of type $\MapsBetweenTypeOf{\StarOf{a}}{\RegexOr{b}{(\RegexConcat{c}{\StarOf{d}})}}$.
Unlike the type before being minified, where there was a type directed way to find
this lens, there is no longer a type directed way: should the lens be an iterate lens
or an or lens?
To handle this sort of issue, DNF regular expressions can be rewritten according
to rules associated with the Star rules of the equational theory for regular
expressions.

% fig:dnf-regex-rewrites
\begin{figure}
\begin{mathpar}
\inferrule[\AtomSumstarRule{}]
{
S\subseteq\RangeIncInc{1}{n}\\
\DNFRegex_{\Set} = [\Sequence_{\Set_1};\ldots;\Sequence_{\Set_{\SizeOf{\Set}}}]\\
\DNFRegex_{\ComplementOf{\Set}} = [\Sequence_{\ComplementOf{\Set}_1};\ldots;\Sequence_{\ComplementOf{\Set}_{\SizeOf{\ComplementOf{\Set}}}}]
}
{
\StarOf{\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}}\RewriteAtom\\\\
\DNFOf{\SequenceOf{\StarOf{(\ConcatDNFOf{\DNFOf{\SequenceOf{\StarOf{\DNFRegex_S}}}}{\DNFRegex_{\ComplementOf{\Set}}})}\SequenceSep
\StarOf{\DNFRegex_{\Set}}}}\\
}

\inferrule[\AtomUnrollstarLeftRule{}]
{
}
{
\StarOf{\DNFRegex}\RewriteAtom
\OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}{(\ConcatDNFOf{\DNFRegex}{\DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}})}
}

\inferrule[\AtomUnrollstarRightRule{}]
{
}
{
\StarOf{\DNFRegex}\RewriteAtom
\OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}{(\ConcatDNFOf{\DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}}{\DNFRegex})}
}

\inferrule[\AtomPowerstarRule{}]
{
n\in\Nats_{\geq1}
}
{
\StarOf{\DNFRegex}\RewriteAtom
\ConcatDNFOf{\DNFOf{\SequenceOf{\StarOf{(\RepeatDNFOf{n}{\DNFRegex})}}}}
{(\RepeatDNFOf{0}{\DNFRegex}\OrDNF\ldots\OrDNF\RepeatDNFOf{n}{\DNFRegex})}
}

\inferrule[\DicyclicRewriteStarRule{}]
{
S\subseteq\RangeIncInc{1}{n}\\
\DNFRegex_{\Set} = [\Sequence_{\Set_1};\ldots;\Sequence_{\Set_{\SizeOf{\Set}}}]\\
\DNFRegex_{\ComplementOf{\Set}} = [\Sequence_{\ComplementOf{\Set}_1};\ldots;\Sequence_{\ComplementOf{\Set}_{\SizeOf{\ComplementOf{\Set}}}}]
}
{
\StarOf{\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}}\RewriteAtom\\\\
\StarOf{(\ConcatDNFOf{(\OrDNFOf{\DNFRegex_{\Set}}{\DNFRegex_{\ComplementOf{\Set}}})}{\OrDNFOf{\DNFRegex_{\ComplementOf{\Set}}}{\ConcatDNFOf{{(\ConcatDNFOf{\DNFRegex_{\Set}}{\StarOf{\DNFRegex_{\ComplementOf{\Set}}}})}^n}{\DNFRegex_{\Set}}}})}\ConcatDNF\\
(\EmptyString\OrDNF(\OrDNFOf{\DNFRegex_{\Set}}{\DNFRegex_{\ComplementOf{\Set}}})\ConcatDNF\\
({(\ConcatDNFOf{\DNFRegex_{\Set}}{\StarOf{\DNFRegex_{\ComplementOf{\Set}}}})}^0\OrDNF\ldots\OrDNF{(\ConcatDNFOf{\DNFRegex_{\Set}}{\StarOf{\DNFRegex_{\ComplementOf{\Set}}}})}^n))
}

\inferrule[\DNFRewriteStarRule{}]
{
\DNFRegex \RewriteDNF \DNFRegex'
}
{
\StarOf{\DNFRegex} \RewriteAtom \DNFOf{\SequenceOf{\StarOf{\DNFRegex'}}}
}

\inferrule[\AtomDNFRewriteRule{}]
{
\Atom_j \RewriteAtom \DNFRegex
}
{
\DNFLeft\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}\DNFSep\\\\
\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}\SequenceSep\Atom_j\SequenceSep\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m}\DNFSep\\\\
\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n\DNFRight\RewriteDNF\\\\
\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF\\
\DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}\ConcatDNF\DNFRegex\ConcatDNF\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m} \OrDNF\\
\DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n}
}

\inferrule[\DNFRewriteCompositionRule{}]
{
\DNFRegex \RewriteDNF \DNFRegex'\\
\DNFRegex' \RewriteDNF \DNFRegex''
}
{
\DNFRegex \RewriteDNF \DNFRegex''
}

\inferrule[\IdentityDNFRewriteRule{}]
{
}
{
\DNFRegex \RewriteDNF \DNFRegex
}

\end{mathpar}
\caption{DNF Regex Rewrite Rules}
\label{fig:dnf-regex-rewrites}
\end{figure}


Rewrite rules are provided in Figure~\ref{fig:dnf-regex-rewrites}.
Intuitively, these rewrite rules correspond to expanding a regular expression
into a regular expression which can be used in a more complicated lens.
These rewrite rules are a way of getting around
requiring a full retyping rule, as is present in standard lenses.
These rewrite rules are presented as rewrites that turn atoms into DNF Regular expressions,
alongside a rule that expresses how these atom rewrites can become rewrites on
the DNF regular expressions themselves.  For example, consider the DNF Regular
Expression $\DNFOf{\SequenceOf{a};\SequenceOf{\StarOf{b};\StarOf{c}};\SequenceOf{d}}$.
This DNF Regular expression matches either $a$, $b^i\Concat c^j$, or $d$.
With the above rules,
$\StarOf{b}\RewriteAtom\DNFOf{\SequenceOf{};\SequenceOf{b\StarOf{b}}}$, which
corresponds to an application of \ProductstarRule{} on $\EmptyString\Concat b$.
This then gets applied in the rules above, leading to the full DNF rewrite
$\DNFOf{\SequenceOf{a};\SequenceOf{\StarOf{b};\StarOf{c}};\SequenceOf{d}}
\RewriteDNF
\DNFOf{\SequenceOf{a};\SequenceOf{\StarOf{c}};\SequenceOf{b;\StarOf{b};\StarOf{c}};\SequenceOf{d}}$.
This has the same language, but $\SequenceOf{\StarOf{b};\StarOf{c}}$
has been expanded into matching $b^0c^j$ and $b^{i>0}c^j$ separately.

Roughly, the \AtomSumstarRule{} rewrite corresponds to \SumstarRule{},
the \AtomUnrollstarLeftRule{} and \AtomUnrollstarRightRule{} rewrites correspond to \ProductstarRule{}.
and the \DicyclicRewriteStarRule{} rewrite corresponds to \DicyclicityRule{}.
There is no rewrite corresponding to Regular Expression equivalence 10, as that
equivalence is an ambiguity introducing equivalence.
An application of \AtomSumstarRule{} corresponds to doing different things after the last time a certain event has occured, and before the last time that event occurs.
An application of \AtomUnrollstarLeftRule{} corresponds to making a different action for
the empty case of an iteration, the first case of an iteration, and all further cases of the iteration,
and similarly with \AtomUnrollstarRightRule{} for the empty case, the last case, and all previous cases, of the iteration.
An application of \DicyclicRewriteStarRule{} corresponds to a reordering of the
variables that corresponds to expressing a ring as an ideal, and the quotient by
that ideal.

\section{DNF Lenses}

% fig:dnf-lens-syntax
\begin{figure}
\centering
\begin{tabular}{@{}l@{\ }l@{\ }c@{}l@{\ }>{\itshape\/}r@{}}
% REGEX
(Atom Lenses) &\AtomLens{} & \GEq{} & $Iterate(\DNFLens)$ & Iterate\\
(Sequence Lenses) &\SequenceLens{} & \GEq{} &
$(\SequenceLensOf{(\String_0,\StringAlt_0)\SequenceLensSep\AtomLens_1\SequenceLensSep\ldots\SequenceLensSep\AtomLens_n\SequenceLensSep(\String_n,\StringAlt_n)}$, &\\
& & & $\sigma \in S_n)$ & Clause\SubN{}\\
(DNF Lenses)& \DNFLens{} & \GEq{} & $(\DNFLensOf{\SequenceLens_1\DNFLensSep\ldots\DNFLensSep\SequenceLens_n}, \sigma \in S_n)$ & DNF\SubN{}\\
\end{tabular}
\caption{DNF Lens Syntax}
\label{fig:dnf-lens-syntax}
\end{figure}

% fig:dnf-lens-semantics
\begin{figure}
Semantics of Atom Lenses:\\
$\SemanticsOf{\IterateLens{\DNFLens}}$=\\
\hspace*{3em}$\SetOf{(\String_1\Concat\ldots\Concat\String_n,
\StringAlt_1\Concat\ldots\Concat\StringAlt_n)\SuchThat
n\in\NatsZero\BooleanAnd(\String_i,\StringAlt_i)\in\SemanticsOf{\DNFLens}}$\\
\\
Semantics of Sequence Lenses:\\
$\SemanticsOf{(\SequenceLensOf{(\String_0,\StringAlt_0)\SequenceLensSep
\AtomLens_1\SequenceLensSep\ldots\SequenceLensSep\AtomLens_n
\SequenceLensSep(\String_n,\StringAlt_n)},\Permutation)}=$\\
\hspace*{3em}$\SetOf{
(\String_0\Concat\String_1'\Concat\ldots\Concat\String_n'\Concat\String_n,
\String_{\Permutation(0)}\Concat\String_{\Permutation(1)}'\Concat\ldots
\Concat\String_{\Permutation(n)}'\Concat\String_{\Permutation(n)})\SuchThat$\\
\hspace*{4em}$(\String_i',\StringAlt_i')\in\SemanticsOf{\Atom_i}}$\\
\\
Semantics of DNF Lenses:\\
$\SemanticsOf{(\DNFLensOf{\SequenceLens_1\DNFLensSep\ldots\DNFLensSep
\SequenceLens_n},\Permutation)}=$\\
\hspace*{3em}$\SetOf{(\String,\StringAlt)\SuchThat
(\String,\StringAlt)\in\SequenceLens_i\text{ for some $i$}}$
\caption{DNF Lens Semantics}
\label{fig:dnf-lens-semantics}
\end{figure}

% fig:dnf-lens-semantics
\begin{figure}
\centering
\begin{mathpar}
\inferrule[\IterateAtomLensRule{}]
{
\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt
}
{
\IterateLens{\DNFLens} \OfType \StarOf{\DNFRegex} \Leftrightarrow \StarOf{\DNFRegexAlt}
(\PutRight\Apply\String_1)\Concat\ldots\Concat(\PutRight\Apply\String_n)
}

\inferrule[\SequenceLensRule{}]
{
\AtomLens_1 \OfType \Atom_1 \Leftrightarrow \AtomAlt_1\\
\ldots\\
\AtomLens_n \OfType \Atom_n \Leftrightarrow \AtomAlt_n\\
\sigma \in \PermutationSetOf{n}\\
\UnambigConcat\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}\\
\UnambigConcat\SequenceOf{\StringAlt_0\SequenceSep\AtomAlt_1\SequenceSep\ldots\SequenceSep\AtomAlt_n\SequenceSep\StringAlt_n}
}
{
(\SequenceLensOf{(\String_0,\StringAlt_0)\SequenceLensSep\Atom_1\SequenceLensSep\ldots\SequenceLensSep\Atom_n\SequenceLensSep(\String_n,\StringAlt_n)},\sigma) \OfType\\
\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}\Leftrightarrow
\SequenceOf{\StringAlt_0\SequenceSep\AtomAlt_1\SequenceSep\ldots\SequenceSep\AtomAlt_n\SequenceSep\StringAlt_n}
}

\inferrule[\DNFLensRule{}]
{
\SequenceLens_1 \OfType \Sequence_1 \Leftrightarrow \SequenceAlt_1\\
\ldots\\
\SequenceLens_n \OfType \Sequence_n \Leftrightarrow \SequenceAlt_n\\
\sigma \in \PermutationSetOf{n}\\
i \neq j \Rightarrow \Sequence_{i} \cap \Sequence_{j}=\emptyset\\
i \neq j \Rightarrow \SequenceAlt_{i} \cap \SequenceAlt_{j}=\emptyset\\
}
{
(\DNFLensOf{\SequenceLens_1\DNFLensSep\ldots\DNFLensSep\SequenceLens_n},\sigma) \OfType\\
\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}
\Leftrightarrow \DNFOf{\SequenceAlt_{\sigma(1)}\DNFSep\ldots\DNFSep\SequenceAlt_{\sigma(n)}}
}

\inferrule[\DNFRewriteLensRule{}]
{
\DNFRegex \RewriteDNF \DNFRegex'\\
\DNFRegexAlt \RewriteDNF \DNFRegexAlt'\\
\DNFLens \OfType \MapsBetweenTypeOf{\DNFRegex}{\DNFRegexAlt}
}
{
\DNFLens \OfType \MapsBetweenTypeOf{\DNFRegex'}{\DNFRegexAlt'}
}

\end{mathpar}
\caption{DNF Lens Typing}
\label{fig:dnf-lens-semantics}
\end{figure}

Armed with these rewrites, a strong language for lenses on these regular
expressions can be defined.
The syntax is defined in Figure~\ref{fig:dnf-lens-syntax}.
Similarly to the language of lenses, the typing of the lenses
correspond closely to the syntax for the lenses themselves.
The typing and semantics of these DNF lenses are defined in Figure~\ref{fig:dnf-lens-semantics}.
Intuitively, a DNF Regex Lens corresponds roughly to an n-ary version of an or lens,
a Sequence Lens corresponds to const lenses for the strings, and a combination of
Concat and Swap lenses for the Atoms.

These DNF lenses only express things expressible in the language of lenses.
\begin{restatable}[Soundness of DNF Lenses]{theorem}{dnfls}
\label{thm:dnfls}
If there exists a derivation of $\DNFLens \OfType \MapsBetweenTypeOf{\DNFRegex}{\DNFRegexAlt}$,
then there exists a derivation of $\Lens \OfType \MapsBetweenTypeOf{\Regex}{\RegexAlt}$ such that
$\LanguageOf{\Regex}=\LanguageOf{\DNFRegex}$,
$\LanguageOf{\RegexAlt}=\LanguageOf{\DNFRegexAlt}$, and
$\SemanticsOf{\Lens}=\SemanticsOf{\DNFLens}$.
\end{restatable}
%proof-dnfls start
We will prove a couple of lemmas first.

\begin{lemma}[Expressibility of Safe Boilerplate Alterations]
\label{lem:boilerplate-alterations}
Suppose
\begin{enumerate}
\item $\UnambigConcat\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}$
\item $\UnambigConcat\SequenceOf{\StringAlt_0;\Atom_1;\ldots;\Atom_n;\StringAlt_n}$
\end{enumerate}
Then there exists a lens
$\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that
\begin{enumerate}
\item $\Regex = \ToRegex(\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n})$
\item $\RegexAlt = \ToRegex(\SequenceOf{\StringAlt_0;\Atom_1;\ldots;\Atom_n;\StringAlt_n})$
\item $\SemanticsOf{\Lens}=\SetOf{(\String,\StringAlt)\SuchThat
\String=\String_0\Concat\String_1'\Concat\ldots\Concat\String_n'\Concat\String_n
\BooleanAnd\\
\hspace*{6.1em}\StringAlt=\StringAlt_0\Concat\String_1'\Concat\ldots\Concat\String_n'\Concat\StringAlt_n
\BooleanAnd\\
\hspace*{6.1em}\String_i\in\LanguageOf{\Atom_i}}$
\end{enumerate}
\end{lemma}
\begin{proof}
By induction on $n$.

Let $n=0$.
Consider the Lens
\begin{mathpar}
\inferrule*
{
}
{
\ConstLens{\String_0}{\StringAlt_0} \OfType \String_0 \Leftrightarrow \StringAlt_0
}
\end{mathpar}
By inspection, this satisfies the desired properties.

Let $n>0$.
By induction, there exists a lens $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$
satisfying the desired properties.
Consider the lens
\begin{mathpar}
\inferrule*[left=\Derivation]
{
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens \OfType \Regex \Leftrightarrow \RegexAlt
}\\
\inferrule*
{
}
{
\ConstLens{\String_n}{\StringAlt_n} \OfType \String_n \Leftrightarrow \StringAlt_n
}
}
{
\ConcatLens{\Lens}{\ConstLens{\String_n}{\StringAlt_n}}
\OfType
\Regex \Concat \String_n \Leftrightarrow
\RegexAlt \Concat \StringAlt_n
}

\inferrule*
{
\Derivation\\
\IdentityLensOf{\ToRegex(\Atom_n)} \OfType \ToRegex(\Atom_n) \Leftrightarrow \ToRegex(\Atom_n)
}
{
\ConcatLens{\ConcatLens{\Lens}{\ConstLens{\String_n}{\StringAlt_n}}}{\IdentityLensOf{\ToRegex(\Atom_n)}}
\OfType\\
\Regex \Concat \String_n \Concat \ToRegex(\Atom_n) \Leftrightarrow
\Regex \Concat \StringAlt_n \Concat \ToRegex(\Atom_n)
}
\end{mathpar}
By inspection, this satisfies the desired properties.
\end{proof}

\begin{lemma}[Creation of Lens from Identity Perm Sequence Lens]
\label{lem:id-clause}
Suppose
\begin{enumerate}
\item $\Sequence=\SequenceOf{\String_0 ; \Atom_1 ; \ldots ; \Atom_n; \String_n}$
\item $\SequenceAlt=\SequenceOf{\StringAlt_0 ; \AtomAlt_1 ; \ldots ; \AtomAlt_n ; \StringAlt_n}$
\item $(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1 ; \ldots ;
	\AtomLens_n;(\String_n,\StringAlt_n)},id) \OfType
	\Sequence \Leftrightarrow \SequenceAlt$
\item For each $\AtomLens_i \OfType \Atom_i \Leftrightarrow \AtomAlt_i$,
there exists a $\Lens_i \OfType \ToRegex(\Atom_i) \Leftrightarrow
\ToRegex(\AtomAlt_i)$ such that $\SemanticsOf{\Lens_i}=\SemanticsOf{\AtomLens_i}$
\end{enumerate}
then there exists a $\Lens \OfType \ToRegex(\Sequence) \Leftrightarrow \ToRegex(\DNFRegexAlt)$ such that
$\SemanticsOf{\Lens} =
\SemanticsOf{(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1 ; \ldots ; \AtomLens_n;(\String_n,\StringAlt_n)},id)}$.
\begin{proof}
By induction on $n$.

Let $n=0$, $(\SequenceLensOf{(\String_0,\StringAlt_0)},id) \OfType
\SequenceOf{\String_0} \Leftrightarrow \SequenceOf{\StringAlt_0}$.
Then consider
\begin{mathpar}
\inferrule[]
{
}
{
\ConstLens{\String_0}{\StringAlt_0}\OfType\String_0\Leftrightarrow\StringAlt_0
}
\end{mathpar}

$\String_0=\ToRegex(\SequenceOf{\String_0})$,
and
$\StringAlt_0=\ToRegex(\SequenceOf{\StringAlt_0})$.
$\SemanticsOf{\ConstLens{\String_0}{\StringAlt_0}}=
\SetOf{\String_0,\StringAlt_0}=
\SemanticsOf{\SequenceOf{(\String_0,\StringAlt_0)},id)}$.

Let $n>0$.
Let $\Sequence'=\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\SequenceSep\Atom_{n-1}\SequenceSep\String_{n-1}}$,
and $\SequenceAlt'=\SequenceOf{\StringAlt_0\SequenceSep\AtomAlt_1\SequenceSep
\ldots\SequenceSep\AtomAlt_{n-1}\SequenceSep\StringAlt_{n-1}}$
By induction assumption, there exists a typing derivation
\begin{mathpar}
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens\OfType\ToRegex(\Sequence')\Leftrightarrow\ToRegex(\SequenceAlt')
}
\end{mathpar}
satisfying $\SemanticsOf{\Lens}=\\
\SemanticsOf{(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1 ;
\ldots ; \AtomLens_{n-1};(\String_{n-1},\StringAlt_{n-1})},id)}$

By problem statement, there exists a typing derivation
\begin{mathpar}
\inferrule*[left=$\Derivation_n$]
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens_{\AtomLens_{n}} \OfType
\ToRegex(\Atom_{n}) \Leftrightarrow \ToRegex(\AtomAlt_{n})
}
\end{mathpar}
satisfying $\SemanticsOf{\Lens_{\Atom_n}}
=\SemanticsOf{\Atom_n}$.

Consider the following lens typing
\begin{mathpar}
\inferrule*[left=\Derivation{}]
{
\Derivation_n\\
\inferrule*
{
}
{
\ConstLens{\String_n}{\StringAlt_n}
\OfType
\String_n \Leftrightarrow \StringAlt_n
}
}
{
\ConcatLens{\Lens_{\AtomLens_n}}{\ConstLens{\String_n}{\StringAlt_n}}
\OfType
\ToRegex(\Atom_n)\Concat\String_n \Leftrightarrow
\ToRegex(\AtomAlt_n)\Concat\StringAlt_n
}

\inferrule*{
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens\OfType\ToRegex(\Sequence) \Leftrightarrow \ToRegex(\SequenceAlt)
}\\
\Derivation{}
}
{
\ConcatLens
{\Lens}
{\ConcatLens{\Lens_{\AtomLens_n}}{\ConstLens{\String_n}{\StringAlt_n}}}
\OfType\\
\ToRegex(\Sequence)\Concat\ToRegex(\Atom_n)\Concat\String_n \Leftrightarrow
\ToRegex(\SequenceAlt)\Concat\ToRegex(\AtomAlt_n)\Concat\StringAlt_n
}
\end{mathpar}

\SemanticsOf{\ConcatLens
{\Lens}
{\ConcatLens{\Lens_{\AtomLens_n}}{\ConstLens{\String_n}{\StringAlt_n}}}}\\
\hspace*{3em}=\SetOf{(\String,\StringAlt)
\SuchThat
\String = \String'\Concat\String''\Concat\String_n\BooleanAnd
\StringAlt = \StringAlt'\Concat\StringAlt''\Concat\StringAlt_n\BooleanAnd\\
\hspace*{7em}
(\String',\StringAlt')\in\SemanticsOf{\Lens}\BooleanAnd
(\String'',\StringAlt'')\in\SemanticsOf{\Lens_{\AtomLens_n}}}\\
\hspace*{3em}=\SetOf{
(\String,\StringAlt)\SuchThat
\String=
\String_0\Concat\String_0'\Concat\ldots
\Concat\String_{n-1}'\Concat\String_{n-1}
\Concat \String_n \Concat \String_n'\BooleanAnd\\
\hspace*{7em}\StringAlt=\StringAlt_0\Concat\StringAlt_0'\Concat\ldots
\Concat\StringAlt_{n-1}'\Concat\StringAlt_{n-1}
\Concat \StringAlt_n \Concat \StringAlt_n'\BooleanAnd\\
\hspace*{7em}\String_i'\in\Atom_i\BooleanAnd\StringAlt_i'\in\AtomAlt_i}\\
\hspace*{3em}=\SemanticsOf{(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1 ;
\ldots ; \AtomLens_n;(\String_n,\StringAlt_{n-1})},id)}
\end{proof}
\end{lemma}

\begin{theorem}[Unambiguity of $\Sep$]
Let $\Alphabet$ be an alphabet.  Let $\Alphabet_{\Sep}=\Alphabet\Union\SetOf{\Sep}$,
where \Sep{} is a character not in \Alphabet{}.
If $\Language_1, \ldots,
\Language_n$, are languages in $\StarOf{\Alphabet}$, then
$\UnambigConcat\SequenceOf{\LanguageOf{\Sep};\Language_1;\LanguageOf{\Sep};
\ldots;\LanguageOf{\Sep};\Language_n;\LanguageOf{\Sep}}$.
\end{theorem}
\begin{proof}
We prove this by induction on $n$.

Let $n=0$.  $\UnambigConcat\SequenceOf{\LanguageOf{\Sep}}$, as
$\UnambigConcat\SequenceOf{\Language}$, for any language $\Language$.

Let $n>0$.
Let $\String_i, \StringAlt_i\in\Language_i$ for all $i\in\RangeIncInc{1}{n}$,
and let $\Sep\String_1\Sep\ldots\Sep\String_n\Sep=\Sep\StringAlt_1\Sep\ldots\Sep\StringAlt_n\Sep$.
We want to show that $\String_n\Sep=\StringAlt_n\Sep$.
If they were not equal, then one string is strictly contained in the other, say without
loss of generality $\String_n\Sep$ is strictly contained in $\StringAlt_n\Sep$.
Because of that $\Sep\String_n\Sep$ is contained in $\StringAlt_n\Sep$, so $\Sep$
is contained in $\StringAlt_n\in\StarOf{\Sigma}$.  This is a contradiction,
as $\Sep\notin\Sigma$, so we know $\String_n\Sep=\StringAlt_n\Sep$, and so $\String_n=\StringAlt_n$.
This means that
$\Sep\String_0\Sep\ldots\Sep\String_{n-1}\Sep=\Sep\StringAlt_0\Sep\ldots\Sep\StringAlt_{n-1}$,
so by induction, I know $\String_i=\StringAlt_i$ for all $i$.
\end{proof}

\begin{definition}[Adjacent Swapping Permutation]
Let $\sigma_{i} \in S_n$ be the permutation where
$\sigma_{i}(i) = i+1$, $\sigma_{i}(i+1) = i$, $\sigma_{i}(k) = k$
when $k\neq i$, and $k\neq i+1$.
\end{definition}

\begin{lemma}[Expressibility of Adjacent Swapping Permutation Lens]
\label{lem:adj-perm-exp}
Suppose
\begin{enumerate}
\item $\sigma_i$ is an adjacent element swapping permutation
\item $\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep}$ is a sequence with
all base strings equal to $\Sep$.
\end{enumerate}
Then there exists a typing of a lens $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that
\begin{enumerate}
\item $\LanguageOf{\Regex}=\LanguageOf{[\Sep;\Atom_1;\ldots;\Atom_n;\Sep]}$
\item $\LanguageOf{\RegexAlt}=\LanguageOf{[\Sep;\Atom_{\sigma_i(1)};\ldots;\Atom_{\sigma_i(n)};\Sep]}$
\item $\SemanticsOf{\Lens}=
\SetOf{(\String,\StringAlt)\SuchThat\String=\Sep\Concat\String_1\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_n\Concat\Sep
\BooleanAnd\\
\hspace*{6em}\StringAlt=\Sep\Concat\String_{\sigma_i(1)}\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_{\sigma_i(n)}\Sep\BooleanAnd\\
\hspace*{6em}\String_i\in\LanguageOf{\Atom_i}}$
\end{enumerate}
\begin{proof}
By the soundness of regular expressions, define regular expressions
$\Regex_1, \Regex_2, \Regex_3, \Regex_4$ as
$\Regex_1=\ToRegex([\Sep;\Atom_1;\ldots;\Atom_{i-1};\Sep])$,
$\Regex_2=\ToRegex(\Atom_i)$,
$\Regex_3=\ToRegex(\Atom_{i+1})$, and
$\Regex_4=\ToRegex([\Sep;\Atom_{i+1};\ldots;\Atom_{n};\Sep])$.
Consider the following deduction\bcp{I find these deductions a bit heavy and
  hard to read, but I guess I can get used to them.  }
\afm{Anybody have suggestions for better deduction package?}
\begin{mathpar}

\inferrule*[left=\Derivation{}]
{
\inferrule*
{
}
{
\IdentityLensOf{\Sep} \OfType \Sep \Leftrightarrow \Sep
}
\inferrule*
{
}
{
\IdentityLensOf{\Regex_3} \OfType \Regex_3 \Leftrightarrow \Regex_3
}
}
{
\SwapLens{\IdentityLensOf{\Sep}}{\IdentityLensOf{\Regex_3}} \OfType 
\Sep\Concat\Regex_3 \Leftrightarrow \Regex_3\Concat\String_i
}

\inferrule*[left=\Derivation{}']
{
\inferrule*
{
}
{
\IdentityLensOf{\Regex_2} \OfType \Regex_2 \Leftrightarrow \Regex_2
}\\
\Derivation
}
{
\SwapLens{\IdentityLensOf{\Regex_2}}{\SwapLensShort{\IdentityLensShortOf{\Sep}}{\IdentityLensShortOf{\Regex_3}}} \OfType
\Regex_2\Concat\Sep\Concat\Regex_3 \Leftrightarrow \Regex_3\Concat\Sep\Concat\Regex_2
}

\inferrule*[left=\Derivation{}'']
{
\inferrule*
{
}
{
\IdentityLensOf{\Regex_1} \OfType \Regex_1 \Leftrightarrow \Regex_1
}\\
\Derivation{}'
}
{
\ConcatLens{\IdentityLensOf{\Regex_1}}{\SwapLensShort{\IdentityLensShortOf{\Regex_2}}{\SwapLensShort{\IdentityLensShortOf{\Sep}}{\IdentityLensShortOf{\Regex_3}}}} \OfType\\
\Regex_1\Concat\Regex_2\Concat\Sep\Concat\Regex_3 \Leftrightarrow \Regex_1\Concat\Regex_3\Concat\Sep\Concat\Regex_2
}


\inferrule*
{
\Derivation{}''\\
\inferrule*
{
}
{
\IdentityLensOf{\Regex_4} \OfType \Regex_4 \Leftrightarrow \Regex_4
}
}
{
\ConcatLens{\ConcatLensShort{\IdentityLensShortOf{\Regex_1}}{\SwapLensShort{\IdentityLensShortOf{\Regex_2}}{\SwapLensShort{\IdentityLensShortOf{\Sep}}{\IdentityLensShortOf{\Regex_3}}}}}{\IdentityLensOf{\Regex_4}} \OfType\\
\Regex_1\Concat\Regex_2\Concat\Sep\Concat\Regex_3\Concat\Regex_4 \Leftrightarrow \Regex_1\Concat\Regex_3\Concat\Sep\Concat\Regex_2\Concat\Regex_4
}
\end{mathpar}

By inspection, the final lens
$\ConcatLensShort{\ConcatLensShort{\IdentityLensShortOf{\Regex_1}}{\SwapLensShort{\IdentityLensShortOf{\Regex_2}}{\SwapLensShort{\IdentityLensShortOf{\Sep}}{\IdentityLensShortOf{\Regex_3}}}}}{\IdentityLensShortOf{\Regex_4}} \OfType
\Regex_1\Concat\Regex_2\Concat\Sep\Concat\Regex_3\Concat\Regex_4 \Leftrightarrow \Regex_1\Concat\Regex_3\Concat\Sep\Concat\Regex_2\Concat\Regex_4$
satisfies $\LanguageOf{\Regex_1\Concat\Regex_2\Concat\String_i\Concat\Regex_3\Concat\Regex_4}=\LanguageOf{\SequenceOf{\Sep;\Atom_1;\Sep;\ldots;\Sep;\Atom_n;\Sep}}$ and
$\LanguageOf{\Regex_1\Concat\Regex_3\Concat\String_i\Concat\Regex_2\Concat\Regex_4}=\LanguageOf{\SequenceOf{\Sep;\Atom_{\sigma_i(1)};\ldots;\Atom_{\sigma_i(n)};\Sep}}$
and has the desired semantics of swapping the strings at spots $i$ and $i+1$.
\end{proof}
\end{lemma}

\begin{lemma}[Expressibility of Adjacent Swapping Permutation Composition]
\label{lem:adj-comp-perm-exp}
Suppose
\begin{enumerate}
\item $\sigma=\sigma_{i_1}\Compose\ldots\Compose\sigma_{i_m}$ 
\item $\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep}$ is a sequence with
all base strings equal to $\Sep$.
\end{enumerate}
Then there exists a typing of a lens $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that
\begin{enumerate}
\item $\LanguageOf{\Regex}=\LanguageOf{[\Sep;\Atom_1;\ldots;\Atom_n;\Sep]}$
\item $\LanguageOf{\RegexAlt}=\LanguageOf{[\Sep;\Atom_{\sigma(1)};\ldots;\Atom_{\sigma(n)};\Sep]}$
\item $\SemanticsOf{\Lens}=
\SetOf{(\String,\StringAlt)\SuchThat\String=\Sep\Concat\String_1\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_n\Concat\Sep
\BooleanAnd\\
\hspace*{6em}\StringAlt=\Sep\Concat\String_{\sigma(1)}\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_{\sigma(n)}\Sep\BooleanAnd\\
\hspace*{6em}\String_i\in\LanguageOf{\Atom_i}}$
\end{enumerate}
\begin{proof}
By induction on $m$.

Let $m=0$.  Then $\sigma=\Identity$.  Consider the lens
$\IdentityLensOf{\ToRegex(\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep})} \OfType
\ToRegex(\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep}) \Leftrightarrow
\ToRegex(\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep})$.
By inspection, this lens satisfies the requirements.

Let $m>0$.  Let $\sigma'=\sigma_{i_1}\Compose\ldots\Compose\sigma_{i_{m-1}}$.
Let $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ be the lens obtained by an
application of the induction assumption on $\sigma'$.
Let $\Lens_m \OfType \RegexAlt' \Leftrightarrow \RegexAlt''$ be the lens obtained by
an application of Lemma~\ref{lem:adj-perm-exp} to the permutation $\sigma_m$ and
the sequence $\SequenceOf{\Sep;\Atom_{\sigma'(1)};\ldots;\Atom_{\sigma'(n)};\Sep}$.
From the induction assumption and the previous lemmas,
we know $\LanguageOf{\RegexAlt}=
\LanguageOf{\SequenceOf{\Sep;\Atom_{\sigma'(1)};\ldots;\Atom_{\sigma'(n)};\Sep}}=
\LanguageOf{\RegexAlt'}$.
Consider the following Lens typing

\begin{mathpar}
\inferrule*
{
\inferrule*
{
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens \OfType \Regex \Leftrightarrow \RegexAlt
}\\
\LanguageOf{\RegexAlt}=\LanguageOf{\RegexAlt'}
}
{
\Lens \OfType \Regex \Leftrightarrow \RegexAlt'
}\\
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens_m \OfType \RegexAlt' \Leftrightarrow \RegexAlt''
}
}
{
\ComposeLens{\Lens_m}{\Lens} \OfType \Regex \Leftrightarrow \RegexAlt''
}
\end{mathpar}

The language of \Regex{} is already as desired, and
$\LanguageOf{\RegexAlt''}=
\LanguageOf{\SequenceOf{\Sep;\Atom_{\sigma_m\Compose\sigma'(1)};\ldots;\Atom_{\sigma_m\Compose\sigma'(n)}}}=
\LanguageOf{\SequenceOf{\Sep;\Atom_{\sigma(1)};\ldots;\Atom_{\sigma(n)}}}$, as desired.
Furthermore, the composition of the lenses composes the permutations of strings,
giving the semantics as desired.
\end{proof}
\end{lemma}

\begin{lemma}[Expressibility of Permutation]
\label{lem:perm-exp}
Suppose
\begin{enumerate}
\item $\sigma$ is a permutation in $S_n$
\item $\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep}$ is a sequence with
all base strings equal to $\Sep$.
\end{enumerate}
Then there exists a typing of a lens $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that
\begin{enumerate}
\item $\LanguageOf{\Regex}=\LanguageOf{[\Sep;\Atom_1;\ldots;\Atom_n;\Sep]}$
\item $\LanguageOf{\RegexAlt}=\LanguageOf{[\Sep;\Atom_{\sigma(1)};\ldots;\Atom_{\sigma(n)};\Sep]}$
\item $\SemanticsOf{\Lens}=
\SetOf{(\String,\StringAlt)\SuchThat\String=\Sep\Concat\String_1\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_n\Concat\Sep
\BooleanAnd\\
\hspace*{6em}\StringAlt=\Sep\Concat\String_{\sigma(1)}\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_{\sigma(n)}\Sep\BooleanAnd\\
\hspace*{6em}\String_i\in\LanguageOf{\Atom_i}}$
\end{enumerate}
\end{lemma}
\begin{proof}
By algebra, any permutation can be expressed as the composition of adjacent swapping permutations.
As such, $\sigma=\sigma_{i_1}\Compose\ldots\Compose\sigma_{i_m}$ for some adjacency swapping
permutations $\sigma_{i_j}$.
By Lemma~\ref{lem:adj-comp-perm-exp}, we obtain a lens with the properties desired.
\end{proof}

\begin{lemma}[Creation of Lens from Identity Perm DNF Lens]
\label{lem:id-dnf}
Suppose
\begin{enumerate}
\item $\DNFRegex = \DNFOf{\Sequence_1 ; \ldots ; \Sequence_n}$
\item $\DNFRegexAlt = \DNFOf{\SequenceAlt_1 ; \ldots ; \SequenceAlt_n}$
\item $(\DNFLensOf{\SequenceLens_1 ; \ldots ; \SequenceLens_n},id) \OfType
\DNFRegex \Leftrightarrow \DNFRegexAlt$
\item For each $\SequenceLens_i \OfType \Sequence_i \Leftrightarrow \SequenceAlt_i$,
there exists a $\Lens_i$ such that $\SemanticsOf{\Lens_i}=\SemanticsOf{\SequenceLens_i}$.
\end{enumerate}
then there exists a $\Lens \OfType \ToRegex(\DNFRegex) \Leftrightarrow \ToRegex(\DNFRegexAlt)$ such that $\SemanticsOf{\Lens} = \SemanticsOf{([\SequenceLens_1 ; \ldots ; \SequenceLens_n],id)}$.
\begin{proof}
By induction on n

Let $n=0$.
$\DNFLensOf{} \OfType \DNFOf{} \Leftrightarrow \DNFOf{}$.  Then consider
\begin{mathpar}
\inferrule*
{
}
{
\IdentityLensOf{\ToRegex(\DNFOf{})} \OfType
\ToRegex(\DNFOf{}) \Leftrightarrow \ToRegex(\DNFOf{})
}
\end{mathpar}
This has the desired typing, and
$\SemanticsOf{\IdentityLensOf{\ToRegex(\DNFOf{})}}
=\SemanticsOf{\IdentityLensOf{\emptyset}}
=\SetOf{}=\SemanticsOf{\DNFLensOf{}}$.

Let $n>0$.
Let $\DNFRegex' = \DNFOf{\Sequence_1;\ldots;\Sequence_{n-1}}$, and
$\DNFRegexAlt' = \DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_{n-1}}$.
By induction assumption, there exists a derivation of 
$\Lens \OfType \ToRegex(\DNFRegex') \Leftrightarrow \ToRegex(\DNFRegexAlt')$.
By problem statement, there exists a typing derivation
$\Lens_n \OfType \ToRegex(\Sequence_n) \Leftrightarrow \ToRegex(\SequenceAlt_n)$
Consider the following derivation
\begin{mathpar}
\inferrule*
{
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens \OfType \ToRegex(\DNFRegex') \Leftrightarrow \ToRegex(\DNFRegexAlt')
}\\
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens_n \OfType \ToRegex(\Sequence_n) \Leftrightarrow \ToRegex(\SequenceAlt_n)
}
}
{
\OrLens{\Lens_n}{\Lens} \OfType \RegexOr{\ToRegex(\DNFRegex')}{\ToRegex(\Sequence_n)} \Leftrightarrow \RegexOr{\ToRegex(\DNFRegexAlt')}{\ToRegex(\Sequence_n)}
}
\end{mathpar}
$\SemanticsOf{\OrLens{\Lens}{\Lens_n}}=\SetOf{(\String,\StringAlt)\SuchThat
(\String,\StringAlt)\in\Lens\BooleanOr(\String,\StringAlt)\in\Lens_n}$\\
\hspace*{4.6em}$=\SetOf{(\String,\StringAlt)\SuchThat
(\String,\StringAlt)\in\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_{n-1}}\\
\hspace*{8em}\BooleanOr(\String,\StringAlt)\in\DNFLensOf{\SequenceLens_n}}$\\
\hspace*{4.6em}$=\SetOf{(\String,\StringAlt)\SuchThat
(\String,\StringAlt)\in\SequenceLens_i}$.
\end{proof}
\end{lemma}

\begin{lemma}[Ineffectiveness of Permutation on DNF Regex Semantics]
\label{lem:dnfr-perm-sem-ineffective}
Let $\sigma\in S_n$, and $\DNFOf{\Sequence_1\ldots\Sequence_n}$ be a DNF regex.
$\LanguageOf{\DNFOf{\Sequence_1;\ldots;\Sequence_n}}=
\LanguageOf{\DNFOf{\Sequence_{\sigma(1)};\ldots;\Sequence_{\sigma(n)}}}$.
\end{lemma}
\begin{proof}
By inspection.
\end{proof}

\begin{lemma}[Ineffectiveness of Permutation on DNF Lens Semantics]
\label{lem:dnfl-perm-sem-ineffective}
Let $\sigma\in S_n$, and
$(\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n},\Identity) \OfType
\DNFOf{\Sequence_1;\ldots;\Sequence_n} \Leftrightarrow
\DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_n}$ be a typing of a DNF lens with
an identity permutation.
$\SemanticsOf{(\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n},\Identity)}
=\SemanticsOf{(\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n},\sigma)}$
\end{lemma}
\begin{proof}
By inspection
\end{proof}

\begin{lemma}[Rewrites Respecting Language]
\label{lem:rrl}
If $\DNFRegex\Rewrite\DNFRegexAlt$, then $\LanguageOf{\DNFRegex}=\LanguageOf{\DNFRegexAlt}$
\end{lemma}
\begin{proof}
Each of the rewrite rules are merely an application of one direction of one of
the regular expression star equivalences.
\end{proof}

\begin{lemma}[Soundness of DNF, Sequence, and Atom Lenses]\leavevmode
\label{lem:dnfcal}
\begin{enumerate}
\item Let \DNFRegex{} and \DNFRegexAlt{} be two dnf regular expressions, and $\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$.  Then there exists a \Lens{} such that $\Lens \OfType \ToRegex(\DNFRegex) \Leftrightarrow \ToRegex(\DNFRegexAlt)$, \SemanticsOf{\Lens}=\SemanticsOf{\DNFLens}

\item Let \Sequence{} and \SequenceAlt{} be two clauses, and $\SequenceLens \OfType \Sequence \Leftrightarrow \SequenceAlt$.  Then there exists a \Lens{} such that $\Lens \OfType \ToRegex(\Sequence) \Leftrightarrow \ToRegex(\SequenceAlt)$, \SemanticsOf{\Lens}=\SemanticsOf{\SequenceLens}.

\item Let \Atom{} and \AtomAlt{} be two atoms, and $\AtomLens \OfType \Atom \Leftrightarrow \AtomAlt$.  Then there exists a \Lens{}, such that $\Lens \OfType \ToRegex(\Atom) \Leftrightarrow \ToRegex(\AtomAlt)$, \SemanticsOf{\Lens}=\SemanticsOf{\AtomLens}.
\end{enumerate}
\begin{proof}
By mutual induction on the structure of the DNF Regex, Sequence, and
Atom lenses typing.\\ 
\\
Let $\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$ be formed from an
application of\\$\DNFRewriteLensRule{}$.
\begin{mathpar}
\inferrule*
{
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\DNFLens \OfType \DNFRegex' \Leftrightarrow \DNFRegexAlt'
}\\
\DNFRegex' \RewriteDNF \DNFRegex\\
\DNFRegexAlt' \RewriteDNF \DNFRegexAlt
}
{
\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt
}
\end{mathpar}
By induction assumption, there exists a
$\Lens \OfType \ToRegex(\DNFRegex') \Leftrightarrow \ToRegex(\DNFRegexAlt')$,
and from Lemma~\ref{lem:rrl}, we know
$\LanguageOf{\DNFRegex}=\LanguageOf{\DNFRegex'}$, and
$\LanguageOf{\DNFRegexAlt}=\LanguageOf{\DNFRegexAlt'}$.
Consider the derivation
\begin{mathpar}
\inferrule*
{
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens \OfType \ToRegex(\DNFRegex') \Leftrightarrow \ToRegex(\DNFRegexAlt')
}\\
\LanguageOf{\ToRegex(\DNFRegex')} = \LanguageOf{\ToRegex(\DNFRegex)}\\
\LanguageOf{\ToRegex(\DNFRegexAlt')} = \LanguageOf{\ToRegex(\DNFRegexAlt)}
}
{
\Lens \OfType \ToRegex(\DNFRegex) \Leftrightarrow \ToRegex(\DNFRegexAlt)
}
\end{mathpar}
This has the desired typing, and by induction assumption, has the desired semantics.\\
\\
Let $(\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n},\sigma) \OfType \DNFOf{\Sequence_1;\ldots;\Sequence_n} \Leftrightarrow \DNFOf{\SequenceAlt_{\sigma(1)};\ldots;\SequenceAlt_{\sigma(n)}}$ be formed from an application of $\DNFLensRule$.
By Induction assumption, for each $\SequenceLens_i \OfType \Sequence_i \Leftrightarrow \SequenceAlt_i$ there exists a $\Lens_i \OfType \ToRegex(\Sequence_i) \Leftrightarrow \ToRegex(\SequenceAlt_i)$.\\
By Lemma~\ref{lem:id-dnf} there exists a $\Lens \OfType \ToRegex(\DNFOf{\Sequence_1;\ldots;\Sequence_{n}}) \Leftrightarrow \ToRegex(\DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_{n}})$ such that $\SemanticsOf{\Lens}=\SemanticsOf{([\SequenceLens_1;\ldots\SequenceLens_n],id)}$,
By Lemma~\ref{lem:dnfl-perm-sem-ineffective},
$\SemanticsOf{(DNFOf{\SequenceLens_1;\ldots;\SequenceLens_n},id)}=
\SemanticsOf{(\DNFOf{\SequenceLens_1;\ldots;\SequenceLens_n},\sigma)}$.
By Lemma~\ref{lem:dnfr-perm-sem-ineffective},
$\LanguageOf{\DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_n}}=
\LanguageOf{\DNFOf{\SequenceAlt_{\sigma(1)};\ldots;\SequenceAlt_{\sigma(n)}}}$.
Consider the following typing

\begin{mathpar}
\inferrule*
{
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens \OfType \ToRegex(\DNFOf{\Sequence_1;\ldots;\Sequence_{n}}) \Leftrightarrow \ToRegex(\DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_{n}})
}\\
\LanguageOf{\ToRegex(\DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_{n}})} =
\LanguageOf{\ToRegex(\DNFOf{\SequenceAlt_{\sigma(1)};\ldots;\SequenceAlt_{\sigma(n)}})}
}
{
\Lens \OfType \ToRegex(\DNFOf{\Sequence_1;\ldots;\Sequence_{n}}) \Leftrightarrow \ToRegex(\DNFOf{\SequenceAlt_{\sigma(1)};\ldots;\SequenceAlt_{\sigma(n)}})
}
\end{mathpar}
This has the typing and semantics as desired.\\
\\
Let $(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)},\sigma \in S_n) \OfType \SequenceOf{\String_0 ; \Atom_1 ; \ldots ; \Atom_n ; \String_n} \Leftrightarrow \SequenceOf{\StringAlt_0; \AtomAlt_{\sigma(1)} ; \ldots ; \AtomAlt_{\sigma(n)} ; \StringAlt_n}$ be formed from an
application of\\$\SequenceLensRule{}$.
By induction assumption, for each
$\AtomLens_i \OfType \Atom_i \Leftrightarrow \AtomAlt_i$ there exists a
$\Lens_i \OfType \ToRegex(\Regex_i) \Leftrightarrow \ToRegex(\RegexAlt_i)$.
By Lemma~\ref{lem:id-clause}, there exists a $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that $\SemanticsOf{\Lens}=\SemanticsOf{([(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)],id)}$,
$\Regex=\ToRegex(\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n})$, and
$\RegexAlt=\ToRegex(\SequenceOf{\StringAlt_0;\AtomAlt_1;\ldots;\AtomAlt_n;\StringAlt_n})$.
Define $\RegexAlt_{\Sep}$ as $\ToRegex(\SequenceOf{\Sep;\AtomAlt_1;\ldots;\AtomAlt_n;\Sep})$.
By Lemma~\ref{lem:boilerplate-alterations}, there exists a
$\Lens' \OfType \RegexAlt \Leftrightarrow \RegexAlt_{\Sep}$, with semantics of
merely changing the boilerplate.
By Lemma~\ref{lem:perm-exp}, there exists a $\Lens'' \OfType \RegexAlt_{\Sep}'
\Leftrightarrow \RegexAlt_{\Sep}''$ where
$\SemanticsOf{\RegexAlt_{\Sep}'}=\SemanticsOf{\RegexAlt_{\Sep}}$ and 
$\SemanticsOf{\RegexAlt_{\Sep}''}=\SemanticsOf{\SequenceOf{\Sep; \AtomAlt_{\sigma(1)} ; \ldots ; \AtomAlt_{\sigma(n)} ; \Sep}}$.
Lastly, with Lemma~\ref{lem:boilerplate-alterations}, there exists a
$\Lens''' \OfType \RegexAlt_{\Sep}'' \Leftrightarrow \RegexAlt'$, where
$\RegexAlt = \ToRegex(\SequenceOf{\StringAlt_0; \AtomAlt_{\sigma(1)} ; \ldots ; \AtomAlt_{\sigma(n)} ; \StringAlt_n})$.
Through composition of all these lenses, we finally get a lens with the desired type
and semantics.\\
\\
Let $\IterateLens{\DNFLens} \OfType \StarOf{\DNFRegex} \Leftrightarrow \StarOf{\DNFRegexAlt}$
be introduced through an application of \IterateAtomLensRule{}.
From induction assumption, I know that there exists $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$, such that
$\SemanticsOf{\DNFLens}=\SemanticsOf{\Lens}$,
\Regex=\ToRegex(\DNFRegex), and
$\RegexAlt=\ToRegex(\DNFRegexAlt)$.\\
Consider $\IterateLens{\Lens} \OfType \StarOf{\Regex} \Leftrightarrow \StarOf{\RegexAlt}$.\\
By definition, $\StarOf{\Regex}$ and $\StarOf{\RegexAlt}$ are $\ToRegex(\StarOf{\DNFRegex})$
and $\ToRegex(\StarOf{\Regex})$, respectively.

\begin{tabular}{RcL}
\SemanticsOf{\IterateLens{\Lens}} & = &
\SetOf{(\String_0\ldots\String_n,\StringAlt_0\ldots\StringAlt_n)\SuchThat
(\String_i,\StringAlt_i)\in\SemanticsOf{\Lens}}\\
& = &
\SetOf{(\String_0\ldots\String_n,\StringAlt_0\ldots\StringAlt_n)\SuchThat
(\String_i,\StringAlt_i)\in\SemanticsOf{\DNFLens}}\\
& = &
\SemanticsOf{\IterateLens{\DNFLens}}
\end{tabular}
\end{proof}
\end{lemma}

\dnfls*
\begin{proof}

The soundess of DNF lenses follows immediatley from Lemma~\ref{lem:dnfcal}

\end{proof}

\begin{theorem}[Strong DNF Lens Soundness]
Let $\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$, be the typing
of a DNF lens $\DNFLens$.
and let $\Regex$ and $\RegexAlt$ be regular expressions, such that
$\LanguageOf{\DNFRegex}=\LanguageOf{\Regex}$,
and $\LanguageOf{\DNFRegexAlt}=\LanguageOf{\RegexAlt}$.
There exists a lens $\Lens : \Regex \Leftrightarrow \RegexAlt$, such that
$\SemanticsOf{\Lens}=\SemanticsOf{\DNFLens}$.
\end{theorem}

\begin{proof}
By Theorem~\ref{thm:dnfls}, there exist regular expressions $\Regex'$,
$\RegexAlt'$, such that there exists a lens $\DNFLens$ such there is the
derivation for a typing.
\begin{mathpar}
\inferrule[]
{
\Derivation{}
}
{
\DNFLens \OfType \Regex' \Leftrightarrow \RegexAlt'
}
\end{mathpar}
\SemanticsOf{\DNFLens}=\SemanticsOf{\Lens},
\LanguageOf{\Regex'}=\LanguageOf{\DNFRegex},
and \LanguageOf{\RegexAlt'}=\LanguageOf{\DNFRegexAlt'}.
Because of this, $\Regex'\equiv\Regex$, and $\RegexAlt'\equiv\RegexAlt$.
Consider the typing
\begin{mathpar}
\inferrule*
{
\inferrule*
{
\Derivation{}
}
{
\DNFLens \OfType \Regex' \Leftrightarrow \RegexAlt'
}\\
\Regex'\equiv\Regex\\
\RegexAlt'\equiv\RegexAlt
}
{
\DNFLens \OfType \Regex \Leftrightarrow \RegexAlt
}
\end{mathpar}

This satisfies the needed requirements!
\end{proof}
%proof-dnfls end

However, these lenses are much more suited to synthesis.
The vast majority of the rules have a syntax directed synthesis algorithm.
Furthermore, even the rewrite rules that don't have an immediate syntax directed
synthesis algorithm have an underlying semantic meaning which can be used
to direct the solution.
