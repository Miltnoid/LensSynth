\section{Background}

\subsubsection{Languages and Alphabets}

\bcp{There's no need for each of these to be a separate, numbered
  definition -- it takes up a lot of space for no good reason.  (The good
  reasons for a numbered definition are either because it is a main, critical
  definition and you want to highlight it, or because you want to refer to
  it by number later.)}

\begin{definition}
We fix a finite set of symbols, called \textit{characters}, $\{\Character_1,\ldots,\Character_n\}$.
We call this fixed set an \textit{alphabet}, denoted \Alphabet{}.
\end{definition}

\begin{definition}
We call a sequence of characters $\Character_1\ldots\Character_n$ a
\textit{string}, denoted \String{}.
We denote the set of all strings $\StarOf{\Alphabet}$, and denote the string
with no characters \EmptyString{}.
\end{definition}

\begin{definition}
We call a subset of $\StarOf{\Alphabet}$ a \textit{language},
denoted \Language{}.
\end{definition}

\begin{definition}
If we have two strings $\Character=\Character_1\ldots\Character_n$,
and $\CharacterAlt=\CharacterAlt_1\ldots\CharacterAlt_m$,
then $\Character\Concat\CharacterAlt=\Character_1\ldots\Character_n\CharacterAlt_1\ldots\CharacterAlt_m$.
\end{definition}

\begin{definition}
We call two languages $\Language_1$, $\Language_2$ \bcp{it would be good to
  consistently emphasize the term being defined.}unambiguously concatenable,
denoted $\UnambigConcatOf{\Language_1}{\Language_2}$,
if, for all strings $\String_1,\StringAlt_1\in\Language_1$,
and $\String_2,\StringAlt_2\in\Language_2$, then
$\String_1\Concat\String_2=\StringAlt_1\Concat\StringAlt_2$
only if $\String_1=\StringAlt_1$ and $\String_2=\StringAlt_2$.
\end{definition}

\begin{definition}
We call a language $\Language$ unambigusously iterable,
denoted $\UnambigItOf{\Language{}}$,
if, for all $n\in\Nats$, for all strings $\String_1,\ldots,\String_n\in\Language$,
and for all strings $\StringAlt_1,\ldots,\StringAlt_n\in\Language$,
$\String_1\Concat\ldots\Concat\String_n=\StringAlt_1\Concat\ldots\Concat\StringAlt_n$
only if $\String_i=\StringAlt_i$ for all $i\in\RangeIncInc{1}{n}$.
\end{definition}

\subsubsection{Regular Expressions}

% fig:regex-syntax
\begin{figure}
\centering
\begin{tabular}{l@{\hspace*{5mm}}l@{\ }c@{\ }l@{\hspace*{5mm}}>{\itshape\/}l}

(Strings)& \String{},\StringAlt{} & \GEq{} & $\String\in\StarOf{\Sigma}$ \\
(Regexs)& \Regex{},\RegexAlt{} & \GEq{} & s & Base \\
& & & \GBar{} $\emptyset$ & Empty \\
& & & \GBar{} \Regex{}* & Star \\
& & & \GBar{} $\RegexConcat{\Regex_1}{\Regex_2}$ & Concat \\
& & & \GBar{} $\RegexOr{\Regex_1}{\Regex_2}$ & Or \\
\end{tabular}
\caption{Regular Expression Syntax}
\label{fig:regex-syntax}
\end{figure}

% fig:regex-semantics
\begin{figure}
\[
\begin{array}{lcl}
\LanguageOf{\String} &=& \{\String\}\\
\LanguageOf{\emptyset} &=& \{\}\\
\LanguageOf{\RegexConcat{\Regex_1}{\Regex_2}} &=&
\{\StringConcat{\String_1}{\String_2} \SuchThat
\String_1\in\LanguageOf{\Regex_1} \BooleanAnd \String_2\in\LanguageOf{\Regex_2}\}\\
\LanguageOf{\RegexOr{\Regex_1}{\Regex_2}} &=&
\{\String \SuchThat
\String\in\LanguageOf{\Regex_1} \BooleanOr \String\in\LanguageOf{\Regex_2}\}\\
\LanguageOf{\StarOf{\Regex}} &=&
\{\String_1\Concat\ldots\Concat\String_n \SuchThat
n\in\Nats \wedge \String_i\in\LanguageOf{\Regex}\}
\end{array}
\]
\caption{Regex Semantics}
\label{fig:regex-semantics}
\end{figure}

The syntax for regular expressions is given in Figure~\ref{fig:regex-syntax}.
These regular expressions have an underlying semantics to express languages,
formalized in Figure~\ref{fig:regex-semantics}.


% fig:bin-rel-regex
\begin{figure}
\centering{}
\begin{mathpar}
\inferrule[\Relation{} application]
{
\Relation(\Regex,\RegexAlt)
}
{
\Regex \Reduces_\Relation{} \RegexAlt
}

\inferrule[Star Induction]
{
\Regex \Reduces_\Relation{} \RegexAlt
}
{
\StarOf{\Regex} \Reduces_\Relation{} \StarOf{\RegexAlt}
}

\inferrule[Concat\SubLeft{} Induction]
{
\Regex \Reduces_\Relation{} \RegexAlt
}
{
\RegexConcat{\Regex}{\Regex'} \Reduces_\Relation{} \RegexConcat{\RegexAlt}{\Regex'}
}

\inferrule[Concat\SubRight{} Induction]
{
\Regex \Reduces_\Relation{} \RegexAlt
}
{
\RegexConcat{\Regex'}{\Regex} \Reduces_\Relation{} \RegexConcat{\Regex'}{\RegexAlt}
}

\inferrule[Or\SubLeft{} Induction]
{
\Regex \Reduces_\Relation{} \RegexAlt
}
{
\RegexOr{\Regex}{\Regex'} \Reduces_\Relation{} \RegexOr{\RegexAlt}{\Regex'}
}

\inferrule[Or\SubRight{} Induction]
{
\Regex \Reduces_\Relation{} \RegexAlt
}
{
\RegexOr{\Regex'}{\Regex} \Reduces_\Relation{} \RegexOr{\Regex'}{\RegexAlt}
}
\end{mathpar}
\caption{Structural Regular Expression Relation Expansion}
\label{fig:bin-rel-regex}
\end{figure}

Let \Relation{} be a binary relation on Regular Expressions.
We can define a structural regular expression expansion to that relation set via
$\Reduces_\Relation{}$, defined as in Figure~\ref{fig:bin-rel-regex}

% fig:regex-equivalence-rules
\begin{figure}
\centering
\begin{tabular}{@{}r@{\hspace{1em}}c@{\hspace{1em}}l@{}r@{}}
\Regex{} & $\equiv$ & \Regex{} & \EqualityRule{}  \\
\RegexOr{\Regex}{\emptyset} & $\equiv$ & \Regex{} & \OrIdentityRule{} \\
$\RegexConcat{\Regex}{\emptyset}$ & $\equiv$ & $\emptyset$ & \EmptyProjectionRuleRightRule{} \\
$\RegexConcat{\emptyset}{\Regex}$ & $\equiv$ & $\emptyset$ & \EmptyProjectionRuleLeftRule{}\SubLeft{} \\
\RegexConcat{(\RegexConcat{\Regex{}}{\Regex'})}{\Regex''} & $\equiv$ & \RegexConcat{\Regex{}}{(\RegexConcat{\Regex'}{\Regex''})} & \ConcatAssocRule{}  \\
\RegexOr{(\RegexOr{\Regex}{\Regex'})}{\Regex''} & $\equiv$ & \RegexOr{\Regex}{(\RegexOr{\Regex'}{\Regex''})} & \OrAssociativityRule{}  \\
\RegexOr{\Regex{}}{\RegexAlt{}} & $\equiv$ & \RegexOr{\RegexAlt{}}{\Regex{}} & \OrCommutativityRule{}\\
\RegexConcat{\Regex{}}{(\RegexOr{\Regex{}'}{\Regex{}''})} & $\equiv$ & \RegexOr{(\RegexConcat{\Regex{}}{\Regex{}'})}{(\RegexConcat{\Regex{}}{\Regex{}''})} & \DistributivityLeftRule{} \\
\RegexConcat{(\RegexOr{\Regex{}'}{\Regex{}''})}{\Regex{}} & $\equiv$ & \RegexOr{(\RegexConcat{\Regex{}'}{\Regex{}})}{(\RegexConcat{\Regex{}''}{\Regex{}})} & \DistributivityRightRule{} \\
\RegexConcat{\Regex{}}{\EmptyString{}} & $\equiv$ & \Regex{} & \ConcatIdentityRule{} \\
\StarOf{(\RegexOr{\Regex{}}{\RegexAlt{}})} & $\equiv$ & \RegexConcat{\StarOf{(\RegexConcat{\StarOf{\Regex{}}}{\RegexAlt{}})}}{\StarOf{\Regex{}}} & \SumstarRule{}\\
\StarOf{(\RegexConcat{\Regex{}}{\RegexAlt{}})} & $\equiv$ & \RegexOr{\EmptyString{}}{(\RegexConcat{\RegexConcat{\Regex{}}{\StarOf{(\RegexConcat{\RegexAlt{}}{\Regex{}})}}}{\RegexAlt{}})} & \ProductstarRule{} \\
${(\Regex{}^*)}^*$ & $\equiv$ & \StarOf{\Regex{}} & \StarstarRule{} \\
\StarOf{(\RegexOr{\Regex}{\RegexAlt})} & $\equiv$ & $\StarOf{(\RegexConcat{(\RegexOr{\Regex}{\RegexAlt})}{\RegexOr{\RegexAlt}{\RegexConcat{{(\RegexConcat{\Regex}{\StarOf{\RegexAlt}})}^n}{\Regex}}})}\Concat$ & \DicyclicityRule{}\\
& & $(\EmptyString\Or(\RegexOr{\Regex}{\RegexAlt})\Concat$\\
& & $({(\RegexConcat{\Regex}{\StarOf{\RegexAlt}})}^0\Or\ldots\Or{(\RegexConcat{\Regex}{\StarOf{\RegexAlt}})}^n))$
\end{tabular}
\caption{Regular Expression Equivalences}
\label{fig:regex-equivalence-rules}
\end{figure}

\afm{fix overloaded syntax here} We call two regular expressions equivalent, denoted $\Regex_1\equiv\Regex_2$,
if $\LanguageOf{\Regex_1}=\LanguageOf{\Regex_2}$.
We define a relation \Relation{} an equational theory for equivalent regular
expressions if $\Regex \Reduces_\Relation{} \RegexAlt$ if, and only if,
$\LanguageOf{\Regex} = \LanguageOf{\RegexAlt}$.
There exists an equational theory for determining if two regular expressions are equivalent,
presented by Conway \cite{conway}
and proven complete by Krob \cite{Krob}\bcp{The citation for Conway reads
  funny.},
shown in Figure~\ref{fig:regex-equivalence-rules}.

\subsubsection{Bijective Lenses}

% fig:lens-syntax
\begin{figure}
\centering
\begin{tabular}{l@{\ }l@{\ }c@{\ }l@{\ }>{\itshape\/}r}
% REGEX
(Lenses)& \Lens{} & \GEq{} & $\ConstLens{s_1 \in \StarOf{\Alphabet}}{s_2 \in \StarOf{\Alphabet}}$ & Const \\
& & & \GBar{} $\IdentityLens$ & Identity\\
& & & \GBar{} $\IterateLens{\Lens}$ & Iterate \\
& & & \GBar{} $\ConcatLens{\Lens_1}{\Lens_2}$ & Concat \\
& & & \GBar{} $\SwapLens{\Lens_1}{\Lens_2}$ & Swap\\
& & & \GBar{} $\OrLens{\Lens_1}{\Lens_2}$ & Or\\
& & & \GBar{} $\ComposeLens{\Lens_1}{\Lens_2}$ & Compose\\
\end{tabular}
\caption{Lens Syntax}
\label{fig:lens-syntax}
\end{figure}

% fig:lens-semantics
\begin{figure}
\[
\begin{array}{rcl}
\SemanticsOf{const(\String_1,\String_2)} &=& \SetOf{(\String_1,\String_2)}\\

\SemanticsOf{\IdentityLens} &=& \SetOf{(\String,\String)}\\

\SemanticsOf{\IterateLens{\Lens}} &=& \SetOf{(\String_1\Concat\ldots\Concat\String_n,
\StringAlt_1\Concat\ldots\Concat\StringAlt_n)\SuchThat
(\String_i,\StringAlt_i)\in\SemanticsOf{\Lens}}\\

\SemanticsOf{\ConcatLens{\Lens_1}{\Lens_2}} &=&
\SetOf{(\String_1\Concat\String_2,\StringAlt_1\Concat\StringAlt_2)\SuchThat\\
& & \hspace*{2em}(\String_1,\StringAlt_1)\in\SemanticsOf{\Lens_1}\BooleanAnd
(\String_2,\StringAlt_2)\in\SemanticsOf{\Lens_2}}\\

\SemanticsOf{\SwapLens{\Lens_1}{\Lens_2}} &=&
\SetOf{(\String_1\Concat\String_2,\StringAlt_2\Concat\StringAlt_1)\SuchThat\\
& & \hspace*{2em}(\String_1,\StringAlt_1)\in\SemanticsOf{\Lens_1}\BooleanAnd
(\String_2,\StringAlt_2)\in\SemanticsOf{\Lens_2}}\\

\SemanticsOf{\OrLens{\Lens_1}{\Lens_2}} &=&
\SetOf{(\String,\StringAlt)
\SuchThat(\String,\StringAlt)\in\SemanticsOf{\Lens_1}
\BooleanOr(\String,\StringAlt)\in\SemanticsOf{\Lens_2}}\\

\SemanticsOf{\ComposeLens{\Lens_1}{\Lens_2}} &=&
\SetOf{(\String_1,\String_3)\SuchThat\exists\String_2\\
& & \hspace*{2em}(\String_1,\String_2)\in\SemanticsOf{\Lens_1}\BooleanAnd
(\String_2,\String_3)\in\SemanticsOf{\Lens_2}}
\end{array}
\]
\caption{Lens Semantics}
\label{fig:lens-semantics}
\end{figure}

% fig:lens-semantics
\begin{figure}
\centering
\begin{mathpar}
\inferrule[\ConstantLensRule{}]
{
\String_1 \in \StarOf{\Sigma}\\
\String_2 \in \StarOf{\Sigma}
}
{
\ConstLens{\String_1}{\String_2} \OfType \String_1 \Leftrightarrow \String_2
}

\inferrule[\IdentityLensRule{}]
{
}
{
\IdentityLens \OfType \Regex \Leftrightarrow \Regex
}

\inferrule[\IterateLensRule{}]
{
\Lens \OfType \Regex \Leftrightarrow \RegexAlt\\
\UnambigItOf{\LanguageOf{\Regex}}\\
\UnambigItOf{\LanguageOf{\RegexAlt}}
}
{
\IterateLens{\Lens} \OfType \StarOf{\Regex} \Leftrightarrow \StarOf{\RegexAlt}
}

\inferrule[\ConcatLensRule{}]
{
\Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1\\
\Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2\\
\UnambigConcatOf{\LanguageOf{\Regex_1}}{\LanguageOf{\Regex_2}}\\
\UnambigConcatOf{\LanguageOf{\RegexAlt_1}}{\LanguageOf{\RegexAlt_2}}
}
{
\ConcatLens{\Lens_1}{\Lens_2} \OfType \Regex_1\Regex_2 \Leftrightarrow \RegexAlt_1\RegexAlt_2
}

\inferrule[\SwapLensRule{}]
{
\Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1\\
\Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2\\
\UnambigConcatOf{\LanguageOf{\Regex_1}}{\LanguageOf{\Regex_2}}\\
\UnambigConcatOf{\LanguageOf{\RegexAlt_2}}{\LanguageOf{\RegexAlt_1}}
}
{
\SwapLens{\Lens_1}{\Lens_2} \OfType \Regex_1\Regex_2 \Leftrightarrow \RegexAlt_2\RegexAlt_1
}

\inferrule[\OrLensRule{}]
{
\Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1\\
\Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2\\
\UnambigOrOf{\LanguageOf{\Regex_1}}{\LanguageOf{\Regex_2}}\\ \UnambigOrOf{\LanguageOf{\RegexAlt_1}}{\LanguageOf{\RegexAlt_2}}
}
{
\OrLens{\Lens_1}{\Lens_2} \OfType \Regex_1 | \RegexAlt_1 \Leftrightarrow \Regex_2 | \RegexAlt_2
}

\inferrule[\ComposeLensRule{}]
{
\Lens_1 \OfType \Regex_1 \Leftrightarrow \Regex_2\\
\Lens_2 \OfType \Regex_2 \Leftrightarrow \Regex_3\\
}
{
\ComposeLens{\Lens_2}{\Lens_1} \OfType \Regex_1 \Leftrightarrow \Regex_3
}

\inferrule[\RetypeLensRule{}]
{
\Lens \OfType \Regex_1 \Leftrightarrow \Regex_2\\
\Regex_1 \equiv \Regex_1'\\
\Regex_2 \equiv \Regex_2'
}
{
\Lens \OfType \Regex_1' \Leftrightarrow \Regex_2'
}
\end{mathpar}

\caption{Lens Typing}
\label{fig:lens-semantics}
\end{figure}


We focus on bijections between these\bcp{?} languages through the language of
bijective lenses.
We define the syntax for these bijective lenses in Figure~\ref{fig:lens-syntax}.
The semantics and typing for these lenses is\bcp{are} defined in Figure~\ref{fig:lens-semantics}.
The semantics is only defined alongside the typing, as the functions are only
well defined when the term is well typed.

We would like to synthesize these lenses from types and examples.
Our approach to synthesis is one of enumeration.
We would like to enumerate the programs that satisfy the desired typing until
we find one that satisfies the examples.
We enumerate these programs by creating subproblems based on typing rules
could potentially create the desired type.

For example, given the type $\RegexConcat{\Regex_1}{\Regex_2}\Leftrightarrow\RegexConcat{\RegexAlt_1}{\RegexAlt_2}$.
We know that it can be created from a Concat Lens rule,
which would create the subproblems of finding a lens of type $\Regex_1\Leftrightarrow\RegexAlt_1$
and a lens of type $\Regex_2\Leftrightarrow\RegexAlt_2$.

\section{DNF Regular Expressions}

% fig:dnf-regex-syntax
\begin{figure}
\begin{tabular}{l@{\ }l@{\ }c@{\ }l@{\ }r}

% DNF_REGEX
(Atoms)& \Atom{},\AtomAlt{} & \GEq{} & \StarOf{\DNFRegex{}} & Iterate DNF\\
(Sequence)& \Sequence{},\SequenceAlt{} & \GEq{} &
$\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}$ & Sequence\\
(DNF Regex)& \DNFRegex{},\DNFRegexAlt{} & \GEq{} & $\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}$ & DNF Or\\
\end{tabular}
\caption{DNF Regex Syntax\bcp{Or how about ``hollow square
  brackets'' for conjuncts (I guess hollow square brackets look too much
  like semantic brackets, but using some kind of square brackets seems good,
  since they are ordered) and ``hollow set braces'' for disjuncts?  We
  should try to get this right, since these widgets are our core technical
  device.}} 
\label{fig:dnf-regex-syntax}
\end{figure}

% fig:dnf-regex-semantics
\begin{figure}
\begin{itemize}
\item $\LanguageOf{\StarOf{\DNFRegex}} =
\{\String_1\Concat\ldots\Concat\String_n \SuchThat n\in\Nats \wedge \String_i\in\LanguageOf{\DNFRegex}\}$
\item $\LanguageOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}}=
\{\String_0\Concat\StringAlt_1\Concat\ldots\Concat\StringAlt_n\Concat\String_n \SuchThat \StringAlt_i\in\LanguageOf{\Atom_i}\}$
\item $\LanguageOf{\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}}=$\\
\hspace*{.5em}$\{\String \SuchThat \String \in \LanguageOf{\Sequence_i} \text{ for some $i\in\RangeIncInc{1}{n}$}\}$
\end{itemize}
\caption{DNF Regex Semantics\bcp{Take away bullets}}
\label{fig:dnf-regex-semantics}
\end{figure}


% fig:bin-rel-dnf-regex
\begin{figure}
\centering{}
\begin{mathpar}
\inferrule[$\Relation{}_{\Atom}$ application]
{
\Relation_\Atom(\Atom,\AtomAlt)
}
{
\Atom
\Reduces_{\Relation_\Atom,\Relation_\Sequence,\Relation_\DNFRegex}
\AtomAlt
}

\inferrule[$\Relation{}_{\Sequence}$ application]
{
\Relation_\Sequence(\Sequence,\SequenceAlt)
}
{
\Sequence
\Reduces_{\Relation_\Atom,\Relation_\Sequence,\Relation_\DNFRegex}
\SequenceAlt
}

\inferrule[$\Relation{}_{\DNFRegex}$ application]
{
\Relation_\DNFRegex(\DNFRegex,\DNFRegexAlt)
}
{
\DNFRegex
\Reduces_{\Relation_\Atom,\Relation_\Sequence,\Relation_\DNFRegex}
\DNFRegexAlt
}

\inferrule[Atom Induction]
{
\DNFRegex
\Reduces_{\Relation_\Atom,\Relation_\Sequence,\Relation_\DNFRegex}
\DNFRegexAlt
}
{
\StarOf{\DNFRegex}
\Reduces_{\Relation_\Atom,\Relation_\Sequence,\Relation_\DNFRegex}
\StarOf{\DNFRegexAlt}
}

\inferrule[Sequence Induction]
{
\Atom_i
\Reduces_{\Relation_\Atom,\Relation_\Sequence,\Relation_\DNFRegex}
\AtomAlt_i
}
{
\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep
\Atom_i\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}
\Reduces_{\Relation_\Atom,\Relation_\Sequence,\Relation_\DNFRegex}\\
\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep
\AtomAlt_i\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}
}

\inferrule[DNF Induction]
{
\Sequence_i
\Reduces_{\Relation_\Atom,\Relation_\Sequence,\Relation_\DNFRegex}
\SequenceAlt_i
}
{
\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_i\SequenceSep
\ldots\SequenceSep\Sequence_n}
\Reduces_{\Relation_\Atom,\Relation_\Sequence,\Relation_\DNFRegex}\\
\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\SequenceAlt_i\SequenceSep
\ldots\SequenceSep\Sequence_n}
}
\end{mathpar}
\caption{Structural DNF Regular Expression Relation Expansion\bcp{It's hard
    to read the rules because the rule names run into the premises}}
\label{fig:bin-rel-dnf-regex}
\end{figure}

A DNF regular esxpression is, intuitively
a regular expression which is completely distributed
applied, with no associativity information through a list representation,
and with base regular expressions only at fixed locations.
We formalize the syntax of this language in Figure~\ref{fig:dnf-regex-syntax}.
We will use the shorthand $\DNFOf{\SequenceOf{\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n}}$
for $\DNFOf{\SequenceOf{\EmptyString\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\EmptyString}}$.

Let \Relation{} be a binary relation on DNF Regular Expressions.
We can define a structural dnf regular expression expansion to that relation set via
$\Reduces_{\Relation_\Atom,\Relation_\Sequence,\Relation_\DNFRegex}$,
defined as in Figure~\ref{fig:bin-rel-dnf-regex}

The outermost layer is a list of sequences.
This layer intuitively corresponds to the choices involved in regular expression matching, and so represents where the Ors of normal regular expressions exist.
The second layer is a list of alternating strings and stars.
After the choice has been made about what will be expressed,
the base strings and iterated portions remains to be expressed.
We keep it in a normal form, by requiring a (possibly empty) string between
each clause.
The clause corresponds to the concatenated data, and is a concatenation of the
fixed data of base strings, and the iterated data of stars.
Finally is the atom, which is a star.
This corresponds to the iteration that takes place in normal stars.
There is no fixed way to break the choices of this into the clause,
as there is an arbitrarily large number of choices made in the stars.
This intuition is formalized by the semantics, given in
Figure~\ref{fig:dnf-regex-semantics}.

% fig:dnf-regex-functions
\begin{figure}
\ConcatSequence{} \OfType{} \ArrowTypeOf{\SequenceType{}}{\ArrowTypeOf{\SequenceType{}}{\SequenceType{}}}\\
$\ConcatSequenceOf{[\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n]}{[\StringAlt_0\SequenceSep\AtomAlt_1\SequenceSep\ldots\SequenceSep\AtomAlt_m\SequenceSep\StringAlt_m]}=$\\
\hspace*{2ex}$[\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n\Concat\StringAlt_0\SequenceSep\AtomAlt_1\SequenceSep\ldots\SequenceSep\AtomAlt_m\SequenceSep\StringAlt_m]$\\
\\
\ConcatDNF{} \OfType{} \ArrowTypeOf{\DNFRegexType{}}{\ArrowTypeOf{\DNFRegexType{}}{\DNFRegexType{}}}\\
$\ConcatDNFOf{\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}}{\DNFOf{\SequenceAlt_1\DNFSep\ldots\DNFSep\SequenceAlt_m}}=$
\[
\begin{array}{rcccl}
\DNFLeft & \ConcatSequenceOf{\Sequence_1}{\SequenceAlt_1}\DNFSep & \cdots & \ConcatSequenceOf{\Sequence_1}{\SequenceAlt_m}\DNFSep \\
& & \cdots & \\
& \ConcatSequenceOf{\Sequence_n}{\SequenceAlt_1}\DNFSep & \cdots & \ConcatSequenceOf{\Sequence_n}{\SequenceAlt_m} & \DNFRight
\end{array}
\]
\\
\OrDNF{} \OfType{} \ArrowTypeOf{\DNFRegexType{}}{\DNFRegexType{}}\\
$\OrDNFOf{\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}}{\DNFOf{\SequenceAlt_1\DNFSep\ldots\DNFSep\SequenceAlt_m}}$=\\
\hspace*{2ex}$\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n\DNFSep\SequenceAlt_1\DNFSep\ldots\DNFSep\SequenceAlt_m}$\\
\\
(-)\RepeatDNFOfTimes{n} \OfType{} \ArrowTypeOf{\DNFRegexType{}}{\DNFRegexType{}}\\
$\RepeatDNFOf{0}{\DNFRegex}=\DNFOf{\SequenceOf{\EmptyString}}$\\
$\RepeatDNFOf{n}{\DNFRegex}=\ConcatDNFOf{\DNFRegex}{\RepeatDNFOf{n-1}{\DNFRegex}}$\\
\caption{DNF Regex Functions} 
\label{fig:dnf-regex-functions}
\end{figure}

% fig:dnf-regex-equivalence-rules
\begin{figure}
\centering
\begin{tabular}{@{}r@{\hspace{1em}}c@{\hspace{1em}}l@{}r@{}}
\DNFRegex{} & $\equiv$ & \Regex{} & \EqualityRule{}  \\
\RegexOr{\Regex{}}{\RegexAlt{}} & $\equiv$ & \RegexOr{\RegexAlt{}}{\Regex{}} & \OrCommutativityRule{}\\
\StarOf{(\RegexOr{\Regex{}}{\RegexAlt{}})} & $\equiv$ & \RegexConcat{\StarOf{(\RegexConcat{\StarOf{\Regex{}}}{\RegexAlt{}})}}{\StarOf{\Regex{}}} & \SumstarRule{}\\
\StarOf{(\RegexConcat{\Regex{}}{\RegexAlt{}})} & $\equiv$ & \RegexOr{\EmptyString{}}{(\RegexConcat{\RegexConcat{\Regex{}}{\StarOf{(\RegexConcat{\RegexAlt{}}{\Regex{}})}}}{\RegexAlt{}})} & \ProductstarRule{} \\
${(\Regex{}^*)}^*$ & $\equiv$ & \StarOf{\Regex{}} & \StarstarRule{} \\
\StarOf{(\RegexOr{\Regex}{\RegexAlt})} & $\equiv$ & $\StarOf{(\RegexConcat{(\RegexOr{\Regex}{\RegexAlt})}{\RegexOr{\RegexAlt}{\RegexConcat{{(\RegexConcat{\Regex}{\StarOf{\RegexAlt}})}^n}{\Regex}}})}\Concat$ & \DicyclicityRule{}\\
& & $(\EmptyString\Or(\RegexOr{\Regex}{\RegexAlt})\Concat$\\
& & $({(\RegexConcat{\Regex}{\StarOf{\RegexAlt}})}^0\Or\ldots\Or{(\RegexConcat{\Regex}{\StarOf{\RegexAlt}})}^n))$
\end{tabular}
\caption{DNF Regular Expression Equivalences}
\label{fig:dnf-regex-equivalence-rules}
\end{figure}

We can create a dnf regular expression from a regular expression through repeated
application of the distributivity rule, and through removal of association information.
To do this, we require some functions defined on DNF regular expressions,
which we define in Figure~\ref{fig:dnf-regex-functions}.
This allows us to define a proposed equational theory, presented in
Figure~\ref{fig:dnf-regex-equivalence-rules}.
We can also use these functions to obtain a completeness result.
From this we can define a function which converts a regular expression into
an equivalent DNF regular expression, \ToDNFRegex{}.\bcp{Calling it
  something (much) shorter, maybe just a single symbol (maybe $\downarrow$ for
  ToDNFRegex and $\downarrow$ for ToRegex?), would make a lot of
  the proofs below very much less hideous.}

\begin{definition}
\leavevmode
\[
\begin{array}{rcl}
\ToDNFRegex(\String) & = & \DNFOf{\SequenceOf{\String}}\\
\ToDNFRegex(\emptyset) & = & \DNFOf{}\\
\ToDNFRegex(\StarOf{(\Regex)}) & = & \DNFOf{\SequenceOf{(\StarOf{\ToDNFRegex(\Regex)})}}\\
\ToDNFRegex(\RegexConcat{\Regex_1}{\Regex_2}) & = & \ToDNFRegex(\Regex_1)\\
& & \ConcatDNF \ToDNFRegex(\Regex_2)\\
\ToDNFRegex(\RegexOr{\Regex_1}{\Regex_2}) & = & \ToDNFRegex(\Regex_1)\\
& & \OrDNF \ToDNFRegex(\Regex_2)\\
\end{array}
\]
\end{definition}
We show that this transformation is a valid transformation.
\begin{restatable}[Completeness of DNF Regexs]{theorem}{dnfrc}\bcp{Can we
  make lemmas/theorems not italic?}
\label{thm:completeness-dnf-lenses}
For all regular expressions \Regex{},
\LanguageOf{\ToDNFRegex(\Regex)}=\LanguageOf{\Regex{}}.
\end{restatable}
\input{proof-dnfrc}

Furthermore, we can use prove that language of DNF regular expressions is sound,
and that \ToDNFRegex{} is surjective, by providing a right inverse.

\begin{definition}\leavevmode\\
$\ToRegex(\StarOf{\DNFRegex}) = \StarOf{\ToRegex(\DNFRegex})$\\
$\ToRegex(\SequenceOf{\String_0}) = \String_0$\\
$\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
\SequenceSep\Atom_n\SequenceSep\String_n}) =\\
\hspace*{2em}\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\SequenceSep\Atom_{n-1}\SequenceSep\String_{n-1}})
\Concat \ToRegex(\Atom_n) \Concat \String_{n+1}$\\
$\ToRegex(\DNFOf{})=\emptyset$\\
$\ToRegex(\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n})=\\
\hspace*{2em}\ToRegex(\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{n-1}})
\Or \ToRegex(\Sequence_n)$
\end{definition}

\begin{restatable}[Soundness of DNF Regexs]{theorem}{dnfrs}\leavevmode\\
\label{thm:soundness-dnf-lenses}
$\ToDNFRegex(\ToRegex(\DNFRegex)) = \DNFRegex$
\end{restatable}
\input{proof-dnfrs}

We can further normalize the DNF regular expressions by providing an order on sequences,
and ordering the sequences in the DNF regular expression according to that order.
With this, we have normalized all regular expression equivalences not involving stars.
In other words, if two regular expressions, $\Regex_1$ and $\Regex_2$,
are equivalent up to the transformations of regular expressions in equivalences
not involving stars,
then $\ToDNFRegex(\Regex_1)=\ToDNFRegex(\Regex_2)$.
A reasonable approach to further normalizing this is to attempt to minimize the
regular expression as much as possible, using the star laws.
Unfortunately, this doesn't work
well for finding lenses.  For example, there is clearly a lens of type
$\MapsBetweenTypeOf{\RegexOr{\EmptyString}{(\RegexConcat{a}{\StarOf{a}})}}{\RegexOr{b}{(\RegexConcat{c}{\StarOf{d}})}}$,
namely $\OrLens{\ConstLens{\EmptyString}{a}}{\ConcatLens{\ConstLens{a}{b}}{\IterateLens{\ConstLens{a}{d}}}}$.
However, if one simplifies as much as possible, then they will have to find a lens
of type $\MapsBetweenTypeOf{\StarOf{a}}{\RegexOr{b}{(\RegexConcat{c}{\StarOf{d}})}}$.
Unlike the type before being minified, where there was a type directed way to find
this lens, there is no longer a type directed way: should the lens be an iterate lens
or an or lens.
However, the regular expression equivalences have meaning.
If we only allow one rewrite, we see that
$\RegexOr{\EmptyString}{(\RegexConcat{a}{\StarOf{a}})}$ can be used for more
complicated lenses than merely $\StarOf{a}$.
A regular expression merely of the form $\StarOf{a}$ only cares about how the iterated case is handled, where a regular expression of the form
$\RegexOr{\EmptyString}{(\RegexConcat{a}{\StarOf{a}})}$ potentially acts differently on the empty
string case than on the nonempty case.

% fig:dnf-regex-rewrites
\begin{figure}
\begin{mathpar}
\inferrule[\AtomSumstarRule{}]
{
S\subseteq\RangeIncInc{1}{n}\\
\DNFRegex_{\Set} = [\Sequence_{\Set_1};\ldots;\Sequence_{\Set_{\SizeOf{\Set}}}]\\
\DNFRegex_{\ComplementOf{\Set}} = [\Sequence_{\ComplementOf{\Set}_1};\ldots;\Sequence_{\ComplementOf{\Set}_{\SizeOf{\ComplementOf{\Set}}}}]
}
{
\StarOf{\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}}\RewriteAtom\\\\
\DNFOf{\SequenceOf{\StarOf{(\ConcatDNFOf{\DNFOf{\SequenceOf{\StarOf{\DNFRegex_S}}}}{\DNFRegex_{\ComplementOf{\Set}}})}\SequenceSep
\StarOf{\DNFRegex_{\Set}}}}\\
}

\inferrule[\AtomUnrollstarLeftRule{}]
{
}
{
\StarOf{\DNFRegex}\RewriteAtom
\OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}{(\ConcatDNFOf{\DNFRegex}{\DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}})}
}

\inferrule[\AtomUnrollstarRightRule{}]
{
}
{
\StarOf{\DNFRegex}\RewriteAtom
\OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}{(\ConcatDNFOf{\DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}}{\DNFRegex})}
}

\inferrule[\AtomPowerstarRule{}]
{
n\in\Nats_{\geq1}
}
{
\StarOf{\DNFRegex}\RewriteAtom
\ConcatDNFOf{\DNFOf{\SequenceOf{\StarOf{(\RepeatDNFOf{n}{\DNFRegex})}}}}
{(\RepeatDNFOf{0}{\DNFRegex}\OrDNF\ldots\OrDNF\RepeatDNFOf{n}{\DNFRegex})}
}

\inferrule[\DicyclicRewriteStarRule{}]
{
S\subseteq\RangeIncInc{1}{n}\\
\DNFRegex_{\Set} = [\Sequence_{\Set_1};\ldots;\Sequence_{\Set_{\SizeOf{\Set}}}]\\
\DNFRegex_{\ComplementOf{\Set}} = [\Sequence_{\ComplementOf{\Set}_1};\ldots;\Sequence_{\ComplementOf{\Set}_{\SizeOf{\ComplementOf{\Set}}}}]
}
{
\StarOf{\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}}\RewriteAtom\\\\
\StarOf{(\ConcatDNFOf{(\OrDNFOf{\DNFRegex_{\Set}}{\DNFRegex_{\ComplementOf{\Set}}})}{\OrDNFOf{\DNFRegex_{\ComplementOf{\Set}}}{\ConcatDNFOf{{(\ConcatDNFOf{\DNFRegex_{\Set}}{\StarOf{\DNFRegex_{\ComplementOf{\Set}}}})}^n}{\DNFRegex_{\Set}}}})}\ConcatDNF\\
(\EmptyString\OrDNF(\OrDNFOf{\DNFRegex_{\Set}}{\DNFRegex_{\ComplementOf{\Set}}})\ConcatDNF\\
({(\ConcatDNFOf{\DNFRegex_{\Set}}{\StarOf{\DNFRegex_{\ComplementOf{\Set}}}})}^0\OrDNF\ldots\OrDNF{(\ConcatDNFOf{\DNFRegex_{\Set}}{\StarOf{\DNFRegex_{\ComplementOf{\Set}}}})}^n))
}

\inferrule[\DNFRewriteStarRule{}]
{
\DNFRegex \RewriteDNF \DNFRegex'
}
{
\StarOf{\DNFRegex} \RewriteAtom \DNFOf{\SequenceOf{\StarOf{\DNFRegex'}}}
}

\inferrule[\AtomDNFRewriteRule{}]
{
\Atom_j \RewriteAtom \DNFRegex
}
{
\DNFLeft\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}\DNFSep\\\\
\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}\SequenceSep\Atom_j\SequenceSep\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m}\DNFSep\\\\
\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n\DNFRight\RewriteDNF\\\\
\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF\\
\DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}\ConcatDNF\DNFRegex\ConcatDNF\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m} \OrDNF\\
\DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n}
}

\inferrule[\DNFRewriteCompositionRule{}]
{
\DNFRegex \RewriteDNF \DNFRegex'\\
\DNFRegex' \RewriteDNF \DNFRegex''
}
{
\DNFRegex \RewriteDNF \DNFRegex''
}

\inferrule[\IdentityDNFRewriteRule{}]
{
}
{
\DNFRegex \RewriteDNF \DNFRegex
}

\end{mathpar}
\caption{DNF Regex Rewrite Rules}
\label{fig:dnf-regex-rewrites}
\end{figure}


Because of this, instead of writing equivalences for DNF regular expressions like
exist for normal regular expressions,
instead we write rewrite rules as shown in
Figure~\ref{fig:dnf-regex-rewrites}.
Intuitively, these rewrite rules correspond to expanding a regular expression
into a regular expression which can be used in a more complicated lens, without requiring retyping.
We define these rules as rewrites that turn atoms into DNF Regular expressions,
and a rule that expresses how these rewrites can become rewrites on
the DNF regular expressions themselves.  \bcp{Here we {\em really} need some
examples.}

Roughly, the \AtomSumstarRule{} rewrite corresponds to \SumstarRule{},
the \AtomUnrollstarLeftRule{} and \AtomUnrollstarRightRule{} rewrites correspond to \ProductstarRule{}.
and the \DicyclicRewriteStarRule{} rewrite corresponds to \DicyclicityRule{}.
There is no rewrite corresponding to Regular Expression equivalence 10, as that
equivalence is an ambiguity introducing equivalence.
An application of \AtomSumstarRule{} corresponds to doing different things after the last time a certain event has occured, and before the last time that event occurs.
An application of \AtomUnrollstarLeftRule{} corresponds to making a different action for
the empty case of an iteration, the first case of an iteration, and all further cases of the iteration,
and similarly with \AtomUnrollstarRightRule{} for the empty case, the last case, and all previous cases, of the iteration.
An application of \DicyclicRewriteStarRule{} corresponds to TODO: understand this
horrible horrible rule.

\section{DNF Lenses}

% fig:dnf-lens-syntax
\begin{figure}
\centering
\begin{tabular}{@{}l@{\ }l@{\ }c@{}l@{\ }>{\itshape\/}r@{}}
% REGEX
(Atom Lenses) &\AtomLens{} & \GEq{} & $Iterate(\DNFLens)$ & Iterate\\
& & & \GBar{} \IdentityLens{} & Identity\\
(Sequence Lenses) &\SequenceLens{} & \GEq{} &
$(\SequenceLensOf{(\String_0,\StringAlt_0)\SequenceLensSep\AtomLens_1\SequenceLensSep\ldots\SequenceLensSep\AtomLens_n\SequenceLensSep(\String_n,\StringAlt_n)}$, &\\
& & & $\sigma \in S_n)$ & Clause\SubN{}\\
(DNF Lenses)& \DNFLens{} & \GEq{} & $(\DNFLensOf{\SequenceLens_1\DNFLensSep\ldots\DNFLensSep\SequenceLens_n}, \sigma \in S_n)$ & DNF\SubN{}\\
\end{tabular}
\caption{DNF Lens Syntax}
\label{fig:dnf-lens-syntax}
\end{figure}

% fig:dnf-lens-semantics
\begin{figure}
Semantics of Atom Lenses:\\
$\SemanticsOf{\IterateLens{\DNFLens}}$=\\
\hspace*{3em}$\SetOf{(\String_1\Concat\ldots\Concat\String_n,
\StringAlt_1\Concat\ldots\Concat\StringAlt_n)\SuchThat
n\in\NatsZero\BooleanAnd(\String_i,\StringAlt_i)\in\SemanticsOf{\DNFLens}}$\\
\\
Semantics of Sequence Lenses:\\
$\SemanticsOf{(\SequenceLensOf{(\String_0,\StringAlt_0)\SequenceLensSep
\AtomLens_1\SequenceLensSep\ldots\SequenceLensSep\AtomLens_n
\SequenceLensSep(\String_n,\StringAlt_n)},\Permutation)}=$\\
\hspace*{3em}$\SetOf{
(\String_0\Concat\String_1'\Concat\ldots\Concat\String_n'\Concat\String_n,
\String_{\Permutation(0)}\Concat\String_{\Permutation(1)}'\Concat\ldots
\Concat\String_{\Permutation(n)}'\Concat\String_{\Permutation(n)})\SuchThat$\\
\hspace*{4em}$(\String_i',\StringAlt_i')\in\SemanticsOf{\Atom_i}}$\\
\\
Semantics of DNF Lenses:\\
$\SemanticsOf{(\DNFLensOf{\SequenceLens_1\DNFLensSep\ldots\DNFLensSep
\SequenceLens_n},\Permutation)}=$\\
\hspace*{3em}$\SetOf{(\String,\StringAlt)\SuchThat
(\String,\StringAlt)\in\SequenceLens_i\text{ for some $i$}}$
\caption{DNF Lens Semantics}
\label{fig:dnf-lens-semantics}
\end{figure}

% fig:dnf-lens-semantics
\begin{figure}
\centering
\begin{mathpar}
\inferrule[\IterateAtomLensRule{}]
{
\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt
}
{
\IterateLens{\DNFLens} \OfType \StarOf{\DNFRegex} \Leftrightarrow \StarOf{\DNFRegexAlt}\\
(\PutRight\Apply\String_1)\Concat\ldots\Concat(\PutRight\Apply\String_n),\\
\lambda \String.\LetWhereIn{\String_1\Concat\ldots\Concat\String_n}{\String}{\String_i\in\LanguageOf{\DNFRegexAlt}}\\
(\PutLeft\Apply\String_1)\Concat\ldots\Concat(\PutLeft\Apply\String_n)
}

\inferrule[\SequenceLensRule{}]
{
\AtomLens_1 \OfType \Atom_1 \Leftrightarrow \AtomAlt_1\\
\ldots\\
\AtomLens_n \OfType \Atom_n \Leftrightarrow \AtomAlt_n\\
\sigma \in \PermutationSetOf{n}\\
\forall i \in \RangeIncInc{1}{n-1} \UnambigConcatOf{\LanguageOf{\String_{i-1}\Atom_i\epsilon}}{\LanguageOf{\String_i\Atom_{i+1}\epsilon}}\\
\forall i \in \RangeIncInc{1}{n-1} \UnambigConcatOf{\LanguageOf{\StringAlt_{i-1}\AtomAlt_{\sigma(i)}\epsilon}}{\LanguageOf{\StringAlt_i\AtomAlt_{\sigma(i+1)}\epsilon}}\\
}
{
(\SequenceLensOf{(\String_0,\StringAlt_0)\SequenceLensSep\Atom_1\SequenceLensSep\ldots\SequenceLensSep\Atom_n\SequenceLensSep(\String_n,\StringAlt_n)},\sigma) \OfType\\
\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}\Leftrightarrow
\SequenceOf{\StringAlt_0\SequenceSep\AtomAlt_1\SequenceSep\ldots\SequenceSep\AtomAlt_n\SequenceSep\StringAlt_n}
}

\inferrule[\DNFLensRule{}]
{
\SequenceLens_1 \OfType \Sequence_1 \Leftrightarrow \SequenceAlt_1\\
\ldots\\
\SequenceLens_n \OfType \Sequence_n \Leftrightarrow \SequenceAlt_n\\
\sigma \in \PermutationSetOf{n}\\
i \neq j \Rightarrow \Sequence_{i} \cap \Sequence_{j}=\emptyset\\
i \neq j \Rightarrow \SequenceAlt_{i} \cap \SequenceAlt_{j}=\emptyset\\
}
{
(\DNFLensOf{\SequenceLens_1\DNFLensSep\ldots\DNFLensSep\SequenceLens_n},\sigma) \OfType\\
\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}
\Leftrightarrow \DNFOf{\SequenceAlt_{\sigma(1)}\DNFSep\ldots\DNFSep\SequenceAlt_{\sigma(n)}}
}

\inferrule[\DNFRewriteLensRule{}]
{
\DNFRegex \RewriteDNF \DNFRegex'\\
\DNFRegexAlt \RewriteDNF \DNFRegexAlt'\\
\DNFLens \OfType \MapsBetweenTypeOf{\DNFRegex}{\DNFRegexAlt}
}
{
\DNFLens \OfType \MapsBetweenTypeOf{\DNFRegex'}{\DNFRegexAlt'}
}

\end{mathpar}
\caption{DNF Lens Typing\bcp{It looks like the first rule has semantics
    attached but the rest are just typing...}}
\label{fig:dnf-lens-semantics}
\end{figure}

Armed with these rewrites, we have the capabilities to define a sufficiently
strong language for lenses on these regular expressions.
The syntax is defined in Figure~\ref{fig:dnf-lens-syntax}.
Similarly to the language of lenses, we aim to have the typing of the lenses
correspond closely to the syntax for the lenses themselves.
The typing and semantics of these dnf lenses are defined in Figure~\ref{fig:dnf-lens-semantics}.
Intuitively, a DNF Regex Lens corresponds roughly to an n-ary version of an or lens,
a Sequence Lens corresponds to const lenses for the strings, and a combination of
Concat and Swap lenses for the Atoms.

These DNF lenses only express things expressible in the language of lenses.
\begin{restatable}[Soundness of DNF Lenses]{theorem}{dnfls}
\label{thm:dnfls}
If there exists a derivation of $\DNFLens \OfType \MapsBetweenTypeOf{\DNFRegex}{\DNFRegexAlt} \HasSemantics \PutRight,\PutLeft$,
then there exists a derivation of $\Lens \OfType \MapsBetweenTypeOf{\Regex}{\RegexAlt} \HasSemantics \PutRight,\PutLeft$ such that
$\LanguageOf{\Regex}=\LanguageOf{\DNFRegex}$, and
$\LanguageOf{\RegexAlt}=\LanguageOf{\DNFRegexAlt}$.
\bcp{We also need that they behave the same, no??}
\end{restatable}
\input{proof-dnfls}

However, these lenses are much more suited to synthesis.
The vast majority of the rules have a syntax directed synthesis algorithm.
Furthermore, even the rewrite rules that don't have an immediate syntax directed
synthesis algorithm have an underlying semantic meaning which can be used
to direct the solution.
