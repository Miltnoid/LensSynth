\section{Background}

\subsubsection{Languages and Alphabets}

A \textit{character}, denoted\bcp{written} \Character{} or \CharacterAlt{}, is a symbol.
An \textit{alphabet}, denoted \Alphabet{}, is set of characters.
A \textit{string}, denoted \String{} or \StringAlt{}, is a sequence of characters.
The empty sequence of characters is denoted \EmptyString{}.
The set of all strings is denoted \StarOf{\Alphabet}.
A \textit{language}, denoted \Language{}, is a subset of \StarOf{\Alphabet}.

If \String{} and \StringAlt{} are strings, with
$\String=\Character_1\ldots\Character_n$,
and $\StringAlt=\CharacterAlt_1\ldots\CharacterAlt_m$,
then the \textit{concatenation} of \String{} and \StringAlt{},
denoted \String{}\Concat\StringAlt{}, is defined as
$\Character_1\ldots\Character_n\CharacterAlt_1\ldots\CharacterAlt_m$.


\subsubsection{Regular Expressions}

% fig:regex-syntax
\begin{figure}
\centering
\begin{tabular}{l@{\hspace*{5mm}}l@{\ }c@{\ }l@{\hspace*{5mm}}>{\itshape\/}l}

(Strings)& \String{},\StringAlt{} & \GEq{} & $\String\in\StarOf{\Sigma}$ \\
(Regexs)& \Regex{},\RegexAlt{} & \GEq{} & s & Base \\
& & & \GBar{} $\emptyset$ & Empty \\
& & & \GBar{} \Regex{}* & Star \\
& & & \GBar{} $\RegexConcat{\Regex_1}{\Regex_2}$ & Concat \\
& & & \GBar{} $\RegexOr{\Regex_1}{\Regex_2}$ & Or \\
\end{tabular}
\caption{Regular Expression Syntax}
\label{fig:regex-syntax}
\end{figure}

% fig:regex-semantics
\begin{figure}
\[
\begin{array}{lcl}
\LanguageOf{\String} &=& \{\String\}\\
\LanguageOf{\emptyset} &=& \{\}\\
\LanguageOf{\RegexConcat{\Regex_1}{\Regex_2}} &=&
\{\StringConcat{\String_1}{\String_2} \SuchThat
\String_1\in\LanguageOf{\Regex_1} \BooleanAnd \String_2\in\LanguageOf{\Regex_2}\}\\
\LanguageOf{\RegexOr{\Regex_1}{\Regex_2}} &=&
\{\String \SuchThat
\String\in\LanguageOf{\Regex_1} \BooleanOr \String\in\LanguageOf{\Regex_2}\}\\
\LanguageOf{\StarOf{\Regex}} &=&
\{\String_1\Concat\ldots\Concat\String_n \SuchThat
n\in\Nats \wedge \String_i\in\LanguageOf{\Regex}\}
\end{array}
\]
\caption{Regex Semantics}
\label{fig:regex-semantics}
\end{figure}

The syntax for regular expressions is given in Figure~\ref{fig:regex-syntax}.
These regular expressions have an underlying semantics to express languages,
formalized in Figure~\ref{fig:regex-semantics}.\bcp{Putting small things in
  figures wastes both space and reader attention (since they have to jump
  over and find the figure).} 

Two regular expressions, $\Regex_1$, $\Regex_2$ are said to be 
\textit{unambiguously concatenable}, denoted
$\Language_1\UnambigConcat\Language_2$ if, 
for all strings $\String_1,\StringAlt_1\in\LanguageOf{\Regex_1}$ and
$\String_2,\StringAlt_2\in\LanguageOf{\Regex_2}$,
$\String_1\Concat\String_2=\StringAlt_1\Concat\StringAlt_2$ implies
$\String_1=\StringAlt_1$ and $\String_2=\StringAlt_2$.

If $\Regex$ is a regular expression, where
for all $n\in\Nats$ and for all strings
$\String_1,\StringAlt_1,\ldots,\String_n,\StringAlt_n\in\LanguageOf{\Regex}$,
$\String_1\Concat\ldots\Concat\String_n=\StringAlt_1\Concat\ldots\Concat\StringAlt_n$
implies $\String_i=\StringAlt_i$ for all $i$,
that regular expression is \textit{unambiguously iterable},
denoted $\UnambigItOf{\Regex}$.


% fig:regex-equivalence-rules
\begin{figure}
\centering
\begin{tabular}{@{}r@{\hspace{1em}}c@{\hspace{1em}}l@{}r@{}}
\Regex{} & $\equiv$ & \Regex{} & \EqualityRule{}  \\
\RegexOr{\Regex}{\emptyset} & $\equiv$ & \Regex{} & \OrIdentityRule{} \\
$\RegexConcat{\Regex}{\emptyset}$ & $\equiv$ & $\emptyset$ & \EmptyProjectionRuleRightRule{} \\
$\RegexConcat{\emptyset}{\Regex}$ & $\equiv$ & $\emptyset$ & \EmptyProjectionRuleLeftRule{}\SubLeft{} \\
\RegexConcat{(\RegexConcat{\Regex{}}{\Regex'})}{\Regex''} & $\equiv$ & \RegexConcat{\Regex{}}{(\RegexConcat{\Regex'}{\Regex''})} & \ConcatAssocRule{}  \\
\RegexOr{(\RegexOr{\Regex}{\Regex'})}{\Regex''} & $\equiv$ & \RegexOr{\Regex}{(\RegexOr{\Regex'}{\Regex''})} & \OrAssociativityRule{}  \\
\RegexOr{\Regex{}}{\RegexAlt{}} & $\equiv$ & \RegexOr{\RegexAlt{}}{\Regex{}} & \OrCommutativityRule{}\\
\RegexConcat{\Regex{}}{(\RegexOr{\Regex{}'}{\Regex{}''})} & $\equiv$ & \RegexOr{(\RegexConcat{\Regex{}}{\Regex{}'})}{(\RegexConcat{\Regex{}}{\Regex{}''})} & \DistributivityLeftRule{} \\
\RegexConcat{(\RegexOr{\Regex{}'}{\Regex{}''})}{\Regex{}} & $\equiv$ & \RegexOr{(\RegexConcat{\Regex{}'}{\Regex{}})}{(\RegexConcat{\Regex{}''}{\Regex{}})} & \DistributivityRightRule{} \\
\RegexConcat{\Regex{}}{\EmptyString{}} & $\equiv$ & \Regex{} & \ConcatIdentityRule{} \\
\StarOf{(\RegexOr{\Regex{}}{\RegexAlt{}})} & $\equiv$ & \RegexConcat{\StarOf{(\RegexConcat{\StarOf{\Regex{}}}{\RegexAlt{}})}}{\StarOf{\Regex{}}} & \SumstarRule{}\\
\StarOf{(\RegexConcat{\Regex{}}{\RegexAlt{}})} & $\equiv$ & \RegexOr{\EmptyString{}}{(\RegexConcat{\RegexConcat{\Regex{}}{\StarOf{(\RegexConcat{\RegexAlt{}}{\Regex{}})}}}{\RegexAlt{}})} & \ProductstarRule{} \\
${(\Regex{}^*)}^*$ & $\equiv$ & \StarOf{\Regex{}} & \StarstarRule{} \\
\StarOf{(\RegexOr{\Regex}{\RegexAlt})} & $\equiv$ & $\StarOf{(\RegexConcat{(\RegexOr{\Regex}{\RegexAlt})}{\RegexOr{\RegexAlt}{\RegexConcat{{(\RegexConcat{\Regex}{\StarOf{\RegexAlt}})}^n}{\Regex}}})}\Concat$ & \DicyclicityRule{}\\
& & $(\EmptyString\Or(\RegexOr{\Regex}{\RegexAlt})\Concat$\\
& & $({(\RegexConcat{\Regex}{\StarOf{\RegexAlt}})}^0\Or\ldots\Or{(\RegexConcat{\Regex}{\StarOf{\RegexAlt}})}^n))$
\end{tabular}
\caption{Regular Expression Equivalences}
\label{fig:regex-equivalence-rules}
\end{figure}

If, $\Regex_1$ and $\Regex_2$ are regular expressions, where
$\LanguageOf{\Regex_1}=\LanguageOf{\Regex_2}$, those two regular expressions
are called \textit{equivalent}, denoted $\Regex_1\equiv\Regex_2$.
There exists an equational theory for determining if two regular expressions are equivalent,
presented by Conway \cite{conway}, and proven complete by Krob \cite{Krob},
shown in Figure~\ref{fig:regex-equivalence-rules}.

\subsubsection{Bijective Lenses}

% fig:lens-syntax
\begin{figure}
\centering
\begin{tabular}{l@{\ }l@{\ }c@{\ }l@{\ }>{\itshape\/}r}
% REGEX
(Lenses)& \Lens{} & \GEq{} & $\ConstLensOf{s_1 \in \StarOf{\Alphabet}}{s_2 \in \StarOf{\Alphabet}}$ & Const \\
& & & \GBar{} $\IdentityLensOf{\Regex}$ & Identity\\
& & & \GBar{} $\IterateLensOf{\Lens}$ & Iterate \\
& & & \GBar{} $\ConcatLensOf{\Lens_1}{\Lens_2}$ & Concat \\
& & & \GBar{} $\SwapLensOf{\Lens_1}{\Lens_2}$ & Swap\\
& & & \GBar{} $\OrLensOf{\Lens_1}{\Lens_2}$ & Or\\
& & & \GBar{} $\ComposeLensOf{\Lens_1}{\Lens_2}$ & Compose\\
\end{tabular}
\caption{Lens Syntax}
\label{fig:lens-syntax}
\end{figure}

% fig:lens-semantics
\begin{figure}
\[
\begin{array}{rcl}
\SemanticsOf{const(\String_1,\String_2)} &=& \SetOf{(\String_1,\String_2)}\\

\SemanticsOf{\IdentityLensOf{\Regex}} &=& \SetOf{(\String,\String)\SuchThat\String\in\LanguageOf{\Regex}}\\

\SemanticsOf{\IterateLensOf{\Lens}} &=& \SetOf{(\String_1\Concat\ldots\Concat\String_n,
\StringAlt_1\Concat\ldots\Concat\StringAlt_n)\SuchThat
(\String_i,\StringAlt_i)\in\SemanticsOf{\Lens}}\\

\SemanticsOf{\ConcatLensOf{\Lens_1}{\Lens_2}} &=&
\SetOf{(\String_1\Concat\String_2,\StringAlt_1\Concat\StringAlt_2)\SuchThat\\
& & \hspace*{2em}(\String_1,\StringAlt_1)\in\SemanticsOf{\Lens_1}\BooleanAnd
(\String_2,\StringAlt_2)\in\SemanticsOf{\Lens_2}}\\

\SemanticsOf{\SwapLensOf{\Lens_1}{\Lens_2}} &=&
\SetOf{(\String_1\Concat\String_2,\StringAlt_2\Concat\StringAlt_1)\SuchThat\\
& & \hspace*{2em}(\String_1,\StringAlt_1)\in\SemanticsOf{\Lens_1}\BooleanAnd
(\String_2,\StringAlt_2)\in\SemanticsOf{\Lens_2}}\\

\SemanticsOf{\OrLensOf{\Lens_1}{\Lens_2}} &=&
\SetOf{(\String,\StringAlt)
\SuchThat(\String,\StringAlt)\in\SemanticsOf{\Lens_1}
\BooleanOr(\String,\StringAlt)\in\SemanticsOf{\Lens_2}}\\

\SemanticsOf{\ComposeLensOf{\Lens_1}{\Lens_2}} &=&
\SetOf{(\String_1,\String_3)\SuchThat\exists\String_2\\
& & \hspace*{2em}(\String_1,\String_2)\in\SemanticsOf{\Lens_1}\BooleanAnd
(\String_2,\String_3)\in\SemanticsOf{\Lens_2}}
\end{array}
\]
\caption{Lens Semantics}
\label{fig:lens-semantics}
\end{figure}

% fig:lens-semantics
\begin{figure}
\centering
\begin{mathpar}
\inferrule[\ConstantLensRule{}]
{
\String_1 \in \StarOf{\Sigma}\\
\String_2 \in \StarOf{\Sigma}
}
{
\ConstLensOf{\String_1}{\String_2} \OfType \String_1 \Leftrightarrow \String_2
}

\inferrule[\IdentityLensRule{}]
{
}
{
\IdentityLensOf{\Regex} \OfType \Regex \Leftrightarrow \Regex
}

\inferrule[\IterateLensRule{}]
{
\Lens \OfType \Regex \Leftrightarrow \RegexAlt\\
\UnambigItOf{\Regex}\\
\UnambigItOf{\RegexAlt}
}
{
\IterateLensOf{\Lens} \OfType \StarOf{\Regex} \Leftrightarrow \StarOf{\RegexAlt}
}

\inferrule[\ConcatLensRule{}]
{
\Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1\\
\Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2\\\\
\UnambigConcatOf{\Regex_1}{\Regex_2}\\
\UnambigConcatOf{\RegexAlt_1}{\RegexAlt_2}
}
{
\ConcatLensOf{\Lens_1}{\Lens_2} \OfType \Regex_1\Regex_2 \Leftrightarrow \RegexAlt_1\RegexAlt_2
}

\inferrule[\SwapLensRule{}]
{
\Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1\\
\Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2\\\\
\UnambigConcatOf{\Regex_1}{\Regex_2}\\
\UnambigConcatOf{\RegexAlt_2}{\RegexAlt_1}
}
{
\SwapLensOf{\Lens_1}{\Lens_2} \OfType \Regex_1\Regex_2 \Leftrightarrow \RegexAlt_2\RegexAlt_1
}

\inferrule[\OrLensRule{}]
{
\Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1\\
\Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2\\\\
\UnambigOrOf{\LanguageOf{\Regex_1}}{\LanguageOf{\Regex_2}}\\ \UnambigOrOf{\LanguageOf{\RegexAlt_1}}{\LanguageOf{\RegexAlt_2}}
}
{
\OrLensOf{\Lens_1}{\Lens_2} \OfType \Regex_1 | \RegexAlt_1 \Leftrightarrow \Regex_2 | \RegexAlt_2
}

\inferrule[\ComposeLensRule{}]
{
\Lens_1 \OfType \Regex_1 \Leftrightarrow \Regex_2\\
\Lens_2 \OfType \Regex_2 \Leftrightarrow \Regex_3\\
}
{
\ComposeLensOf{\Lens_2}{\Lens_1} \OfType \Regex_1 \Leftrightarrow \Regex_3
}

\inferrule[\RewriteRegexLensRule{}]
{
\Lens \OfType \Regex_1 \Leftrightarrow \Regex_2\\
\Regex_1 \equiv \Regex_1'\\
\Regex_2 \equiv \Regex_2'
}
{
\Lens \OfType \Regex_1' \Leftrightarrow \Regex_2'
}
\end{mathpar}

\caption{Lens Typing}
\label{fig:lens-typing}
\end{figure}

Bijective lenses are a certain class of lenses which define bijective functions
between the languages of regular expressions.
The syntax for these bijective lenses is provided in Figure~\ref{fig:lens-syntax}.
The semantics and for these lenses are defined in Figure~\ref{fig:lens-semantics},
and the typing is given in Figure~\ref{fig:lens-typing}, where a well
typed program provides a bijection between the language of the regular expressions
of its type.

\begin{theorem}[Bijections Between Well-Typed Lenses\bcp{??}]
  If there exists a typing $\Lens\OfType\Regex\Leftrightarrow\RegexAlt$, then
  \begin{enumerate}
    \item
      For all $\String\in\LanguageOf{\Regex}$, there exists a unique
      $\StringAlt\in\LanguageOf{\RegexAlt}$ such that
      $(\String,\StringAlt)\in\SemanticsOf{\Lens}$.
    \item
      For all $\StringAlt\in\LanguageOf{\RegexAlt}$, there exists a unique
      $\String\in\LanguageOf{\Regex}$ such that
      $(\String,\StringAlt)\in\SemanticsOf{\Lens}$.
  \end{enumerate}
\end{theorem}
\bcp{I think the rest of the subsection doesn't belong here---this kind of
  explanation belongs in the ``by example'' section, which I propose should
  come next.}These lenses can be synthesized from types and examples through an enumeration
of programs of the desired typing.
We would like to enumerate all of the lenses that satisfy the desired typing
until we find one that satisfies the examples.
Through enumeration of the programs that satisfy the desired typing, eventually
one that satisfies the examples will be found.
The strict typing of these programs allows for enumeration by creating
subproblems based on typing rules.

For example, given the type $\RegexConcat{\Regex_1}{\Regex_2}\Leftrightarrow\RegexConcat{\RegexAlt_1}{\RegexAlt_2}$.
A lens of this type can be created from a Concat Lens rule,
which would create the subproblems of finding a lens of type $\Regex_1\Leftrightarrow\RegexAlt_1$
and a lens of type $\Regex_2\Leftrightarrow\RegexAlt_2$.

\section{DNF Regular Expressions}

% fig:dnf-regex-syntax
\begin{figure}
\begin{tabular}{l@{\ }l@{\ }c@{\ }l@{\ }>{\itshape\/}r}

% DNF_REGEX
(Atoms)& \Atom{},\AtomAlt{} & \GEq{} & \StarOf{\DNFRegex{}} & Iterate\\
(Sequences)& \Sequence{},\SequenceAlt{} & \GEq{} &
$\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}$ & MultiConcat\\
(DNF Regexes)& \DNFRegex{},\DNFRegexAlt{} & \GEq{} & $\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}$ & MultiOr\\
\end{tabular}
\caption{DNF Regex Syntax} 
\label{fig:dnf-regex-syntax}
\end{figure}

% fig:dnf-regex-semantics
\begin{figure}
\begin{tabular}{R@{}L}
\LanguageOf{\StarOf{\DNFRegex}} = &
\{\String_1\Concat\ldots\Concat\String_n \SuchThat n\in\Nats \wedge \String_i\in\LanguageOf{\DNFRegex}\}\\
\LanguageOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}}= &
\{\String_0\Concat\StringAlt_1\Concat\ldots\Concat\StringAlt_n\Concat\String_n \SuchThat \StringAlt_i\in\LanguageOf{\Atom_i}\}\\
\LanguageOf{\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}}= &
\{\String \SuchThat \String \in \LanguageOf{\Sequence_i} \text{ for some $i\in\RangeIncInc{1}{n}$}\}
\end{tabular}
\caption{DNF Regex Semantics}
\label{fig:dnf-regex-semantics}
\end{figure}

When attempting to synthesize a lens, one would be able to synthesize the lens
in a type directed fashion, were it not for \RewriteRegexLensRule{}.
Because of that, the job of synthesis is made easier if there is less of a use
for \RewriteRegexLensRule{}.
A good way to minimize the impact of this rule is to make more
regular expressions equivalent.  This is done by putting the regular expressions
into a normal form called DNF regular expressions.
A DNF regular expression is, intuitively, a regular expression with
distributivity applied wherever possible, causing outer layer of \Or{} operations,
with a sequences of \Concat{} operations being operated on by the \Or{} operations.
Furthermore, because of the associativity of \Or{} and \Concat{}, we
remove associativity information through a list representation.
Furthermore, we can further simplify by requiring
base string regular expressions to always appear at fixed locations,
utilizing the fact that $\EmptyString{}$ is the $\Concat$ identity, and
the ability to concatenate strings.
The syntax of the language of DNF regular expressions is formalized in Figure~\ref{fig:dnf-regex-syntax}.
The shorthand $\DNFOf{\SequenceOf{\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n}}$
stands for
$\DNFOf{\SequenceOf{\EmptyString\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\EmptyString}}$.

A sequence of strings and atoms is said to be \textit{unambiguously concatenable},
denoted $\UnambigConcat\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}$,
if, $\String_i',\StringAlt_i'\in\LanguageOf{\Atom_i}$ for all $i$, then
$\String_0\Concat\String_1'\ldots\Concat\String_n'\String_n=
\String_0\Concat\StringAlt_1'\ldots\Concat\StringAlt_n'\String_n$
implies $\String_i=\StringAlt_i$ for all $i$.  A DNF Regular expression is said
to be \textit{unambiguously iterable} denoted $\UnambigItOf{\DNFRegex}$ if, for
all
$\String_1,\StringAlt_1,\ldots,\String_n,\StringAlt_n\in\LanguageOf{\DNFRegex}$,
$\String_1\Concat\ldots\Concat\String_n=\StringAlt_1\Concat\ldots\Concat\StringAlt_n$,
implies $\String_i=\StringAlt_i$ for all $i$.

The outermost layer is a list of sequences.
This layer intuitively corresponds to the choices involved in regular expression matching, and so represents where the Ors of normal regular expressions exist.
The second layer is a list of alternating strings and stars.
After the choice has been made about what will be expressed,
the base strings and iterated portions remains to be expressed.
This is kept in a normal form by requiring a (possibly empty) string between
each clause.
The clause corresponds to the concatenated data, and is a concatenation of the
fixed data of base strings, and the iterated data of stars.
Finally is the atom, which is a star.
The iteration in atoms correspond to the iteration that takes place in normal stars.
There is no fixed way to break the choices of the iteration into the clause,
as there is an arbitrarily large number of choices made in the stars, proceed
in the iteration to stop iteration.
This intuition is formalized by the semantics, given in
Figure~\ref{fig:dnf-regex-semantics}.

% fig:dnf-regex-functions
\begin{figure}
\ConcatSequence{} \OfType{} \ArrowTypeOf{\SequenceType{}}{\ArrowTypeOf{\SequenceType{}}{\SequenceType{}}}\\
$\ConcatSequenceOf{[\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n]}{[\StringAlt_0\SequenceSep\AtomAlt_1\SequenceSep\ldots\SequenceSep\AtomAlt_m\SequenceSep\StringAlt_m]}=$\\
\hspace*{2ex}$[\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n\Concat\StringAlt_0\SequenceSep\AtomAlt_1\SequenceSep\ldots\SequenceSep\AtomAlt_m\SequenceSep\StringAlt_m]$\\
\\
\ConcatDNF{} \OfType{} \ArrowTypeOf{\DNFRegexType{}}{\ArrowTypeOf{\DNFRegexType{}}{\DNFRegexType{}}}\\
$\ConcatDNFOf{\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}}{\DNFOf{\SequenceAlt_1\DNFSep\ldots\DNFSep\SequenceAlt_m}}=$
\[
\begin{array}{rcccl}
\DNFLeft & \ConcatSequenceOf{\Sequence_1}{\SequenceAlt_1}\DNFSep & \cdots & \ConcatSequenceOf{\Sequence_1}{\SequenceAlt_m}\DNFSep \\
& \vdots & \ddots & \vdots \\
& \ConcatSequenceOf{\Sequence_n}{\SequenceAlt_1}\DNFSep & \cdots & \ConcatSequenceOf{\Sequence_n}{\SequenceAlt_m} & \DNFRight
\end{array}
\]
\\
\OrDNF{} \OfType{}
\ArrowTypeOf{\DNFRegexType{}}{\ArrowTypeOf{\DNFRegexType{}}{\DNFRegexType{}}
}\\
$\OrDNFOf{\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}}{\DNFOf{\SequenceAlt_1\DNFSep\ldots\DNFSep\SequenceAlt_m}}$=\\
\hspace*{2ex}$\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n\DNFSep\SequenceAlt_1\DNFSep\ldots\DNFSep\SequenceAlt_m}$\\
\\
(-)\RepeatDNFOfTimes{n} \OfType{} \ArrowTypeOf{\DNFRegexType{}}{\DNFRegexType{}}\\
$\RepeatDNFOf{0}{\DNFRegex}=\DNFOf{\SequenceOf{\EmptyString}}$\\
$\RepeatDNFOf{n}{\DNFRegex}=\ConcatDNFOf{\DNFRegex}{\RepeatDNFOf{n-1}{\DNFRegex}}$\\
\caption{DNF Regex Functions} 
\label{fig:dnf-regex-functions}
\end{figure}

A DNF regular expression can be created from a regular expression through repeated
application of the distributivity rule, and through removal of association information.
To create a DNF regular expresion from a regular expression,
some functions need to be defined on DNF regular expressions,
which are defined in Figure~\ref{fig:dnf-regex-functions}.
From these functions, \ToDNFRegex{}, a function which converts a regular expression into
an equivalent DNF regular expression, can be defined.

\begin{definition}
\leavevmode
\[
\begin{array}{rcl}
\ToDNFRegex(\String) & = & \DNFOf{\SequenceOf{\String}}\\
\ToDNFRegex(\emptyset) & = & \DNFOf{}\\
\ToDNFRegex(\StarOf{(\Regex)}) & = & \DNFOf{\SequenceOf{(\StarOf{\ToDNFRegex(\Regex)})}}\\
\ToDNFRegex(\RegexConcat{\Regex_1}{\Regex_2}) & = & \ToDNFRegex(\Regex_1) \ConcatDNF \ToDNFRegex(\Regex_2)\\
\ToDNFRegex(\RegexOr{\Regex_1}{\Regex_2}) & = & \ToDNFRegex(\Regex_1) \OrDNF \ToDNFRegex(\Regex_2)\\
\end{array}
\]
\end{definition}
\begin{restatable}[Completeness of DNF Regexs]{theorem}{dnfrc}
\label{thm:completeness-dnf-lenses}
For all regular expressions \Regex{},
\LanguageOf{\ToDNFRegex(\Regex)}=\LanguageOf{\Regex{}}.
\end{restatable}

Furthermore, we can use prove that language of DNF regular expressions is sound,
and that \ToDNFRegex{} is surjective, by providing a right inverse, $\ToRegex$.

\begin{definition}\leavevmode\\
$\ToRegex(\StarOf{\DNFRegex}) = \StarOf{\ToRegex(\DNFRegex)}$\\
$\ToRegex(\SequenceOf{\String_0}) = \String_0$\\
$\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
\SequenceSep\Atom_n\SequenceSep\String_n}) =\\
\hspace*{2em}\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\SequenceSep\Atom_{n-1}\SequenceSep\String_{n-1}})
\Concat \ToRegex(\Atom_n) \Concat \String_{n+1}$\\
$\ToRegex(\DNFOf{})=\emptyset$\\
$\ToRegex(\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n})=\\
\hspace*{2em}\ToRegex(\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{n-1}})
\Or \ToRegex(\Sequence_n)$
\end{definition}

\begin{restatable}[Soundness of DNF Regexs]{theorem}{dnfrs}\leavevmode\\
\label{thm:soundness-dnf-lenses}
$\ToDNFRegex(\ToRegex(\DNFRegex)) = \DNFRegex$
\end{restatable}

A reasonable approach to further normalizing a DNF regular expression is to attempt to minimize the
regular expression as much as possible, using the star laws.
Unfortunately, this strategy doesn't work
well for finding lenses.  For example, there is clearly a lens of type
$\MapsBetweenTypeOf{\RegexOr{\EmptyString}{(\RegexConcat{a}{\StarOf{a}})}}{\RegexOr{b}{(\RegexConcat{c}{\StarOf{d}})}}$,
namely $\OrLensOf{\ConstLensOf{\EmptyString}{a}}{\ConcatLensOf{\ConstLensOf{a}{b}}{\IterateLensOf{\ConstLensOf{a}{d}}}}$.
However, if one simplifies as much as possible, then they will have to find a lens
of type $\MapsBetweenTypeOf{\StarOf{a}}{\RegexOr{b}{(\RegexConcat{c}{\StarOf{d}})}}$.
Unlike the type before being minified, where there was a type directed way to find
this lens, there is no longer a type directed way: should the lens be an iterate lens
or an or lens?
To handle this sort of issue, DNF regular expressions can be rewritten according
to rules associated with the Star rules of the equational theory for regular
expressions.

% fig:dnf-regex-rewrites
\begin{figure}
\begin{mathpar}
\inferrule[\AtomSumstarRule{}]
{
S\subseteq\RangeIncInc{1}{n}\\
\DNFRegex_{\Set} = [\Sequence_{\Set_1};\ldots;\Sequence_{\Set_{\SizeOf{\Set}}}]\\
\DNFRegex_{\ComplementOf{\Set}} = [\Sequence_{\ComplementOf{\Set}_1};\ldots;\Sequence_{\ComplementOf{\Set}_{\SizeOf{\ComplementOf{\Set}}}}]
}
{
\StarOf{\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}}\RewriteAtom\\\\
\DNFOf{\SequenceOf{\StarOf{(\ConcatDNFOf{\DNFOf{\SequenceOf{\StarOf{\DNFRegex_S}}}}{\DNFRegex_{\ComplementOf{\Set}}})}\SequenceSep
\StarOf{\DNFRegex_{\Set}}}}\\
}

\inferrule[\AtomUnrollstarLeftRule{}]
{
}
{
\StarOf{\DNFRegex}\RewriteAtom
\OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}{(\ConcatDNFOf{\DNFRegex}{\DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}})}
}

\inferrule[\AtomUnrollstarRightRule{}]
{
}
{
\StarOf{\DNFRegex}\RewriteAtom
\OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}{(\ConcatDNFOf{\DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}}{\DNFRegex})}
}

\inferrule[\AtomPowerstarRule{}]
{
n\in\Nats_{\geq1}
}
{
\StarOf{\DNFRegex}\RewriteAtom
\ConcatDNFOf{\DNFOf{\SequenceOf{\StarOf{(\RepeatDNFOf{n}{\DNFRegex})}}}}
{(\RepeatDNFOf{0}{\DNFRegex}\OrDNF\ldots\OrDNF\RepeatDNFOf{n}{\DNFRegex})}
}

\inferrule[\DicyclicRewriteStarRule{}]
{
S\subseteq\RangeIncInc{1}{n}\\
\DNFRegex_{\Set} = [\Sequence_{\Set_1};\ldots;\Sequence_{\Set_{\SizeOf{\Set}}}]\\
\DNFRegex_{\ComplementOf{\Set}} = [\Sequence_{\ComplementOf{\Set}_1};\ldots;\Sequence_{\ComplementOf{\Set}_{\SizeOf{\ComplementOf{\Set}}}}]
}
{
\StarOf{\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}}\RewriteAtom\\\\
\StarOf{(\ConcatDNFOf{(\OrDNFOf{\DNFRegex_{\Set}}{\DNFRegex_{\ComplementOf{\Set}}})}{\OrDNFOf{\DNFRegex_{\ComplementOf{\Set}}}{\ConcatDNFOf{{(\ConcatDNFOf{\DNFRegex_{\Set}}{\StarOf{\DNFRegex_{\ComplementOf{\Set}}}})}^n}{\DNFRegex_{\Set}}}})}\ConcatDNF\\
(\EmptyString\OrDNF(\OrDNFOf{\DNFRegex_{\Set}}{\DNFRegex_{\ComplementOf{\Set}}})\ConcatDNF\\
({(\ConcatDNFOf{\DNFRegex_{\Set}}{\StarOf{\DNFRegex_{\ComplementOf{\Set}}}})}^0\OrDNF\ldots\OrDNF{(\ConcatDNFOf{\DNFRegex_{\Set}}{\StarOf{\DNFRegex_{\ComplementOf{\Set}}}})}^n))
}

\inferrule[\DNFRewriteStarRule{}]
{
\DNFRegex \RewriteDNF \DNFRegex'
}
{
\StarOf{\DNFRegex} \RewriteAtom \DNFOf{\SequenceOf{\StarOf{\DNFRegex'}}}
}

\inferrule[\AtomDNFRewriteRule{}]
{
\Atom_j \RewriteAtom \DNFRegex
}
{
\DNFLeft\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}\DNFSep\\\\
\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}\SequenceSep\Atom_j\SequenceSep\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m}\DNFSep\\\\
\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n\DNFRight\RewriteDNF\\\\
\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF\\
\DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}\ConcatDNF\DNFRegex\ConcatDNF\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m} \OrDNF\\
\DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n}
}

\inferrule[\DNFRewriteCompositionRule{}]
{
\DNFRegex \RewriteDNF \DNFRegex'\\
\DNFRegex' \RewriteDNF \DNFRegex''
}
{
\DNFRegex \RewriteDNF \DNFRegex''
}

\inferrule[\IdentityDNFRewriteRule{}]
{
}
{
\DNFRegex \RewriteDNF \DNFRegex
}

\end{mathpar}
\caption{DNF Regex Rewrite Rules}
\label{fig:dnf-regex-rewrites}
\end{figure}


Rewrite rules are provided in Figure~\ref{fig:dnf-regex-rewrites}.
Intuitively, these rewrite rules correspond to expanding a regular expression
into a regular expression which can be used in a more complicated lens.
These rewrite rules are a way of getting around
requiring a full retyping rule, as is present in standard lenses.
These rewrite rules present ways for atoms to be rewritten to DNF regular
expressions.  With the atoms rewritten as regular expressions, \AtomDNFRewriteRule{}
provides a way to combine the rewritten atom into the broader regular
expression.  For example, consider the DNF Regular
Expression $\DNFOf{\SequenceOf{a};\SequenceOf{\StarOf{b};\StarOf{c}};\SequenceOf{d}}$.
This DNF Regular expression matches either $a$, $b^i\Concat c^j$, or $d$.
With the above rules,
$\StarOf{b}\RewriteAtom\DNFOf{\SequenceOf{};\SequenceOf{b\StarOf{b}}}$, which
corresponds to an application of \ProductstarRule{} on $\EmptyString\Concat b$.
This then gets applied in the rules above, leading to the full DNF rewrite
$\DNFOf{\SequenceOf{a};\SequenceOf{\StarOf{b};\StarOf{c}};\SequenceOf{d}}
\RewriteDNF
\DNFOf{\SequenceOf{a};\SequenceOf{\StarOf{c}};\SequenceOf{b;\StarOf{b};\StarOf{c}};\SequenceOf{d}}$.
This has the same language, but $\SequenceOf{\StarOf{b};\StarOf{c}}$
has been expanded into matching $b^0c^j$ and $b^{i>0}c^j$ separately.

Roughly, the \AtomSumstarRule{} rewrite corresponds to \SumstarRule{},
the \AtomUnrollstarLeftRule{} and \AtomUnrollstarRightRule{} rewrites correspond to \ProductstarRule{}.
and the \DicyclicRewriteStarRule{} rewrite corresponds to \DicyclicityRule{}.
There is no rewrite corresponding to Regular Expression equivalence 10, as that
equivalence introduces ambiguity.
An application of \AtomSumstarRule{} corresponds to doing different things after the last time a certain event has occured, and before the last time that event occurs.
An application of \AtomUnrollstarLeftRule{} corresponds to making a different action for
the empty case of an iteration, the first case of an iteration, and all further cases of the iteration,
and similarly with \AtomUnrollstarRightRule{} for the empty case, the last case, and all previous cases, of the iteration.
An application of \DicyclicRewriteStarRule{} corresponds to a reordering of the
variables that corresponds to expressing a ring as an ideal, and the quotient by
that ideal.
\section{DNF Lenses}

% fig:dnf-lens-syntax
\begin{figure}
\centering
\begin{tabular}{@{}l@{\ }l@{\ }c@{}l@{\ }>{\itshape\/}r@{}}
% REGEX
(Atom Lenses) &\AtomLens{} & \GEq{} & $Iterate(\DNFLens)$ & Iterate\\
(Sequence Lenses) &\SequenceLens{} & \GEq{} &
$(\SequenceLensOf{(\String_0,\StringAlt_0)\SequenceLensSep\AtomLens_1\SequenceLensSep\ldots\SequenceLensSep\AtomLens_n\SequenceLensSep(\String_n,\StringAlt_n)}$, &\\
& & & $\sigma \in S_n)$ & Clause\SubN{}\\
(DNF Lenses)& \DNFLens{} & \GEq{} & $(\DNFLensOf{\SequenceLens_1\DNFLensSep\ldots\DNFLensSep\SequenceLens_n}, \sigma \in S_n)$ & DNF\SubN{}\\
\end{tabular}
\caption{DNF Lens Syntax}
\label{fig:dnf-lens-syntax}
\end{figure}

% fig:dnf-lens-semantics
\begin{figure}
Semantics of Atom Lenses:\\
$\SemanticsOf{\IterateLensOf{\DNFLens}}$=\\
\hspace*{3em}$\SetOf{(\String_1\Concat\ldots\Concat\String_n,
\StringAlt_1\Concat\ldots\Concat\StringAlt_n)\SuchThat
n\in\NatsZero\BooleanAnd(\String_i,\StringAlt_i)\in\SemanticsOf{\DNFLens}}$\\
\\
Semantics of Sequence Lenses:\\
$\SemanticsOf{(\SequenceLensOf{(\String_0,\StringAlt_0)\SequenceLensSep
\AtomLens_1\SequenceLensSep\ldots\SequenceLensSep\AtomLens_n
\SequenceLensSep(\String_n,\StringAlt_n)},\Permutation)}=$\\
\hspace*{3em}$\SetOf{
(\String_0\Concat\String_1'\Concat\ldots\Concat\String_n'\Concat\String_n,
\String_{\Permutation(0)}\Concat\String_{\Permutation(1)}'\Concat\ldots
\Concat\String_{\Permutation(n)}'\Concat\String_{\Permutation(n)})\SuchThat$\\
\hspace*{4em}$(\String_i',\StringAlt_i')\in\SemanticsOf{\Atom_i}}$\\
\\
Semantics of DNF Lenses:\\
$\SemanticsOf{(\DNFLensOf{\SequenceLens_1\DNFLensSep\ldots\DNFLensSep
\SequenceLens_n},\Permutation)}=$\\
\hspace*{3em}$\SetOf{(\String,\StringAlt)\SuchThat
(\String,\StringAlt)\in\SequenceLens_i\text{ for some $i$}}$
\caption{DNF Lens Semantics}
\label{fig:dnf-lens-semantics}
\end{figure}

% fig:dnf-lens-typing
\begin{figure}
\centering
\begin{mathpar}
\inferrule[\IterateAtomLensRule{}]
{
\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt
}
{
\IterateLensOf{\DNFLens} \OfType \StarOf{\DNFRegex} \Leftrightarrow \StarOf{\DNFRegexAlt}
(\PutRight\Apply\String_1)\Concat\ldots\Concat(\PutRight\Apply\String_n)
}

\inferrule[\SequenceLensRule{}]
{
\AtomLens_1 \OfType \Atom_1 \Leftrightarrow \AtomAlt_1\\
\ldots\\
\AtomLens_n \OfType \Atom_n \Leftrightarrow \AtomAlt_n\\
\sigma \in \PermutationSetOf{n}\\
\UnambigConcat\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}\\
\UnambigConcat\SequenceOf{\StringAlt_0\SequenceSep\AtomAlt_1\SequenceSep\ldots\SequenceSep\AtomAlt_n\SequenceSep\StringAlt_n}
}
{
(\SequenceLensOf{(\String_0,\StringAlt_0)\SequenceLensSep\Atom_1\SequenceLensSep\ldots\SequenceLensSep\Atom_n\SequenceLensSep(\String_n,\StringAlt_n)},\sigma) \OfType\\
\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}\Leftrightarrow
\SequenceOf{\StringAlt_0\SequenceSep\AtomAlt_1\SequenceSep\ldots\SequenceSep\AtomAlt_n\SequenceSep\StringAlt_n}
}

\inferrule[\DNFLensRule{}]
{
\SequenceLens_1 \OfType \Sequence_1 \Leftrightarrow \SequenceAlt_1\\
\ldots\\
\SequenceLens_n \OfType \Sequence_n \Leftrightarrow \SequenceAlt_n\\
\sigma \in \PermutationSetOf{n}\\
i \neq j \Rightarrow \Sequence_{i} \cap \Sequence_{j}=\emptyset\\
i \neq j \Rightarrow \SequenceAlt_{i} \cap \SequenceAlt_{j}=\emptyset\\
}
{
(\DNFLensOf{\SequenceLens_1\DNFLensSep\ldots\DNFLensSep\SequenceLens_n},\sigma) \OfType\\
\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}
\Leftrightarrow \DNFOf{\SequenceAlt_{\sigma(1)}\DNFSep\ldots\DNFSep\SequenceAlt_{\sigma(n)}}
}

\inferrule[\DNFRewriteLensRule{}]
{
\DNFRegex \RewriteDNF \DNFRegex'\\
\DNFRegexAlt \RewriteDNF \DNFRegexAlt'\\
\DNFLens \OfType \MapsBetweenTypeOf{\DNFRegex}{\DNFRegexAlt}
}
{
\DNFLens \OfType \MapsBetweenTypeOf{\DNFRegex'}{\DNFRegexAlt'}
}

\end{mathpar}
\caption{DNF Lens Typing}
\label{fig:dnf-lens-typing}
\end{figure}

Armed with these rewrites, a language for lenses on DNF regular
expressions can be defined.
The syntax is defined in Figure~\ref{fig:dnf-lens-syntax}.
Similarly to the language of lenses, the typing of the lenses
correspond closely to the syntax for the lenses themselves.
The semantics of these DNF lenses are defined in
Figure~\ref{fig:dnf-lens-semantics}.
The typing of these DNF lenses are defined in Figure~\ref{fig:dnf-lens-typing}.
Intuitively, a DNF Regex Lens corresponds roughly to an n-ary version of an or lens,
a Sequence Lens corresponds to const lenses for the strings, and a combination of
Concat and Swap lenses for the Atoms.

These DNF lenses only express bijections expressible in the language of lenses.
\begin{restatable}[Soundness of DNF Lenses]{theorem}{dnfls}
\label{thm:dnfls}
If there exists a derivation of $\DNFLens \OfType \MapsBetweenTypeOf{\DNFRegex}{\DNFRegexAlt}$,
then there exists a derivation of $\Lens \OfType \MapsBetweenTypeOf{\Regex}{\RegexAlt}$ such that
$\LanguageOf{\Regex}=\LanguageOf{\DNFRegex}$,
$\LanguageOf{\RegexAlt}=\LanguageOf{\DNFRegexAlt}$, and
$\SemanticsOf{\Lens}=\SemanticsOf{\DNFLens}$.
\end{restatable}

Furthermore, these DNF lenses are able to express a large number of things
expressible in a subset of the language of lenses.
\begin{restatable}[Partial Completeness of DNF Lenses]{theorem}{dnflc}
\label{thm:dnflc}
If there exists a derivation for $\Lens \OfType \Regex \Leftrightarrow
\RegexAlt$,
where there is no use of \DicyclicityRule{}, or \SumstarRule{} in the
proof of equivalence of regular expressions\bcp{I think we should give a
  name to this restricted equivalence relation (in the Background section)
  and talk about its properties a bit, rather than introducing it {\em en
    passant} here.} in the application of
\RewriteRegexLensRule{} in the typing of
$\Lens \OfType \Regex \Leftrightarrow \RegexAlt$,
then there exists a derivation for
$\DNFLens \OfType \ToDNFRegex(\Regex) \Leftrightarrow \ToDNFRegex(\RegexAlt)$
such that $\SemanticsOf{\Lens}=\SemanticsOf{\DNFLens}$.
\end{restatable}


These lenses are much more suited to synthesis.
The vast majority of the rules have a syntax directed synthesis algorithm.
We have reduced the dimensions we are searching in from 3 to 2.  Before, given a
specification, multiple rules could be applicable, equivalent regular
expressions would have to be searched through, and regular expressions for
composition would need to be found.
For DNF lenses, only the correct rewrites for the regular expressions, and the
correct permutations for each rule application, must be searched through.



%%% Local Variables:
%%% TeX-master: "main"
%%% End: