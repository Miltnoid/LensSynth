\begin{figure}
%A typing derivation is of the form $\FullContext \HasSemantics \Lens : \Regex \Leftrightarrow \RegexAlt \HasSemantics \PutRight,\PutLeft$.
%This means that under the regular expression context \RegexContext, and under the lens context \LensContext, the lens $\Lens$ has typing $\Regex \Leftrightarrow \RegexAlt$.
%It defines two functions, $\PutRight : \LanguageOf{\Regex}\rightarrow\LanguageOf{\RegexAlt}$, and $\PutLeft : \LanguageOf{\RegexAlt}\rightarrow\LanguageOf{\Regex}$.
%These functions are bijective functions, and are
%inverses of each other.
\centering
\begin{mathpar}
\inferrule[Constant Lens]
{
\String_1 \in \Star{\Sigma}\\
\String_2 \in \Star{\Sigma}\\
}
{
\ConstLens{\String_1}{\String_2} \OfType \String_1 \Leftrightarrow \String_2 \HasSemantics \lambda \String. \String_2 , \lambda \String. \String_1
}

\inferrule[Identity Lens]
{
}
{
\IdentityLens \OfType \Regex \Leftrightarrow \Regex \HasSemantics \lambda \String.\String, \lambda \String . \String
}

\inferrule[Iterate Lens]
{
\Lens \OfType \Regex \Leftrightarrow \RegexAlt \HasSemantics \PutRight , \PutLeft \\
\UnambigIt{\LanguageOf{\Regex}}\\
\UnambigIt{\LanguageOf{\RegexAlt}}\\
}
{
\IterateLens{\Lens} \OfType \Star{\Regex} \Leftrightarrow \Star{\RegexAlt} \HasSemantics\\\\
\lambda \String.\LetWhereIn{\String_1\Concat\ldots\Concat\String_n}{\String}{\String_i\in\LanguageOf{\Regex}} (\PutRight\Apply\String_1)\Concat\ldots\Concat(\PutRight\Apply\String_n),\\\\
\lambda \String.\LetWhereIn{\String_1\Concat\ldots\Concat\String_n}{\String}{\String_i\in\LanguageOf{\RegexAlt}} (\PutLeft\Apply\String_1)\Concat\ldots\Concat(\PutLeft\Apply\String_n)
}

\inferrule[Concat Lens]
{
\Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1 \HasSemantics \PutRight_1, \PutLeft_1\\
\Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2 \HasSemantics \PutRight_2, \PutLeft_2\\\\
\UnambigConcat{\LanguageOf{\Regex_1}}{\LanguageOf{\Regex_2}}\\
\UnambigConcat{\LanguageOf{\RegexAlt_1}}{\LanguageOf{\RegexAlt_2}}
}
{
\ConcatLens{\Lens_1}{\Lens_2} \OfType \Regex_1\Regex_2 \Leftrightarrow \RegexAlt_1\RegexAlt_2 \HasSemantics\\\\
\lambda \String.\LetWhereIn{\String_1\Concat\String_2}{\String}{\String_i\in\LanguageOf{\Regex_i}} (\PutRight_1\Apply\String_1)\Concat(\PutRight_2\Apply\String_2),\\\\
\lambda \String.\LetWhereIn{\String_1\Concat\String_2}{\String}{\String_i\in\LanguageOf{\RegexAlt_i}} (\PutLeft_1\Apply\String_1)\Concat(\PutLeft_2\Apply\String_2)
}

\inferrule[Swap Lens]
{
\Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1 \HasSemantics \PutRight_1,\PutLeft_2\\
\Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2 \HasSemantics \PutRight_1,\PutLeft_2\\\\
\UnambigConcat{\LanguageOf{\Regex_1}}{\LanguageOf{\Regex_2}}\\
\UnambigConcat{\LanguageOf{\RegexAlt_2}}{\LanguageOf{\RegexAlt_1}}
}
{
\SwapLens{\Lens_1}{\Lens_2} \OfType \Regex_1\Regex_2 \Leftrightarrow \RegexAlt_2\RegexAlt_1 \HasSemantics\\\\
\lambda \String.\LetWhereIn{\String_1\Concat\String_2}{\String}{\String_i\in\LanguageOf{\Regex_i}} (\PutRight_2\Apply\String_2)\Concat(\PutRight_1\Apply\String_1),\\\\
\lambda \String.\LetWhereIn{\String_1\Concat\String_2}{\String}{\String_i\in\LanguageOf{\RegexAlt_i}} (\PutLeft_2\Apply\String_2)\Concat(\PutLeft_1\Apply\String_1)
}

\inferrule[Or Lens]
{
\Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1 \HasSemantics \PutRight_1,\PutLeft_1\\
\Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2 \HasSemantics \PutRight_2,\PutLeft_2\\\\
\UnambigOr{\LanguageOf{\Regex_1}}{\LanguageOf{\Regex_2}}\\ \UnambigOr{\LanguageOf{\RegexAlt_1}}{\LanguageOf{\RegexAlt_2}}
}
{
\OrLens{\Lens_1}{\Lens_2} \OfType \Regex_1 | \RegexAlt_1 \Leftrightarrow \Regex_2 | \RegexAlt_2 \HasSemantics\\\\
\lambda \String.\{\PutRight_1(\String) \text{ if $\String\in\LanguageOf{\Regex_1}$ }, \PutRight_2(\String) \text{ if $\String\in\LanguageOf{\Regex_2}$ }\},\\\\
\lambda \String.\{\PutLeft_1(\String) \text{ if $\String\in\LanguageOf{\RegexAlt_1}$ }, \PutLeft_2(\String) \text{ if $\String\in\LanguageOf{\RegexAlt_2}$ }\}
}

\inferrule[Compose Lens]
{
\Lens_1 \OfType \Regex_1 \Leftrightarrow \Regex_2 \HasSemantics \PutRight_1,\PutLeft_1\\
\Lens_2 \OfType \Regex_2 \Leftrightarrow \Regex_3 \HasSemantics \PutRight_2,\PutLeft_2\\
}
{
\ComposeLens{\Lens_2}{\Lens_1} \OfType \Regex_1 \Leftrightarrow \Regex_3 \HasSemantics
\PutRight_2\Compose\PutRight_1,\PutLeft_2\Compose\PutLeft_1
}

\inferrule[Retype Lens]
{
\Lens \OfType \Regex_1 \Leftrightarrow \Regex_2 \HasSemantics \PutRight,\PutLeft\\
\LanguageOf{\Regex_1} = \LanguageOf{\Regex_1'}\\
\LanguageOf{\Regex_2} = \LanguageOf{\Regex_2'}
}
{
\Lens \OfType \Regex_1' \Leftrightarrow \Regex_2' \HasSemantics \PutRight,\PutLeft
}
\end{mathpar}

\caption{Lens Semantics and Typing}
\label{fig:lens-alternate-alternate-semantics}
\end{figure}
