\begin{figure}
%A typing derivation is of the form $\FullContext \HasSemantics \Lens : \Regex \Leftrightarrow \RegexAlt \HasSemantics \PutRight,\PutLeft$.
%This means that under the regular expression context \RegexContext, and under the lens context \LensContext, the lens $\Lens$ has typing $\Regex \Leftrightarrow \RegexAlt$.
%It defines two functions, $\PutRight : \LanguageOf{\Regex}\rightarrow\LanguageOf{\RegexAlt}$, and $\PutLeft : \LanguageOf{\RegexAlt}\rightarrow\LanguageOf{\Regex}$.
%These functions are bijective functions, and are
%inverses of each other.
\centering

\tcbset{colframe=blue!50!black,colback=white,colupper=red!50!black,
fonttitle=\bfseries,nobeforeafter,center title}

\begin{tcolorbox}[title=Const Lens,left skip=5mm,right skip=5mm,left=0mm,right=0mm,middle=0mm,boxsep=.5mm,top=0mm,bottom=0mm,after skip=3mm,before skip=0mm]
\begin{tcolorbox}[left skip=0mm,right skip=0mm,left=0mm,right=0mm,top=0mm,bottom=2mm,middle=0mm,boxsep=.5mm,after skip=0mm,before skip=0mm]
\begin{mathpar}
\inferrule*
{
\String_1 \in \Star{\Sigma}\\
\String_2 \in \Star{\Sigma}\\
}
{
\ConstLens{\String_1}{\String_2} \OfType \String_1 \Leftrightarrow \String_2 \HasSemantics \lambda \String. \String_2 , \lambda \String. \String_1
}
\end{mathpar}
\end{tcolorbox}
\begin{tcolorbox}[left skip=0mm,right skip=0mm,left=0mm,right=0mm,top=0mm,bottom=1mm,middle=0mm,boxsep=0mm,after skip=0mm,before skip=.5mm]
\[
\begin{array}{ll@{\hspace*{\tabcolsep}=\hspace*{\tabcolsep}}l}
\PutRight & \String & \String_2 \\
\PutLeft & \String & \String_1
\end{array}
\]
\end{tcolorbox}
\end{tcolorbox}

\begin{tcolorbox}[title=Or Lens,left skip=5mm,right skip=5mm,left=0mm,right=0mm,middle=0mm,boxsep=.5mm,top=0mm,bottom=0mm,after skip=3mm,before skip=0mm]
\begin{tcolorbox}[left skip=0mm,right skip=0mm,left=0mm,right=0mm,top=0mm,bottom=2mm,middle=0mm,boxsep=.5mm,after skip=0mm,before skip=0mm]
\begin{mathpar}
\inferrule*
{
\Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1\\
\Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2\\\\
\UnambigOrOf{\LanguageOf{\Regex_1}}{\LanguageOf{\Regex_2}}\\ \UnambigOrOf{\LanguageOf{\RegexAlt_1}}{\LanguageOf{\RegexAlt_2}}
}
{
\OrLens{\Lens_1}{\Lens_2} \OfType \RegexOr{\Regex_1}{\RegexAlt_1} \Leftrightarrow \RegexOr{\Regex_2}{\RegexAlt_2}
}
\end{mathpar}
\end{tcolorbox}
\begin{tcolorbox}[left skip=0mm,right skip=0mm,left=0mm,right=0mm,top=0mm,bottom=1mm,middle=0mm,boxsep=0mm,after skip=0mm,before skip=.5mm]
\[
\begin{array}{ll@{\hspace*{\tabcolsep}=\hspace*{\tabcolsep}}l}
\PutRight & \String &
\begin{cases}
\PutRightOf{\Lens_1}(\String) & \mbox{if } \String\in\LanguageOf{\Regex_1}\\
\PutRightOf{\Lens_2}(\String) & \mbox{if } \String\in\LanguageOf{\Regex_2}
\end{cases}\\

\PutLeft & \String &
\begin{cases}
\PutLeftOf{\Lens_1}(\String) & \mbox{if } \String\in\LanguageOf{\RegexAlt_1}\\
\PutLeftOf{\Lens_2}(\String) & \mbox{if } \String\in\LanguageOf{\RegexAlt_2}
\end{cases}
\end{array}
\]
\end{tcolorbox}
\end{tcolorbox}

\begin{mathpar}
\inferrule[Constant Lens]
{
\String_1 \in \Star{\Sigma}\\
\String_2 \in \Star{\Sigma}\\
}
{
\ConstLens{\String_1}{\String_2} \OfType \String_1 \Leftrightarrow \String_2 \HasSemantics \lambda \String. \String_2 , \lambda \String. \String_1
}

\inferrule[Identity Lens]
{
}
{
\IdentityLens \OfType \Regex \Leftrightarrow \Regex \HasSemantics \lambda \String.\String, \lambda \String . \String
}

\inferrule[Iterate Lens]
{
\Lens \OfType \Regex \Leftrightarrow \RegexAlt \HasSemantics \PutRight , \PutLeft \\
\UnambigItOf{\LanguageOf{\Regex}}\\
\UnambigItOf{\LanguageOf{\RegexAlt}}\\
}
{
\IterateLens{\Lens} \OfType \Star{\Regex} \Leftrightarrow \Star{\RegexAlt} \HasSemantics\\\\
\lambda \String.\LetWhereIn{\String_1\Concat\ldots\Concat\String_n}{\String}{\String_i\in\LanguageOf{\Regex}} (\PutRight\Apply\String_1)\Concat\ldots\Concat(\PutRight\Apply\String_n),\\\\
\lambda \String.\LetWhereIn{\String_1\Concat\ldots\Concat\String_n}{\String}{\String_i\in\LanguageOf{\RegexAlt}} (\PutLeft\Apply\String_1)\Concat\ldots\Concat(\PutLeft\Apply\String_n)
}

\inferrule[Concat Lens]
{
\Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1 \HasSemantics \PutRight_1, \PutLeft_1\\
\Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2 \HasSemantics \PutRight_2, \PutLeft_2\\\\
\UnambigConcatOf{\LanguageOf{\Regex_1}}{\LanguageOf{\Regex_2}}\\
\UnambigConcatOf{\LanguageOf{\RegexAlt_1}}{\LanguageOf{\RegexAlt_2}}
}
{
\ConcatLens{\Lens_1}{\Lens_2} \OfType \Regex_1\Regex_2 \Leftrightarrow \RegexAlt_1\RegexAlt_2 \HasSemantics\\\\
\lambda \String.\LetWhereIn{\String_1\Concat\String_2}{\String}{\String_i\in\LanguageOf{\Regex_i}} (\PutRight_1\Apply\String_1)\Concat(\PutRight_2\Apply\String_2),\\\\
\lambda \String.\LetWhereIn{\String_1\Concat\String_2}{\String}{\String_i\in\LanguageOf{\RegexAlt_i}} (\PutLeft_1\Apply\String_1)\Concat(\PutLeft_2\Apply\String_2)
}

\inferrule[Swap Lens]
{
\Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1 \HasSemantics \PutRight_1,\PutLeft_2\\
\Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2 \HasSemantics \PutRight_1,\PutLeft_2\\\\
\UnambigConcatOf{\LanguageOf{\Regex_1}}{\LanguageOf{\Regex_2}}\\
\UnambigConcatOf{\LanguageOf{\RegexAlt_2}}{\LanguageOf{\RegexAlt_1}}
}
{
\SwapLens{\Lens_1}{\Lens_2} \OfType \Regex_1\Regex_2 \Leftrightarrow \RegexAlt_2\RegexAlt_1 \HasSemantics\\\\
\lambda \String.\LetWhereIn{\String_1\Concat\String_2}{\String}{\String_i\in\LanguageOf{\Regex_i}} (\PutRight_2\Apply\String_2)\Concat(\PutRight_1\Apply\String_1),\\\\
\lambda \String.\LetWhereIn{\String_1\Concat\String_2}{\String}{\String_i\in\LanguageOf{\RegexAlt_i}} (\PutLeft_2\Apply\String_2)\Concat(\PutLeft_1\Apply\String_1)
}

\inferrule[Or Lens]
{
\Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1 \HasSemantics \PutRight_1,\PutLeft_1\\
\Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2 \HasSemantics \PutRight_2,\PutLeft_2\\\\
\UnambigOrOf{\LanguageOf{\Regex_1}}{\LanguageOf{\Regex_2}}\\ \UnambigOrOf{\LanguageOf{\RegexAlt_1}}{\LanguageOf{\RegexAlt_2}}
}
{
\OrLens{\Lens_1}{\Lens_2} \OfType \Regex_1 | \RegexAlt_1 \Leftrightarrow \Regex_2 | \RegexAlt_2 \HasSemantics\\\\
\lambda \String.\{\PutRight_1(\String) \text{ if $\String\in\LanguageOf{\Regex_1}$ }, \PutRight_2(\String) \text{ if $\String\in\LanguageOf{\Regex_2}$ }\},\\\\
\lambda \String.\{\PutLeft_1(\String) \text{ if $\String\in\LanguageOf{\RegexAlt_1}$ }, \PutLeft_2(\String) \text{ if $\String\in\LanguageOf{\RegexAlt_2}$ }\}
}

\inferrule[Compose Lens]
{
\Lens_1 \OfType \Regex_1 \Leftrightarrow \Regex_2 \HasSemantics \PutRight_1,\PutLeft_1\\
\Lens_2 \OfType \Regex_2 \Leftrightarrow \Regex_3 \HasSemantics \PutRight_2,\PutLeft_2\\
}
{
\ComposeLens{\Lens_2}{\Lens_1} \OfType \Regex_1 \Leftrightarrow \Regex_3 \HasSemantics
\PutRight_2\Compose\PutRight_1,\PutLeft_2\Compose\PutLeft_1
}

\inferrule[Retype Lens]
{
\Lens \OfType \Regex_1 \Leftrightarrow \Regex_2 \HasSemantics \PutRight,\PutLeft\\
\LanguageOf{\Regex_1} = \LanguageOf{\Regex_1'}\\
\LanguageOf{\Regex_2} = \LanguageOf{\Regex_2'}
}
{
\Lens \OfType \Regex_1' \Leftrightarrow \Regex_2' \HasSemantics \PutRight,\PutLeft
}
\end{mathpar}

\caption{Lens Semantics and Typing}
\label{fig:lens-alternate-alternate-semantics}
\end{figure}
