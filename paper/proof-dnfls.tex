\subsection{DNF Lens Soundness}

\begin{lemma}[Creation of Lens from Identity Perm Conjunct Lens]
\label{lem:id-clause}
If $\Delta \vdash ([(\String_0,\StringAlt_0);\AtomLens_1 ; \ldots ; \AtomLens_n;(\String_n,\StringAlt_n)],id) \OfType [\String_0 ; \Atom_1 ; \ldots ; \Atom_n; \String_n] \Leftrightarrow [\StringAlt_0 ; \AtomAlt_1 ; \ldots ; \AtomAlt_n ; \StringAlt_n]$,
and for each $\AtomLens_i \OfType \Atom_i \Leftrightarrow \AtomAlt_i$,
there exists a $\Delta \vdash \Lens_i \OfType \Regex_i \Leftrightarrow \RegexAlt_i$ such that
$\LanguageOf{\Atom_i}=\LanguageOf{\Regex_i}$, and $\Lens_i.putr = \ConjunctLens_i.putr$,
then there exists a $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that $\Lens.putr = ([\AtomLens_1 ; \ldots ; \AtomLens_n],id).putr$, $\LanguageOf{[\String_0 ; \Atom_1 ; \ldots ; \Conjunct_n ; \String_n]}$ = $\LanguageOf{\Regex}$,
and $\LanguageOf{[\StringAlt_0 ; \AtomAlt_1 ; \ldots ; \AtomAlt_n ; \StringAlt_n]}$ = $\LanguageOf{\RegexAlt}$.
\begin{proof}
Base case: $\FullContext \vdash [(\String_0,\StringAlt_0)] \OfType [\String_0] \Leftrightarrow [\StringAlt_0]$.
Then consider $\Lens$ = $\ConstLens{\String_0}{\StringAlt_0}$, $\Regex = \String$, $\RegexAlt = \StringAlt$.
$\LanguageOf{[\String_0]} = \String_0 = \LanguageOf{\String_0}$ by definition.\\
$\LanguageOf{[\StringAlt_0]} = \StringAlt_0 = \LanguageOf{\String_0}$ by definition.\\
$\PutRightOf{[(\String_0,\StringAlt_0)]}(\String_0)=\StringAlt_0=\PutRightOf{\ConstLens{\String}{\StringAlt}}(\String_0)$.
\\\\\\

By induction assumption, I know
there exists a $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that
$\Lens.putr = ([(\String_0,\StringAlt_0);\AtomLens_1 ; \ldots ; \AtomLens_n;(\String_n,\StringAlt_n)],id).putr$,
$\LanguageOf{[\String_0 ; \Atom_1 ; \ldots ; \Atom_n ; \String_n]}$ =
$\LanguageOf{\Regex}$,
and $\LanguageOf{[\StringAlt_0 ; \AtomAlt_1 ; \ldots ; \Atom_n ; \StringAlt_n]}$ = $\LanguageOf{\RegexAlt}$.\\
By assumption, I know that there exists a $\Delta \vdash \Lens_{n+1} \OfType \Regex_{n+1} \Leftrightarrow \RegexAlt_{n+1}$ such that $\LanguageOf{\Regex_{n+1}}=\LanguageOf{\Atom_{n+1}}$
and $\LanguageOf{\RegexAlt_{n+1}}=\LanguageOf{\AtomAlt_{n+1}}$, where $\Lens_{n+1}.putr=\AtomLens_{n+1}$.\\
Consider the lens $\FullContext \vdash \ConcatLens{\Lens}{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}} \OfType \RegexConcat{\Regex}{\RegexConcat{\Regex_{n+1}}{\String_{n+1}}} \Leftrightarrow \RegexConcat{\RegexAlt}{\RegexConcat{\RegexAlt_{n+1}}{\StringAlt_{n+1}}}$.\\
$\LanguageOf{\RegexConcat{\Regex}{\RegexConcat{\Regex_{n+1}}{\String_{n+1}}}}
= \LanguageOf{\Regex}\Concat\LanguageOf{\Regex_{n+1}}\Concat\{\String_{n+1}\}$
by definition\\
$\LanguageOf{\RegexConcat{\Regex}{\RegexConcat{\Regex_{n+1}}{\String_{n+1}}}}
= \LanguageOf{[\String_0;\Atom_1; \ldots ; \Atom_n;\String_n]}
\Concat\LanguageOf{\Regex_{n+1}}\Concat\{\String_{n+1}\}$ by induction assumption.\\
$\LanguageOf{\RegexConcat{\Regex}{\RegexConcat{\Regex_{n+1}}{\String_{n+1}}}}
= \{\String_0\}\Concat\LanguageOf{\Atom_1}\Concat\ldots\Concat\LanguageOf{\Atom_n}\Concat\{\String_n\}
\Concat\LanguageOf{\Regex_{n+1}}\Concat\{\String_{n+1}\}$ by definition.\\
$\LanguageOf{\RegexConcat{\Regex}{\RegexConcat{\Regex_{n+1}}{\String_{n+1}}}}
= \{\String_0\}\Concat\LanguageOf{\Atom_1}\Concat\ldots\Concat\LanguageOf{\Atom_n}\Concat\{\String_n\}
\Concat\LanguageOf{\Atom_{n+1}}\Concat\{\String_{n+1}\}$ by problem assumption.\\
$\LanguageOf{\RegexConcat{\Regex}{\RegexConcat{\Regex_{n+1}}{\String_{n+1}}}}
= \LanguageOf{[\String_0;\Atom_0;\ldots;\Atom_{n+1};\String_{n+1}]}$ by definition.\\

Similarly for
$\LanguageOf{\RegexConcat{\RegexAlt}{\RegexConcat{\RegexAlt_{n+1}}{\StringAlt_{n+1}}}}
= \LanguageOf{[\StringAlt_0;\AtomAlt_0;\ldots;\AtomAlt_{n+1};\StringAlt_{n+1}]}$
 TODO, split into lemma?.\\
\\
$\PutRightOf{\ConcatLens{\Lens}{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}}}
(\String_0\String_1'\ldots\String_{n+1}'\String_{n+1}) =$\\
$\PutRightOf{\Lens}(\String_0\String_1'\ldots\String_n'\String_n)\PutRightOf{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}}(\String_{n+1}'\String_{n+1})$ by definition\\
\\
$\PutRightOf{\ConcatLens{\Lens}{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}}}
(\String_0\String_1'\ldots\String_{n+1}'\String_{n+1}) =$\\
$\PutRightOf{\Lens}(\String_0\String_1'\ldots\String_n'\String_n)\PutRightOf{\Lens_{n+1}}(\String_{n+1}')\PutRightOf{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}(\String_{n+1})$ by definition\\
\\
$\PutRightOf{\ConcatLens{\Lens}{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}}}
(\String_0\String_1'\ldots\String_{n+1}'\String_{n+1}) =$\\
$\PutRightOf{[(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)]}(\String_0\String_1'\ldots\String_n'\String_n)\PutRightOf{\Lens_{n+1}}(\String_{n+1}')\PutRightOf{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}(\String_{n+1})$ by induction assumption\\
\\
$\PutRightOf{\ConcatLens{\Lens}{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}}}
(\String_0\String_1'\ldots\String_{n+1}'\String_{n+1}) =$\\
$\PutRightOf{[(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)]}(\String_0\String_1'\ldots\String_n'\String_n)\PutRightOf{\AtomLens_{n+1}}(\String_{n+1}')\PutRightOf{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}(\String_{n+1})$ by problem assumption\\
\\
$\PutRightOf{\ConcatLens{\Lens}{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}}}
(\String_0\String_1'\ldots\String_{n+1}'\String_{n+1}) =$\\
$\StringAlt_0\Concat\PutRightOf{\AtomLens_1}(\String_1')\Concat\ldots\Concat\PutRightOf{\AtomLens_n}(\String_n')\Concat\StringAlt_n\Concat\PutRightOf{\AtomLens_{n+1}}(\String_{n+1}')\Concat\StringAlt_{n+1}$ by definition\\
\\
$\PutRightOf{\ConcatLens{\Lens}{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}}}
(\String_0\String_1'\ldots\String_{n+1}'\String_{n+1}) =$\\
$\PutRightOf{[(\String_0,\StringAlt_0);\AtomLens_0;\ldots;\AtomLens_{n+1};(\String_{n+1},\StringAlt_{n+1})]}(\String_0\String_0'\ldots\String_{n+1}'\String_{n+1})$ by definition
\end{proof}
\end{lemma}

\begin{definition}[Adjacent Swapping Permutation]
Let $\sigma_{i} \in S_n$ be the permutation where
$\sigma_{i}(i) = i+1$, $\sigma_{i}(i+1) = i$, $\sigma_{i,j}(k\neq i,i+1) = k$
\end{definition}

\begin{definition}[Insertion Permutation]
Let $\sigma_{i,j} \in S_n$ where $i\geq j$ be the permutation where
\[
  \sigma_{i,j}(k)=
    \begin{cases}
      j& \text{if } k=i\\
      k+1& \text{if } j\leq k<i\\
      k& \text{otherwise}
    \end{cases}
\]
\end{definition}

\begin{lemma}[Generation of \PermutationSetOf{n}]
If $\sigma\in\PermutationSetOf{n}$, then there exists a decomposition
$\sigma_{i_1,j_1}\Compose\ldots\Compose\sigma_{i_m,j_m}$ such that
$\sigma_{i_1,j_1}\Compose\ldots\Compose\sigma_{i_m,j_m}=\sigma$,
and for all $k\in\RangeIncInc{0}{m}$,
if $\sigma_{i_1,j_1}\Compose\ldots\Compose\sigma_{i_k,j_k}(i)<
\sigma_{i_1,j_1}\Compose\ldots\Compose\sigma_{i_k,j_k}(j)$,
then $i<j$ or $\sigma(i)<\sigma(j)$.
\begin{proof}
Consider the decomposition $\sigma_{i_n,n}\Compose\ldots\Compose\sigma_{i_1,1}$ where $i_k$ is defined as
$(\InverseOf{\sigma}\Compose\sigma_{i_{k-1},k-1}\Compose\ldots\sigma_{i_1,1})(k)$.
Define $\sigma_k$ as $\sigma_{i_k,k}\Compose\ldots\Compose\sigma_{i_1,1}$, and as \Identity{} for $k=0$.
So $\sigma_k$ = $\sigma_{i_k,k}\Compose\sigma_{k-1}$.
We will prove for all $k\in\RangeIncInc{0}{n}$, by induction, that
for all $i$ such that $\sigma(i)\in\RangeIncInc{1,k}$, $\sigma_k(i)=\sigma(i)$,
and if
$\sigma_k(i)<\sigma_k(j)$
and $\sigma_k(i)\in\RangeIncInc{1}{k}$, then $\sigma(i)<\sigma(j)$,
else if $\sigma_k(i),\sigma_k(j)$, then $i<j$.

Base Case: $k=0$, identity permutation

If $\Identity i<\Identity j$ then $i < j$.  For all $i\in\RangeIncInc{1,0}$, anything is true vacuously.

Induction Step:
$\sigma_k(i)=\sigma_{i_k,k}\Compose\sigma_{k-1}(i)$.
If $\sigma(i)\in\RangeIncInc{1}{k-1}$, then $\sigma_k(i)=\sigma_{i_k,k}(\sigma(i))$, by induction assumption.
As $\sigma(i)<k$, $\sigma_{i_k,k}(\sigma(i))=\sigma(i)$.
If $\sigma(i)=k$, then $\sigma_k(i)=\sigma_{i_k,k}(\sigma_k(i))$.
So by definition of composition $\sigma_k(i)=\sigma_{i_k,k}(\sigma_{k-1}(i))$.
$i_k=\sigma_{k-1}(\InverseOf{\sigma}(k))$, so $i_k=\sigma_{k-1}(i)$.
So, by the definition of $\sigma_{i_k,k}$, $\sigma_{i_k,k}(\sigma_{k-1}(i))=k$.

Let $\sigma_{i_k,k}\Compose\ldots\Compose\sigma_{i_1,1}(i) < \sigma_{i_k,k}\Compose\ldots\Compose\sigma_{i_1,1}(j)$.
Let $i'=\sigma_k(i)$
and $j'=\sigma_k(j)$
If $j'\leq k$, then $j'=\sigma(j)$ and $i'=\sigma(i)$, as $i'<j'\leq k$.
If $i'\leq i_k$, but $j'>i_k$, then $\sigma(j)>\sigma(i)$, as $\sigma(i)\in\RangeIncInc{1}{k}$,
but $\sigma(j)$ isn't.
If $i' > i_k$, then if 
\end{proof}
\end{lemma}

\begin{definition}[Conjunct Permuting Bijection]
Let $[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]$ be a clause, let $\sigma$ be a permutation, and let $\RegexContext$ be a regular expression context.
Define
$f_{\sigma,\RegexContext,[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]}$ as:
$f_{\sigma,\RegexContext,[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]}\OfType \LanguageOf{[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]}\rightarrow\LanguageOf{[\String_0;\Atom_{\sigma(1)};\ldots;\Atom_{\sigma(n)};\String_n]}$, where $\String_0\String_1'\ldots\String_n'\String_n\mapsto\String_0\String_{\sigma(1)}'\ldots\String_{\sigma(n)}'\String_n$.
\end{definition}

\begin{definition}[Left Quotient]
$\LeftQuotientOf{\Language_1}{\Language_2}\triangleq \{v \in \Star{\Sigma}\SuchThat \exists u\in L_1. u\Concat v\in L_2\}$
\end{definition}

\begin{definition}[Right Quotient]
$\RightQuotientOf{\Language_1}{\Language_2}\triangleq \{u \in \Star{\Sigma}\SuchThat \exists v\in \Language_1. u\Concat v\in \Language_2\}$
\end{definition}

\begin{definition}[Suffixes]
$\SuffixOf{\Language}\triangleq \LeftQuotientOf{\Language}{\Language}$
\end{definition}

\begin{definition}[Prefixes]
$\PrefixOf{\Language}\triangleq \RightQuotientOf{\Language}{\Language}$
\end{definition}

\begin{lemma}[Atom Separators]
Let $\Atom_1$ and $\Atom_2$ be atoms, and
$\Language=\SuffixOf{\LanguageOf{\Atom_1}}\Intersect\PrefixOf{\LanguageOf{\Atom_2}}$.
If $\SuffixOf{\Language}\Union\PrefixOf{\Language}\neq\Star{\Sigma}$, then there exists a string \String{} such that
$\UnambigConcatOf{[\EmptyString;\Atom_1;\String]}{[\EmptyString;\Atom_2;\EmptyString]}$
\begin{proof}
Let $\Atom_1$ and $\Atom_2$ be atoms, and
$\Language=\SuffixOf{\LanguageOf{\Atom_1}}\Intersect\PrefixOf{\LanguageOf{\Atom_2}}$,
such that $\SuffixOf{\Language}\Union\PrefixOf{\Language}\neq\Star{\Sigma}$.
If $\SuffixOf{\Language}\Union\PrefixOf{\Language}\neq\Star{\Sigma}$, then $\ComplementOf{\SuffixOf{\Language}\Union\PrefixOf{\Language}}\neq\emptyset$.
Let $\String\in\ComplementOf{\SuffixOf{\Language}\Union\PrefixOf{\Language}}$.
Suppose, for contraction, that $[\EmptyString;\Atom_1;\String]$ is unambiguously concatenable
with ${[\EmptyString;\Atom_2;\EmptyString]}$.
\end{proof}
\end{lemma}

\begin{lemma}[Expressibility of Adjacent Swapping Permutation Lens]
Let $\sigma_i$ be an adjacent element swapping permutation, $[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]$ be a clause, $\RegexContext$ be a regular expression context, and $\LensContext$ be a lens context.
There exists regular expressions $\Regex$ and $\RegexAlt$, and a lens $\Lens$,
such that $\LanguageOf{\Delta}{\Regex}=\LanguageOf{\Delta}{[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]}$,
$\LanguageOf{\Delta}{\RegexAlt}=\LanguageOf{\Delta}{[\String_0;\Atom_{\sigma(1)};\ldots;\Atom_{\sigma(n)};\String_n]}$, and
$\FullContext \vdash \Lens \OfType \Regex \Leftrightarrow \RegexAlt \HasSemantics f_{\sigma,\RegexContext,[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]}, f_{\sigma,\RegexContext,[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]}^{-1}$
\begin{proof}
By the soundness of regular expressions, there exists
a regular expressions $\Regex_1, \Regex_2, \Regex_3, \Regex_4$ such that
$\LanguageOf{\Delta}{\Regex_1}=\LanguageOf{\Delta}{[\String_1;\Atom_1;\ldots;\Atom_{i-1};\String_{i-1}]}$,
$\LanguageOf{\Delta}{\Regex_2}=\LanguageOf{\Delta}{\Atom_i}$,
$\LanguageOf{\Delta}{\Regex_3}=\LanguageOf{\Delta}{\Atom_{i+1}}$, and
$\LanguageOf{\Delta}{\Regex_4}=\LanguageOf{\Delta}{[\String_i;\Atom_{i+1};\ldots;\Atom_{n};\String_n]}$.
Consider the following deduction
\begin{mathpar}
\inferrule*
{
\inferrule*
{
\inferrule*
{
}
{
\FullContext \vdash \IdentityLens \OfType \Regex_1 \Leftrightarrow \Regex_1 \HasSemantics id, id
}
\inferrule*
{
\inferrule*
{
}
{
\FullContext \vdash \Lens \OfType \Regex_2 \Leftrightarrow \Regex_2 \HasSemantics id, id
}
\inferrule*
{
\inferrule*
{
}
{
\FullContext \vdash \Lens \OfType \String_i \Leftrightarrow \String_i \HasSemantics id, id
}
\inferrule*
{
}
{
\FullContext \vdash \Lens \OfType \Regex_3 \Leftrightarrow \Regex_3 \HasSemantics id, id
}
}
{
\FullContext \vdash \Lens \OfType \String_i\Concat\Regex_3 \Leftrightarrow \Regex_3\Concat\String_i \HasSemantics swap(id,id), swap(id,id)
}
}
{
\FullContext \vdash \Lens \OfType \Regex_2\Concat\String_i\Concat\Regex_3 \Leftrightarrow \Regex_3\Concat\String_i\Concat\Regex_2 \HasSemantics id, id^{-1}
}
}
{
\FullContext \vdash \Lens \OfType \Regex_1\Concat\Regex_2\Concat\String_i\Concat\Regex_3 \Leftrightarrow \Regex_1\Concat\Regex_3\Concat\String_i\Concat\Regex_2 \HasSemantics id, id^{-1}
}
\inferrule*
{
}
{
\FullContext \vdash \Lens \OfType \Regex_4 \Leftrightarrow \Regex_4 \HasSemantics id, id
}
}
{
\FullContext \vdash \Lens \OfType \Regex_1\Concat\Regex_2\Concat\String_i\Concat\Regex_3\Concat\Regex_4 \Leftrightarrow \Regex_1\Concat\Regex_3\Concat\String_i\Concat\Regex_2\Concat\Regex_4 \HasSemantics f_{\sigma,\RegexContext,[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]}, f_{\sigma,\RegexContext,[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]}^{-1}
}
\end{mathpar}


Consider the regular expressions $repregex([\String_1;\Atom_1; \ldots;\String_i])$ $(repregex(\Atom_i) (\String_{i+1} repregex(\Atom_{i+1})))$ $repregex([\String_{i+2} ; \ldots ; \Atom_{n} ; \String_{n+1}])$ and 
$repregex([\String_{1,2};\Atom_{1,2}; \ldots;\String_{i,1}])$ $((\Atom_{i+1,1} \String_{i+1,1})\Atom_{i,1})$ $repregex([\String_{i+2,1} ; \ldots ; \Atom_{n} ; \String_{n+1}])$
Consider the lens between them\\ $\ConcatLens{\ConcatLens{\IdentityLens}{\SwapLens{\IdentityLens}{\SwapLens{\IdentityLens}{\IdentityLens}}}}{\IdentityLens}$
By inspection, this lens is equivalent to the adjacent swapping permutation.
\end{proof}
\end{lemma}

\begin{lemma}[Expressibility of Permutation]
\label{lem:perm-exp}
The language of lenses can express $([(\String_1,\String_1) ; \IdentityLens ; \ldots ; \IdentityLens ; (\String_n,\String_n)], \sigma)$
for any permutation $\sigma$.
\begin{proof}
Let $\sigma$ be a permutation.
Consider the clause lens $([(\String_1,\String_1) ; \IdentityLens ; \ldots ; \IdentityLens ; (\String_n,\String_n)], \sigma_{i})$.
From algebra, we know that the group of permutations is generated by all
adjacent swaps $\sigma_i = (i,i+1)$.
So there exists an adjacency swap decomposition of $\sigma = \sigma_{i_1}\ldots\sigma_{i_m}$.
Consider the dnf lens $([(\String_1,\String_1) ; \IdentityLens ; \ldots ; \IdentityLens ; (\String_n,\String_n)], \sigma_{i_j})$ for each $\sigma_{i_j}$.
By the above lemma, there exists a $\Lens_j$ for each of these adjacency swaps.
Consider the lens $\Lens = \ComposeLens{\Lens_{i_1}}{\ComposeLens{\Lens_{i_2}}{\ldots \ComposeLens{}{\Lens_{i_m}}}}$
By the semantics, they are the same.

\end{proof}
\end{lemma}

\begin{lemma}[Creation of Lens from Identity Perm DNF Lens]
\label{lem:id-dnf}
If $\Delta \vdash ([\ConjunctLens_1 ; \ldots ; \ConjunctLens_n],id) \OfType [\Conjunct_1 ; \ldots ; \Conjunct_n] \Leftrightarrow [\ConjunctAlt_1 ; \ldots ; \ConjunctAlt_n]$,
and for each $\ConjunctLens_i \OfType \Conjunct_i \Leftrightarrow \ConjunctAlt_i$,
there exists a $\Delta \vdash \Lens_i \OfType \Regex_i \Leftrightarrow \RegexAlt_i$ such that
$\LanguageOf{\Delta}{\Conjunct_i}=\LanguageOf{\Delta}{\Regex_i}$, and $\Lens_i.putr = \ConjunctLens_i.putr$,
then there exists a $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that $\Lens.putr = ([\ConjunctLens_1 ; \ldots ; \ConjunctLens_n],id).putr$, $\LanguageOf{\Delta}{[\Conjunct_1 ; \ldots ; \Conjunct_n]}$ = $\LanguageOf{\Delta}{\Regex}$,
and $\LanguageOf{\Delta}{[\ConjunctAlt_1 ; \ldots ; \ConjunctAlt_n]}$ = $\LanguageOf{\Delta}{\RegexAlt}$.
\begin{proof}
Base case: $\FullContext \vdash [\ConjunctLens_1] \OfType [\Conjunct_1] \Leftrightarrow [\ConjunctAlt_1]$.  Then consider $\Lens$ = $\Lens_1$, $\Regex = \Regex_1$, $\RegexAlt = \RegexAlt_1$.
$\LanguageOf{\Delta}{[\Conjunct_1]} = \LanguageOf{\Delta}{\Conjunct_1}$ by definition.\\
$\LanguageOf{\Delta}{[\Conjunct_1]} = \LanguageOf{\Delta}{\Regex_1}$ by problem assumption.

Symmetrically for $\LanguageOf{\Delta}{[\ConjunctAlt_1]}$.\\
$\PutRightOf{[\ConjunctLens]} = \PutRightOf{\ConjunctLens}$ by definition\\
$\PutRightOf{[\ConjunctLens]} = \PutRightOf{\Lens_1}$ by problem assumption.
\\\\\\



By induction assumption, I know
there exists a $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that
$\Lens.putr = ([\ConjunctLens_1 ; \ldots ; \ConjunctLens_n],id).putr$,
$\LanguageOf{\Delta}{[\Conjunct_1 ; \ldots ; \Conjunct_n]}$ =
$\LanguageOf{\Delta}{\Regex}$,
and $\LanguageOf{\Delta}{[\ConjunctAlt_1 ; \ldots ; \ConjunctAlt_n}$ = $\LanguageOf{\Delta}{\RegexAlt}$.\\
By assumption, I know that there exists a $\Delta \vdash \Lens_{n+1} \OfType \Regex_{n+1} \Leftrightarrow \RegexAlt_{n+1}$ such that $\LanguageOf{\Delta}{\Regex_{n+1}}=\LanguageOf{\Delta}{\Conjunct_{n+1}}$
and $\LanguageOf{\Delta}{\RegexAlt_{n+1}}=\LanguageOf{\Delta}{\ConjunctAlt_{n+1}}$, where $\Lens_{n+1}.putr=\ConjunctLens_{n+1}$.\\
Consider the lens $\FullContext \vdash \OrLens{\Lens}{\Lens_{n+1}} \OfType \RegexOr{\Regex}{\Regex_{n+1}} \Leftrightarrow \RegexOr{\RegexAlt}{\RegexAlt_{n+1}}$.\\
$\LanguageOf{\Delta}{\RegexOr{\Regex}{\Regex_{n+1}}}
= \LanguageOf{\Delta}{\Regex}\cup\LanguageOf{\Delta}{\Regex_{n+1}}$
by definition\\
$\LanguageOf{\Delta}{\RegexOr{\Regex}{\Regex_{n+1}}}
= \LanguageOf{\Delta}{[\Conjunct_1; \ldots ; \Conjunct_n]}
\cup\LanguageOf{\Delta}{\Regex_{n+1}}$ by induction assumption.\\
$\LanguageOf{\Delta}{\RegexOr{\Regex}{\Regex_{n+1}}}
= \bigcup_{i=1\ldots n}\LanguageOf{\Delta}{\Conjunct_i}
\cup\LanguageOf{\Delta}{\Regex_{n+1}}$ by definition.\\
$\LanguageOf{\Delta}{\RegexOr{\Regex}{\Regex_{n+1}}}
= \bigcup_{i=1\ldots n}\LanguageOf{\Delta}{\Conjunct_i}
\cup\LanguageOf{\Delta}{\Conjunct_{n+1}}$ by problem assumption.\\
$\LanguageOf{\Delta}{\RegexOr{\Regex}{\Regex_{n+1}}}
= \bigcup_{i=1\ldots n+1}\LanguageOf{\Delta}{\Conjunct_i}$ by distributivity of $\cup$.\\
$\LanguageOf{\Delta}{\RegexOr{\Regex}{\Regex_{n+1}}}
= \LanguageOf{\Delta}{[\Conjunct_1; \ldots ; \Conjunct_n]}$ by definition.

Similarly for
$\LanguageOf{\Delta}{\RegexOr{\RegexAlt}{\RegexAlt_{n+1}}}
= \LanguageOf{\Delta}{[\ConjunctAlt_1; \ldots ; \ConjunctAlt_n]}$ TODO, split into lemma?.\\
\[
\PutRightOf{\OrLens{\Lens}{\Lens_{n+1}}}(\String) =
  \begin{cases}
    \PutRightOf{\Lens}(\String)& \text{if } \String \in \LanguageOf{\Delta}{\Regex}\\
    \Lens_{n+1}.putr(\String)& \text{if } \String \in \LanguageOf{\Delta}{\Regex_{n+1}}
  \end{cases}
\] by definition.\\
\[
\PutRightOf{\OrLens{\Lens}{\Lens_{n+1}}}(\String) =
  \begin{cases}
    \PutRightOf{[\ConjunctLens_1;\ldots;\ConjunctLens_n}(\String)& \text{if } \String \in \LanguageOf{[\Conjunct_1 ; \ldots ; \Conjunct_n]}{\Regex}\\
    \Lens_{n+1}.putr(\String)& \text{if } \String \in \LanguageOf{\Delta}{\Regex_{n+1}}
  \end{cases}
\] by induction assumption.\\
\[
\PutRightOf{\OrLens{\Lens}{\Lens_{n+1}}}(\String) =
  \begin{cases}
    \PutRightOf{\ConjunctLens_1}(\String)& \text{if } \String \in \LanguageOf{\Delta}{\Conjunct_1}\\
\ldots \\
    \PutRightOf{\ConjunctLens_n(\String)}& \text{if } \String \in \LanguageOf{\Delta}{\Conjunct_n}\\
    \Lens_{n+1}.putr(\String)& \text{if } \String \in \LanguageOf{\Delta}{\Regex_{n+1}}
  \end{cases}
\] by definition of putr.\\
\[
\PutRightOf{\OrLens{\Lens}{\Lens_{n+1}}}(\String) =
  \begin{cases}
    \PutRightOf{\ConjunctLens_1}(\String)& \text{if } \String \in \LanguageOf{\Delta}{\Conjunct_1}\\
\ldots \\
    \PutRightOf{\ConjunctLens_n(\String)}& \text{if } \String \in \LanguageOf{\Delta}{\Conjunct_n}\\
    \Conjunct_{n+1}.putr(\String)& \text{if } \String \in \LanguageOf{\Delta}{\Conjunct_{n+1}}
  \end{cases}
\] by problem assumption.\\
$\PutRightOf{\OrLens{\Lens}{\Lens_{n+1}}}(\String) =
\PutRightOf{[\ConjunctLens_1; \ldots ; \ConjunctLens_{n+1}]}(\String)$ by definition of putr.\\
\end{proof}
\end{lemma}

\begin{lemma}[Soundness of DNF Lenses, Conjuncts, and Atoms]\leavevmode
\begin{enumerate}
\item Let \DNFRegex{} and \DNFRegexAlt{} be two dnf regular expressions, and $\FullContext \vdash \DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$.  Then there exists a \Lens{}, \Regex{}, and \RegexAlt{} such that $\FullContext \vdash \Lens \OfType \Regex \Leftrightarrow \RegexAlt$, \PutRightOf{\Lens}=\PutRightOf{\DNFLens}, \LanguageOf{\Delta}{\Regex}=\LanguageOf{\Delta}{\DNFRegex}, and \LanguageOf{\Delta}{\RegexAlt}=\LanguageOf{\Delta}{\DNFRegexAlt}.  \LanguageOf{\Delta{}}{\Regex{}} = \LanguageOf{\Delta{}}{\DNFRegex{}} and
\LanguageOf{\Delta{}}{\RegexAlt{}} = \LanguageOf{\Delta{}}{\DNFRegexAlt{}}

\item Let \Conjunct{} and \ConjunctAlt{} be two clauses, and $\FullContext \vdash \ConjunctLens \OfType \Conjunct \Leftrightarrow \ConjunctAlt$.  Then there exists a \Lens{}, \Regex{}, and \RegexAlt{} such that $\FullContext \vdash \Lens \OfType \Regex \Leftrightarrow \RegexAlt$, \PutRightOf{\Lens}=\PutRightOf{\ConjunctLens}, \LanguageOf{\Delta}{\Regex}=\LanguageOf{\Delta}{\Conjunct}, and \LanguageOf{\Delta}{\RegexAlt}=\LanguageOf{\Delta}{\ConjunctAlt}.  \LanguageOf{\Delta{}}{\Regex{}} = \LanguageOf{\Delta{}}{\Conjunct{}} and
\LanguageOf{\Delta{}}{\RegexAlt{}} = \LanguageOf{\Delta{}}{\ConjunctAlt{}}

\item Let \Atom{} and \AtomAlt{} be two atoms, and $\FullContext \vdash \AtomLens \OfType \Atom \Leftrightarrow \AtomAlt$.  Then there exists a \Lens{}, \Regex{}, and \RegexAlt{} such that $\FullContext \vdash \Lens \OfType \Regex \Leftrightarrow \RegexAlt$, \PutRightOf{\Lens}=\PutRightOf{\AtomLens}, \LanguageOf{\Delta}{\Regex}=\LanguageOf{\Delta}{\Atom}, and \LanguageOf{\Delta}{\RegexAlt}=\LanguageOf{\Delta}{\AtomAlt}.  \LanguageOf{\Delta{}}{\Regex{}} = \LanguageOf{\Delta{}}{\Atom{}} and
\LanguageOf{\Delta{}}{\RegexAlt{}} = \LanguageOf{\Delta{}}{\AtomAlt{}}
\end{enumerate}
\begin{proof}
\begin{itemize}\leavevmode\\
\item $\FullContext \vdash ([\ConjunctLens_1;\ldots;\ConjunctLens_n],\sigma) \OfType [\Conjunct_1;\ldots;\Conjunct_n] \Leftrightarrow [\ConjunctAlt_{\sigma(1)};\ldots;\ConjunctAlt_{\sigma(n)}]$\\
By Induction assumption, for each $\FullContext \vdash \ConjunctLens_i \OfType \Conjunct_i \Leftrightarrow \ConjunctAlt_i$ there exists a $\FullContext \vdash \Lens_i \OfType \Regex_i \Leftrightarrow \RegexAlt_i$.\\
By Lemma~\ref{lem:id-dnf} there exists a $\FullContext \vdash \Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that $\PutRightOf{\Lens}=\PutRightOf{([\ConjunctLens_1;\ldots\ConjunctLens_n],id)}$,
$\LanguageOf{\Delta}{\Regex}=\LanguageOf{\Delta}{[\Conjunct_1;\ldots;\Conjunct_n]}$, and
$\LanguageOf{\Delta}{\RegexAlt}=\LanguageOf{\Delta}{[\ConjunctAlt_1;\ldots;\ConjunctAlt_n]}$.\\
By Lemma TODO, $\PutRightOf{([\ConjunctLens_1;\ldots\ConjunctLens_n],id)}=\PutRightOf{([\ConjunctLens_1;\ldots\ConjunctLens_n],\sigma)}$.\\
By Lemma TODO, $\LanguageOf{\Delta}{[\ConjunctAlt_1;\ldots;\ConjunctAlt_n]}=\LanguageOf{\Delta}{[\ConjunctAlt_{\sigma(1)};\ldots;\ConjunctAlt_{\sigma(n)}]}$.\\
As such, $\PutRightOf{\Lens}=\PutRightOf{([\ConjunctLens_1;\ldots\ConjunctLens_n],\sigma)}$,
$\LanguageOf{\Delta}{\Regex}=\LanguageOf{\Delta}{[\Conjunct_1;\ldots;\Conjunct_n]}$,
and $\LanguageOf{\Delta}{\RegexAlt}=\LanguageOf{\Delta}{[\ConjunctAlt_{\sigma(1)};\ldots;\ConjunctAlt_{\sigma(n)}]}$.\\

\item$\FullContext \vdash ([(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)],\sigma \in S_n) \OfType [\String_0 ; \Atom_1 ; \ldots ; \Atom_n ; \String_n] \Leftrightarrow [\StringAlt_0; \AtomAlt_{\sigma(1)} ; \ldots ; \AtomAlt_{\sigma(n)} ; \StringAlt_n]$\\
From induction assumption, I know for each $\FullContext \vdash \AtomLens_i \OfType \Atom_i \Leftrightarrow \AtomAlt_i$, there exists a $\FullContext \vdash \Lens_i \OfType \Regex_i \Leftrightarrow \RegexAlt_i$ such that $\PutRightOf{\AtomLens_i}=\PutRightOf{\Lens_i}$,
and $\LanguageOf{\Delta}{\Regex_i}=\LanguageOf{\Delta}{\Atom_i}$ and $\LanguageOf{\Delta}{\RegexAlt_i}=\LanguageOf{\Delta}{\AtomAlt_i}$.\\
By Lemma~\ref{lem:id-clause}, there exists a $\FullContext \vdash \Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that $\PutRightOf{\Lens}=\PutRightOf{([(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)],id)}$,
$\LanguageOf{\Delta}{\Regex}=\LanguageOf{\Delta}{[\String_0;\Conjunct_1;\ldots;\Conjunct_n;\String_{n+1}]}$,
$\LanguageOf{\Delta}{\RegexAlt}=\LanguageOf{\Delta}{[\StringAlt_0;\ConjunctAlt_1;\ldots;\ConjunctAlt_n;\StringAlt_{n+1}]}$.\\
By Lemma~\ref{lem:perm-exp} there exists a $\FullContext \vdash \Lens_{\sigma} \OfType \Regex' \Leftrightarrow \RegexAlt'$,
such that $\PutRightOf{\Lens_{\sigma}}(\StringAlt_0;\StringAlt_1';\StringAlt_1;\ldots;\StringAlt_n'\StringAlt_n)=\StringAlt_0;\StringAlt_{\sigma(1)}';\StringAlt_1;\ldots;\StringAlt_{\sigma(n)}'\StringAlt_n$,
$\LanguageOf{\Delta}{\Regex'}=\LanguageOf{\Delta}{[\String_0;\Conjunct_1;\ldots;\Conjunct_n;\String_{n+1}]}$, and
$\LanguageOf{\Delta}{\RegexAlt'}=\LanguageOf{\Delta}{[\String_0;\Conjunct_{\sigma(1)};\ldots;\Conjunct_{\sigma(n)}\String_{n+1}]}$.\\
Consider the lens $\Delta \vdash \ComposeLens{\Lens_{\sigma}}{\Lens} \OfType \Regex \Leftrightarrow \RegexAlt'$.\\
$\PutRightOf{\ComposeLens{\Lens_{\sigma}}{\Lens}}(\String_0\String_1'\ldots\String_n'\String_n)=\PutRightOf{\Lens_{\sigma}}(\PutRightOf{\Lens}(\String_0\String_1'\ldots\String_n'\String_n))$ by definition of compose\\
$\PutRightOf{\ComposeLens{\Lens_{\sigma}}{\Lens}}(\String_0\String_1'\ldots\String_n'\String_n)=\PutRightOf{\Lens_{\sigma}}(\StringAlt_1\PutRightOf{\AtomLens_1}(\String_1')\ldots\PutRightOf{\AtomLens_n}(\String_n')\StringAlt_n)$ by definition of \Lens{}\\
$\PutRightOf{\ComposeLens{\Lens_{\sigma}}{\Lens}}(\String_0\String_1'\ldots\String_n'\String_n)=\StringAlt_1\PutRightOf{\AtomLens_{\sigma(1)}}(\String_{\sigma(1)}')\ldots\PutRightOf{\AtomLens_{\sigma(n)}}(\String_{\sigma(n)}')\StringAlt_n$ by definition of $\Lens_{\sigma}$\\
$\PutRightOf{\ComposeLens{\Lens_{\sigma}}{\Lens}}(\String_0\String_1'\ldots\String_n'\String_n)=([(\String_0,\StringAlt_0);\AtomLens_0;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)],\sigma)(\String_0\String_1'\ldots\String_n'\String_n)$ by definition of clause lens\\
\\
\item$\FullContext \vdash \IterateLens{\DNFLens} \OfType \Star{\DNFRegex} \Leftrightarrow \Star{\DNFRegexAlt}$\\
From induction assumption, I know that there exists $\FullContext \vdash \Lens \OfType \Regex \Leftrightarrow \RegexAlt$, such that
$\PutRightOf{\DNFLens}=\PutRightOf{\Lens}$,
\LanguageOf{\RegexContext}{\Regex}=\LanguageOf{\RegexContext}{\DNFRegex}, and
$\LanguageOf{\Delta}{\RegexAlt}=\LanguageOf{\Delta}{\DNFRegexAlt}$.\\
Consider $\FullContext \vdash \IterateLens{\Lens} \OfType \Star{\Regex} \Leftrightarrow \Star{\RegexAlt}$.\\
$\LanguageOf{\Delta}{\Star{\Regex}} = \String_0\ldots\String_n$ such that $\String_i \in \LanguageOf{\Delta}{\Regex}$ by definition of \LanguageOf{\Delta}{\Star{\Regex}}.\\
$\LanguageOf{\Delta}{\Star{\Regex}} = \String_0\ldots\String_n$ such that $\String_i \in \LanguageOf{\Delta}{\DNFRegex}$ as $\LanguageOf{\Delta}{\DNFRegex}=\LanguageOf{\Delta}{\Regex}$.\\
$\LanguageOf{\RegexContext}{\Star{\Regex}} = \LanguageOf{\RegexContext}{\Star{\DNFRegex}}$ by definition of \LanguageOf{\RegexContext}{\Star{\DNFRegex}}.

Similarly for \LanguageOf{\RegexContext}{\Star{\RegexAlt}}\\\\
$\PutRightOf{\IterateLens{\Lens}}(\String_0\ldots\String_n)=\PutRightOf{\Lens}(\String_0)\ldots\PutRightOf{\Lens}(\String_n)$ by definition of $\PutRightOf{\IterateLens{\Lens}}$.\\
$\PutRightOf{\IterateLens{\Lens}}(\String_0\ldots\String_n)=\PutRightOf{\DNFLens}(\String_0)\ldots\PutRightOf{\DNFLens}(\String_n)$ as \PutRightOf{\DNFLens}=\PutRightOf{\Lens}.\\
$\PutRightOf{\IterateLens{\Lens}}(\String_0\ldots\String_n)=\PutRightOf{\IterateLens{\DNFLens}}(\String_0\ldots\String_n)$ by definition of $\PutRightOf{\IterateLens{\DNFLens}}$.\\
\\
\item$\FullContext \vdash \IdentityLens \OfType \RegexVariable \Leftrightarrow \RegexVariable$\\
Consider $\FullContext \vdash \IdentityLens \OfType \RegexVariable \Leftrightarrow \RegexVariable$\\
$\PutRightOf{\IdentityLens}(\String)=\String$ by definition of dnf \PutRightOf{\IdentityLens{}}.\\
$\PutRightOf{\IdentityLens}(\String)=\PutRightOf{\IdentityLens}(\String)$ by definition of normal $\PutRightOf{\IdentityLens{}}$.
\end{itemize}
\end{proof}
\end{lemma}

\dnfls*
\begin{proof}
By mutual induction on the typing \DNFLens{}, the typing of \ConjunctLens{}, and the typing of \AtomLens{}.
\begin{enumerate}
\item[DNF Lens Intro] Let $\Delta \vdash ([\ConjunctLens_1 ; \ldots ; \ConjunctLens_n],\sigma) \OfType [\Conjunct_{1,1}, \ldots, \Conjunct_{n,1}] \Leftrightarrow [\Conjunct_{\sigma(1),2}, \ldots, \Conjunct_{\sigma(n),2}]$.
This comes from the derivations that $\Delta \vdash \ConjunctLens_i \OfType \Conjunct_{i,1} \Leftrightarrow \Conjunct_{i,2}$ for all $i$.
Consider instead the lens $\DNFLens' = \Delta \vdash ([\ConjunctLens_1 ; \ldots ; \ConjunctLens_n],\sigma_id) \OfType [\Conjunct_{1,1}, \ldots, \Conjunct_{n,1}] \Leftrightarrow[\Conjunct_{1,2}, \ldots, \Conjunct_{n,2}]$.
By Lemma (TODO: this lemma), these two lenses are semantically equivalent.
By Lemma (TODO: this lemma), $\Delta \vdash repregex(\DNFLens') \OfType repregex(\DNFRegex_1) \Leftrightarrow repregex(\DNFRegex_2')$, with $repregex(\DNFLens)$ semantically equivalent to $\DNFLens$.
So $repregex(\DNFLens')$ is semantically equivalent to $\DNFLens'$, and $DNFLens'$ is semantically equivalent $\DNFLens$, so $repregex(\DNFLens')$ is
semantically equivalent to $\DNFLens$.  Merely adding in a retyping rule at
the end of $repregex(\DNFLens')$ (as they have the same type), completes this case.
\item[Conjunct Lens Intro] Let $\Delta \vdash ([(\String_{1,1},\String_{1,2}) ; \AtomLens_1 ; \ldots ; \AtomLens_n ; (\String_{n+1,1},\String_{n+1,2})],\sigma) \OfType [\String_{1,1};\Atom_{1,1}; \ldots ; \Atom_{1,n} ; \String_{1,n+1}] \Leftrightarrow [\String_{1,2};\Atom_{\sigma(1),2}; \ldots ; \Atom_{\sigma(n),2} ; \String_{n+1,2}]$.
Consider two lenses, $\Delta \vdash ([(\String_{1,1},\String_{1,2}) ; \AtomLens_1 ; \ldots ; \AtomLens_n ; (\String_{n+1,1},\String_{n+1,2})],\sigma_id) \OfType [\String_{1,1};\Atom_{1,1}; \ldots ; \Atom_{1,n} ; \String_{1,n+1}] \Leftrightarrow [\String_{1,2};\Atom_{1,2}; \ldots ; \Atom_{n,2} ; \String_{n+1,2}]$,
and $\Delta \vdash ([(\String_{1,2},\String_{1,2});identitylens(\Atom_{1,2}); \ldots ; identitylens(\Atom_{n,2}) ; (\String_{n+1,2},\String_{n+1,2})],\sigma) \OfType [\String_{1,2};\Atom_{1,2}; \ldots ; \Atom_{n,2} ; \String_{n+1,2}] \Leftrightarrow [\String_{1,2};\Atom_{\sigma(1),2}; \ldots ; \Atom_{\sigma(n),2} ; \String_{n+1,2}]$.
By Lemma (TODO:), there exists a lens equivalent to the first one, call it $\Lens_{transform}$.
By Lemma (TODO:), there exists a lens equivalent to the second one, call it $\Lens_{\sigma}$.
Consider $\ComposeLens{\Lens_{\sigma}}{\Lens_{transform}}$.  Go through semantics, oh look they are equivalent.

\end{enumerate}
\end{proof}

