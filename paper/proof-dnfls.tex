\begin{lemma}[Creation of Lens from Identity Perm Sequence Lens]
\label{lem:id-clause}
If $(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1 ; \ldots ;
\AtomLens_n;(\String_n,\StringAlt_n)},id) \OfType
\SequenceOf{\String_0 ; \Atom_1 ; \ldots ; \Atom_n; \String_n} \Leftrightarrow
\SequenceOf{\StringAlt_0 ; \AtomAlt_1 ; \ldots ; \AtomAlt_n ; \StringAlt_n}$,
and for each $\AtomLens_i \OfType \Atom_i \Leftrightarrow \AtomAlt_i$,
there exists a $\Lens_i \OfType \Regex_i \Leftrightarrow \RegexAlt_i$ such that
$\LanguageOf{\Atom_i}=\LanguageOf{\Regex_i}$, and
$\SemanticsOf{\Lens_i} = \SemanticsOf{\SequenceLens_i}$,
then there exists a $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that
$\SemanticsOf{\Lens} =
\SemanticsOf{(\SequenceLensOf{\AtomLens_1 ; \ldots ; \AtomLens_n},id)}$,
$\LanguageOf{\SequenceOf{\String_0 ; \Atom_1 ; \ldots ;
\Sequence_n ; \String_n}}$ = $\LanguageOf{\Regex}$,
and $\LanguageOf{\SequenceOf{\StringAlt_0 ; \AtomAlt_1 ; \ldots ;
\AtomAlt_n ; \StringAlt_n}}$ = $\LanguageOf{\RegexAlt}$.
\begin{proof}

By induction on $n$.

Let $n=0$, $(\SequenceLensOf{(\String_0,\StringAlt_0)},id) \OfType
\SequenceOf{\String_0} \Leftrightarrow \SequenceOf{\StringAlt_0}$.
Then consider
\begin{mathpar}
\inferrule[]
{
}
{
\ConstLens{\String_0}{\StringAlt_0}\OfType\String_0\Leftrightarrow\StringAlt_0
}
\end{mathpar}

$\LanguageOf{\String_0}=\SetOf{\String_0}=\LanguageOf{\SequenceOf{\String_0}}$,
and
$\LanguageOf{\StringAlt_0}=\SetOf{\StringAlt_0}=
\LanguageOf{\SequenceOf{\StringAlt_0}}$.
$\SemanticsOf{\ConstLens{\String_0}{\StringAlt_0}}=
\SetOf{(\String_0,\StringAlt_0)}=
\SemanticsOf{\SequenceOf{(\String_0,\StringAlt_0)},id)}$

Let $n>0$.
By induction assumption, there exists a typing derivation
\begin{mathpar}
\inferrule[]
{
\Derivation
}
{
\Lens\OfType\Regex\Leftrightarrow\RegexAlt
}
\end{mathpar}
Satisfying $\LanguageOf{\Regex}=
\LanguageOf{\SequenceOf{\String_0 ; \Atom_1 ; \ldots ;
\Atom_n ; \String_{n-1}}}$,
and $\LanguageOf{\RegexAlt}=
\LanguageOf{\SequenceOf{\StringAlt_0 ; \AtomAlt_1 ; \ldots ;
\AtomAlt_n ; \StringAlt_{n-1}}}$, and
$\SemanticsOf{\Lens}=
\SemanticsOf{(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1 ;
\ldots ; \AtomLens_n;(\String_n,\StringAlt_{n-1})},id)}$
By problem statement, there exists a typing derivation
\begin{mathpar}
\inferrule[]
{
\Derivation_{\AtomLens_{n}}
}
{
\Lens_{\AtomLens_{n}} \OfType
\Regex_{\Atom_{n}} \Leftrightarrow \RegexAlt_{\AtomAlt_{n}}
}
\end{mathpar}
satisfying $\LanguageOf{\Regex_{\Atom_{n}}} = \LanguageOf{\Atom_n}$,
$\LanguageOf{\RegexAlt_{\AtomAlt_n}}=\LanguageOf{\AtomAlt_n}$, and
$\SemanticsOf{\Lens_{\Atom_n}}=\SemanticsOf{\Atom_n}$.
Consider the following lens typing
\begin{mathpar}
\inferrule*[left=\Derivation{}']
{
\inferrule*
{
\Derivation_{\AtomLens_n}
}
{
\Lens_{\AtomLens_{n}} \OfType
\Regex_{\Atom_{n}} \Leftrightarrow \RegexAlt_{\AtomAlt_{n}}
}\\
\inferrule*
{
}
{
\ConstLens{\String_n}{\StringAlt_n}
}
}
{
\ConcatLens{\Lens_{\AtomLens_n}}{\ConstLens{\String_n}{\StringAlt_n}}
\OfType
\Regex_{\Atom_n}\Concat\String_n \Leftrightarrow
\RegexAlt_{\AtomAlt_n}\Concat\StringAlt_n
}

\inferrule*{
\inferrule*
{
\Derivation
}
{
\Lens\OfType\Regex \Leftrightarrow \RegexAlt
}\\
\Derivation{}'
}
{
\ConcatLens
{\Lens}
{\ConcatLens{\Lens_{\AtomLens_n}}{\ConstLens{\String_n}{\StringAlt_n}}}
\OfType\\
\Regex\Concat\Regex_{\Atom_n}\Concat\String_n \Leftrightarrow
\RegexAlt\Concat\RegexAlt_{\AtomAlt_n}\Concat\StringAlt_n
}
\end{mathpar}

By Lemma (TODO, find ref),
$\LanguageOf{\Regex\Concat\Regex_{\Atom_n}\Concat\String_n}=
\LanguageOf{\SequenceOf{\String_0 ; \Atom_1 ; \ldots ;
\Atom_n ; \String_{n-1}}}$ and
$\LanguageOf{\RegexAlt\Concat\RegexAlt_{\AtomAlt_n}\Concat\StringAlt_n}=
\LanguageOf{\SequenceOf{\StringAlt_0 ; \AtomAlt_1 ; \ldots ;
\AtomAlt_n ; \StringAlt_{n-1}}}$.\\
\SemanticsOf{\ConcatLens
{\Lens}
{\ConcatLens{\Lens_{\AtomLens_n}}{\ConstLens{\String_n}{\StringAlt_n}}}}=\\
\SetOf{(\String'\Concat\String''\String_n,\StringAlt'\Concat\StringAlt''\StringAlt_n)
\SuchThat
(\String',\StringAlt')\in\SemanticsOf{\Lens}\BooleanAnd
(\String'',\StringAlt'')\in\SemanticsOf{\Lens_{\AtomLens_n}}}=\\
\SetOf{
(\String_0\Concat\String_0'\Concat\ldots
\Concat\String_{n-1}'\Concat\String_{n-1}
\Concat \String_n \Concat \String_n'
,
\StringAlt_0\Concat\StringAlt_0'\Concat\ldots
\Concat\StringAlt_{n-1}'\Concat\StringAlt_{n-1}
\Concat \String_n \Concat \String_n')\SuchThat\\
\hspace*{1em}\String_i'\in\Atom_i\BooleanAnd\StringAlt_i'\in\AtomAlt_i}=\\
\SemanticsOf{(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1 ;
\ldots ; \AtomLens_n;(\String_n,\StringAlt_{n-1})},id)}
\end{proof}
\end{lemma}

\begin{definition}[Adjacent Swapping Permutation]
Let $\sigma_{i} \in S_n$ be the permutation where
$\sigma_{i}(i) = i+1$, $\sigma_{i}(i+1) = i$, $\sigma_{i,j}(k\neq i,i+1) = k$
\end{definition}

\begin{definition}[Insertion Permutation]
Let $\sigma_{i,j} \in S_n$ where $i\geq j$ be the permutation where
\[
  \sigma_{i,j}(k)=
    \begin{cases}
      j& \text{if } k=i\\
      k+1& \text{if } j\leq k<i\\
      k& \text{otherwise}
    \end{cases}
\]
\end{definition}

\begin{lemma}[Generation of \PermutationSetOf{n}]
If $\sigma\in\PermutationSetOf{n}$, then there exists a decomposition
$\sigma_{i_1,j_1}\Compose\ldots\Compose\sigma_{i_m,j_m}$ such that
$\sigma_{i_1,j_1}\Compose\ldots\Compose\sigma_{i_m,j_m}=\sigma$,
and for all $k\in\RangeIncInc{0}{m}$,
if $\sigma_{i_1,j_1}\Compose\ldots\Compose\sigma_{i_k,j_k}(i)<
\sigma_{i_1,j_1}\Compose\ldots\Compose\sigma_{i_k,j_k}(j)$,
then $i<j$ or $\sigma(i)<\sigma(j)$.
\begin{proof}
Consider the decomposition $\sigma_{i_n,n}\Compose\ldots\Compose\sigma_{i_1,1}$ where $i_k$ is defined as
$(\InverseOf{\sigma}\Compose\sigma_{i_{k-1},k-1}\Compose\ldots\sigma_{i_1,1})(k)$.
Define $\sigma_k$ as $\sigma_{i_k,k}\Compose\ldots\Compose\sigma_{i_1,1}$, and as \Identity{} for $k=0$.
So $\sigma_k$ = $\sigma_{i_k,k}\Compose\sigma_{k-1}$.
We will prove for all $k\in\RangeIncInc{0}{n}$, by induction, that
for all $i$ such that $\sigma(i)\in\RangeIncInc{1,k}$, $\sigma_k(i)=\sigma(i)$,
and if
$\sigma_k(i)<\sigma_k(j)$
and $\sigma_k(i)\in\RangeIncInc{1}{k}$, then $\sigma(i)<\sigma(j)$,
else if $\sigma_k(i),\sigma_k(j)$, then $i<j$.

Base Case: $k=0$, identity permutation

If $\Identity i<\Identity j$ then $i < j$.  For all $i\in\RangeIncInc{1,0}$, anything is true vacuously.

Induction Step:
$\sigma_k(i)=\sigma_{i_k,k}\Compose\sigma_{k-1}(i)$.
If $\sigma(i)\in\RangeIncInc{1}{k-1}$, then $\sigma_k(i)=\sigma_{i_k,k}(\sigma(i))$, by induction assumption.
As $\sigma(i)<k$, $\sigma_{i_k,k}(\sigma(i))=\sigma(i)$.
If $\sigma(i)=k$, then $\sigma_k(i)=\sigma_{i_k,k}(\sigma_k(i))$.
So by definition of composition $\sigma_k(i)=\sigma_{i_k,k}(\sigma_{k-1}(i))$.
$i_k=\sigma_{k-1}(\InverseOf{\sigma}(k))$, so $i_k=\sigma_{k-1}(i)$.
So, by the definition of $\sigma_{i_k,k}$, $\sigma_{i_k,k}(\sigma_{k-1}(i))=k$.

Let $\sigma_{i_k,k}\Compose\ldots\Compose\sigma_{i_1,1}(i) < \sigma_{i_k,k}\Compose\ldots\Compose\sigma_{i_1,1}(j)$.
Let $i'=\sigma_k(i)$
and $j'=\sigma_k(j)$
If $j'\leq k$, then $j'=\sigma(j)$ and $i'=\sigma(i)$, as $i'<j'\leq k$.
If $i'\leq i_k$, but $j'>i_k$, then $\sigma(j)>\sigma(i)$, as $\sigma(i)\in\RangeIncInc{1}{k}$,
but $\sigma(j)$ isn't.
If $i' > i_k$, then if 
\end{proof}
\end{lemma}

\begin{definition}[Sequence Permuting Bijection]
Let $[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]$ be a clause, let $\sigma$ be a permutation, and let $\RegexContext$ be a regular expression context.
Define
$f_{\sigma,\RegexContext,[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]}$ as:
$f_{\sigma,\RegexContext,[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]}\OfType \LanguageOf{[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]}\rightarrow\LanguageOf{[\String_0;\Atom_{\sigma(1)};\ldots;\Atom_{\sigma(n)};\String_n]}$, where $\String_0\String_1'\ldots\String_n'\String_n\mapsto\String_0\String_{\sigma(1)}'\ldots\String_{\sigma(n)}'\String_n$.
\end{definition}

\begin{definition}[Left Quotient]
$\LeftQuotientOf{\Language_1}{\Language_2}\triangleq \{v \in \Star{\Sigma}\SuchThat \exists u\in L_1. u\Concat v\in L_2\}$
\end{definition}

\begin{definition}[Right Quotient]
$\RightQuotientOf{\Language_1}{\Language_2}\triangleq \{u \in \Star{\Sigma}\SuchThat \exists v\in \Language_1. u\Concat v\in \Language_2\}$
\end{definition}

\begin{definition}[Suffixes]
$\SuffixOf{\Language}\triangleq \LeftQuotientOf{\Language}{\Language}$
\end{definition}

\begin{definition}[Prefixes]
$\PrefixOf{\Language}\triangleq \RightQuotientOf{\Language}{\Language}$
\end{definition}

\begin{lemma}[Atom Separators]
Let $\Atom_1$ and $\Atom_2$ be atoms, and
$\Language=\SuffixOf{\LanguageOf{\Atom_1}}\Intersect\PrefixOf{\LanguageOf{\Atom_2}}$.
If $\SuffixOf{\Language}\Union\PrefixOf{\Language}\neq\Star{\Sigma}$, then there exists a string \String{} such that
$\UnambigConcatOf{[\EmptyString;\Atom_1;\String]}{[\EmptyString;\Atom_2;\EmptyString]}$
\begin{proof}
Let $\Atom_1$ and $\Atom_2$ be atoms, and
$\Language=\SuffixOf{\LanguageOf{\Atom_1}}\Intersect\PrefixOf{\LanguageOf{\Atom_2}}$,
such that $\SuffixOf{\Language}\Union\PrefixOf{\Language}\neq\Star{\Sigma}$.
If $\SuffixOf{\Language}\Union\PrefixOf{\Language}\neq\Star{\Sigma}$, then $\ComplementOf{\SuffixOf{\Language}\Union\PrefixOf{\Language}}\neq\emptyset$.
Let $\String\in\ComplementOf{\SuffixOf{\Language}\Union\PrefixOf{\Language}}$.
Suppose, for contraction, that $[\EmptyString;\Atom_1;\String]$ is unambiguously concatenable
with ${[\EmptyString;\Atom_2;\EmptyString]}$.
\end{proof}
\end{lemma}

\begin{lemma}[Expressibility of Adjacent Swapping Permutation Lens]
Let $\sigma_i$ be an adjacent element swapping permutation, $[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]$ be a clause, $\RegexContext$ be a regular expression context, and $\LensContext$ be a lens context.
There exists regular expressions $\Regex$ and $\RegexAlt$, and a lens $\Lens$,
such that $\LanguageOf{\Regex}=\LanguageOf{[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]}$,
$\LanguageOf{\RegexAlt}=\LanguageOf{[\String_0;\Atom_{\sigma(1)};\ldots;\Atom_{\sigma(n)};\String_n]}$, and
$\FullContext \vdash \Lens \OfType \Regex \Leftrightarrow \RegexAlt \HasSemantics f_{\sigma,\RegexContext,[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]}, f_{\sigma,\RegexContext,[\String_0;\Atom_1;\ldots;\Atom_n;\String_n]}^{-1}$
\begin{proof}
By the soundness of regular expressions, there exists
a regular expressions $\Regex_1, \Regex_2, \Regex_3, \Regex_4$ such that
$\LanguageOf{\Regex_1}=\LanguageOf{[\String_1;\Atom_1;\ldots;\Atom_{i-1};\String_{i-1}]}$,
$\LanguageOf{\Regex_2}=\LanguageOf{\Atom_i}$,
$\LanguageOf{\Regex_3}=\LanguageOf{\Atom_{i+1}}$, and
$\LanguageOf{\Regex_4}=\LanguageOf{[\String_i;\Atom_{i+1};\ldots;\Atom_{n};\String_n]}$.
Consider the following deduction
\begin{mathpar}

\inferrule*[left=\Derivation{}]
{
\inferrule*
{
}
{
\FullContext \vdash \Lens \OfType \String_i \Leftrightarrow \String_i
}
\inferrule*
{
}
{
\FullContext \vdash \Lens \OfType \Regex_3 \Leftrightarrow \Regex_3
}
}
{
\FullContext \vdash \Lens \OfType \String_i\Concat\Regex_3 \Leftrightarrow \Regex_3\Concat\String_i
}

\inferrule*[left=\Derivation{}']
{
\inferrule*
{
}
{
\FullContext \vdash \Lens \OfType \Regex_2 \Leftrightarrow \Regex_2
}\\
\Derivation
}
{
\FullContext \vdash \Lens \OfType \Regex_2\Concat\String_i\Concat\Regex_3 \Leftrightarrow \Regex_3\Concat\String_i\Concat\Regex_2
}

\inferrule*[left=\Derivation{}'']
{
\inferrule*
{
}
{
\FullContext \vdash \IdentityLens \OfType \Regex_1 \Leftrightarrow \Regex_1
}\\
\Derivation{}'
}
{
\FullContext \vdash \Lens \OfType \Regex_1\Concat\Regex_2\Concat\String_i\Concat\Regex_3 \Leftrightarrow \Regex_1\Concat\Regex_3\Concat\String_i\Concat\Regex_2
}


\inferrule*
{
\Derivation{}''\\
\inferrule*
{
}
{
\FullContext \vdash \Lens \OfType \Regex_4 \Leftrightarrow \Regex_4
}
}
{
\FullContext \vdash \Lens \OfType \Regex_1\Concat\Regex_2\Concat\String_i\Concat\Regex_3\Concat\Regex_4 \Leftrightarrow \Regex_1\Concat\Regex_3\Concat\String_i\Concat\Regex_2\Concat\Regex_4
}
\end{mathpar}


Consider the regular expressions $repregex([\String_1;\Atom_1; \ldots;\String_i])$ $(repregex(\Atom_i) (\String_{i+1} repregex(\Atom_{i+1})))$ $repregex([\String_{i+2} ; \ldots ; \Atom_{n} ; \String_{n+1}])$ and 
$repregex([\String_{1,2};\Atom_{1,2}; \ldots;\String_{i,1}])$ $((\Atom_{i+1,1} \String_{i+1,1})\Atom_{i,1})$ $repregex([\String_{i+2,1} ; \ldots ; \Atom_{n} ; \String_{n+1}])$
Consider the lens between them\\ $\ConcatLens{\ConcatLens{\IdentityLens}{\SwapLens{\IdentityLens}{\SwapLens{\IdentityLens}{\IdentityLens}}}}{\IdentityLens}$
By inspection, this lens is equivalent to the adjacent swapping permutation.
\end{proof}
\end{lemma}

\begin{lemma}[Expressibility of Permutation]
\label{lem:perm-exp}
The language of lenses can express $([(\String_1,\String_1) ; \IdentityLens ; \ldots ; \IdentityLens ; (\String_n,\String_n)], \sigma)$
for any permutation $\sigma$.
\begin{proof}
Let $\sigma$ be a permutation.
Consider the clause lens $([(\String_1,\String_1) ; \IdentityLens ; \ldots ; \IdentityLens ; (\String_n,\String_n)], \sigma_{i})$.
From algebra, we know that the group of permutations is generated by all
adjacent swaps $\sigma_i = (i,i+1)$.
So there exists an adjacency swap decomposition of $\sigma = \sigma_{i_1}\ldots\sigma_{i_m}$.
Consider the dnf lens $([(\String_1,\String_1) ; \IdentityLens ; \ldots ; \IdentityLens ; (\String_n,\String_n)], \sigma_{i_j})$ for each $\sigma_{i_j}$.
By the above lemma, there exists a $\Lens_j$ for each of these adjacency swaps.
Consider the lens $\Lens = \ComposeLens{\Lens_{i_1}}{\ComposeLens{\Lens_{i_2}}{\ldots \ComposeLens{}{\Lens_{i_m}}}}$
By the semantics, they are the same.

\end{proof}
\end{lemma}

\begin{lemma}[Creation of Lens from Identity Perm DNF Lens]
\label{lem:id-dnf}
If $\Delta \vdash ([\SequenceLens_1 ; \ldots ; \SequenceLens_n],id) \OfType [\Sequence_1 ; \ldots ; \Sequence_n] \Leftrightarrow [\SequenceAlt_1 ; \ldots ; \SequenceAlt_n]$,
and for each $\SequenceLens_i \OfType \Sequence_i \Leftrightarrow \SequenceAlt_i$,
there exists a $\Delta \vdash \Lens_i \OfType \Regex_i \Leftrightarrow \RegexAlt_i$ such that
$\LanguageOf{\Sequence_i}=\LanguageOf{\Regex_i}$, and $\Lens_i.putr = \SequenceLens_i.putr$,
then there exists a $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that $\Lens.putr = ([\SequenceLens_1 ; \ldots ; \SequenceLens_n],id).putr$, $\LanguageOf{[\Sequence_1 ; \ldots ; \Sequence_n]}$ = $\LanguageOf{\Regex}$,
and $\LanguageOf{[\SequenceAlt_1 ; \ldots ; \SequenceAlt_n]}$ = $\LanguageOf{\RegexAlt}$.
\begin{proof}
Base case: $\FullContext \vdash [\SequenceLens_1] \OfType [\Sequence_1] \Leftrightarrow [\SequenceAlt_1]$.  Then consider $\Lens$ = $\Lens_1$, $\Regex = \Regex_1$, $\RegexAlt = \RegexAlt_1$.
$\LanguageOf{[\Sequence_1]} = \LanguageOf{\Sequence_1}$ by definition.\\
$\LanguageOf{[\Sequence_1]} = \LanguageOf{\Regex_1}$ by problem assumption.

Symmetrically for $\LanguageOf{[\SequenceAlt_1]}$.\\
$\PutRightOf{[\SequenceLens]} = \PutRightOf{\SequenceLens}$ by definition\\
$\PutRightOf{[\SequenceLens]} = \PutRightOf{\Lens_1}$ by problem assumption.
\\\\\\



By induction assumption, I know
there exists a $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that
$\Lens.putr = ([\SequenceLens_1 ; \ldots ; \SequenceLens_n],id).putr$,
$\LanguageOf{[\Sequence_1 ; \ldots ; \Sequence_n]}$ =
$\LanguageOf{\Regex}$,
and $\LanguageOf{[\SequenceAlt_1 ; \ldots ; \SequenceAlt_n}$ = $\LanguageOf{\RegexAlt}$.\\
By assumption, I know that there exists a $\Delta \vdash \Lens_{n+1} \OfType \Regex_{n+1} \Leftrightarrow \RegexAlt_{n+1}$ such that $\LanguageOf{\Regex_{n+1}}=\LanguageOf{\Sequence_{n+1}}$
and $\LanguageOf{\RegexAlt_{n+1}}=\LanguageOf{\SequenceAlt_{n+1}}$, where $\Lens_{n+1}.putr=\SequenceLens_{n+1}$.\\
Consider the lens $\FullContext \vdash \OrLens{\Lens}{\Lens_{n+1}} \OfType \RegexOr{\Regex}{\Regex_{n+1}} \Leftrightarrow \RegexOr{\RegexAlt}{\RegexAlt_{n+1}}$.\\
$\LanguageOf{\RegexOr{\Regex}{\Regex_{n+1}}}
= \LanguageOf{\Regex}\cup\LanguageOf{\Delta}{\Regex_{n+1}}$
by definition\\
$\LanguageOf{\RegexOr{\Regex}{\Regex_{n+1}}}
= \LanguageOf{[\Sequence_1; \ldots ; \Sequence_n]}
\cup\LanguageOf{\Regex_{n+1}}$ by induction assumption.\\
$\LanguageOf{\RegexOr{\Regex}{\Regex_{n+1}}}
= \bigcup_{i=1\ldots n}\LanguageOf{\Sequence_i}
\cup\LanguageOf{\Regex_{n+1}}$ by definition.\\
$\LanguageOf{\RegexOr{\Regex}{\Regex_{n+1}}}
= \bigcup_{i=1\ldots n}\LanguageOf{\Sequence_i}
\cup\LanguageOf{\Sequence_{n+1}}$ by problem assumption.\\
$\LanguageOf{\RegexOr{\Regex}{\Regex_{n+1}}}
= \bigcup_{i=1\ldots n+1}\LanguageOf{\Sequence_i}$ by distributivity of $\cup$.\\
$\LanguageOf{\RegexOr{\Regex}{\Regex_{n+1}}}
= \LanguageOf{[\Sequence_1; \ldots ; \Sequence_n]}$ by definition.

Similarly for
$\LanguageOf{\RegexOr{\RegexAlt}{\RegexAlt_{n+1}}}
= \LanguageOf{[\SequenceAlt_1; \ldots ; \SequenceAlt_n]}$ TODO, split into lemma?.\\
\[
\PutRightOf{\OrLens{\Lens}{\Lens_{n+1}}}(\String) =
  \begin{cases}
    \PutRightOf{\Lens}(\String)& \text{if } \String \in \LanguageOf{\Regex}\\
    \Lens_{n+1}.putr(\String)& \text{if } \String \in \LanguageOf{\Regex_{n+1}}
  \end{cases}
\] by definition.\\
\[
\PutRightOf{\OrLens{\Lens}{\Lens_{n+1}}}(\String) =
  \begin{cases}
    \PutRightOf{[\SequenceLens_1;\ldots;\SequenceLens_n}(\String)& \text{if } \String \in \LanguageOf{[\Sequence_1 ; \ldots ; \Sequence_n]}{\Regex}\\
    \Lens_{n+1}.putr(\String)& \text{if } \String \in \LanguageOf{\Regex_{n+1}}
  \end{cases}
\] by induction assumption.\\
\[
\PutRightOf{\OrLens{\Lens}{\Lens_{n+1}}}(\String) =
  \begin{cases}
    \PutRightOf{\SequenceLens_1}(\String)& \text{if } \String \in \LanguageOf{\Sequence_1}\\
\ldots \\
    \PutRightOf{\SequenceLens_n(\String)}& \text{if } \String \in \LanguageOf{\Sequence_n}\\
    \Lens_{n+1}.putr(\String)& \text{if } \String \in \LanguageOf{\Regex_{n+1}}
  \end{cases}
\] by definition of putr.\\
\[
\PutRightOf{\OrLens{\Lens}{\Lens_{n+1}}}(\String) =
  \begin{cases}
    \PutRightOf{\SequenceLens_1}(\String)& \text{if } \String \in \LanguageOf{\Sequence_1}\\
\ldots \\
    \PutRightOf{\SequenceLens_n(\String)}& \text{if } \String \in \LanguageOf{\Sequence_n}\\
    \Sequence_{n+1}.putr(\String)& \text{if } \String \in \LanguageOf{\Sequence_{n+1}}
  \end{cases}
\] by problem assumption.\\
$\PutRightOf{\OrLens{\Lens}{\Lens_{n+1}}}(\String) =
\PutRightOf{[\SequenceLens_1; \ldots ; \SequenceLens_{n+1}]}(\String)$ by definition of putr.\\
\end{proof}
\end{lemma}

\begin{lemma}
If a regular expression is strongly unambiguous, an application of any rule but
\StarstarRule{}, maintains unambiguity.
If a regular expression is not strongly unambiguous, an application of any rule
but \StarstarRule{}, maintains ambiguity.
\end{lemma}
\begin{proof}
TODO: By cases, show each case maintains unambiguity and ambiguity
\end{proof}

\begin{lemma}[Soundness of DNF, Sequence, and Atom Lenses]\leavevmode
\label{lem:dnfcal}
\begin{enumerate}
\item Let \DNFRegex{} and \DNFRegexAlt{} be two dnf regular expressions, and $\FullContext \vdash \DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$.  Then there exists a \Lens{}, \Regex{}, and \RegexAlt{} such that $\FullContext \vdash \Lens \OfType \Regex \Leftrightarrow \RegexAlt$, \PutRightOf{\Lens}=\PutRightOf{\DNFLens}, \LanguageOf{\Regex}=\LanguageOf{\DNFRegex}, and \LanguageOf{\RegexAlt}=\LanguageOf{\DNFRegexAlt}.  \LanguageOf{\Regex{}} = \LanguageOf{\DNFRegex{}} and
\LanguageOf{\RegexAlt{}} = \LanguageOf{\DNFRegexAlt{}}

\item Let \Sequence{} and \SequenceAlt{} be two clauses, and $\FullContext \vdash \SequenceLens \OfType \Sequence \Leftrightarrow \SequenceAlt$.  Then there exists a \Lens{}, \Regex{}, and \RegexAlt{} such that $\FullContext \vdash \Lens \OfType \Regex \Leftrightarrow \RegexAlt$, \PutRightOf{\Lens}=\PutRightOf{\SequenceLens}, \LanguageOf{\Regex}=\LanguageOf{\Sequence}, and \LanguageOf{\RegexAlt}=\LanguageOf{\SequenceAlt}.  \LanguageOf{\Regex{}} = \LanguageOf{\Sequence{}} and
\LanguageOf{\RegexAlt{}} = \LanguageOf{\SequenceAlt{}}

\item Let \Atom{} and \AtomAlt{} be two atoms, and $\FullContext \vdash \AtomLens \OfType \Atom \Leftrightarrow \AtomAlt$.  Then there exists a \Lens{}, \Regex{}, and \RegexAlt{} such that $\FullContext \vdash \Lens \OfType \Regex \Leftrightarrow \RegexAlt$, \PutRightOf{\Lens}=\PutRightOf{\AtomLens}, \LanguageOf{\Regex}=\LanguageOf{\Atom}, and \LanguageOf{\RegexAlt}=\LanguageOf{\AtomAlt}.  \LanguageOf{\Regex{}} = \LanguageOf{\Atom{}} and
\LanguageOf{\RegexAlt{}} = \LanguageOf{\AtomAlt{}}
\end{enumerate}
\begin{proof}
\begin{itemize}\leavevmode\\
\item $\FullContext \vdash ([\SequenceLens_1;\ldots;\SequenceLens_n],\sigma) \OfType [\Sequence_1;\ldots;\Sequence_n] \Leftrightarrow [\SequenceAlt_{\sigma(1)};\ldots;\SequenceAlt_{\sigma(n)}]$ formed from an application of $\DNFLensRule$.
By Induction assumption, for each $\FullContext \vdash \SequenceLens_i \OfType \Sequence_i \Leftrightarrow \SequenceAlt_i$ there exists a $\FullContext \vdash \Lens_i \OfType \Regex_i \Leftrightarrow \RegexAlt_i$.\\
By Lemma~\ref{lem:id-dnf} there exists a $\FullContext \vdash \Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that $\PutRightOf{\Lens}=\PutRightOf{([\SequenceLens_1;\ldots\SequenceLens_n],id)}$,
$\LanguageOf{\Regex}=\LanguageOf{[\Sequence_1;\ldots;\Sequence_n]}$, and
$\LanguageOf{\RegexAlt}=\LanguageOf{[\SequenceAlt_1;\ldots;\SequenceAlt_n]}$.\\
By Lemma TODO, $\PutRightOf{([\SequenceLens_1;\ldots\SequenceLens_n],id)}=\PutRightOf{([\SequenceLens_1;\ldots\SequenceLens_n],\sigma)}$.\\
By Lemma TODO, $\LanguageOf{[\SequenceAlt_1;\ldots;\SequenceAlt_n]}=\LanguageOf{[\SequenceAlt_{\sigma(1)};\ldots;\SequenceAlt_{\sigma(n)}]}$.\\
As such, $\PutRightOf{\Lens}=\PutRightOf{([\SequenceLens_1;\ldots\SequenceLens_n],\sigma)}$,
$\LanguageOf{\Regex}=\LanguageOf{[\Sequence_1;\ldots;\Sequence_n]}$,
and $\LanguageOf{\RegexAlt}=\LanguageOf{[\SequenceAlt_{\sigma(1)};\ldots;\SequenceAlt_{\sigma(n)}]}$.\\

\item $\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$, and the last rule
is an application of DNF rewrite rules.  By Lemma~\ref{lem:language-rewrite-safe},
we know that if $\DNFRegex\RewriteDNF\DNFRegex'$, then
$\LanguageOf{\DNFRegex}=\LanguageOf{\DNFRegex'}$,
so we can merely use the typing before the rewrite.

\item$\FullContext \vdash ([(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)],\sigma \in S_n) \OfType [\String_0 ; \Atom_1 ; \ldots ; \Atom_n ; \String_n] \Leftrightarrow [\StringAlt_0; \AtomAlt_{\sigma(1)} ; \ldots ; \AtomAlt_{\sigma(n)} ; \StringAlt_n]$\\
From induction assumption, I know for each $\FullContext \vdash \AtomLens_i \OfType \Atom_i \Leftrightarrow \AtomAlt_i$, there exists a $\FullContext \vdash \Lens_i \OfType \Regex_i \Leftrightarrow \RegexAlt_i$ such that $\PutRightOf{\AtomLens_i}=\PutRightOf{\Lens_i}$,
and $\LanguageOf{\Regex_i}=\LanguageOf{\Atom_i}$ and $\LanguageOf{\RegexAlt_i}=\LanguageOf{\AtomAlt_i}$.\\
By Lemma~\ref{lem:id-clause}, there exists a $\FullContext \vdash \Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that $\PutRightOf{\Lens}=\PutRightOf{([(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)],id)}$,
$\LanguageOf{\Regex}=\LanguageOf{[\String_0;\Sequence_1;\ldots;\Sequence_n;\String_{n+1}]}$,
$\LanguageOf{\RegexAlt}=\LanguageOf{[\StringAlt_0;\SequenceAlt_1;\ldots;\SequenceAlt_n;\StringAlt_{n+1}]}$.\\
By Lemma~\ref{lem:perm-exp} there exists a $\FullContext \vdash \Lens_{\sigma} \OfType \Regex' \Leftrightarrow \RegexAlt'$,
such that $\PutRightOf{\Lens_{\sigma}}(\StringAlt_0;\StringAlt_1';\StringAlt_1;\ldots;\StringAlt_n'\StringAlt_n)=\StringAlt_0;\StringAlt_{\sigma(1)}';\StringAlt_1;\ldots;\StringAlt_{\sigma(n)}'\StringAlt_n$,
$\LanguageOf{\Regex'}=\LanguageOf{[\String_0;\Sequence_1;\ldots;\Sequence_n;\String_{n+1}]}$, and
$\LanguageOf{\RegexAlt'}=\LanguageOf{[\String_0;\Sequence_{\sigma(1)};\ldots;\Sequence_{\sigma(n)}\String_{n+1}]}$.\\
Consider the lens $\Delta \vdash \ComposeLens{\Lens_{\sigma}}{\Lens} \OfType \Regex \Leftrightarrow \RegexAlt'$.\\
$\PutRightOf{\ComposeLens{\Lens_{\sigma}}{\Lens}}(\String_0\String_1'\ldots\String_n'\String_n)=\PutRightOf{\Lens_{\sigma}}(\PutRightOf{\Lens}(\String_0\String_1'\ldots\String_n'\String_n))$ by definition of compose\\
$\PutRightOf{\ComposeLens{\Lens_{\sigma}}{\Lens}}(\String_0\String_1'\ldots\String_n'\String_n)=\PutRightOf{\Lens_{\sigma}}(\StringAlt_1\PutRightOf{\AtomLens_1}(\String_1')\ldots\PutRightOf{\AtomLens_n}(\String_n')\StringAlt_n)$ by definition of \Lens{}\\
$\PutRightOf{\ComposeLens{\Lens_{\sigma}}{\Lens}}(\String_0\String_1'\ldots\String_n'\String_n)=\StringAlt_1\PutRightOf{\AtomLens_{\sigma(1)}}(\String_{\sigma(1)}')\ldots\PutRightOf{\AtomLens_{\sigma(n)}}(\String_{\sigma(n)}')\StringAlt_n$ by definition of $\Lens_{\sigma}$\\
$\PutRightOf{\ComposeLens{\Lens_{\sigma}}{\Lens}}(\String_0\String_1'\ldots\String_n'\String_n)=([(\String_0,\StringAlt_0);\AtomLens_0;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)],\sigma)(\String_0\String_1'\ldots\String_n'\String_n)$ by definition of clause lens\\
\\
\item$\FullContext \vdash \IterateLens{\DNFLens} \OfType \Star{\DNFRegex} \Leftrightarrow \Star{\DNFRegexAlt}$\\
From induction assumption, I know that there exists $\FullContext \vdash \Lens \OfType \Regex \Leftrightarrow \RegexAlt$, such that
$\PutRightOf{\DNFLens}=\PutRightOf{\Lens}$,
\LanguageOf{\Regex}=\LanguageOf{\DNFRegex}, and
$\LanguageOf{\RegexAlt}=\LanguageOf{\DNFRegexAlt}$.\\
Consider $\FullContext \vdash \IterateLens{\Lens} \OfType \Star{\Regex} \Leftrightarrow \Star{\RegexAlt}$.\\
$\LanguageOf{\Star{\Regex}} = \String_0\ldots\String_n$ such that $\String_i \in \LanguageOf{\Regex}$ by definition of \LanguageOf{\Star{\Regex}}.\\
$\LanguageOf{\Star{\Regex}} = \String_0\ldots\String_n$ such that $\String_i \in \LanguageOf{\DNFRegex}$ as $\LanguageOf{\DNFRegex}=\LanguageOf{\Regex}$.\\
$\LanguageOf{\Star{\Regex}} = \LanguageOf{\Star{\DNFRegex}}$ by definition of \LanguageOf{\Star{\DNFRegex}}.

Similarly for \LanguageOf{\Star{\RegexAlt}}\\\\
$\PutRightOf{\IterateLens{\Lens}}(\String_0\ldots\String_n)=\PutRightOf{\Lens}(\String_0)\ldots\PutRightOf{\Lens}(\String_n)$ by definition of $\PutRightOf{\IterateLens{\Lens}}$.\\
$\PutRightOf{\IterateLens{\Lens}}(\String_0\ldots\String_n)=\PutRightOf{\DNFLens}(\String_0)\ldots\PutRightOf{\DNFLens}(\String_n)$ as \PutRightOf{\DNFLens}=\PutRightOf{\Lens}.\\
$\PutRightOf{\IterateLens{\Lens}}(\String_0\ldots\String_n)=\PutRightOf{\IterateLens{\DNFLens}}(\String_0\ldots\String_n)$ by definition of $\PutRightOf{\IterateLens{\DNFLens}}$.\\
\\
\item$\FullContext \vdash \IdentityLens \OfType \RegexVariable \Leftrightarrow \RegexVariable$\\
Consider $\FullContext \vdash \IdentityLens \OfType \RegexVariable \Leftrightarrow \RegexVariable$\\
$\PutRightOf{\IdentityLens}(\String)=\String$ by definition of dnf \PutRightOf{\IdentityLens{}}.\\
$\PutRightOf{\IdentityLens}(\String)=\PutRightOf{\IdentityLens}(\String)$ by definition of normal $\PutRightOf{\IdentityLens{}}$.
\end{itemize}
\end{proof}
\end{lemma}

\dnfls*
\begin{proof}

The soundess of DNF lenses follows immediatley from Lemma~\ref{lem:dnfcal}

\end{proof}

\begin{theorem}[Strong DNF Lens Soundness]
Let $\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$, be the typing
of a DNF lens $\DNFLens$.
and let $\Regex$ and $\RegexAlt$ be regular expressions, such that
$\LanguageOf{\DNFRegex}=\LanguageOf{\Regex}$,
and $\LanguageOf{\DNFRegexAlt}=\LanguageOf{\RegexAlt}$.
There exists a lens $\Lens : \Regex \Leftrightarrow \RegexAlt$, such that
$\SemanticsOf{\Lens}=\SemanticsOf{\DNFLens}$.
\end{theorem}

\begin{proof}
By Theorem~\ref{thm:dnfls}, there exists regular expressions $\Regex'$,
$\RegexAlt'$, such that there exists a lens $\DNFLens$ such there is the
derivation for a typing.
\begin{mathpar}
\inferrule[]
{
\Derivation{}
}
{
\DNFLens \OfType \Regex' \Leftrightarrow \RegexAlt'
}
\end{mathpar}
\SemanticsOf{\DNFLens}=\SemanticsOf{\Lens},
\LanguageOf{\Regex'}=\LanguageOf{\DNFRegex},
and \LanguageOf{\RegexAlt'}=\LanguageOf{\DNFRegexAlt'}.
Because of this, $\Regex'\equiv\Regex$, and $\RegexAlt'\equiv\RegexAlt$.
Consider the typing
\begin{mathpar}
\inferrule*
{
\inferrule*
{
\Derivation{}
}
{
\DNFLens \OfType \Regex' \Leftrightarrow \RegexAlt'
}\\
\Regex'\equiv\Regex\\
\RegexAlt'\equiv\RegexAlt
}
{
\DNFLens \OfType \Regex \Leftrightarrow \RegexAlt
}
\end{mathpar}

This satisfies the needed requirements!

\end{proof}
