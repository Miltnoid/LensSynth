The growing dependence on big data makes reliably converting
between different data formats increasingly important.
\emph{Lenses} are a bi-directional technique for specifying such
conversions.  Specifically, a lens is a declarative program that
simultaneously specifies a function to convert data from type $A$ to
type $B$ and a second function to convert data from type $B$ to type
$A$.  Such programs usually provide invertibility guarantees, avoiding
pernicious bugs that can corrupt data and downstream processing.
Unfortunately, lenses can be quite difficult to write because they
require programmers to think in two directions at once.  To overcome
this difficulty, we develop an algorithm to automatically synthesize
lenses from format descriptions, specified as regular expressions, and
a small number of examples.  The rich structure of regular expressions
makes lens synthesis more complicated than previous work on other
forms of type-directed synthesis.  Specifically, finding a term to
bi-directionally map between regular expressions $A$ and $B$ requires
first finding equivalent regular expressions $A'$ and $B'$ that are
more algorithmically tractable.
We show how to manage this search by defining a new language of
lenses governed by semi-canonical regular expression types and prove it
sound with respect to a standard language of bijective lenses.  
We then show
how to search the reduced space for well-typed lenses that are consistent
with the given examples.  We demonstrate the effectiveness of our algorithm
by experimenting on a benchmark suite containing 42 examples
comprising microbenchmarks, Flash Fill
examples, and Augeas transformations of Linux configuration files.
We show we are able to infer lenses for most examples in the
benchmark suite in an average of 0.134 seconds. 



%% The language of regular lenses expresses programs which can convert between
%% source and target regular languages.
%% We tackle the task of synthesizing these programs through the regular expressions
%% of their types.
%% This is difficult because we cannot use basic type directed synthesis techniques,
%% as there are many equivalences in the types of these regular expressions.
%% We do this by developing a language for partially normalized regular expressions,
%% and searching through those regular expressions for two that have a lens between
%% them which can be synthesized in a type-directed way.
%% We develop strategies for efficiently enacting this search and synthesis,
%% and evaluate our strategies against a suite of microbenchmarks and linux
%% configuration files.
