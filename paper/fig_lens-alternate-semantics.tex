\begin{figure}[b]
We define the semantics of $\FullContext \vdash \Lens :
\Regex \Leftrightarrow \RegexAlt$ in parallel with its typing
derivation definition.  $\Lens.putl : \LanguageOf{\Delta}{\Regex} \rightarrow \LanguageOf{\Delta}{\RegexAlt}$, defined when $\FullContext \vdash \Lens : \Regex \Leftrightarrow \RegexAlt$ as follows
\centering
\begin{mathpar}
\inferrule[Constant Lens]
{
\String_1 \in \Star{\Sigma}
\String_2 \in \Star{\Sigma}
}
{
\ConstLens{\String_1}{\String_2} : \String_1 \Leftrightarrow \String_2
}
\end{mathpar}
$\ConstLens{\String_1}{\String_2}.putr(\String_1)=\String_2$

\begin{mathpar}
\inferrule[Identity Lens]
{
}
{
\FullContext \vdash \IdentityLens : \Regex \Leftrightarrow \Regex 
}
\end{mathpar}
$\IdentityLens.putr(s)=s$

\begin{mathpar}
\inferrule[Iterate Lens]
{
\FullContext \vdash \Lens : \Regex_1 \Leftrightarrow \Regex_2\and
\UnambigIt{\LanguageOf{\Delta}{\Regex_1}}\and
\UnambigIt{\LanguageOf{\Delta}{\Regex_2}}
}
{
\FullContext \vdash \IterateLens{\Lens} : \Star{\Regex_1} \Leftrightarrow \Star{\Regex_2}
}
\end{mathpar}
${\IterateLens{\Lens}}.putr(\String_1\ldots \String_n) = \Lens.putr(\StringAlt_1)\ldots \Lens.putr(\StringAlt_n)$


\begin{mathpar}
\inferrule[Concat Lens]
{
\FullContext \vdash \Lens_1 : \Regex_1 \Leftrightarrow \RegexAlt_1\\
\FullContext \vdash \Lens_2 : \Regex_2 \Leftrightarrow \RegexAlt_2\\\\
\UnambigConcat{\LanguageOf{\Delta}{\Regex_1}}{\LanguageOf{\Delta}{\Regex_2}}\\
\UnambigConcat{\LanguageOf{\Delta}{\RegexAlt_1}}{\LanguageOf{\Delta}{\RegexAlt_2}}
}
{
\FullContext \vdash \ConcatLens{\Lens_1}{\Lens_2} : \Regex_1\Regex_2 \Leftrightarrow \RegexAlt_1\RegexAlt_2
}
\end{mathpar}
$\ConcatLens{\Lens_1}{\Lens_2}.putr(\String_1\String_2)=\Lens_1.putr(\String_1)\Lens_2.putr(\String_2)$


\begin{mathpar}
\inferrule[Swap Lens]
{
\FullContext \vdash \Lens_1 : \Regex_1 \Leftrightarrow \RegexAlt_1\\
\FullContext \vdash \Lens_2 : \Regex_2 \Leftrightarrow \RegexAlt_2\\\\
\UnambigConcat{\LanguageOf{\Delta}{\Regex_1}}{\LanguageOf{\Delta}{\Regex_2}}\\
\UnambigConcat{\LanguageOf{\Delta}{\RegexAlt_2}}{\LanguageOf{\Delta}{\RegexAlt_1}}
}
{
\FullContext \vdash \SwapLens{\Lens_1}{\Lens_2} : \Regex_1\Regex_2 \Leftrightarrow \RegexAlt_2\RegexAlt_1
}
\end{mathpar}
$\SwapLens{\Lens_1}{\Lens_2}.putr(\String_1\String_2)=\Lens_2.putr(\String_2)\Lens_1.putr(\String_1)$


\begin{mathpar}
\inferrule[Or Lens]
{
\FullContext \vdash \Lens_1 : \Regex_1 \Leftrightarrow \RegexAlt_1\\
\FullContext \vdash \Lens_2 : \Regex_2 \Leftrightarrow \RegexAlt_2\\\\
\UnambigOr{\LanguageOf{\Delta}{\Regex_1}}{\LanguageOf{\Delta}{\Regex_2}}\\ \UnambigOr{\LanguageOf{\Delta}{\RegexAlt_1}}{\LanguageOf{\Delta}{\RegexAlt_2}}
}
{
\FullContext \vdash \OrLens{\Lens_1}{\Lens_2} : \Regex_1 | \RegexAlt_1 \Leftrightarrow \Regex_2 | \RegexAlt_2
}
\end{mathpar}
\[
\PutRightOf{\OrLens{\Lens_1}{\Lens_2}} =
  \begin{cases}
    \Lens_1.putr(s)& \text{if } s \in \LanguageOf{\Delta}{\Regex_1}\\
    \Lens_2.putr(s)& \text{if } s \in \LanguageOf{\Delta}{\Regex_2}
  \end{cases}
\]



\begin{mathpar}
\inferrule[Compose Lens]
{
\FullContext \vdash \Lens_1 : \Regex_1 \Leftrightarrow \Regex_2\\
\FullContext \vdash \Lens_2 : \Regex_2 \Leftrightarrow \Regex_3 
}
{
\FullContext \vdash \ComposeLens{\Lens_2}{\Lens_1} : \Regex_1 \Leftrightarrow \Regex_3
}
\end{mathpar}
$\ComposeLens{\Lens_2}{\Lens_1}(s) = \Lens_2.putr(\Lens_1.putr(s))$


\begin{mathpar}
{
\FullContext \vdash \Lens : \Regex_1 \Leftrightarrow \Regex_2\\
\LanguageOf{\Delta}{\Regex_1} = \LanguageOf{\Delta}{\Regex_1'}\\
\LanguageOf{\Delta}{\Regex_2} = \LanguageOf{\Delta}{\Regex_2'}
}
{
\FullContext \vdash \Lens : \Regex_1' \Leftrightarrow \Regex_2' 
}
\end{mathpar}

\caption{Lens Alternate Semantics and Typing}
\label{fig:lens-alternate-semantics}
\end{figure}
