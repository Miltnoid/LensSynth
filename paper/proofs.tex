\section{Proofs}
%proof-dnfrc start
%First we will prove some lemmas.
\begin{lemma}[Equivalence of \ConcatSequence{} and \Concat{}]
If $\LanguageOf{\Regex}=\LanguageOf{\Sequence}$,
and $\LanguageOf{\RegexAlt}=\LanguageOf{\SequenceAlt}$,
then $\LanguageOf{\RegexConcat{\Regex}{\RegexAlt}}=\LanguageOf{\ConcatSequenceOf{\Sequence}{\SequenceAlt}}$.
\end{lemma}
\begin{proof}
Let $\Sequence=\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
\SequenceSep\Atom_n\SequenceSep\String_n}$, and
let\\ $\SequenceAlt=[\StringAlt_0\SequenceSep\AtomAlt_1\SequenceSep\ldots
\SequenceSep\AtomAlt_m\SequenceSep\StringAlt_m]$\\
\begin{tabular}{@{}L@{}L@{}}
\LanguageOf{\ConcatSequenceOf{\Sequence}{\SequenceAlt}} & = 
\LanguageOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
\SequenceSep\Atom_n\SequenceSep\String_n\Concat\StringAlt_0\SequenceSep{}
\AtomAlt_1\SequenceSep\ldots\SequenceSep\AtomAlt_m\SequenceSep\StringAlt_m}} \\
& = 
\{\String_0\Concat\String_1'\Concat\ldots\Concat\String_n'\Concat\String_n
\Concat\StringAlt_0\Concat\StringAlt_1'\Concat\ldots
\Concat\StringAlt_m'\Concat\StringAlt_m \\
& \hspace{5em} \SuchThat{} \String_i'\in\LanguageOf{\Atom_i} \BooleanAnd{}
\StringAlt_i'\in\LanguageOf{\AtomAlt_i}\}\\
& = 
\{\String\Concat\StringAlt{} \SuchThat{} \String\in\LanguageOf{\Sequence}
\BooleanAnd{} \StringAlt\in\LanguageOf{\SequenceAlt}\}\\
& =
\{\String\Concat\StringAlt{} \SuchThat{} \String\in\LanguageOf{\Regex}
\BooleanAnd{} \StringAlt\in\LanguageOf{\RegexAlt}\}\\
& =
\LanguageOf{\RegexConcat{\Regex}{\RegexAlt}}
\end{tabular}
\end{proof}

\begin{lemma}[Equivalence of \ConcatDNF{} and \Concat{}]
\label{lem:cdnfeq}
If $\LanguageOf{\Regex}=\LanguageOf{\DNFRegex}$,
and $\LanguageOf{\RegexAlt}=\LanguageOf{\DNFRegexAlt}$,
then $\LanguageOf{\RegexConcat{\Regex}{\RegexAlt}}=
\LanguageOf{\ConcatDNFOf{\DNFRegex}{\DNFRegexAlt}}$.
\end{lemma}
\begin{proof}
Let $\DNFRegex=\DNFOf{\Sequence_0\DNFSep\ldots\DNFSep\Sequence_n}$, and
let $\DNFRegexAlt=\DNFOf{\SequenceAlt_0\DNFSep\ldots\DNFSep\SequenceAlt_m}$
\begin{tabular}{@{}L@{}L@{}}
\LanguageOf{\ConcatDNFOf{\DNFRegex}{\DNFRegexAlt}} & = 
\LanguageOf{\DNFOf{\ConcatSequenceOf{\Sequence_i}{\SequenceAlt_j}
\text{ for $i\in\RangeIncInc{1}{n}$, $j\in\RangeIncInc{1}{m}$}}} \\
& = 
\{\String\SuchThat \String\in\ConcatSequenceOf{\Sequence_i}{\SequenceAlt_j}\\
& \hspace{5em}
\text{ where $i\in\RangeIncInc{1}{n}$, $j\in\RangeIncInc{1}{m}$}\}\\
& = 
\{\String\Concat\StringAlt{} \SuchThat{} \String\in\LanguageOf{\Sequence_i}
\BooleanAnd{} \StringAlt\in\LanguageOf{\SequenceAlt_j}\}\\
& \hspace{5em}
\text{ where $i\in\RangeIncInc{1}{n}$, $j\in\RangeIncInc{1}{m}$}\}\\
& =
\{\String\Concat\StringAlt{} \SuchThat{} \String\in\LanguageOf{\DNFRegex}
\BooleanAnd{} \StringAlt\in\LanguageOf{\DNFRegexAlt}\}\\
& =
\{\String\Concat\StringAlt{} \SuchThat{} \String\in\LanguageOf{\Regex}
\BooleanAnd{} \StringAlt\in\LanguageOf{\RegexAlt}\}\\
& =
\LanguageOf{\RegexConcat{\Regex}{\RegexAlt}}
\end{tabular}
\end{proof}

\begin{lemma}[Equivalence of \OrDNF{} and \Or{}]
\label{lem:odnfeq}
If $\LanguageOf{\Regex}=\LanguageOf{\DNFRegex}$,
and $\LanguageOf{\RegexAlt}=\LanguageOf{\DNFRegexAlt}$,
then $\LanguageOf{\RegexOr{\Regex}{\RegexAlt}}=
\LanguageOf{\OrDNFOf{\DNFRegex}{\DNFRegexAlt}}$.
\end{lemma}
\begin{proof}
Let $\DNFRegex=\DNFOf{\Sequence_0\DNFSep\ldots\DNFSep\Sequence_n}$, and
let $\DNFRegexAlt=\DNFOf{\SequenceAlt_0\DNFSep\ldots\DNFSep\SequenceAlt_m}$
\begin{tabular}{@{}L@{}L@{}}
\LanguageOf{\OrDNFOf{\DNFRegex}{\DNFRegexAlt}} & = 
\LanguageOf{\DNFOf{\Sequence_0\DNFSep\ldots\DNFSep\Sequence_n\DNFSep
\SequenceAlt_1\DNFSep\ldots\DNFSep\SequenceAlt_m}}\\
& = 
\{\String\SuchThat{} \String\in\Sequence_i\vee\String\in\SequenceAlt_j\\
& \hspace{5em}
\text{ where $i\in\RangeIncInc{1}{n}$, $j\in\RangeIncInc{1}{m}$}\}\\
& = 
\{\String{} \SuchThat{} \String\in\LanguageOf{\DNFRegex}
\BooleanOr{} \String\in\LanguageOf{\DNFRegexAlt}\}\\
& =
\{\String \SuchThat{} \String\in\LanguageOf{\Regex}
\BooleanOr{} \String\in\LanguageOf{\RegexAlt}\}\\
& =
\LanguageOf{\RegexOr{\Regex}{\RegexAlt}}
\end{tabular}\\
\end{proof}

\dnfrc*
\begin{proof}
By structural induction.

Let $\Regex=\String$.
$\LanguageOf{\ToDNFRegex(\String)}=\LanguageOf{\DNFOf{\SequenceOf{\String}}}=
\{\String\}=\LanguageOf{\String}$

Let $\Regex=\emptyset$.
$\LanguageOf{\ToDNFRegex(\emptyset)}=\LanguageOf{\DNFOf{}} =
\{\} = \LanguageOf{\emptyset}$.

Let $\Regex=\StarOf{\Regex'}$.
By induction assumption, $\LanguageOf{\ToDNFRegex(\Regex')}=
\LanguageOf{\Regex'}$.\\
\begin{tabular}{@{}L@{}L@{}}
\LanguageOf{\ToDNFRegex(\StarOf{\DNFRegex'})} & =
\LanguageOf{\DNFOf{\SequenceOf{\StarOf{\ToDNFRegex(\Regex')}}}}\\
& =
\{\String\SuchThat\String\in
\LanguageOf{\SequenceOf{\StarOf{\ToDNFRegex(\Regex')}}}\}\\
& = 
\{\String\SuchThat{} \String\in\LanguageOf{\StarOf{\ToDNFRegex(\Regex')}}\}\\
& =
\{\String_1\Concat\ldots\Concat\String_n\SuchThat{}
n\in\Nats\\
& \hspace*{3em}\BooleanAnd\String_i\in\LanguageOf{\ToDNFRegex(\Regex')}\}\\
& =
\{\String_1\Concat\ldots\Concat\String_n\SuchThat{}
n\in\Nats\BooleanAnd\String_i\in\LanguageOf{\Regex'}\}\\
& = \LanguageOf{\StarOf{\Regex'}}
\end{tabular}

Let $\Regex=\RegexConcat{\Regex_1}{\Regex_2}$.
By induction assumption,
$\LanguageOf{\ToDNFRegex(\Regex_1)}=\LanguageOf{\Regex_1}$, and
$\LanguageOf{\ToDNFRegex(\Regex_2)}=\LanguageOf{\Regex_2}$.
$\ToDNFRegex(\RegexConcat{\Regex_1}{\Regex_2})=
\ConcatDNFOf{\ToDNFRegex(\Regex_1)}{\ToDNFRegex(\Regex_2)}$.
By Lemma~\ref{lem:cdnfeq},
$\RegexConcat{\Regex_1}{\Regex_2}=
\ConcatDNFOf{\ToDNFRegex(\Regex_1)}{\ToDNFRegex(\Regex_2)}$.

Let $\Regex=\RegexOr{\Regex_1}{\Regex_2}$.
By induction assumption,
$\LanguageOf{\ToDNFRegex(\Regex_1)}=\LanguageOf{\Regex_1}$, and
$\LanguageOf{\ToDNFRegex(\Regex_2)}=\LanguageOf{\Regex_2}$.
$\ToDNFRegex(\RegexOr{\Regex_1}{\Regex_2})=
\OrDNFOf{\ToDNFRegex(\Regex_1)}{\ToDNFRegex(\Regex_2)}$.
By Lemma~\ref{lem:odnfeq},
$\RegexOr{\Regex_1}{\Regex_2}=
\OrDNFOf{\ToDNFRegex(\Regex_1)}{\ToDNFRegex(\Regex_2)}$.
\end{proof}
%proof-dnfrc end



%proof-dnfrs start
%First we will prove some lemmas.
\begin{lemma}
\label{lem:sequence-rx}
Let $\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_n\SequenceSep\String_n}$ be a sequence,
and\\
$\ToDNFRegex(\ToRegex(\Atom_i))=\DNFOf{\SequenceOf{\Atom_i}}$.
Then,\\$\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_n\SequenceSep\String_n}))=$\\
$\DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_n\SequenceSep\String_n}}$.
\end{lemma}
\begin{proof}
By induction on $n$.

Let $n=0$.
$\Sequence=\SequenceOf{\String_0}$.\\
$\ToDNFRegex(\ToRegex(\SequenceOf{\String_0}))=
\ToDNFRegex(\String_0)=\DNFOf{\SequenceOf{\String_0}}$

Let $n>0$,
$\Sequence=\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_n\SequenceSep\String_n}$.\\
$\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_n\SequenceSep\String_n}))$\\
$\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_{n-1}\SequenceSep\String_{n-1}})\Concat\ToRegex(\Atom_n)
\Concat\String_n)$=\\
$\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_{n-1}\SequenceSep\String_{n-1}}))
\ConcatDNF\\
\ToDNFRegex(\ToRegex(\Atom_n))
\ConcatDNF\\
\ToDNFRegex(\String_{n-1})$=
$\DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_{n-1}\SequenceSep\String_{n-1}}}
\ConcatDNF\\
\DNFOf{\SequenceOf{\Atom_n}}
\ConcatDNF
\DNFOf{\SequenceOf{\String_n}}$=
$\DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_n\SequenceSep\String_n}}$.
\end{proof}



\begin{lemma}
\label{lem:dnf-rx}
Let $\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}$ be a sequence,
and\\ $\ToDNFRegex(\ToRegex(\Sequence_i))=\DNFOf{\Sequence_i}$.
Then,\\ $\ToDNFRegex(\ToRegex(\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}))=
\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}$.
\end{lemma}
\begin{proof}

By induction on $n$.

Let $n=0$
$\ToDNFRegex(\ToRegex(\DNFOf{}))=\ToDNFRegex(\emptyset)=\DNFOf{}$.

Let $n>0$
$\ToDNFRegex(\ToRegex(\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_n}))=
\ToDNFRegex(\ToRegex(\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_{n-1}})
\Concat\ToRegex(\Sequence_n))$=
$\ToDNFRegex(\ToRegex(\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_{n-1}}))
\ConcatDNF\\\ToDNFRegex(\ToRegex(\Sequence_n))$=
$\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_n}$
\end{proof}

\begin{lemma}[Elimination of $\ToDNFRegex\Compose\ToRegex$]\leavevmode
\begin{enumerate}
\item $\ToDNFRegex(\ToRegex(\Atom))=\DNFOf{\SequenceOf{\Atom}}$
\item $\ToDNFRegex(\ToRegex(\Sequence))=\DNFOf{\Sequence}$
\item $\ToDNFRegex(\ToRegex(\DNFRegex))=\DNFRegex$
\end{enumerate}
\end{lemma}
\begin{proof}
By mutual induction

Let $\StarOf{\DNFRegex}$ be an atom.
$\ToDNFRegex(\ToRegex(\StarOf{\DNFRegex}))=
\ToDNFRegex(\StarOf{\ToRegex(\DNFRegex)})=
\DNFOf{\SequenceOf{\StarOf{\ToDNFRegex(\ToRegex(\DNFRegex))}}}=
\DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}$

Let $\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
\SequenceSep\Atom_n\SequenceSep\String_n}$ be a sequence.
$\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
\SequenceSep\Atom_n\SequenceSep\String_n}))$.
By induction assumption, for each $\Atom_i$,
$\ToDNFRegex(\ToRegex(\Atom_i))=\DNFOf{\SequenceOf{\Atom_i}}$.
By Lemma~\ref{lem:sequence-rx},
$\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
\SequenceSep\Atom_n\SequenceSep\String_n}))=
\DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
\SequenceSep\Atom_n\SequenceSep\String_n}}$.

Let $\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_n}$ be a DNF
regular expression.
By induction assumption, for each $\Sequence_i$,
$\ToDNFRegex(\ToRegex(\Sequence_i))=\DNFOf{\Sequence_i}$.
By Lemma~\ref{lem:dnf-rx},
$\ToDNFRegex(\ToRegex(\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_n}))=
\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_n}$.

\end{proof}
%proof-dnfrs end




%proof-dnfls start
%We will prove a couple of lemmas first.

\begin{lemma}[Expressibility of Safe Boilerplate Alterations]
\label{lem:boilerplate-alterations}
Suppose
\begin{enumerate}
\item $\UnambigConcat\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}$
\item $\UnambigConcat\SequenceOf{\StringAlt_0;\Atom_1;\ldots;\Atom_n;\StringAlt_n}$
\end{enumerate}
Then there exists a lens
$\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that
\begin{enumerate}
\item $\Regex = \ToRegex(\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n})$
\item $\RegexAlt = \ToRegex(\SequenceOf{\StringAlt_0;\Atom_1;\ldots;\Atom_n;\StringAlt_n})$
\item $\SemanticsOf{\Lens}=\SetOf{(\String,\StringAlt)\SuchThat
\String=\String_0\Concat\String_1'\Concat\ldots\Concat\String_n'\Concat\String_n
\BooleanAnd\\
\hspace*{6.1em}\StringAlt=\StringAlt_0\Concat\String_1'\Concat\ldots\Concat\String_n'\Concat\StringAlt_n
\BooleanAnd\\
\hspace*{6.1em}\String_i\in\LanguageOf{\Atom_i}}$
\end{enumerate}
\end{lemma}
\begin{proof}
By induction on $n$.

Let $n=0$.
Consider the Lens
\begin{mathpar}
\inferrule*
{
}
{
\ConstLens{\String_0}{\StringAlt_0} \OfType \String_0 \Leftrightarrow \StringAlt_0
}
\end{mathpar}
By inspection, this satisfies the desired properties.

Let $n>0$.
By induction, there exists a lens $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$
satisfying the desired properties.
Consider the lens
\begin{mathpar}
\inferrule*[left=\Derivation]
{
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens \OfType \Regex \Leftrightarrow \RegexAlt
}\\
\inferrule*
{
}
{
\ConstLens{\String_n}{\StringAlt_n} \OfType \String_n \Leftrightarrow \StringAlt_n
}
}
{
\ConcatLens{\Lens}{\ConstLens{\String_n}{\StringAlt_n}}
\OfType
\Regex \Concat \String_n \Leftrightarrow
\RegexAlt \Concat \StringAlt_n
}

\inferrule*
{
\Derivation\\
\IdentityLensOf{\ToRegex(\Atom_n)} \OfType \ToRegex(\Atom_n) \Leftrightarrow \ToRegex(\Atom_n)
}
{
\ConcatLens{\ConcatLens{\Lens}{\ConstLens{\String_n}{\StringAlt_n}}}{\IdentityLensOf{\ToRegex(\Atom_n)}}
\OfType\\
\Regex \Concat \String_n \Concat \ToRegex(\Atom_n) \Leftrightarrow
\Regex \Concat \StringAlt_n \Concat \ToRegex(\Atom_n)
}
\end{mathpar}
By inspection, this satisfies the desired properties.
\end{proof}

\begin{lemma}[Creation of Lens from Identity Perm Sequence Lens]
\label{lem:id-clause}
Suppose
\begin{enumerate}
\item $\Sequence=\SequenceOf{\String_0 ; \Atom_1 ; \ldots ; \Atom_n; \String_n}$
\item $\SequenceAlt=\SequenceOf{\StringAlt_0 ; \AtomAlt_1 ; \ldots ; \AtomAlt_n ; \StringAlt_n}$
\item $(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1 ; \ldots ;
	\AtomLens_n;(\String_n,\StringAlt_n)},id) \OfType
	\Sequence \Leftrightarrow \SequenceAlt$
\item For each $\AtomLens_i \OfType \Atom_i \Leftrightarrow \AtomAlt_i$,
there exists a $\Lens_i \OfType \ToRegex(\Atom_i) \Leftrightarrow
\ToRegex(\AtomAlt_i)$ such that $\SemanticsOf{\Lens_i}=\SemanticsOf{\AtomLens_i}$
\end{enumerate}
then there exists a $\Lens \OfType \ToRegex(\Sequence) \Leftrightarrow \ToRegex(\DNFRegexAlt)$ such that
$\SemanticsOf{\Lens} =
\SemanticsOf{(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1 ; \ldots ; \AtomLens_n;(\String_n,\StringAlt_n)},id)}$.
\begin{proof}
By induction on $n$.

Let $n=0$, $(\SequenceLensOf{(\String_0,\StringAlt_0)},id) \OfType
\SequenceOf{\String_0} \Leftrightarrow \SequenceOf{\StringAlt_0}$.
Then consider
\begin{mathpar}
\inferrule[]
{
}
{
\ConstLens{\String_0}{\StringAlt_0}\OfType\String_0\Leftrightarrow\StringAlt_0
}
\end{mathpar}

$\String_0=\ToRegex(\SequenceOf{\String_0})$,
and
$\StringAlt_0=\ToRegex(\SequenceOf{\StringAlt_0})$.
$\SemanticsOf{\ConstLens{\String_0}{\StringAlt_0}}=
\SetOf{\String_0,\StringAlt_0}=
\SemanticsOf{\SequenceOf{(\String_0,\StringAlt_0)},id)}$.

Let $n>0$.
Let $\Sequence'=\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\SequenceSep\Atom_{n-1}\SequenceSep\String_{n-1}}$,
and $\SequenceAlt'=\SequenceOf{\StringAlt_0\SequenceSep\AtomAlt_1\SequenceSep
\ldots\SequenceSep\AtomAlt_{n-1}\SequenceSep\StringAlt_{n-1}}$
By induction assumption, there exists a typing derivation
\begin{mathpar}
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens\OfType\ToRegex(\Sequence')\Leftrightarrow\ToRegex(\SequenceAlt')
}
\end{mathpar}
satisfying $\SemanticsOf{\Lens}=\\
\SemanticsOf{(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1 ;
\ldots ; \AtomLens_{n-1};(\String_{n-1},\StringAlt_{n-1})},id)}$

By problem statement, there exists a typing derivation
\begin{mathpar}
\inferrule*[left=$\Derivation_n$]
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens_{\AtomLens_{n}} \OfType
\ToRegex(\Atom_{n}) \Leftrightarrow \ToRegex(\AtomAlt_{n})
}
\end{mathpar}
satisfying $\SemanticsOf{\Lens_{\Atom_n}}
=\SemanticsOf{\Atom_n}$.

Consider the following lens typing
\begin{mathpar}
\inferrule*[left=\Derivation{}]
{
\Derivation_n\\
\inferrule*
{
}
{
\ConstLens{\String_n}{\StringAlt_n}
\OfType
\String_n \Leftrightarrow \StringAlt_n
}
}
{
\ConcatLens{\Lens_{\AtomLens_n}}{\ConstLens{\String_n}{\StringAlt_n}}
\OfType
\ToRegex(\Atom_n)\Concat\String_n \Leftrightarrow
\ToRegex(\AtomAlt_n)\Concat\StringAlt_n
}

\inferrule*{
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens\OfType\ToRegex(\Sequence) \Leftrightarrow \ToRegex(\SequenceAlt)
}\\
\Derivation{}
}
{
\ConcatLens
{\Lens}
{\ConcatLens{\Lens_{\AtomLens_n}}{\ConstLens{\String_n}{\StringAlt_n}}}
\OfType\\
\ToRegex(\Sequence)\Concat\ToRegex(\Atom_n)\Concat\String_n \Leftrightarrow
\ToRegex(\SequenceAlt)\Concat\ToRegex(\AtomAlt_n)\Concat\StringAlt_n
}
\end{mathpar}

\SemanticsOf{\ConcatLens
{\Lens}
{\ConcatLens{\Lens_{\AtomLens_n}}{\ConstLens{\String_n}{\StringAlt_n}}}}\\
\hspace*{3em}=\SetOf{(\String,\StringAlt)
\SuchThat
\String = \String'\Concat\String''\Concat\String_n\BooleanAnd
\StringAlt = \StringAlt'\Concat\StringAlt''\Concat\StringAlt_n\BooleanAnd\\
\hspace*{7em}
(\String',\StringAlt')\in\SemanticsOf{\Lens}\BooleanAnd
(\String'',\StringAlt'')\in\SemanticsOf{\Lens_{\AtomLens_n}}}\\
\hspace*{3em}=\SetOf{
(\String,\StringAlt)\SuchThat
\String=
\String_0\Concat\String_0'\Concat\ldots
\Concat\String_{n-1}'\Concat\String_{n-1}
\Concat \String_n \Concat \String_n'\BooleanAnd\\
\hspace*{7em}\StringAlt=\StringAlt_0\Concat\StringAlt_0'\Concat\ldots
\Concat\StringAlt_{n-1}'\Concat\StringAlt_{n-1}
\Concat \StringAlt_n \Concat \StringAlt_n'\BooleanAnd\\
\hspace*{7em}\String_i'\in\Atom_i\BooleanAnd\StringAlt_i'\in\AtomAlt_i}\\
\hspace*{3em}=\SemanticsOf{(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1 ;
\ldots ; \AtomLens_n;(\String_n,\StringAlt_{n-1})},id)}
\end{proof}
\end{lemma}

\begin{theorem}[Unambiguity of $\Sep$]
Let $\Alphabet$ be an alphabet.  Let $\Alphabet_{\Sep}=\Alphabet\Union\SetOf{\Sep}$,
where \Sep{} is a character not in \Alphabet{}.
If $\Language_1, \ldots,
\Language_n$, are languages in $\StarOf{\Alphabet}$, then
$\UnambigConcat\SequenceOf{\LanguageOf{\Sep};\Language_1;\LanguageOf{\Sep};
\ldots;\LanguageOf{\Sep};\Language_n;\LanguageOf{\Sep}}$.
\end{theorem}
\begin{proof}
We prove this by induction on $n$.

Let $n=0$.  $\UnambigConcat\SequenceOf{\LanguageOf{\Sep}}$, as
$\UnambigConcat\SequenceOf{\Language}$, for any language $\Language$.

Let $n>0$.
Let $\String_i, \StringAlt_i\in\Language_i$ for all $i\in\RangeIncInc{1}{n}$,
and let $\Sep\String_1\Sep\ldots\Sep\String_n\Sep=\Sep\StringAlt_1\Sep\ldots\Sep\StringAlt_n\Sep$.
We want to show that $\String_n\Sep=\StringAlt_n\Sep$.
If they were not equal, then one string is strictly contained in the other, say without
loss of generality $\String_n\Sep$ is strictly contained in $\StringAlt_n\Sep$.
Because of that $\Sep\String_n\Sep$ is contained in $\StringAlt_n\Sep$, so $\Sep$
is contained in $\StringAlt_n\in\StarOf{\Sigma}$.  This is a contradiction,
as $\Sep\notin\Sigma$, so we know $\String_n\Sep=\StringAlt_n\Sep$, and so $\String_n=\StringAlt_n$.
This means that
$\Sep\String_0\Sep\ldots\Sep\String_{n-1}\Sep=\Sep\StringAlt_0\Sep\ldots\Sep\StringAlt_{n-1}$,
so by induction, I know $\String_i=\StringAlt_i$ for all $i$.
\end{proof}

\begin{definition}[Adjacent Swapping Permutation]
Let $\sigma_{i} \in S_n$ be the permutation where
$\sigma_{i}(i) = i+1$, $\sigma_{i}(i+1) = i$, $\sigma_{i}(k) = k$
when $k\neq i$, and $k\neq i+1$.
\end{definition}

\begin{lemma}[Expressibility of Adjacent Swapping Permutation Lens]
\label{lem:adj-perm-exp}
Suppose
\begin{enumerate}
\item $\sigma_i$ is an adjacent element swapping permutation
\item $\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep}$ is a sequence with
all base strings equal to $\Sep$.
\end{enumerate}
Then there exists a typing of a lens $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that
\begin{enumerate}
\item $\LanguageOf{\Regex}=\LanguageOf{[\Sep;\Atom_1;\ldots;\Atom_n;\Sep]}$
\item $\LanguageOf{\RegexAlt}=\LanguageOf{[\Sep;\Atom_{\sigma_i(1)};\ldots;\Atom_{\sigma_i(n)};\Sep]}$
\item $\SemanticsOf{\Lens}=
\SetOf{(\String,\StringAlt)\SuchThat\String=\Sep\Concat\String_1\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_n\Concat\Sep
\BooleanAnd\\
\hspace*{6em}\StringAlt=\Sep\Concat\String_{\sigma_i(1)}\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_{\sigma_i(n)}\Sep\BooleanAnd\\
\hspace*{6em}\String_i\in\LanguageOf{\Atom_i}}$
\end{enumerate}
\begin{proof}
By the soundness of regular expressions, define regular expressions
$\Regex_1, \Regex_2, \Regex_3, \Regex_4$ as
$\Regex_1=\ToRegex([\Sep;\Atom_1;\ldots;\Atom_{i-1};\Sep])$,
$\Regex_2=\ToRegex(\Atom_i)$,
$\Regex_3=\ToRegex(\Atom_{i+1})$, and
$\Regex_4=\ToRegex([\Sep;\Atom_{i+1};\ldots;\Atom_{n};\Sep])$.
Consider the following deduction\bcp{I find these deductions a bit heavy and
  hard to read, but I guess I can get used to them.  }
\afm{Anybody have suggestions for better deduction package?}
\begin{mathpar}

\inferrule*[left=\Derivation{}]
{
\inferrule*
{
}
{
\IdentityLensOf{\Sep} \OfType \Sep \Leftrightarrow \Sep
}
\inferrule*
{
}
{
\IdentityLensOf{\Regex_3} \OfType \Regex_3 \Leftrightarrow \Regex_3
}
}
{
\SwapLens{\IdentityLensOf{\Sep}}{\IdentityLensOf{\Regex_3}} \OfType 
\Sep\Concat\Regex_3 \Leftrightarrow \Regex_3\Concat\String_i
}

\inferrule*[left=\Derivation{}']
{
\inferrule*
{
}
{
\IdentityLensOf{\Regex_2} \OfType \Regex_2 \Leftrightarrow \Regex_2
}\\
\Derivation
}
{
\SwapLens{\IdentityLensOf{\Regex_2}}{\SwapLensShort{\IdentityLensShortOf{\Sep}}{\IdentityLensShortOf{\Regex_3}}} \OfType
\Regex_2\Concat\Sep\Concat\Regex_3 \Leftrightarrow \Regex_3\Concat\Sep\Concat\Regex_2
}

\inferrule*[left=\Derivation{}'']
{
\inferrule*
{
}
{
\IdentityLensOf{\Regex_1} \OfType \Regex_1 \Leftrightarrow \Regex_1
}\\
\Derivation{}'
}
{
\ConcatLens{\IdentityLensOf{\Regex_1}}{\SwapLensShort{\IdentityLensShortOf{\Regex_2}}{\SwapLensShort{\IdentityLensShortOf{\Sep}}{\IdentityLensShortOf{\Regex_3}}}} \OfType\\
\Regex_1\Concat\Regex_2\Concat\Sep\Concat\Regex_3 \Leftrightarrow \Regex_1\Concat\Regex_3\Concat\Sep\Concat\Regex_2
}


\inferrule*
{
\Derivation{}''\\
\inferrule*
{
}
{
\IdentityLensOf{\Regex_4} \OfType \Regex_4 \Leftrightarrow \Regex_4
}
}
{
\ConcatLens{\ConcatLensShort{\IdentityLensShortOf{\Regex_1}}{\SwapLensShort{\IdentityLensShortOf{\Regex_2}}{\SwapLensShort{\IdentityLensShortOf{\Sep}}{\IdentityLensShortOf{\Regex_3}}}}}{\IdentityLensOf{\Regex_4}} \OfType\\
\Regex_1\Concat\Regex_2\Concat\Sep\Concat\Regex_3\Concat\Regex_4 \Leftrightarrow \Regex_1\Concat\Regex_3\Concat\Sep\Concat\Regex_2\Concat\Regex_4
}
\end{mathpar}

By inspection, the final lens
$\ConcatLensShort{\ConcatLensShort{\IdentityLensShortOf{\Regex_1}}{\SwapLensShort{\IdentityLensShortOf{\Regex_2}}{\SwapLensShort{\IdentityLensShortOf{\Sep}}{\IdentityLensShortOf{\Regex_3}}}}}{\IdentityLensShortOf{\Regex_4}} \OfType
\Regex_1\Concat\Regex_2\Concat\Sep\Concat\Regex_3\Concat\Regex_4 \Leftrightarrow \Regex_1\Concat\Regex_3\Concat\Sep\Concat\Regex_2\Concat\Regex_4$
satisfies $\LanguageOf{\Regex_1\Concat\Regex_2\Concat\String_i\Concat\Regex_3\Concat\Regex_4}=\LanguageOf{\SequenceOf{\Sep;\Atom_1;\Sep;\ldots;\Sep;\Atom_n;\Sep}}$ and
$\LanguageOf{\Regex_1\Concat\Regex_3\Concat\String_i\Concat\Regex_2\Concat\Regex_4}=\LanguageOf{\SequenceOf{\Sep;\Atom_{\sigma_i(1)};\ldots;\Atom_{\sigma_i(n)};\Sep}}$
and has the desired semantics of swapping the strings at spots $i$ and $i+1$.
\end{proof}
\end{lemma}

\begin{lemma}[Expressibility of Adjacent Swapping Permutation Composition]
\label{lem:adj-comp-perm-exp}
Suppose
\begin{enumerate}
\item $\sigma=\sigma_{i_1}\Compose\ldots\Compose\sigma_{i_m}$ 
\item $\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep}$ is a sequence with
all base strings equal to $\Sep$.
\end{enumerate}
Then there exists a typing of a lens $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that
\begin{enumerate}
\item $\LanguageOf{\Regex}=\LanguageOf{[\Sep;\Atom_1;\ldots;\Atom_n;\Sep]}$
\item $\LanguageOf{\RegexAlt}=\LanguageOf{[\Sep;\Atom_{\sigma(1)};\ldots;\Atom_{\sigma(n)};\Sep]}$
\item $\SemanticsOf{\Lens}=
\SetOf{(\String,\StringAlt)\SuchThat\String=\Sep\Concat\String_1\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_n\Concat\Sep
\BooleanAnd\\
\hspace*{6em}\StringAlt=\Sep\Concat\String_{\sigma(1)}\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_{\sigma(n)}\Sep\BooleanAnd\\
\hspace*{6em}\String_i\in\LanguageOf{\Atom_i}}$
\end{enumerate}
\begin{proof}
By induction on $m$.

Let $m=0$.  Then $\sigma=\Identity$.  Consider the lens
$\IdentityLensOf{\ToRegex(\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep})} \OfType
\ToRegex(\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep}) \Leftrightarrow
\ToRegex(\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep})$.
By inspection, this lens satisfies the requirements.

Let $m>0$.  Let $\sigma'=\sigma_{i_1}\Compose\ldots\Compose\sigma_{i_{m-1}}$.
Let $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ be the lens obtained by an
application of the induction assumption on $\sigma'$.
Let $\Lens_m \OfType \RegexAlt' \Leftrightarrow \RegexAlt''$ be the lens obtained by
an application of Lemma~\ref{lem:adj-perm-exp} to the permutation $\sigma_m$ and
the sequence $\SequenceOf{\Sep;\Atom_{\sigma'(1)};\ldots;\Atom_{\sigma'(n)};\Sep}$.
From the induction assumption and the previous lemmas,
we know $\LanguageOf{\RegexAlt}=
\LanguageOf{\SequenceOf{\Sep;\Atom_{\sigma'(1)};\ldots;\Atom_{\sigma'(n)};\Sep}}=
\LanguageOf{\RegexAlt'}$.
Consider the following Lens typing

\begin{mathpar}
\inferrule*
{
\inferrule*
{
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens \OfType \Regex \Leftrightarrow \RegexAlt
}\\
\LanguageOf{\RegexAlt}=\LanguageOf{\RegexAlt'}
}
{
\Lens \OfType \Regex \Leftrightarrow \RegexAlt'
}\\
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens_m \OfType \RegexAlt' \Leftrightarrow \RegexAlt''
}
}
{
\ComposeLens{\Lens_m}{\Lens} \OfType \Regex \Leftrightarrow \RegexAlt''
}
\end{mathpar}

The language of \Regex{} is already as desired, and
$\LanguageOf{\RegexAlt''}=
\LanguageOf{\SequenceOf{\Sep;\Atom_{\sigma_m\Compose\sigma'(1)};\ldots;\Atom_{\sigma_m\Compose\sigma'(n)}}}=
\LanguageOf{\SequenceOf{\Sep;\Atom_{\sigma(1)};\ldots;\Atom_{\sigma(n)}}}$, as desired.
Furthermore, the composition of the lenses composes the permutations of strings,
giving the semantics as desired.
\end{proof}
\end{lemma}

\begin{lemma}[Expressibility of Permutation]
\label{lem:perm-exp}
Suppose
\begin{enumerate}
\item $\sigma$ is a permutation in $S_n$
\item $\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep}$ is a sequence with
all base strings equal to $\Sep$.
\end{enumerate}
Then there exists a typing of a lens $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that
\begin{enumerate}
\item $\LanguageOf{\Regex}=\LanguageOf{[\Sep;\Atom_1;\ldots;\Atom_n;\Sep]}$
\item $\LanguageOf{\RegexAlt}=\LanguageOf{[\Sep;\Atom_{\sigma(1)};\ldots;\Atom_{\sigma(n)};\Sep]}$
\item $\SemanticsOf{\Lens}=
\SetOf{(\String,\StringAlt)\SuchThat\String=\Sep\Concat\String_1\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_n\Concat\Sep
\BooleanAnd\\
\hspace*{6em}\StringAlt=\Sep\Concat\String_{\sigma(1)}\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_{\sigma(n)}\Sep\BooleanAnd\\
\hspace*{6em}\String_i\in\LanguageOf{\Atom_i}}$
\end{enumerate}
\end{lemma}
\begin{proof}
By algebra, any permutation can be expressed as the composition of adjacent swapping permutations.
As such, $\sigma=\sigma_{i_1}\Compose\ldots\Compose\sigma_{i_m}$ for some adjacency swapping
permutations $\sigma_{i_j}$.
By Lemma~\ref{lem:adj-comp-perm-exp}, we obtain a lens with the properties desired.
\end{proof}

\begin{lemma}[Creation of Lens from Identity Perm DNF Lens]
\label{lem:id-dnf}
Suppose
\begin{enumerate}
\item $\DNFRegex = \DNFOf{\Sequence_1 ; \ldots ; \Sequence_n}$
\item $\DNFRegexAlt = \DNFOf{\SequenceAlt_1 ; \ldots ; \SequenceAlt_n}$
\item $(\DNFLensOf{\SequenceLens_1 ; \ldots ; \SequenceLens_n},id) \OfType
\DNFRegex \Leftrightarrow \DNFRegexAlt$
\item For each $\SequenceLens_i \OfType \Sequence_i \Leftrightarrow \SequenceAlt_i$,
there exists a $\Lens_i$ such that $\SemanticsOf{\Lens_i}=\SemanticsOf{\SequenceLens_i}$.
\end{enumerate}
then there exists a $\Lens \OfType \ToRegex(\DNFRegex) \Leftrightarrow \ToRegex(\DNFRegexAlt)$ such that $\SemanticsOf{\Lens} = \SemanticsOf{([\SequenceLens_1 ; \ldots ; \SequenceLens_n],id)}$.
\begin{proof}
By induction on n

Let $n=0$.
$\DNFLensOf{} \OfType \DNFOf{} \Leftrightarrow \DNFOf{}$.  Then consider
\begin{mathpar}
\inferrule*
{
}
{
\IdentityLensOf{\ToRegex(\DNFOf{})} \OfType
\ToRegex(\DNFOf{}) \Leftrightarrow \ToRegex(\DNFOf{})
}
\end{mathpar}
This has the desired typing, and
$\SemanticsOf{\IdentityLensOf{\ToRegex(\DNFOf{})}}
=\SemanticsOf{\IdentityLensOf{\emptyset}}
=\SetOf{}=\SemanticsOf{\DNFLensOf{}}$.

Let $n>0$.
Let $\DNFRegex' = \DNFOf{\Sequence_1;\ldots;\Sequence_{n-1}}$, and
$\DNFRegexAlt' = \DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_{n-1}}$.
By induction assumption, there exists a derivation of 
$\Lens \OfType \ToRegex(\DNFRegex') \Leftrightarrow \ToRegex(\DNFRegexAlt')$.
By problem statement, there exists a typing derivation
$\Lens_n \OfType \ToRegex(\Sequence_n) \Leftrightarrow \ToRegex(\SequenceAlt_n)$
Consider the following derivation
\begin{mathpar}
\inferrule*
{
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens \OfType \ToRegex(\DNFRegex') \Leftrightarrow \ToRegex(\DNFRegexAlt')
}\\
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens_n \OfType \ToRegex(\Sequence_n) \Leftrightarrow \ToRegex(\SequenceAlt_n)
}
}
{
\OrLens{\Lens_n}{\Lens} \OfType \RegexOr{\ToRegex(\DNFRegex')}{\ToRegex(\Sequence_n)} \Leftrightarrow \RegexOr{\ToRegex(\DNFRegexAlt')}{\ToRegex(\Sequence_n)}
}
\end{mathpar}
$\SemanticsOf{\OrLens{\Lens}{\Lens_n}}=\SetOf{(\String,\StringAlt)\SuchThat
(\String,\StringAlt)\in\Lens\BooleanOr(\String,\StringAlt)\in\Lens_n}$\\
\hspace*{4.6em}$=\SetOf{(\String,\StringAlt)\SuchThat
(\String,\StringAlt)\in\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_{n-1}}\\
\hspace*{8em}\BooleanOr(\String,\StringAlt)\in\DNFLensOf{\SequenceLens_n}}$\\
\hspace*{4.6em}$=\SetOf{(\String,\StringAlt)\SuchThat
(\String,\StringAlt)\in\SequenceLens_i}$.
\end{proof}
\end{lemma}

\begin{lemma}[Ineffectiveness of Permutation on DNF Regex Semantics]
\label{lem:dnfr-perm-sem-ineffective}
Let $\sigma\in S_n$, and $\DNFOf{\Sequence_1\ldots\Sequence_n}$ be a DNF regex.
$\LanguageOf{\DNFOf{\Sequence_1;\ldots;\Sequence_n}}=
\LanguageOf{\DNFOf{\Sequence_{\sigma(1)};\ldots;\Sequence_{\sigma(n)}}}$.
\end{lemma}
\begin{proof}
By inspection.
\end{proof}

\begin{lemma}[Ineffectiveness of Permutation on DNF Lens Semantics]
\label{lem:dnfl-perm-sem-ineffective}
Let $\sigma\in S_n$, and
$(\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n},\Identity) \OfType
\DNFOf{\Sequence_1;\ldots;\Sequence_n} \Leftrightarrow
\DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_n}$ be a typing of a DNF lens with
an identity permutation.
$\SemanticsOf{(\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n},\Identity)}
=\SemanticsOf{(\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n},\sigma)}$
\end{lemma}
\begin{proof}
By inspection
\end{proof}

\begin{lemma}[Rewrites Respecting Language]
\label{lem:rrl}
If $\DNFRegex\Rewrite\DNFRegexAlt$, then $\LanguageOf{\DNFRegex}=\LanguageOf{\DNFRegexAlt}$
\end{lemma}
\begin{proof}
Each of the rewrite rules are merely an application of one direction of one of
the regular expression star equivalences.
\end{proof}

\begin{lemma}[Soundness of DNF, Sequence, and Atom Lenses]\leavevmode
\label{lem:dnfcal}
\begin{enumerate}
\item Let \DNFRegex{} and \DNFRegexAlt{} be two dnf regular expressions, and $\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$.  Then there exists a \Lens{} such that $\Lens \OfType \ToRegex(\DNFRegex) \Leftrightarrow \ToRegex(\DNFRegexAlt)$, \SemanticsOf{\Lens}=\SemanticsOf{\DNFLens}

\item Let \Sequence{} and \SequenceAlt{} be two clauses, and $\SequenceLens \OfType \Sequence \Leftrightarrow \SequenceAlt$.  Then there exists a \Lens{} such that $\Lens \OfType \ToRegex(\Sequence) \Leftrightarrow \ToRegex(\SequenceAlt)$, \SemanticsOf{\Lens}=\SemanticsOf{\SequenceLens}.

\item Let \Atom{} and \AtomAlt{} be two atoms, and $\AtomLens \OfType \Atom \Leftrightarrow \AtomAlt$.  Then there exists a \Lens{}, such that $\Lens \OfType \ToRegex(\Atom) \Leftrightarrow \ToRegex(\AtomAlt)$, \SemanticsOf{\Lens}=\SemanticsOf{\AtomLens}.
\end{enumerate}
\begin{proof}
By mutual induction on the structure of the DNF Regex, Sequence, and
Atom lenses typing.\\ 
\\
Let $\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$ be formed from an
application of\\$\DNFRewriteLensRule{}$.
\begin{mathpar}
\inferrule*
{
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\DNFLens \OfType \DNFRegex' \Leftrightarrow \DNFRegexAlt'
}\\
\DNFRegex' \RewriteDNF \DNFRegex\\
\DNFRegexAlt' \RewriteDNF \DNFRegexAlt
}
{
\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt
}
\end{mathpar}
By induction assumption, there exists a
$\Lens \OfType \ToRegex(\DNFRegex') \Leftrightarrow \ToRegex(\DNFRegexAlt')$,
and from Lemma~\ref{lem:rrl}, we know
$\LanguageOf{\DNFRegex}=\LanguageOf{\DNFRegex'}$, and
$\LanguageOf{\DNFRegexAlt}=\LanguageOf{\DNFRegexAlt'}$.
Consider the derivation
\begin{mathpar}
\inferrule*
{
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens \OfType \ToRegex(\DNFRegex') \Leftrightarrow \ToRegex(\DNFRegexAlt')
}\\
\LanguageOf{\ToRegex(\DNFRegex')} = \LanguageOf{\ToRegex(\DNFRegex)}\\
\LanguageOf{\ToRegex(\DNFRegexAlt')} = \LanguageOf{\ToRegex(\DNFRegexAlt)}
}
{
\Lens \OfType \ToRegex(\DNFRegex) \Leftrightarrow \ToRegex(\DNFRegexAlt)
}
\end{mathpar}
This has the desired typing, and by induction assumption, has the desired semantics.\\
\\
Let $(\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n},\sigma) \OfType \DNFOf{\Sequence_1;\ldots;\Sequence_n} \Leftrightarrow \DNFOf{\SequenceAlt_{\sigma(1)};\ldots;\SequenceAlt_{\sigma(n)}}$ be formed from an application of $\DNFLensRule$.
By Induction assumption, for each $\SequenceLens_i \OfType \Sequence_i \Leftrightarrow \SequenceAlt_i$ there exists a $\Lens_i \OfType \ToRegex(\Sequence_i) \Leftrightarrow \ToRegex(\SequenceAlt_i)$.\\
By Lemma~\ref{lem:id-dnf} there exists a $\Lens \OfType \ToRegex(\DNFOf{\Sequence_1;\ldots;\Sequence_{n}}) \Leftrightarrow \ToRegex(\DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_{n}})$ such that $\SemanticsOf{\Lens}=\SemanticsOf{([\SequenceLens_1;\ldots\SequenceLens_n],id)}$,
By Lemma~\ref{lem:dnfl-perm-sem-ineffective},
$\SemanticsOf{(DNFOf{\SequenceLens_1;\ldots;\SequenceLens_n},id)}=
\SemanticsOf{(\DNFOf{\SequenceLens_1;\ldots;\SequenceLens_n},\sigma)}$.
By Lemma~\ref{lem:dnfr-perm-sem-ineffective},
$\LanguageOf{\DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_n}}=
\LanguageOf{\DNFOf{\SequenceAlt_{\sigma(1)};\ldots;\SequenceAlt_{\sigma(n)}}}$.
Consider the following typing

\begin{mathpar}
\inferrule*
{
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens \OfType \ToRegex(\DNFOf{\Sequence_1;\ldots;\Sequence_{n}}) \Leftrightarrow \ToRegex(\DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_{n}})
}\\
\LanguageOf{\ToRegex(\DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_{n}})} =
\LanguageOf{\ToRegex(\DNFOf{\SequenceAlt_{\sigma(1)};\ldots;\SequenceAlt_{\sigma(n)}})}
}
{
\Lens \OfType \ToRegex(\DNFOf{\Sequence_1;\ldots;\Sequence_{n}}) \Leftrightarrow \ToRegex(\DNFOf{\SequenceAlt_{\sigma(1)};\ldots;\SequenceAlt_{\sigma(n)}})
}
\end{mathpar}
This has the typing and semantics as desired.\\
\\
Let $(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)},\sigma \in S_n) \OfType \SequenceOf{\String_0 ; \Atom_1 ; \ldots ; \Atom_n ; \String_n} \Leftrightarrow \SequenceOf{\StringAlt_0; \AtomAlt_{\sigma(1)} ; \ldots ; \AtomAlt_{\sigma(n)} ; \StringAlt_n}$ be formed from an
application of\\$\SequenceLensRule{}$.
By induction assumption, for each
$\AtomLens_i \OfType \Atom_i \Leftrightarrow \AtomAlt_i$ there exists a
$\Lens_i \OfType \ToRegex(\Regex_i) \Leftrightarrow \ToRegex(\RegexAlt_i)$.
By Lemma~\ref{lem:id-clause}, there exists a $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that $\SemanticsOf{\Lens}=\SemanticsOf{([(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)],id)}$,
$\Regex=\ToRegex(\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n})$, and
$\RegexAlt=\ToRegex(\SequenceOf{\StringAlt_0;\AtomAlt_1;\ldots;\AtomAlt_n;\StringAlt_n})$.
Define $\RegexAlt_{\Sep}$ as $\ToRegex(\SequenceOf{\Sep;\AtomAlt_1;\ldots;\AtomAlt_n;\Sep})$.
By Lemma~\ref{lem:boilerplate-alterations}, there exists a
$\Lens' \OfType \RegexAlt \Leftrightarrow \RegexAlt_{\Sep}$, with semantics of
merely changing the boilerplate.
By Lemma~\ref{lem:perm-exp}, there exists a $\Lens'' \OfType \RegexAlt_{\Sep}'
\Leftrightarrow \RegexAlt_{\Sep}''$ where
$\SemanticsOf{\RegexAlt_{\Sep}'}=\SemanticsOf{\RegexAlt_{\Sep}}$ and 
$\SemanticsOf{\RegexAlt_{\Sep}''}=\SemanticsOf{\SequenceOf{\Sep; \AtomAlt_{\sigma(1)} ; \ldots ; \AtomAlt_{\sigma(n)} ; \Sep}}$.
Lastly, with Lemma~\ref{lem:boilerplate-alterations}, there exists a
$\Lens''' \OfType \RegexAlt_{\Sep}'' \Leftrightarrow \RegexAlt'$, where
$\RegexAlt = \ToRegex(\SequenceOf{\StringAlt_0; \AtomAlt_{\sigma(1)} ; \ldots ; \AtomAlt_{\sigma(n)} ; \StringAlt_n})$.
Through composition of all these lenses, we finally get a lens with the desired type
and semantics.\\
\\
Let $\IterateLens{\DNFLens} \OfType \StarOf{\DNFRegex} \Leftrightarrow \StarOf{\DNFRegexAlt}$
be introduced through an application of \IterateAtomLensRule{}.
From induction assumption, I know that there exists $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$, such that
$\SemanticsOf{\DNFLens}=\SemanticsOf{\Lens}$,
\Regex=\ToRegex(\DNFRegex), and
$\RegexAlt=\ToRegex(\DNFRegexAlt)$.\\
Consider $\IterateLens{\Lens} \OfType \StarOf{\Regex} \Leftrightarrow \StarOf{\RegexAlt}$.\\
By definition, $\StarOf{\Regex}$ and $\StarOf{\RegexAlt}$ are $\ToRegex(\StarOf{\DNFRegex})$
and $\ToRegex(\StarOf{\Regex})$, respectively.

\begin{tabular}{RcL}
\SemanticsOf{\IterateLens{\Lens}} & = &
\SetOf{(\String_0\ldots\String_n,\StringAlt_0\ldots\StringAlt_n)\SuchThat
(\String_i,\StringAlt_i)\in\SemanticsOf{\Lens}}\\
& = &
\SetOf{(\String_0\ldots\String_n,\StringAlt_0\ldots\StringAlt_n)\SuchThat
(\String_i,\StringAlt_i)\in\SemanticsOf{\DNFLens}}\\
& = &
\SemanticsOf{\IterateLens{\DNFLens}}
\end{tabular}
\end{proof}
\end{lemma}

\dnfls*
\begin{proof}

The soundess of DNF lenses follows immediatley from Lemma~\ref{lem:dnfcal}

\end{proof}

\begin{theorem}[Strong DNF Lens Soundness]
Let $\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$, be the typing
of a DNF lens $\DNFLens$.
and let $\Regex$ and $\RegexAlt$ be regular expressions, such that
$\LanguageOf{\DNFRegex}=\LanguageOf{\Regex}$,
and $\LanguageOf{\DNFRegexAlt}=\LanguageOf{\RegexAlt}$.
There exists a lens $\Lens : \Regex \Leftrightarrow \RegexAlt$, such that
$\SemanticsOf{\Lens}=\SemanticsOf{\DNFLens}$.
\end{theorem}

\begin{proof}
By Theorem~\ref{thm:dnfls}, there exist regular expressions $\Regex'$,
$\RegexAlt'$, such that there exists a lens $\DNFLens$ such there is the
derivation for a typing.
\begin{mathpar}
\inferrule[]
{
\Derivation{}
}
{
\DNFLens \OfType \Regex' \Leftrightarrow \RegexAlt'
}
\end{mathpar}
\SemanticsOf{\DNFLens}=\SemanticsOf{\Lens},
\LanguageOf{\Regex'}=\LanguageOf{\DNFRegex},
and \LanguageOf{\RegexAlt'}=\LanguageOf{\DNFRegexAlt'}.
Because of this, $\Regex'\equiv\Regex$, and $\RegexAlt'\equiv\RegexAlt$.
Consider the typing
\begin{mathpar}
\inferrule*
{
\inferrule*
{
\Derivation{}
}
{
\DNFLens \OfType \Regex' \Leftrightarrow \RegexAlt'
}\\
\Regex'\equiv\Regex\\
\RegexAlt'\equiv\RegexAlt
}
{
\DNFLens \OfType \Regex \Leftrightarrow \RegexAlt
}
\end{mathpar}

This satisfies the needed requirements!
\end{proof}
%proof-dnfls end




%%% Local Variables:
%%% TeX-master: "main"
%%% End: