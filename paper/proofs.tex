\section{Proofs}
\subsection{Completeness of DNF Regular Expressions to Regular Expressions}
Is suffices to provide a mapping from regular expressions to DNF regular
expressions.
\begin{definition}[RepDnfRegex]
We define a representative dnf regex for a regex as follows:
\begin{itemize}
\item[variable] $RepDnfRegex(\RegexVariable)=[([\RegexVariable],[\epsilon,\epsilon])]$
\item[base] $RepDnfRegex(\String)=[([],[\String])]$
\item[star] $RepDnfRegex(\Star{\Regex}) = [([\Star{RepDnfRegex(\Regex)}],[\epsilon,\epsilon])]$
\item[concat] $RepDnfRegex(\Regex_1\Regex_2) = Concat(RepDnfRegex(\Regex_1),RepDnfRegex(\Regex_2))$ where $Concat$ is defined via something horrible
\item[or] $RepDnfRegex(\Regex_1|\Regex_2) = append(RepDnfRegex(\Regex_1),RepDnfRegex(\Regex_2))$
\end{itemize}
\end{definition}

\begin{lemma}[Equivalence of $RepDnfRegex$]
For all $\Delta$, $\LanguageOf{\Delta}{RepDnfRegex(\Regex)} = \LanguageOf{\Delta}{\Regex}$
\begin{proof}
\end{proof}
\end{lemma}

\begin{theorem}[Completeness of DNF Regular Expressions]
For any regular expression \Regex{}, there exists a DNF regular expression, \DNFRegex{},
such that for all $\Delta$, $\LanguageOf{\Delta}{\DNFRegex} = \LanguageOf{\Delta}{\Regex}$.
\begin{proof}
Consider $\DNFRegex=RepDnfRegex(\Regex)$.  By above lemma, $\LanguageOf{\Delta}{\DNFRegex}=\LanguageOf{\Delta}{\Regex}$.
\end{proof}
\end{theorem}

\subsection{Soundness of DNF Regular Expressions to Regular Expressions}
Is suffices to provide a mapping from DNF regular expressions to regular
expressions.
\begin{definition}[RepRegex]
We define a representative regex for a DNF regex, clause, and atom as follows:
\begin{itemize}
\item[userdef] $RepRegex(\RegexVariable)=[([\RegexVariable],[\epsilon,\epsilon])]$
\item[star] $RepRegex(\String)=[([],[\String])]$
\item[clause] $RepRegex(\Star{\Regex}) = [([\Star{RepDnfRegex(\Regex)}],[\epsilon,\epsilon])]$
\item[dnf regex] $RepRegex(\Regex_1\Regex_2) = Concat(RepDnfRegex(\Regex_1),RepDnfRegex(\Regex_2))$ where $Concat$ is defined via something horrible
\item[or] $RepRegex(\Regex_1|\Regex_2) = append(RepDnfRegex(\Regex_1),RepDnfRegex(\Regex_2))$
\end{itemize}
\end{definition}

\begin{lemma}[Equivalence of $RepRegex$]
For all $\Delta$, $\LanguageOf{\Delta}{RepRegex(\DNFRegex)} = \LanguageOf{\Delta}{\DNFRegex}$
\begin{proof}
\end{proof}
\end{lemma}

\begin{theorem}[Soundness of DNF Regular Expressions]
For any dnf regular expression \DNFRegex{}, there exists a regular expression, \DNFRegex{},
such that for all $\Delta$, $\LanguageOf{\Delta}{\DNFRegex} = \LanguageOf{\Delta}{\Regex}$.
\begin{proof}
Consider $\DNFRegex=RepDnfRegex(\Regex)$.  By above lemma, $\LanguageOf{\Delta}{\DNFRegex}=\LanguageOf{\Delta}{\Regex}$.
\end{proof}
\end{theorem}

\subsection{Completeness}
\begin{lemma}[Identity Completeness]
Identity is expressible in the language of DNF Lenses
\begin{proof}
By induction on regular expressions
\begin{enumerate}
\item[\Regex=\RegexVariable] a
\end{enumerate}
\end{proof}
\end{lemma}

\begin{lemma}[DNF Inversion]
\label{lem:dnf-inversion}
\leavevmode
\begin{enumerate}
\item If $\Delta \vdash (\lambda i:\RangeIncInc{1}{n}.\ClauseLens_i,\sigma \in \RangeIncInc{1}{n} \rightarrowtail \RangeIncInc{1}{n} : \lambda i:\RangeIncInc{1}{n}.\Clause_i \Leftrightarrow \lambda i:\RangeIncInc{1}{n}.\ClauseAlt_i \circ \sigma$
then for all $i \in \RangeIncInc{1}{n}$, $\Delta \vdash \ClauseLens_i : \Clause_i \Leftrightarrow \ClauseAlt_i$,
and for all $i \neq j$, $\Clause_i \cap \Clause_j = \emptyset$ and $\ClauseAlt_i \cap \ClauseAlt_j = \emptyset$
\item If $\Delta \vdash (\lambda i:\RangeIncInc{1}{n}.\Atom_i,\lambda i:\RangeIncInc{0}{n}.(\String_i,\StringAlt_i),\sigma \in \RangeIncInc{1}{n} \rightarrowtail \RangeIncInc{1}{n}) : (\lambda i:\RangeIncInc{1}{n}.\Atom_i,\lambda i:\RangeIncInc{0}{n}.\String_i)\Leftrightarrow
((\lambda i:\RangeIncInc{1}{n}.\AtomAlt_i)\circ \sigma,\lambda i:\RangeIncInc{0}{n}.\StringAlt_i)$, then for all
$i \in \RangeIncInc{1}{n}$, $\Delta \vdash \AtomLens_i : \Atom_i \Leftrightarrow \AtomAlt_i$ and for all
$i \in \RangeIncInc{1}{n-1}$, 
$\UnambigConcat{\LanguageOf{\Delta}{\String_{i-1}\Atom_i\epsilon}}{\LanguageOf{\Delta}{\String_i\Atom_{i+1}\epsilon}}$ and
$\UnambigConcat{\LanguageOf{\Delta}{\StringAlt_{i-1}\AtomAlt_{\sigma(i)}\epsilon}}{\LanguageOf{\Delta}{\StringAlt_i\AtomAlt_{\sigma(i+1)}\epsilon}}$
\item If $\Delta \vdash \IterateLens{\DNFLens} : \Star{\DNFRegex} \Leftrightarrow \Star{\DNFRegexAlt}$, then
$\DNFLens : \DNFRegex \Leftrightarrow \DNFRegex$,
$\UnambigIt{\LanguageOf{\Delta}{\DNFRegex_1}}$,
 and $\UnambigIt{\LanguageOf{\Delta}{\DNFRegex_2}}$
\end{enumerate}
\end{lemma}

\subsection{Soundness}
We say that dnf lenses are \textit{sound} if, there is a dnf lens between two
dnf regular expressions, then between any two regular expressions equivalent
to the two dnf regular expressions, there is a lens between those regular
expressions such that the lens and dnf lens have the same semantics.

\begin{definition}[repregex]
We define a representative regex for a dnf regex as follows:
\begin{itemize}
\item $repregex([\Clause])=repregex(\Clause)$
\item $repregex([\Clause_1 ; \ldots ; \Clause_n])$ =\\ $repregex(\Clause_1)| repregex([\Clause_2 ; \ldots ; \Clause_n]))$
\item $regregex([\String]) = \String$
\item $repregex([\String_1 ; \Atom_1 ; \ldots ; \Atom_n ; \String_{n+1}])$ =\\ $\String_1 (repregex(\Atom_1) repregex([\String_2 ; \Atom_2 ; \ldots ; \String_{n+1}]))$
\item $repregex(\RegexVariable) = \RegexVariable$
\item $repregex(\Star{\DNFRegex}) = \Star{repregex(\DNFRegex)}$
\end{itemize}
\end{definition}

\begin{lemma}[Equivalence of repregex]
\label{lem:repregex-equiv}
$\LanguageOf{\Delta}{\DNFRegex}=\LanguageOf{\Delta}{repregex(\DNFRegex)}$,
$\LanguageOf{\Delta}{\Clause} = \LanguageOf{\Delta}{repregex(\Clause)}$,
and $\LanguageOf{\Delta}{\Atom} = \LanguageOf{\Delta}{repregex(\Atom)}$
\begin{proof}
By induction on the structure of \DNFRegex{}, \Clause{}, and \Atom{}
\end{proof}
\end{lemma}

\begin{definition}[Adjacent Swapping Permutation]
Let $\sigma_{i} : [0,n] \rightarrowtail [0,n]$ be the permutation, where
$\sigma_{i}(i) = i+1$, $\sigma_{i}(i+1) = i$, $\sigma_{i,j}(k\neq i,i+1) = k$
\end{definition}

\begin{lemma}[Expressibility of Adjacent Swapping Permutation]
Let $\sigma_{i}$ be an adjacent element swapping permutation.  The language of
lenses can express $([(\String_1,\String_1) ; \IdentityLens ; \ldots ; \IdentityLens ; (\String_n,\String_n)], \sigma_{i})$.
\begin{proof}
Consider the regular expressions $repregex([\String_1;\Atom_1; \ldots;\String_i])$ $(repregex(\Atom_i) (\String_{i+1} repregex(\Atom_{i+1})))$ $repregex([\String_{i+2} ; \ldots ; \Atom_{n} ; \String_{n+1}])$ and 
$repregex([\String_{1,2};\Atom_{1,2}; \ldots;\String_{i,1}])$ $((\Atom_{i+1,1} \String_{i+1,1})\Atom_{i,1})$ $repregex([\String_{i+2,1} ; \ldots ; \Atom_{n} ; \String_{n+1}])$
Consider the lens between them\\ $\ConcatLens{\ConcatLens{\IdentityLens}{\SwapLens{\IdentityLens}{\SwapLens{\IdentityLens}{\IdentityLens}}}}{\IdentityLens}$
By inspection, this lens is equivalent to the adjacent swapping permutation.
\end{proof}
\end{lemma}

\begin{lemma}[Expressibility of Permutation]
\label{lem:perm-exp}
The language of lenses can express $([(\String_1,\String_1) ; \IdentityLens ; \ldots ; \IdentityLens ; (\String_n,\String_n)], \sigma)$
for any permutation $\sigma$.
\begin{proof}
Let $\sigma$ be a permutation.
Consider the clause lens $([(\String_1,\String_1) ; \IdentityLens ; \ldots ; \IdentityLens ; (\String_n,\String_n)], \sigma_{i})$.
From algebra, we know that the group of permutations is generated by all
adjacent swaps $\sigma_i = (i,i+1)$.
So there exists an adjacency swap decomposition of $\sigma = \sigma_{i_1}\ldots\sigma_{i_m}$.
Consider the dnf lens $([(\String_1,\String_1) ; \IdentityLens ; \ldots ; \IdentityLens ; (\String_n,\String_n)], \sigma_{i_j})$ for each $\sigma_{i_j}$.
By the above lemma, there exists a $\Lens_j$ for each of these adjacency swaps.
Consider the lens $\Lens = \ComposeLens{\Lens_{i_1}}{\ComposeLens{\Lens_{i_2}}{\ldots \ComposeLens{}{\Lens_{i_m}}}}$
By the semantics, they are the same.

\end{proof}
\end{lemma}

\begin{definition}[well-founded relation on DNF Lenses, Clauses, and Atoms]
The well founded relation is the transitive closure of
DO I NEED TO DO THIS FORMALLY?
\begin{itemize}
\item $([\ClauseLens],id \in S_1) \prec \ClauseLens$
\item $\lambda i:\RangeIncInc{1}{n}.\ClauseLens_i$
\end{itemize}
\end{definition}

\begin{definition}[replens]
We define a representative lens for a dnf lens, a clause lens, and an atom lens as follows:
\begin{itemize}
\item $replens([\ClauseLens],id\in S_1) = replens(\ClauseLens)$
\item $replens(\lambda i:\RangeIncInc{1}{n}.\ClauseLens_i,id\in S_n) =$\\
$\OrLens{replens(\lambda i:\RangeIncInc{1}{n-1}.\ClauseLens_i, id\in S_{n-1})}{replens(\ClauseLens_n)}$
\item $replens(\lambda i:\RangeIncInc{1}{n}.\ClauseLens_i,\sigma\in S_n) =$\\
$replens(\lambda i:\RangeIncInc{1}{n}.\ClauseLens_i,id\in S_n)$
\item $replens([(\String_i,\StringAlt_i)],id\in S_0)=\ConstLens{\String_i}{\StringAlt_i}$
\item $replens(\lambda i:\RangeIncInc{1}{n}.\AtomLens_i,\lambda i:\RangeIncInc{0}{n}.(\String_i,\StringAlt_i),id\in S_n)=$\\
$\ConcatLens{\ConcatLens{replens(\lambda i:\RangeIncInc{1}{n-1}.\AtomLens_i,\lambda i:\RangeIncInc{0}{n-1}.(\String_i,\StringAlt_i),id\in S_{n-1})}{replens(\AtomLens_i)}}{\ConstLens{\String_n}{\StringAlt_n}}$
\item $replens(\lambda i:\RangeIncInc{1}{n}.\AtomLens_i,\lambda i:\RangeIncInc{0}{n}.(\String_i,\StringAlt_i),\sigma \in S_n)=$\\
$\ComposeLens{permlens(\lambda i:\RangeIncInc{0}{n} \StringAlt_i,\sigma \in S_n)}{replens(\lambda i:\RangeIncInc{1}{n}.\AtomLens_i,\lambda i:\RangeIncInc{0}{n}.(\String_i,\StringAlt_i),id \in S_n)}$
\item $replens(\IdentityLens)=\IdentityLens$
\item $replens(\IterateLens{\DNFLens})=\IterateLens{replens(\DNFLens)}$
\end{itemize}
\end{definition}

\begin{lemma}[Denotational Equivalence of $replens$]\leavevmode
\begin{enumerate}
\item For a DNF Lens $\DNFLens$, $\denot{\DNFLens}=\denot{replens(\DNFLens)}$
\item For a Clause Lens $\ClauseLens$, $\denot{\ClauseLens}=\denot{replens(\ClauseLens)}$
\item For a DNF Lens $\DNFLens$, $\denot{\DNFLens}=\denot{replens(\DNFLens)}$
\end{enumerate}
By induction on the well-founded relation underlying the 
\end{lemma}

\begin{lemma}[Creation of Lens from Identity Perm DNF Lens]
\label{lem:id-dnf}
If $\Delta \vdash ([\ClauseLens_1 ; \ldots ; \ClauseLens_n],id) : [\Clause_1 ; \ldots ; \Clause_n] \Leftrightarrow [\ClauseAlt_1 ; \ldots ; \ClauseAlt_n]$,
and for each $\ClauseLens_i : \Clause_i \Leftrightarrow \ClauseAlt_i$,
there exists a $\Delta \vdash \Lens_i : \Regex_i \Leftrightarrow \RegexAlt_i$ such that
$\LanguageOf{\Delta}{\Clause_i}=\LanguageOf{\Delta}{\Regex_i}$, and $\Lens_i.putr = \ClauseLens_i.putr$,
then there exists a $\Lens : \Regex \Leftrightarrow \RegexAlt$ such that $\Lens.putr = ([\ClauseLens_1 ; \ldots ; \ClauseLens_n],id).putr$, $\LanguageOf{\Delta}{[\Clause_1 ; \ldots ; \Clause_n]}$ = $\LanguageOf{\Delta}{\Regex}$,
and $\LanguageOf{\Delta}{[\ClauseAlt_1 ; \ldots ; \ClauseAlt_n]}$ = $\LanguageOf{\Delta}{\RegexAlt}$.
\begin{proof}
Base case: $\FullContext \vdash [\ClauseLens_1] : [\Clause_1] \Leftrightarrow [\ClauseAlt_1]$.  Then consider $\Lens$ = $\Lens_1$, $\Regex = \Regex_1$, $\RegexAlt = \RegexAlt_1$.
$\LanguageOf{\Delta}{[\Clause_1]} = \LanguageOf{\Delta}{\Clause_1}$ by definition.\\
$\LanguageOf{\Delta}{[\Clause_1]} = \LanguageOf{\Delta}{\Regex_1}$ by problem assumption.

Symmetrically for $\LanguageOf{\Delta}{[\ClauseAlt_1]}$.\\
$\PutRight{[\ClauseLens]} = \PutRight{\ClauseLens}$ by definition\\
$\PutRight{[\ClauseLens]} = \PutRight{\Lens_1}$ by problem assumption.
\\\\\\



By induction assumption, I know
there exists a $\Lens : \Regex \Leftrightarrow \RegexAlt$ such that
$\Lens.putr = ([\ClauseLens_1 ; \ldots ; \ClauseLens_n],id).putr$,
$\LanguageOf{\Delta}{[\Clause_1 ; \ldots ; \Clause_n]}$ =
$\LanguageOf{\Delta}{\Regex}$,
and $\LanguageOf{\Delta}{[\ClauseAlt_1 ; \ldots ; \ClauseAlt_n}$ = $\LanguageOf{\Delta}{\RegexAlt}$.\\
By assumption, I know that there exists a $\Delta \vdash \Lens_{n+1} : \Regex_{n+1} \Leftrightarrow \RegexAlt_{n+1}$ such that $\LanguageOf{\Delta}{\Regex_{n+1}}=\LanguageOf{\Delta}{\Clause_{n+1}}$
and $\LanguageOf{\Delta}{\RegexAlt_{n+1}}=\LanguageOf{\Delta}{\ClauseAlt_{n+1}}$, where $\Lens_{n+1}.putr=\ClauseLens_{n+1}$.\\
Consider the lens $\FullContext \vdash \OrLens{\Lens}{\Lens_{n+1}} : \RegexOr{\Regex}{\Regex_{n+1}} \Leftrightarrow \RegexOr{\RegexAlt}{\RegexAlt_{n+1}}$.\\
$\LanguageOf{\Delta}{\RegexOr{\Regex}{\Regex_{n+1}}}
= \LanguageOf{\Delta}{\Regex}\cup\LanguageOf{\Delta}{\Regex_{n+1}}$
by definition\\
$\LanguageOf{\Delta}{\RegexOr{\Regex}{\Regex_{n+1}}}
= \LanguageOf{\Delta}{[\Clause_1; \ldots ; \Clause_n]}
\cup\LanguageOf{\Delta}{\Regex_{n+1}}$ by induction assumption.\\
$\LanguageOf{\Delta}{\RegexOr{\Regex}{\Regex_{n+1}}}
= \bigcup_{i=1\ldots n}\LanguageOf{\Delta}{\Clause_i}
\cup\LanguageOf{\Delta}{\Regex_{n+1}}$ by definition.\\
$\LanguageOf{\Delta}{\RegexOr{\Regex}{\Regex_{n+1}}}
= \bigcup_{i=1\ldots n}\LanguageOf{\Delta}{\Clause_i}
\cup\LanguageOf{\Delta}{\Clause_{n+1}}$ by problem assumption.\\
$\LanguageOf{\Delta}{\RegexOr{\Regex}{\Regex_{n+1}}}
= \bigcup_{i=1\ldots n+1}\LanguageOf{\Delta}{\Clause_i}$ by distributivity of $\cup$.\\
$\LanguageOf{\Delta}{\RegexOr{\Regex}{\Regex_{n+1}}}
= \LanguageOf{\Delta}{[\Clause_1; \ldots ; \Clause_n]}$ by definition.

Similarly for
$\LanguageOf{\Delta}{\RegexOr{\RegexAlt}{\RegexAlt_{n+1}}}
= \LanguageOf{\Delta}{[\ClauseAlt_1; \ldots ; \ClauseAlt_n]}$ TODO, split into lemma?.\\
\[
\PutRight{\OrLens{\Lens}{\Lens_{n+1}}}(\String) =
  \begin{cases}
    \PutRight{\Lens}(\String)& \text{if } \String \in \LanguageOf{\Delta}{\Regex}\\
    \Lens_{n+1}.putr(\String)& \text{if } \String \in \LanguageOf{\Delta}{\Regex_{n+1}}
  \end{cases}
\] by definition.\\
\[
\PutRight{\OrLens{\Lens}{\Lens_{n+1}}}(\String) =
  \begin{cases}
    \PutRight{[\ClauseLens_1;\ldots;\ClauseLens_n}(\String)& \text{if } \String \in \LanguageOf{[\Clause_1 ; \ldots ; \Clause_n]}{\Regex}\\
    \Lens_{n+1}.putr(\String)& \text{if } \String \in \LanguageOf{\Delta}{\Regex_{n+1}}
  \end{cases}
\] by induction assumption.\\
\[
\PutRight{\OrLens{\Lens}{\Lens_{n+1}}}(\String) =
  \begin{cases}
    \PutRight{\ClauseLens_1}(\String)& \text{if } \String \in \LanguageOf{\Delta}{\Clause_1}\\
\ldots \\
    \PutRight{\ClauseLens_n(\String)}& \text{if } \String \in \LanguageOf{\Delta}{\Clause_n}\\
    \Lens_{n+1}.putr(\String)& \text{if } \String \in \LanguageOf{\Delta}{\Regex_{n+1}}
  \end{cases}
\] by definition of putr.\\
\[
\PutRight{\OrLens{\Lens}{\Lens_{n+1}}}(\String) =
  \begin{cases}
    \PutRight{\ClauseLens_1}(\String)& \text{if } \String \in \LanguageOf{\Delta}{\Clause_1}\\
\ldots \\
    \PutRight{\ClauseLens_n(\String)}& \text{if } \String \in \LanguageOf{\Delta}{\Clause_n}\\
    \Clause_{n+1}.putr(\String)& \text{if } \String \in \LanguageOf{\Delta}{\Clause_{n+1}}
  \end{cases}
\] by problem assumption.\\
$\PutRight{\OrLens{\Lens}{\Lens_{n+1}}}(\String) =
\PutRight{[\ClauseLens_1; \ldots ; \ClauseLens_{n+1}]}(\String)$ by definition of putr.\\
\end{proof}
\end{lemma}

\begin{lemma}[Creation of Lens from Identity Perm Clause Lens]
\label{lem:id-clause}
If $\Delta \vdash ([(\String_0,\StringAlt_0);\AtomLens_1 ; \ldots ; \AtomLens_n;(\String_n,\StringAlt_n)],id) : [\String_0 ; \Atom_1 ; \ldots ; \Atom_n; \String_n] \Leftrightarrow [\StringAlt_0 ; \AtomAlt_1 ; \ldots ; \AtomAlt_n ; \StringAlt_n]$,
and for each $\AtomLens_i : \Atom_i \Leftrightarrow \AtomAlt_i$,
there exists a $\Delta \vdash \Lens_i : \Regex_i \Leftrightarrow \RegexAlt_i$ such that
$\LanguageOf{\Delta}{\Atom_i}=\LanguageOf{\Delta}{\Regex_i}$, and $\Lens_i.putr = \ClauseLens_i.putr$,
then there exists a $\Lens : \Regex \Leftrightarrow \RegexAlt$ such that $\Lens.putr = ([\AtomLens_1 ; \ldots ; \AtomLens_n],id).putr$, $\LanguageOf{\Delta}{[\String_0 ; \Atom_1 ; \ldots ; \Clause_n ; \String_n]}$ = $\LanguageOf{\Delta}{\Regex}$,
and $\LanguageOf{\Delta}{[\StringAlt_0 ; \AtomAlt_1 ; \ldots ; \AtomAlt_n ; \StringAlt_n]}$ = $\LanguageOf{\Delta}{\RegexAlt}$.
\begin{proof}
Base case: $\FullContext \vdash [(\String_0,\StringAlt_0)] : [\String_0] \Leftrightarrow [\StringAlt_0]$.
Then consider $\Lens$ = $\ConstLens{\String_0}{\StringAlt_0}$, $\Regex = \String$, $\RegexAlt = \StringAlt$.
$\LanguageOf{\Delta}{[\String_0]} = \String_0 = \LanguageOf{\Delta}{\String_0}$ by definition.\\
$\LanguageOf{\Delta}{[\StringAlt_0]} = \StringAlt_0 = \LanguageOf{\Delta}{\String_0}$ by definition.\\
$\PutRight{[(\String_0,\StringAlt_0)]}(\String_0)=\StringAlt_0=\PutRight{\ConstLens{\String}{\StringAlt}}(\String_0)$.
\\\\\\

By induction assumption, I know
there exists a $\Lens : \Regex \Leftrightarrow \RegexAlt$ such that
$\Lens.putr = ([(\String_0,\StringAlt_0);\AtomLens_1 ; \ldots ; \AtomLens_n;(\String_n,\StringAlt_n)],id).putr$,
$\LanguageOf{\Delta}{[\String_0 ; \Atom_1 ; \ldots ; \Atom_n ; \String_n]}$ =
$\LanguageOf{\Delta}{\Regex}$,
and $\LanguageOf{\Delta}{[\StringAlt_0 ; \AtomAlt_1 ; \ldots ; \Atom_n ; \StringAlt_n]}$ = $\LanguageOf{\Delta}{\RegexAlt}$.\\
By assumption, I know that there exists a $\Delta \vdash \Lens_{n+1} : \Regex_{n+1} \Leftrightarrow \RegexAlt_{n+1}$ such that $\LanguageOf{\Delta}{\Regex_{n+1}}=\LanguageOf{\Delta}{\Atom_{n+1}}$
and $\LanguageOf{\Delta}{\RegexAlt_{n+1}}=\LanguageOf{\Delta}{\AtomAlt_{n+1}}$, where $\Lens_{n+1}.putr=\AtomLens_{n+1}$.\\
Consider the lens $\FullContext \vdash \ConcatLens{\Lens}{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}} : \RegexConcat{\Regex}{\RegexConcat{\Regex_{n+1}}{\String_{n+1}}} \Leftrightarrow \RegexConcat{\RegexAlt}{\RegexConcat{\RegexAlt_{n+1}}{\StringAlt_{n+1}}}$.\\
$\LanguageOf{\Delta}{\RegexConcat{\Regex}{\RegexConcat{\Regex_{n+1}}{\String_{n+1}}}}
= \LanguageOf{\Delta}{\Regex}\Concat\LanguageOf{\Delta}{\Regex_{n+1}}\Concat\{\String_{n+1}\}$
by definition\\
$\LanguageOf{\Delta}{\RegexConcat{\Regex}{\RegexConcat{\Regex_{n+1}}{\String_{n+1}}}}
= \LanguageOf{\Delta}{[\String_0;\Atom_1; \ldots ; \Atom_n;\String_n]}
\Concat\LanguageOf{\Delta}{\Regex_{n+1}}\Concat\{\String_{n+1}\}$ by induction assumption.\\
$\LanguageOf{\Delta}{\RegexConcat{\Regex}{\RegexConcat{\Regex_{n+1}}{\String_{n+1}}}}
= \{\String_0\}\Concat\LanguageOf{\Delta}{\Atom_1}\Concat\ldots\Concat\LanguageOf{\Delta}{\Atom_n}\Concat\{\String_n\}
\Concat\LanguageOf{\Delta}{\Regex_{n+1}}\Concat\{\String_{n+1}\}$ by definition.\\
$\LanguageOf{\Delta}{\RegexConcat{\Regex}{\RegexConcat{\Regex_{n+1}}{\String_{n+1}}}}
= \{\String_0\}\Concat\LanguageOf{\Delta}{\Atom_1}\Concat\ldots\Concat\LanguageOf{\Delta}{\Atom_n}\Concat\{\String_n\}
\Concat\LanguageOf{\Delta}{\Atom_{n+1}}\Concat\{\String_{n+1}\}$ by problem assumption.\\
$\LanguageOf{\Delta}{\RegexConcat{\Regex}{\RegexConcat{\Regex_{n+1}}{\String_{n+1}}}}
= \LanguageOf{\Delta}{[\String_0;\Atom_0;\ldots;\Atom_{n+1};\String_{n+1}]}$ by definition.\\

Similarly for
$\LanguageOf{\Delta}{\RegexConcat{\RegexAlt}{\RegexConcat{\RegexAlt_{n+1}}{\StringAlt_{n+1}}}}
= \LanguageOf{\Delta}{[\StringAlt_0;\AtomAlt_0;\ldots;\AtomAlt_{n+1};\StringAlt_{n+1}]}$
 TODO, split into lemma?.\\
\\
$\PutRight{\ConcatLens{\Lens}{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}}}
(\String_0\String_1'\ldots\String_{n+1}'\String_{n+1}) =$\\
$\PutRight{\Lens}(\String_0\String_1'\ldots\String_n'\String_n)\PutRight{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}}(\String_{n+1}'\String_{n+1})$ by definition\\
\\
$\PutRight{\ConcatLens{\Lens}{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}}}
(\String_0\String_1'\ldots\String_{n+1}'\String_{n+1}) =$\\
$\PutRight{\Lens}(\String_0\String_1'\ldots\String_n'\String_n)\PutRight{\Lens_{n+1}}(\String_{n+1}')\PutRight{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}(\String_{n+1})$ by definition\\
\\
$\PutRight{\ConcatLens{\Lens}{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}}}
(\String_0\String_1'\ldots\String_{n+1}'\String_{n+1}) =$\\
$\PutRight{[(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)]}(\String_0\String_1'\ldots\String_n'\String_n)\PutRight{\Lens_{n+1}}(\String_{n+1}')\PutRight{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}(\String_{n+1})$ by induction assumption\\
\\
$\PutRight{\ConcatLens{\Lens}{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}}}
(\String_0\String_1'\ldots\String_{n+1}'\String_{n+1}) =$\\
$\PutRight{[(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)]}(\String_0\String_1'\ldots\String_n'\String_n)\PutRight{\AtomLens_{n+1}}(\String_{n+1}')\PutRight{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}(\String_{n+1})$ by problem assumption\\
\\
$\PutRight{\ConcatLens{\Lens}{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}}}
(\String_0\String_1'\ldots\String_{n+1}'\String_{n+1}) =$\\
$\StringAlt_0\Concat\PutRight{\AtomLens_1}(\String_1')\Concat\ldots\Concat\PutRight{\AtomLens_n}(\String_n')\Concat\StringAlt_n\Concat\PutRight{\AtomLens_{n+1}}(\String_{n+1}')\Concat\StringAlt_{n+1}$ by definition\\
\\
$\PutRight{\ConcatLens{\Lens}{\ConcatLens{\Lens_{n+1}}{\ConstLens{\String_{n+1}}{\StringAlt_{n+1}}}}}
(\String_0\String_1'\ldots\String_{n+1}'\String_{n+1}) =$\\
$\PutRight{[(\String_0,\StringAlt_0);\AtomLens_0;\ldots;\AtomLens_{n+1};(\String_{n+1},\StringAlt_{n+1})]}(\String_0\String_0'\ldots\String_{n+1}'\String_{n+1})$ by definition
\end{proof}
\end{lemma}

\begin{lemma}[Soundness of DNF Lenses, Clauses, and Atoms]\leavevmode
\begin{enumerate}
\item Let \DNFRegex{} and \DNFRegexAlt{} be two dnf regular expressions, and $\FullContext \vdash \DNFLens : \DNFRegex \Leftrightarrow \DNFRegexAlt$.  Then there exists a \Lens{}, \Regex{}, and \RegexAlt{} such that $\FullContext \vdash \Lens : \Regex \Leftrightarrow \RegexAlt$, \PutRight{\Lens}=\PutRight{\DNFLens}, \LanguageOf{\Delta}{\Regex}=\LanguageOf{\Delta}{\DNFRegex}, and \LanguageOf{\Delta}{\RegexAlt}=\LanguageOf{\Delta}{\DNFRegexAlt}.  \LanguageOf{\Delta{}}{\Regex{}} = \LanguageOf{\Delta{}}{\DNFRegex{}} and
\LanguageOf{\Delta{}}{\RegexAlt{}} = \LanguageOf{\Delta{}}{\DNFRegexAlt{}}

\item Let \Clause{} and \ClauseAlt{} be two clauses, and $\FullContext \vdash \ClauseLens : \Clause \Leftrightarrow \ClauseAlt$.  Then there exists a \Lens{}, \Regex{}, and \RegexAlt{} such that $\FullContext \vdash \Lens : \Regex \Leftrightarrow \RegexAlt$, \PutRight{\Lens}=\PutRight{\ClauseLens}, \LanguageOf{\Delta}{\Regex}=\LanguageOf{\Delta}{\Clause}, and \LanguageOf{\Delta}{\RegexAlt}=\LanguageOf{\Delta}{\ClauseAlt}.  \LanguageOf{\Delta{}}{\Regex{}} = \LanguageOf{\Delta{}}{\Clause{}} and
\LanguageOf{\Delta{}}{\RegexAlt{}} = \LanguageOf{\Delta{}}{\ClauseAlt{}}

\item Let \Atom{} and \AtomAlt{} be two atoms, and $\FullContext \vdash \AtomLens : \Atom \Leftrightarrow \AtomAlt$.  Then there exists a \Lens{}, \Regex{}, and \RegexAlt{} such that $\FullContext \vdash \Lens : \Regex \Leftrightarrow \RegexAlt$, \PutRight{\Lens}=\PutRight{\AtomLens}, \LanguageOf{\Delta}{\Regex}=\LanguageOf{\Delta}{\Atom}, and \LanguageOf{\Delta}{\RegexAlt}=\LanguageOf{\Delta}{\AtomAlt}.  \LanguageOf{\Delta{}}{\Regex{}} = \LanguageOf{\Delta{}}{\Atom{}} and
\LanguageOf{\Delta{}}{\RegexAlt{}} = \LanguageOf{\Delta{}}{\AtomAlt{}}
\end{enumerate}
\begin{proof}
\begin{itemize}\leavevmode\\
\item $\FullContext \vdash ([\ClauseLens_1;\ldots;\ClauseLens_n],\sigma) : [\Clause_1;\ldots;\Clause_n] \Leftrightarrow [\ClauseAlt_{\sigma(1)};\ldots;\ClauseAlt_{\sigma(n)}]$\\
By Induction assumption, for each $\FullContext \vdash \ClauseLens_i : \Clause_i \Leftrightarrow \ClauseAlt_i$ there exists a $\FullContext \vdash \Lens_i : \Regex_i \Leftrightarrow \RegexAlt_i$.\\
By Lemma~\ref{lem:id-dnf} there exists a $\FullContext \vdash \Lens : \Regex \Leftrightarrow \RegexAlt$ such that $\PutRight{\Lens}=\PutRight{([\ClauseLens_1;\ldots\ClauseLens_n],id)}$,
$\LanguageOf{\Delta}{\Regex}=\LanguageOf{\Delta}{[\Clause_1;\ldots;\Clause_n]}$, and
$\LanguageOf{\Delta}{\RegexAlt}=\LanguageOf{\Delta}{[\ClauseAlt_1;\ldots;\ClauseAlt_n]}$.\\
By Lemma TODO, $\PutRight{([\ClauseLens_1;\ldots\ClauseLens_n],id)}=\PutRight{([\ClauseLens_1;\ldots\ClauseLens_n],\sigma)}$.\\
By Lemma TODO, $\LanguageOf{\Delta}{[\ClauseAlt_1;\ldots;\ClauseAlt_n]}=\LanguageOf{\Delta}{[\ClauseAlt_{\sigma(1)};\ldots;\ClauseAlt_{\sigma(n)}]}$.\\
As such, $\PutRight{\Lens}=\PutRight{([\ClauseLens_1;\ldots\ClauseLens_n],\sigma)}$,
$\LanguageOf{\Delta}{\Regex}=\LanguageOf{\Delta}{[\Clause_1;\ldots;\Clause_n]}$,
and $\LanguageOf{\Delta}{\RegexAlt}=\LanguageOf{\Delta}{[\ClauseAlt_{\sigma(1)};\ldots;\ClauseAlt_{\sigma(n)}]}$.\\

\item$\FullContext \vdash ([(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)],\sigma \in S_n) : [\String_0 ; \Atom_1 ; \ldots ; \Atom_n ; \String_n] \Leftrightarrow [\StringAlt_0; \AtomAlt_{\sigma(1)} ; \ldots ; \AtomAlt_{\sigma(n)} ; \StringAlt_n]$\\
From induction assumption, I know for each $\FullContext \vdash \AtomLens_i : \Atom_i \Leftrightarrow \AtomAlt_i$, there exists a $\FullContext \vdash \Lens_i : \Regex_i \Leftrightarrow \RegexAlt_i$ such that $\PutRight{\AtomLens_i}=\PutRight{\Lens_i}$,
and $\LanguageOf{\Delta}{\Regex_i}=\LanguageOf{\Delta}{\Atom_i}$ and $\LanguageOf{\Delta}{\RegexAlt_i}=\LanguageOf{\Delta}{\AtomAlt_i}$.\\
By Lemma~\ref{lem:id-clause}, there exists a $\FullContext \vdash \Lens : \Regex \Leftrightarrow \RegexAlt$ such that $\PutRight{\Lens}=\PutRight{([(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)],id)}$,
$\LanguageOf{\Delta}{\Regex}=\LanguageOf{\Delta}{[\String_0;\Clause_1;\ldots;\Clause_n;\String_{n+1}]}$,
$\LanguageOf{\Delta}{\RegexAlt}=\LanguageOf{\Delta}{[\StringAlt_0;\ClauseAlt_1;\ldots;\ClauseAlt_n;\StringAlt_{n+1}]}$.\\
By Lemma~\ref{lem:perm-exp} there exists a $\FullContext \vdash \Lens_{\sigma} : \Regex' \Leftrightarrow \RegexAlt'$,
such that $\PutRight{\Lens_{\sigma}}(\StringAlt_0;\StringAlt_1';\StringAlt_1;\ldots;\StringAlt_n'\StringAlt_n)=\StringAlt_0;\StringAlt_{\sigma(1)}';\StringAlt_1;\ldots;\StringAlt_{\sigma(n)}'\StringAlt_n$,
$\LanguageOf{\Delta}{\Regex'}=\LanguageOf{\Delta}{[\String_0;\Clause_1;\ldots;\Clause_n;\String_{n+1}]}$, and
$\LanguageOf{\Delta}{\RegexAlt'}=\LanguageOf{\Delta}{[\String_0;\Clause_{\sigma(1)};\ldots;\Clause_{\sigma(n)}\String_{n+1}]}$.\\
Consider the lens $\Delta \vdash \ComposeLens{\Lens_{\sigma}}{\Lens} : \Regex \Leftrightarrow \RegexAlt'$.\\
$\PutRight{\ComposeLens{\Lens_{\sigma}}{\Lens}}(\String_0\String_1'\ldots\String_n'\String_n)=\PutRight{\Lens_{\sigma}}(\PutRight{\Lens}(\String_0\String_1'\ldots\String_n'\String_n))$ by definition of compose\\
$\PutRight{\ComposeLens{\Lens_{\sigma}}{\Lens}}(\String_0\String_1'\ldots\String_n'\String_n)=\PutRight{\Lens_{\sigma}}(\StringAlt_1\PutRight{\AtomLens_1}(\String_1')\ldots\PutRight{\AtomLens_n}(\String_n')\StringAlt_n)$ by definition of \Lens{}\\
$\PutRight{\ComposeLens{\Lens_{\sigma}}{\Lens}}(\String_0\String_1'\ldots\String_n'\String_n)=\StringAlt_1\PutRight{\AtomLens_{\sigma(1)}}(\String_{\sigma(1)}')\ldots\PutRight{\AtomLens_{\sigma(n)}}(\String_{\sigma(n)}')\StringAlt_n$ by definition of $\Lens_{\sigma}$\\
$\PutRight{\ComposeLens{\Lens_{\sigma}}{\Lens}}(\String_0\String_1'\ldots\String_n'\String_n)=([(\String_0,\StringAlt_0);\AtomLens_0;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)],\sigma)(\String_0\String_1'\ldots\String_n'\String_n)$ by definition of clause lens\\
\\
\item$\FullContext \vdash \IterateLens{\DNFLens} : \Star{\DNFRegex} \Leftrightarrow \Star{\DNFRegexAlt}$\\
From induction assumption, I know that there exists $\FullContext \vdash \Lens : \Regex \Leftrightarrow \RegexAlt$, such that
$\PutRight{\DNFLens}=\PutRight{\Lens}$,
\LanguageOf{\RegexContext}{\Regex}=\LanguageOf{\RegexContext}{\DNFRegex}, and
$\LanguageOf{\Delta}{\RegexAlt}=\LanguageOf{\Delta}{\DNFRegexAlt}$.\\
Consider $\FullContext \vdash \IterateLens{\Lens} : \Star{\Regex} \Leftrightarrow \Star{\RegexAlt}$.\\
$\LanguageOf{\Delta}{\Star{\Regex}} = \String_0\ldots\String_n$ such that $\String_i \in \LanguageOf{\Delta}{\Regex}$ by definition of \LanguageOf{\Delta}{\Star{\Regex}}.\\
$\LanguageOf{\Delta}{\Star{\Regex}} = \String_0\ldots\String_n$ such that $\String_i \in \LanguageOf{\Delta}{\DNFRegex}$ as $\LanguageOf{\Delta}{\DNFRegex}=\LanguageOf{\Delta}{\Regex}$.\\
$\LanguageOf{\RegexContext}{\Star{\Regex}} = \LanguageOf{\RegexContext}{\Star{\DNFRegex}}$ by definition of \LanguageOf{\RegexContext}{\Star{\DNFRegex}}.

Similarly for \LanguageOf{\RegexContext}{\Star{\RegexAlt}}\\\\
$\PutRight{\IterateLens{\Lens}}(\String_0\ldots\String_n)=\PutRight{\Lens}(\String_0)\ldots\PutRight{\Lens}(\String_n)$ by definition of $\PutRight{\IterateLens{\Lens}}$.\\
$\PutRight{\IterateLens{\Lens}}(\String_0\ldots\String_n)=\PutRight{\DNFLens}(\String_0)\ldots\PutRight{\DNFLens}(\String_n)$ as \PutRight{\DNFLens}=\PutRight{\Lens}.\\
$\PutRight{\IterateLens{\Lens}}(\String_0\ldots\String_n)=\PutRight{\IterateLens{\DNFLens}}(\String_0\ldots\String_n)$ by definition of $\PutRight{\IterateLens{\DNFLens}}$.\\
\\
\item$\FullContext \vdash \IdentityLens : \RegexVariable \Leftrightarrow \RegexVariable$\\
Consider $\FullContext \vdash \IdentityLens : \RegexVariable \Leftrightarrow \RegexVariable$\\
$\PutRight{\IdentityLens}(\String)=\String$ by definition of dnf \PutRight{\IdentityLens{}}.\\
$\PutRight{\IdentityLens}(\String)=\PutRight{\IdentityLens}(\String)$ by definition of normal $\PutRight{\IdentityLens{}}$.
\end{itemize}
\end{proof}
\end{lemma}

\begin{theorem}[Soundness]
Let \Regex{} and \RegexAlt{} be two regular expressions, and \DNFRegex{} and \DNFRegexAlt{} be two dnf regular expressions.
If \LanguageOf{\Delta}{\Regex{}} = \LanguageOf{\Delta}{\DNFRegex{}} and \LanguageOf{\Delta}{\RegexAlt} = \LanguageOf{\Delta}{\DNFRegexAlt{}},
then if there exists a dnf lens $\DNFLens : \DNFRegex \Leftrightarrow \DNFRegexAlt$,
then there exists a lens $\Lens : \Regex \Leftrightarrow \RegexAlt$ such that
$\DNFLens.putr = \Lens.putr$.
\begin{proof}
By mutual induction on the typing \DNFLens{}, the typing of \ClauseLens{}, and the typing of \AtomLens{}.
\begin{enumerate}
\item[DNF Lens Intro] Let $\Delta \vdash ([\ClauseLens_1 ; \ldots ; \ClauseLens_n],\sigma) : [\Clause_{1,1}, \ldots, \Clause_{n,1}] \Leftrightarrow [\Clause_{\sigma(1),2}, \ldots, \Clause_{\sigma(n),2}]$.
This comes from the derivations that $\Delta \vdash \ClauseLens_i : \Clause_{i,1} \Leftrightarrow \Clause_{i,2}$ for all $i$.
Consider instead the lens $\DNFLens' = \Delta \vdash ([\ClauseLens_1 ; \ldots ; \ClauseLens_n],\sigma_id) : [\Clause_{1,1}, \ldots, \Clause_{n,1}] \Leftrightarrow[\Clause_{1,2}, \ldots, \Clause_{n,2}]$.
By Lemma (TODO: this lemma), these two lenses are semantically equivalent.
By Lemma (TODO: this lemma), $\Delta \vdash repregex(\DNFLens') : repregex(\DNFRegex_1) \Leftrightarrow repregex(\DNFRegex_2')$, with $repregex(\DNFLens)$ semantically equivalent to $\DNFLens$.
So $repregex(\DNFLens')$ is semantically equivalent to $\DNFLens'$, and $DNFLens'$ is semantically equivalent $\DNFLens$, so $repregex(\DNFLens')$ is
semantically equivalent to $\DNFLens$.  Merely adding in a retyping rule at
the end of $repregex(\DNFLens')$ (as they have the same type), completes this case.
\item[Clause Lens Intro] Let $\Delta \vdash ([(\String_{1,1},\String_{1,2}) ; \AtomLens_1 ; \ldots ; \AtomLens_n ; (\String_{n+1,1},\String_{n+1,2})],\sigma) : [\String_{1,1};\Atom_{1,1}; \ldots ; \Atom_{1,n} ; \String_{1,n+1}] \Leftrightarrow [\String_{1,2};\Atom_{\sigma(1),2}; \ldots ; \Atom_{\sigma(n),2} ; \String_{n+1,2}]$.
Consider two lenses, $\Delta \vdash ([(\String_{1,1},\String_{1,2}) ; \AtomLens_1 ; \ldots ; \AtomLens_n ; (\String_{n+1,1},\String_{n+1,2})],\sigma_id) : [\String_{1,1};\Atom_{1,1}; \ldots ; \Atom_{1,n} ; \String_{1,n+1}] \Leftrightarrow [\String_{1,2};\Atom_{1,2}; \ldots ; \Atom_{n,2} ; \String_{n+1,2}]$,
and $\Delta \vdash ([(\String_{1,2},\String_{1,2});identitylens(\Atom_{1,2}); \ldots ; identitylens(\Atom_{n,2}) ; (\String_{n+1,2},\String_{n+1,2})],\sigma) : [\String_{1,2};\Atom_{1,2}; \ldots ; \Atom_{n,2} ; \String_{n+1,2}] \Leftrightarrow [\String_{1,2};\Atom_{\sigma(1),2}; \ldots ; \Atom_{\sigma(n),2} ; \String_{n+1,2}]$.
By Lemma (TODO:), there exists a lens equivalent to the first one, call it $\Lens_{transform}$.
By Lemma (TODO:), there exists a lens equivalent to the second one, call it $\Lens_{\sigma}$.
Consider $\ComposeLens{\Lens_{\sigma}}{\Lens_{transform}}$.  Go through semantics, oh look they are equivalent.

\end{enumerate}
\end{proof}
\end{theorem}

