\section{Proofs}
%proof-dnfrc start
%First we will prove some lemmas.
\begin{lemma}[Equivalence of \ConcatSequence{} and \Concat{}]
If $\LanguageOf{\Regex}=\LanguageOf{\Sequence}$,
and $\LanguageOf{\RegexAlt}=\LanguageOf{\SequenceAlt}$,
then $\LanguageOf{\RegexConcat{\Regex}{\RegexAlt}}=\LanguageOf{\ConcatSequenceOf{\Sequence}{\SequenceAlt}}$.
\end{lemma}
\begin{proof}
Let $\Sequence=\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
\SequenceSep\Atom_n\SequenceSep\String_n}$, and
let\\ $\SequenceAlt=[\StringAlt_0\SequenceSep\AtomAlt_1\SequenceSep\ldots
\SequenceSep\AtomAlt_m\SequenceSep\StringAlt_m]$\\
\begin{tabular}{@{}L@{}L@{}}
\LanguageOf{\ConcatSequenceOf{\Sequence}{\SequenceAlt}} & = 
\LanguageOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
\SequenceSep\Atom_n\SequenceSep\String_n\Concat\StringAlt_0\SequenceSep{}
\AtomAlt_1\SequenceSep\ldots\SequenceSep\AtomAlt_m\SequenceSep\StringAlt_m}} \\
& = 
\{\String_0\Concat\String_1'\Concat\ldots\Concat\String_n'\Concat\String_n
\Concat\StringAlt_0\Concat\StringAlt_1'\Concat\ldots
\Concat\StringAlt_m'\Concat\StringAlt_m \\
& \hspace{5em} \SuchThat{} \String_i'\in\LanguageOf{\Atom_i} \BooleanAnd{}
\StringAlt_i'\in\LanguageOf{\AtomAlt_i}\}\\
& = 
\{\String\Concat\StringAlt{} \SuchThat{} \String\in\LanguageOf{\Sequence}
\BooleanAnd{} \StringAlt\in\LanguageOf{\SequenceAlt}\}\\
& =
\{\String\Concat\StringAlt{} \SuchThat{} \String\in\LanguageOf{\Regex}
\BooleanAnd{} \StringAlt\in\LanguageOf{\RegexAlt}\}\\
& =
\LanguageOf{\RegexConcat{\Regex}{\RegexAlt}}
\end{tabular}
\end{proof}

\begin{lemma}[Equivalence of \ConcatDNF{} and \Concat{}]
\label{lem:cdnfeq}
If $\LanguageOf{\Regex}=\LanguageOf{\DNFRegex}$,
and $\LanguageOf{\RegexAlt}=\LanguageOf{\DNFRegexAlt}$,
then $\LanguageOf{\RegexConcat{\Regex}{\RegexAlt}}=
\LanguageOf{\ConcatDNFOf{\DNFRegex}{\DNFRegexAlt}}$.
\end{lemma}
\begin{proof}
Let $\DNFRegex=\DNFOf{\Sequence_0\DNFSep\ldots\DNFSep\Sequence_n}$, and
let $\DNFRegexAlt=\DNFOf{\SequenceAlt_0\DNFSep\ldots\DNFSep\SequenceAlt_m}$
\begin{tabular}{@{}L@{}L@{}}
\LanguageOf{\ConcatDNFOf{\DNFRegex}{\DNFRegexAlt}} & = 
\LanguageOf{\DNFOf{\ConcatSequenceOf{\Sequence_i}{\SequenceAlt_j}
\text{ for $i\in\RangeIncInc{1}{n}$, $j\in\RangeIncInc{1}{m}$}}} \\
& = 
\{\String\SuchThat \String\in\ConcatSequenceOf{\Sequence_i}{\SequenceAlt_j}\\
& \hspace{5em}
\text{ where $i\in\RangeIncInc{1}{n}$, $j\in\RangeIncInc{1}{m}$}\}\\
& = 
\{\String\Concat\StringAlt{} \SuchThat{} \String\in\LanguageOf{\Sequence_i}
\BooleanAnd{} \StringAlt\in\LanguageOf{\SequenceAlt_j}\}\\
& \hspace{5em}
\text{ where $i\in\RangeIncInc{1}{n}$, $j\in\RangeIncInc{1}{m}$}\}\\
& =
\{\String\Concat\StringAlt{} \SuchThat{} \String\in\LanguageOf{\DNFRegex}
\BooleanAnd{} \StringAlt\in\LanguageOf{\DNFRegexAlt}\}\\
& =
\{\String\Concat\StringAlt{} \SuchThat{} \String\in\LanguageOf{\Regex}
\BooleanAnd{} \StringAlt\in\LanguageOf{\RegexAlt}\}\\
& =
\LanguageOf{\RegexConcat{\Regex}{\RegexAlt}}
\end{tabular}
\end{proof}

\begin{lemma}[Equivalence of \OrDNF{} and \Or{}]
\label{lem:odnfeq}
If $\LanguageOf{\Regex}=\LanguageOf{\DNFRegex}$,
and $\LanguageOf{\RegexAlt}=\LanguageOf{\DNFRegexAlt}$,
then $\LanguageOf{\RegexOr{\Regex}{\RegexAlt}}=
\LanguageOf{\OrDNFOf{\DNFRegex}{\DNFRegexAlt}}$.
\end{lemma}
\begin{proof}
Let $\DNFRegex=\DNFOf{\Sequence_0\DNFSep\ldots\DNFSep\Sequence_n}$, and
let $\DNFRegexAlt=\DNFOf{\SequenceAlt_0\DNFSep\ldots\DNFSep\SequenceAlt_m}$
\begin{tabular}{@{}L@{}L@{}}
\LanguageOf{\OrDNFOf{\DNFRegex}{\DNFRegexAlt}} & = 
\LanguageOf{\DNFOf{\Sequence_0\DNFSep\ldots\DNFSep\Sequence_n\DNFSep
\SequenceAlt_1\DNFSep\ldots\DNFSep\SequenceAlt_m}}\\
& = 
\{\String\SuchThat{} \String\in\Sequence_i\vee\String\in\SequenceAlt_j\\
& \hspace{5em}
\text{ where $i\in\RangeIncInc{1}{n}$, $j\in\RangeIncInc{1}{m}$}\}\\
& = 
\{\String{} \SuchThat{} \String\in\LanguageOf{\DNFRegex}
\BooleanOr{} \String\in\LanguageOf{\DNFRegexAlt}\}\\
& =
\{\String \SuchThat{} \String\in\LanguageOf{\Regex}
\BooleanOr{} \String\in\LanguageOf{\RegexAlt}\}\\
& =
\LanguageOf{\RegexOr{\Regex}{\RegexAlt}}
\end{tabular}\\
\end{proof}

\dnfrc*
\begin{proof}
By structural induction.

Let $\Regex=\String$.
$\LanguageOf{\ToDNFRegex(\String)}=\LanguageOf{\DNFOf{\SequenceOf{\String}}}=
\{\String\}=\LanguageOf{\String}$

Let $\Regex=\emptyset$.
$\LanguageOf{\ToDNFRegex(\emptyset)}=\LanguageOf{\DNFOf{}} =
\{\} = \LanguageOf{\emptyset}$.

Let $\Regex=\StarOf{\Regex'}$.
By induction assumption, $\LanguageOf{\ToDNFRegex(\Regex')}=
\LanguageOf{\Regex'}$.\\
\begin{tabular}{@{}L@{}L@{}}
\LanguageOf{\ToDNFRegex(\StarOf{\DNFRegex'})} & =
\LanguageOf{\DNFOf{\SequenceOf{\StarOf{\ToDNFRegex(\Regex')}}}}\\
& =
\{\String\SuchThat\String\in
\LanguageOf{\SequenceOf{\StarOf{\ToDNFRegex(\Regex')}}}\}\\
& = 
\{\String\SuchThat{} \String\in\LanguageOf{\StarOf{\ToDNFRegex(\Regex')}}\}\\
& =
\{\String_1\Concat\ldots\Concat\String_n\SuchThat{}
n\in\Nats\\
& \hspace*{3em}\BooleanAnd\String_i\in\LanguageOf{\ToDNFRegex(\Regex')}\}\\
& =
\{\String_1\Concat\ldots\Concat\String_n\SuchThat{}
n\in\Nats\BooleanAnd\String_i\in\LanguageOf{\Regex'}\}\\
& = \LanguageOf{\StarOf{\Regex'}}
\end{tabular}

Let $\Regex=\RegexConcat{\Regex_1}{\Regex_2}$.
By induction assumption,
$\LanguageOf{\ToDNFRegex(\Regex_1)}=\LanguageOf{\Regex_1}$, and
$\LanguageOf{\ToDNFRegex(\Regex_2)}=\LanguageOf{\Regex_2}$.
$\ToDNFRegex(\RegexConcat{\Regex_1}{\Regex_2})=
\ConcatDNFOf{\ToDNFRegex(\Regex_1)}{\ToDNFRegex(\Regex_2)}$.
By Lemma~\ref{lem:cdnfeq},
$\RegexConcat{\Regex_1}{\Regex_2}=
\ConcatDNFOf{\ToDNFRegex(\Regex_1)}{\ToDNFRegex(\Regex_2)}$.

Let $\Regex=\RegexOr{\Regex_1}{\Regex_2}$.
By induction assumption,
$\LanguageOf{\ToDNFRegex(\Regex_1)}=\LanguageOf{\Regex_1}$, and
$\LanguageOf{\ToDNFRegex(\Regex_2)}=\LanguageOf{\Regex_2}$.
$\ToDNFRegex(\RegexOr{\Regex_1}{\Regex_2})=
\OrDNFOf{\ToDNFRegex(\Regex_1)}{\ToDNFRegex(\Regex_2)}$.
By Lemma~\ref{lem:odnfeq},
$\RegexOr{\Regex_1}{\Regex_2}=
\OrDNFOf{\ToDNFRegex(\Regex_1)}{\ToDNFRegex(\Regex_2)}$.
\end{proof}
%proof-dnfrc end



%proof-dnfrs start
%First we will prove some lemmas.
\begin{lemma}
\label{lem:sequence-rx}
Let $\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_n\SequenceSep\String_n}$ be a sequence,
and\\
$\ToDNFRegex(\ToRegex(\Atom_i))=\DNFOf{\SequenceOf{\Atom_i}}$.
Then,\\$\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_n\SequenceSep\String_n}))=$\\
$\DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_n\SequenceSep\String_n}}$.
\end{lemma}
\begin{proof}
By induction on $n$.

Let $n=0$.
$\Sequence=\SequenceOf{\String_0}$.\\
$\ToDNFRegex(\ToRegex(\SequenceOf{\String_0}))=
\ToDNFRegex(\String_0)=\DNFOf{\SequenceOf{\String_0}}$

Let $n>0$,
$\Sequence=\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_n\SequenceSep\String_n}$.\\
$\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_n\SequenceSep\String_n}))$\\
$\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_{n-1}\SequenceSep\String_{n-1}})\Concat\ToRegex(\Atom_n)
\Concat\String_n)$=\\
$\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_{n-1}\SequenceSep\String_{n-1}}))
\ConcatDNF\\
\ToDNFRegex(\ToRegex(\Atom_n))
\ConcatDNF\\
\ToDNFRegex(\String_{n-1})$=
$\DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_{n-1}\SequenceSep\String_{n-1}}}
\ConcatDNF\\
\DNFOf{\SequenceOf{\Atom_n}}
\ConcatDNF
\DNFOf{\SequenceOf{\String_n}}$=
$\DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\Atom_n\SequenceSep\String_n}}$.
\end{proof}



\begin{lemma}
\label{lem:dnf-rx}
Let $\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}$ be a sequence,
and\\ $\ToDNFRegex(\ToRegex(\Sequence_i))=\DNFOf{\Sequence_i}$.
Then,\\ $\ToDNFRegex(\ToRegex(\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}))=
\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}$.
\end{lemma}
\begin{proof}

By induction on $n$.

Let $n=0$
$\ToDNFRegex(\ToRegex(\DNFOf{}))=\ToDNFRegex(\emptyset)=\DNFOf{}$.

Let $n>0$
$\ToDNFRegex(\ToRegex(\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_n}))=
\ToDNFRegex(\ToRegex(\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_{n-1}})
\Concat\ToRegex(\Sequence_n))$=
$\ToDNFRegex(\ToRegex(\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_{n-1}}))
\ConcatDNF\\\ToDNFRegex(\ToRegex(\Sequence_n))$=
$\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_n}$
\end{proof}

\begin{lemma}[Elimination of $\ToDNFRegex\Compose\ToRegex$]\leavevmode
\begin{enumerate}
\item $\ToDNFRegex(\ToRegex(\Atom))=\DNFOf{\SequenceOf{\Atom}}$
\item $\ToDNFRegex(\ToRegex(\Sequence))=\DNFOf{\Sequence}$
\item $\ToDNFRegex(\ToRegex(\DNFRegex))=\DNFRegex$
\end{enumerate}
\end{lemma}
\begin{proof}
By mutual induction

Let $\StarOf{\DNFRegex}$ be an atom.
$\ToDNFRegex(\ToRegex(\StarOf{\DNFRegex}))=
\ToDNFRegex(\StarOf{\ToRegex(\DNFRegex)})=
\DNFOf{\SequenceOf{\StarOf{\ToDNFRegex(\ToRegex(\DNFRegex))}}}=
\DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}$

Let $\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
\SequenceSep\Atom_n\SequenceSep\String_n}$ be a sequence.
$\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
\SequenceSep\Atom_n\SequenceSep\String_n}))$.
By induction assumption, for each $\Atom_i$,
$\ToDNFRegex(\ToRegex(\Atom_i))=\DNFOf{\SequenceOf{\Atom_i}}$.
By Lemma~\ref{lem:sequence-rx},
$\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
\SequenceSep\Atom_n\SequenceSep\String_n}))=
\DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
\SequenceSep\Atom_n\SequenceSep\String_n}}$.

Let $\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_n}$ be a DNF
regular expression.
By induction assumption, for each $\Sequence_i$,
$\ToDNFRegex(\ToRegex(\Sequence_i))=\DNFOf{\Sequence_i}$.
By Lemma~\ref{lem:dnf-rx},
$\ToDNFRegex(\ToRegex(\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_n}))=
\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_n}$.

\end{proof}
%proof-dnfrs end




%proof-dnfls start
%We will prove a couple of lemmas first.

\begin{lemma}[Expressibility of Safe Boilerplate Alterations]
\label{lem:boilerplate-alterations}
Suppose
\begin{enumerate}
\item $\UnambigConcat\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}$
\item $\UnambigConcat\SequenceOf{\StringAlt_0;\Atom_1;\ldots;\Atom_n;\StringAlt_n}$
\end{enumerate}
Then there exists a lens
$\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that
\begin{enumerate}
\item $\Regex = \ToRegex(\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n})$
\item $\RegexAlt = \ToRegex(\SequenceOf{\StringAlt_0;\Atom_1;\ldots;\Atom_n;\StringAlt_n})$
\item $\SemanticsOf{\Lens}=\SetOf{(\String,\StringAlt)\SuchThat
\String=\String_0\Concat\String_1'\Concat\ldots\Concat\String_n'\Concat\String_n
\BooleanAnd\\
\hspace*{6.1em}\StringAlt=\StringAlt_0\Concat\String_1'\Concat\ldots\Concat\String_n'\Concat\StringAlt_n
\BooleanAnd\\
\hspace*{6.1em}\String_i\in\LanguageOf{\Atom_i}}$
\end{enumerate}
\end{lemma}
\begin{proof}
By induction on $n$.

Let $n=0$.
Consider the Lens
\begin{mathpar}
\inferrule*
{
}
{
\ConstLensOf{\String_0}{\StringAlt_0} \OfType \String_0 \Leftrightarrow \StringAlt_0
}
\end{mathpar}
By inspection, this satisfies the desired properties.

Let $n>0$.
By induction, there exists a lens $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$
satisfying the desired properties.
Consider the lens
\begin{mathpar}
\inferrule*[left=\Derivation]
{
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens \OfType \Regex \Leftrightarrow \RegexAlt
}\\
\inferrule*
{
}
{
\ConstLensOf{\String_n}{\StringAlt_n} \OfType \String_n \Leftrightarrow \StringAlt_n
}
}
{
\ConcatLensOf{\Lens}{\ConstLensOf{\String_n}{\StringAlt_n}}
\OfType
\Regex \Concat \String_n \Leftrightarrow
\RegexAlt \Concat \StringAlt_n
}

\inferrule*
{
\Derivation\\
\IdentityLensOf{\ToRegex(\Atom_n)} \OfType \ToRegex(\Atom_n) \Leftrightarrow \ToRegex(\Atom_n)
}
{
\ConcatLensOf{\ConcatLensOf{\Lens}{\ConstLensOf{\String_n}{\StringAlt_n}}}{\IdentityLensOf{\ToRegex(\Atom_n)}}
\OfType\\
\Regex \Concat \String_n \Concat \ToRegex(\Atom_n) \Leftrightarrow
\Regex \Concat \StringAlt_n \Concat \ToRegex(\Atom_n)
}
\end{mathpar}
By inspection, this satisfies the desired properties.
\end{proof}

\begin{lemma}[Creation of Lens from Identity Perm Sequence Lens]
\label{lem:id-clause}
Suppose
\begin{enumerate}
\item $\Sequence=\SequenceOf{\String_0 ; \Atom_1 ; \ldots ; \Atom_n; \String_n}$
\item $\SequenceAlt=\SequenceOf{\StringAlt_0 ; \AtomAlt_1 ; \ldots ; \AtomAlt_n ; \StringAlt_n}$
\item $(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1 ; \ldots ;
	\AtomLens_n;(\String_n,\StringAlt_n)},id) \OfType
	\Sequence \Leftrightarrow \SequenceAlt$
\item For each $\AtomLens_i \OfType \Atom_i \Leftrightarrow \AtomAlt_i$,
there exists a $\Lens_i \OfType \ToRegex(\Atom_i) \Leftrightarrow
\ToRegex(\AtomAlt_i)$ such that $\SemanticsOf{\Lens_i}=\SemanticsOf{\AtomLens_i}$
\end{enumerate}
then there exists a $\Lens \OfType \ToRegex(\Sequence) \Leftrightarrow \ToRegex(\DNFRegexAlt)$ such that
$\SemanticsOf{\Lens} =
\SemanticsOf{(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1 ; \ldots ; \AtomLens_n;(\String_n,\StringAlt_n)},id)}$.
\begin{proof}
By induction on $n$.

Let $n=0$, $(\SequenceLensOf{(\String_0,\StringAlt_0)},id) \OfType
\SequenceOf{\String_0} \Leftrightarrow \SequenceOf{\StringAlt_0}$.
Then consider
\begin{mathpar}
\inferrule[]
{
}
{
\ConstLensOf{\String_0}{\StringAlt_0}\OfType\String_0\Leftrightarrow\StringAlt_0
}
\end{mathpar}

$\String_0=\ToRegex(\SequenceOf{\String_0})$,
and
$\StringAlt_0=\ToRegex(\SequenceOf{\StringAlt_0})$.
$\SemanticsOf{\ConstLensOf{\String_0}{\StringAlt_0}}=
\SetOf{\String_0,\StringAlt_0}=
\SemanticsOf{\SequenceOf{(\String_0,\StringAlt_0)},id)}$.

Let $n>0$.
Let $\Sequence'=\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
\ldots\SequenceSep\Atom_{n-1}\SequenceSep\String_{n-1}}$,
and $\SequenceAlt'=\SequenceOf{\StringAlt_0\SequenceSep\AtomAlt_1\SequenceSep
\ldots\SequenceSep\AtomAlt_{n-1}\SequenceSep\StringAlt_{n-1}}$
By induction assumption, there exists a typing derivation
\begin{mathpar}
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens\OfType\ToRegex(\Sequence')\Leftrightarrow\ToRegex(\SequenceAlt')
}
\end{mathpar}
satisfying $\SemanticsOf{\Lens}=\\
\SemanticsOf{(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1 ;
\ldots ; \AtomLens_{n-1};(\String_{n-1},\StringAlt_{n-1})},id)}$

By problem statement, there exists a typing derivation
\begin{mathpar}
\inferrule*[left=$\Derivation_n$]
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens_{\AtomLens_{n}} \OfType
\ToRegex(\Atom_{n}) \Leftrightarrow \ToRegex(\AtomAlt_{n})
}
\end{mathpar}
satisfying $\SemanticsOf{\Lens_{\Atom_n}}
=\SemanticsOf{\Atom_n}$.

Consider the following lens typing
\begin{mathpar}
\inferrule*[left=\Derivation{}]
{
\Derivation_n\\
\inferrule*
{
}
{
\ConstLensOf{\String_n}{\StringAlt_n}
\OfType
\String_n \Leftrightarrow \StringAlt_n
}
}
{
\ConcatLensOf{\Lens_{\AtomLens_n}}{\ConstLensOf{\String_n}{\StringAlt_n}}
\OfType
\ToRegex(\Atom_n)\Concat\String_n \Leftrightarrow
\ToRegex(\AtomAlt_n)\Concat\StringAlt_n
}

\inferrule*{
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens\OfType\ToRegex(\Sequence) \Leftrightarrow \ToRegex(\SequenceAlt)
}\\
\Derivation{}
}
{
\ConcatLensOf
{\Lens}
{\ConcatLensOf{\Lens_{\AtomLens_n}}{\ConstLensOf{\String_n}{\StringAlt_n}}}
\OfType\\
\ToRegex(\Sequence)\Concat\ToRegex(\Atom_n)\Concat\String_n \Leftrightarrow
\ToRegex(\SequenceAlt)\Concat\ToRegex(\AtomAlt_n)\Concat\StringAlt_n
}
\end{mathpar}

\SemanticsOf{\ConcatLensOf
{\Lens}
{\ConcatLensOf{\Lens_{\AtomLens_n}}{\ConstLensOf{\String_n}{\StringAlt_n}}}}\\
\hspace*{3em}=\SetOf{(\String,\StringAlt)
\SuchThat
\String = \String'\Concat\String''\Concat\String_n\BooleanAnd
\StringAlt = \StringAlt'\Concat\StringAlt''\Concat\StringAlt_n\BooleanAnd\\
\hspace*{7em}
(\String',\StringAlt')\in\SemanticsOf{\Lens}\BooleanAnd
(\String'',\StringAlt'')\in\SemanticsOf{\Lens_{\AtomLens_n}}}\\
\hspace*{3em}=\SetOf{
(\String,\StringAlt)\SuchThat
\String=
\String_0\Concat\String_0'\Concat\ldots
\Concat\String_{n-1}'\Concat\String_{n-1}
\Concat \String_n \Concat \String_n'\BooleanAnd\\
\hspace*{7em}\StringAlt=\StringAlt_0\Concat\StringAlt_0'\Concat\ldots
\Concat\StringAlt_{n-1}'\Concat\StringAlt_{n-1}
\Concat \StringAlt_n \Concat \StringAlt_n'\BooleanAnd\\
\hspace*{7em}\String_i'\in\Atom_i\BooleanAnd\StringAlt_i'\in\AtomAlt_i}\\
\hspace*{3em}=\SemanticsOf{(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1 ;
\ldots ; \AtomLens_n;(\String_n,\StringAlt_{n-1})},id)}
\end{proof}
\end{lemma}

\begin{theorem}[Unambiguity of $\Sep$]
Let $\Alphabet$ be an alphabet.  Let $\Alphabet_{\Sep}=\Alphabet\Union\SetOf{\Sep}$,
where \Sep{} is a character not in \Alphabet{}.
If $\Language_1, \ldots,
\Language_n$, are languages in $\StarOf{\Alphabet}$, then
$\UnambigConcat\SequenceOf{\LanguageOf{\Sep};\Language_1;\LanguageOf{\Sep};
\ldots;\LanguageOf{\Sep};\Language_n;\LanguageOf{\Sep}}$.
\end{theorem}
\begin{proof}
We prove this by induction on $n$.

Let $n=0$.  $\UnambigConcat\SequenceOf{\LanguageOf{\Sep}}$, as
$\UnambigConcat\SequenceOf{\Language}$, for any language $\Language$.

Let $n>0$.
Let $\String_i, \StringAlt_i\in\Language_i$ for all $i\in\RangeIncInc{1}{n}$,
and let $\Sep\String_1\Sep\ldots\Sep\String_n\Sep=\Sep\StringAlt_1\Sep\ldots\Sep\StringAlt_n\Sep$.
We want to show that $\String_n\Sep=\StringAlt_n\Sep$.
If they were not equal, then one string is strictly contained in the other, say without
loss of generality $\String_n\Sep$ is strictly contained in $\StringAlt_n\Sep$.
Because of that $\Sep\String_n\Sep$ is contained in $\StringAlt_n\Sep$, so $\Sep$
is contained in $\StringAlt_n\in\StarOf{\Sigma}$.  This is a contradiction,
as $\Sep\notin\Sigma$, so we know $\String_n\Sep=\StringAlt_n\Sep$, and so $\String_n=\StringAlt_n$.
This means that
$\Sep\String_0\Sep\ldots\Sep\String_{n-1}\Sep=\Sep\StringAlt_0\Sep\ldots\Sep\StringAlt_{n-1}$,
so by induction, I know $\String_i=\StringAlt_i$ for all $i$.
\end{proof}

\begin{definition}[Adjacent Swapping Permutation]
Let $\sigma_{i} \in S_n$ be the permutation where
$\sigma_{i}(i) = i+1$, $\sigma_{i}(i+1) = i$, $\sigma_{i}(k) = k$
when $k\neq i$, and $k\neq i+1$.
\end{definition}

\begin{lemma}[Expressibility of Adjacent Swapping Permutation Lens]
\label{lem:adj-perm-exp}
Suppose
\begin{enumerate}
\item $\sigma_i$ is an adjacent element swapping permutation
\item $\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep}$ is a sequence with
all base strings equal to $\Sep$.
\end{enumerate}
Then there exists a typing of a lens $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that
\begin{enumerate}
\item $\LanguageOf{\Regex}=\LanguageOf{[\Sep;\Atom_1;\ldots;\Atom_n;\Sep]}$
\item $\LanguageOf{\RegexAlt}=\LanguageOf{[\Sep;\Atom_{\sigma_i(1)};\ldots;\Atom_{\sigma_i(n)};\Sep]}$
\item $\SemanticsOf{\Lens}=
\SetOf{(\String,\StringAlt)\SuchThat\String=\Sep\Concat\String_1\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_n\Concat\Sep
\BooleanAnd\\
\hspace*{6em}\StringAlt=\Sep\Concat\String_{\sigma_i(1)}\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_{\sigma_i(n)}\Sep\BooleanAnd\\
\hspace*{6em}\String_i\in\LanguageOf{\Atom_i}}$
\end{enumerate}
\begin{proof}
By the soundness of regular expressions, define regular expressions
$\Regex_1, \Regex_2, \Regex_3, \Regex_4$ as
$\Regex_1=\ToRegex([\Sep;\Atom_1;\ldots;\Atom_{i-1};\Sep])$,
$\Regex_2=\ToRegex(\Atom_i)$,
$\Regex_3=\ToRegex(\Atom_{i+1})$, and
$\Regex_4=\ToRegex([\Sep;\Atom_{i+1};\ldots;\Atom_{n};\Sep])$.
Consider the following deduction\bcp{I find these deductions a bit heavy and
  hard to read, but I guess I can get used to them.  }
\afm{Anybody have suggestions for better deduction package?}
\begin{mathpar}

\inferrule*[left=\Derivation{}]
{
\inferrule*
{
}
{
\IdentityLensOf{\Sep} \OfType \Sep \Leftrightarrow \Sep
}
\inferrule*
{
}
{
\IdentityLensOf{\Regex_3} \OfType \Regex_3 \Leftrightarrow \Regex_3
}
}
{
\SwapLensOf{\IdentityLensOf{\Sep}}{\IdentityLensOf{\Regex_3}} \OfType 
\Sep\Concat\Regex_3 \Leftrightarrow \Regex_3\Concat\String_i
}

\inferrule*[left=\Derivation{}']
{
\inferrule*
{
}
{
\IdentityLensOf{\Regex_2} \OfType \Regex_2 \Leftrightarrow \Regex_2
}\\
\Derivation
}
{
\SwapLensOf{\IdentityLensOf{\Regex_2}}{\SwapLensShortOf{\IdentityLensShortOf{\Sep}}{\IdentityLensShortOf{\Regex_3}}} \OfType
\Regex_2\Concat\Sep\Concat\Regex_3 \Leftrightarrow \Regex_3\Concat\Sep\Concat\Regex_2
}

\inferrule*[left=\Derivation{}'']
{
\inferrule*
{
}
{
\IdentityLensOf{\Regex_1} \OfType \Regex_1 \Leftrightarrow \Regex_1
}\\
\Derivation{}'
}
{
\ConcatLensOf{\IdentityLensOf{\Regex_1}}{\SwapLensShortOf{\IdentityLensShortOf{\Regex_2}}{\SwapLensShortOf{\IdentityLensShortOf{\Sep}}{\IdentityLensShortOf{\Regex_3}}}} \OfType\\
\Regex_1\Concat\Regex_2\Concat\Sep\Concat\Regex_3 \Leftrightarrow \Regex_1\Concat\Regex_3\Concat\Sep\Concat\Regex_2
}


\inferrule*
{
\Derivation{}''\\
\inferrule*
{
}
{
\IdentityLensOf{\Regex_4} \OfType \Regex_4 \Leftrightarrow \Regex_4
}
}
{
\ConcatLensOf{\ConcatLensShortOf{\IdentityLensShortOf{\Regex_1}}{\SwapLensShortOf{\IdentityLensShortOf{\Regex_2}}{\SwapLensShortOf{\IdentityLensShortOf{\Sep}}{\IdentityLensShortOf{\Regex_3}}}}}{\IdentityLensOf{\Regex_4}} \OfType\\
\Regex_1\Concat\Regex_2\Concat\Sep\Concat\Regex_3\Concat\Regex_4 \Leftrightarrow \Regex_1\Concat\Regex_3\Concat\Sep\Concat\Regex_2\Concat\Regex_4
}
\end{mathpar}

By inspection, the final lens
$\ConcatLensShortOf{\ConcatLensShortOf{\IdentityLensShortOf{\Regex_1}}{\SwapLensShortOf{\IdentityLensShortOf{\Regex_2}}{\SwapLensShortOf{\IdentityLensShortOf{\Sep}}{\IdentityLensShortOf{\Regex_3}}}}}{\IdentityLensShortOf{\Regex_4}} \OfType
\Regex_1\Concat\Regex_2\Concat\Sep\Concat\Regex_3\Concat\Regex_4 \Leftrightarrow \Regex_1\Concat\Regex_3\Concat\Sep\Concat\Regex_2\Concat\Regex_4$
satisfies $\LanguageOf{\Regex_1\Concat\Regex_2\Concat\String_i\Concat\Regex_3\Concat\Regex_4}=\LanguageOf{\SequenceOf{\Sep;\Atom_1;\Sep;\ldots;\Sep;\Atom_n;\Sep}}$ and
$\LanguageOf{\Regex_1\Concat\Regex_3\Concat\String_i\Concat\Regex_2\Concat\Regex_4}=\LanguageOf{\SequenceOf{\Sep;\Atom_{\sigma_i(1)};\ldots;\Atom_{\sigma_i(n)};\Sep}}$
and has the desired semantics of swapping the strings at spots $i$ and $i+1$.
\end{proof}
\end{lemma}

\begin{lemma}[Expressibility of Adjacent Swapping Permutation Composition]
\label{lem:adj-comp-perm-exp}
Suppose
\begin{enumerate}
\item $\sigma=\sigma_{i_1}\Compose\ldots\Compose\sigma_{i_m}$ 
\item $\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep}$ is a sequence with
all base strings equal to $\Sep$.
\end{enumerate}
Then there exists a typing of a lens $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that
\begin{enumerate}
\item $\LanguageOf{\Regex}=\LanguageOf{[\Sep;\Atom_1;\ldots;\Atom_n;\Sep]}$
\item $\LanguageOf{\RegexAlt}=\LanguageOf{[\Sep;\Atom_{\sigma(1)};\ldots;\Atom_{\sigma(n)};\Sep]}$
\item $\SemanticsOf{\Lens}=
\SetOf{(\String,\StringAlt)\SuchThat\String=\Sep\Concat\String_1\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_n\Concat\Sep
\BooleanAnd\\
\hspace*{6em}\StringAlt=\Sep\Concat\String_{\sigma(1)}\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_{\sigma(n)}\Sep\BooleanAnd\\
\hspace*{6em}\String_i\in\LanguageOf{\Atom_i}}$
\end{enumerate}
\begin{proof}
By induction on $m$.

Let $m=0$.  Then $\sigma=\Identity$.  Consider the lens
$\IdentityLensOf{\ToRegex(\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep})} \OfType
\ToRegex(\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep}) \Leftrightarrow
\ToRegex(\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep})$.
By inspection, this lens satisfies the requirements.

Let $m>0$.  Let $\sigma'=\sigma_{i_1}\Compose\ldots\Compose\sigma_{i_{m-1}}$.
Let $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ be the lens obtained by an
application of the induction assumption on $\sigma'$.
Let $\Lens_m \OfType \RegexAlt' \Leftrightarrow \RegexAlt''$ be the lens obtained by
an application of Lemma~\ref{lem:adj-perm-exp} to the permutation $\sigma_m$ and
the sequence $\SequenceOf{\Sep;\Atom_{\sigma'(1)};\ldots;\Atom_{\sigma'(n)};\Sep}$.
From the induction assumption and the previous lemmas,
we know $\LanguageOf{\RegexAlt}=
\LanguageOf{\SequenceOf{\Sep;\Atom_{\sigma'(1)};\ldots;\Atom_{\sigma'(n)};\Sep}}=
\LanguageOf{\RegexAlt'}$.
Consider the following Lens typing

\begin{mathpar}
\inferrule*
{
\inferrule*
{
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens \OfType \Regex \Leftrightarrow \RegexAlt
}\\
\LanguageOf{\RegexAlt}=\LanguageOf{\RegexAlt'}
}
{
\Lens \OfType \Regex \Leftrightarrow \RegexAlt'
}\\
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens_m \OfType \RegexAlt' \Leftrightarrow \RegexAlt''
}
}
{
\ComposeLensOf{\Lens_m}{\Lens} \OfType \Regex \Leftrightarrow \RegexAlt''
}
\end{mathpar}

The language of \Regex{} is already as desired, and
$\LanguageOf{\RegexAlt''}=
\LanguageOf{\SequenceOf{\Sep;\Atom_{\sigma_m\Compose\sigma'(1)};\ldots;\Atom_{\sigma_m\Compose\sigma'(n)}}}=
\LanguageOf{\SequenceOf{\Sep;\Atom_{\sigma(1)};\ldots;\Atom_{\sigma(n)}}}$, as desired.
Furthermore, the composition of the lenses composes the permutations of strings,
giving the semantics as desired.
\end{proof}
\end{lemma}

\begin{lemma}[Expressibility of Permutation]
\label{lem:perm-exp}
Suppose
\begin{enumerate}
\item $\sigma$ is a permutation in $S_n$
\item $\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep}$ is a sequence with
all base strings equal to $\Sep$.
\end{enumerate}
Then there exists a typing of a lens $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that
\begin{enumerate}
\item $\LanguageOf{\Regex}=\LanguageOf{[\Sep;\Atom_1;\ldots;\Atom_n;\Sep]}$
\item $\LanguageOf{\RegexAlt}=\LanguageOf{[\Sep;\Atom_{\sigma(1)};\ldots;\Atom_{\sigma(n)};\Sep]}$
\item $\SemanticsOf{\Lens}=
\SetOf{(\String,\StringAlt)\SuchThat\String=\Sep\Concat\String_1\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_n\Concat\Sep
\BooleanAnd\\
\hspace*{6em}\StringAlt=\Sep\Concat\String_{\sigma(1)}\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_{\sigma(n)}\Sep\BooleanAnd\\
\hspace*{6em}\String_i\in\LanguageOf{\Atom_i}}$
\end{enumerate}
\end{lemma}
\begin{proof}
By algebra, any permutation can be expressed as the composition of adjacent swapping permutations.
As such, $\sigma=\sigma_{i_1}\Compose\ldots\Compose\sigma_{i_m}$ for some adjacency swapping
permutations $\sigma_{i_j}$.
By Lemma~\ref{lem:adj-comp-perm-exp}, we obtain a lens with the properties desired.
\end{proof}

\begin{lemma}[Creation of Lens from Identity Perm DNF Lens]
\label{lem:id-dnf}
Suppose
\begin{enumerate}
\item $\DNFRegex = \DNFOf{\Sequence_1 ; \ldots ; \Sequence_n}$
\item $\DNFRegexAlt = \DNFOf{\SequenceAlt_1 ; \ldots ; \SequenceAlt_n}$
\item $(\DNFLensOf{\SequenceLens_1 ; \ldots ; \SequenceLens_n},id) \OfType
\DNFRegex \Leftrightarrow \DNFRegexAlt$
\item For each $\SequenceLens_i \OfType \Sequence_i \Leftrightarrow \SequenceAlt_i$,
there exists a $\Lens_i$ such that $\SemanticsOf{\Lens_i}=\SemanticsOf{\SequenceLens_i}$.
\end{enumerate}
then there exists a $\Lens \OfType \ToRegex(\DNFRegex) \Leftrightarrow \ToRegex(\DNFRegexAlt)$ such that $\SemanticsOf{\Lens} = \SemanticsOf{([\SequenceLens_1 ; \ldots ; \SequenceLens_n],id)}$.
\begin{proof}
By induction on n

Let $n=0$.
$\DNFLensOf{} \OfType \DNFOf{} \Leftrightarrow \DNFOf{}$.  Then consider
\begin{mathpar}
\inferrule*
{
}
{
\IdentityLensOf{\ToRegex(\DNFOf{})} \OfType
\ToRegex(\DNFOf{}) \Leftrightarrow \ToRegex(\DNFOf{})
}
\end{mathpar}
This has the desired typing, and
$\SemanticsOf{\IdentityLensOf{\ToRegex(\DNFOf{})}}
=\SemanticsOf{\IdentityLensOf{\emptyset}}
=\SetOf{}=\SemanticsOf{\DNFLensOf{}}$.

Let $n>0$.
Let $\DNFRegex' = \DNFOf{\Sequence_1;\ldots;\Sequence_{n-1}}$, and
$\DNFRegexAlt' = \DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_{n-1}}$.
By induction assumption, there exists a derivation of 
$\Lens \OfType \ToRegex(\DNFRegex') \Leftrightarrow \ToRegex(\DNFRegexAlt')$.
By problem statement, there exists a typing derivation
$\Lens_n \OfType \ToRegex(\Sequence_n) \Leftrightarrow \ToRegex(\SequenceAlt_n)$
Consider the following derivation
\begin{mathpar}
\inferrule*
{
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens \OfType \ToRegex(\DNFRegex') \Leftrightarrow \ToRegex(\DNFRegexAlt')
}\\
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens_n \OfType \ToRegex(\Sequence_n) \Leftrightarrow \ToRegex(\SequenceAlt_n)
}
}
{
\OrLensOf{\Lens_n}{\Lens} \OfType \RegexOr{\ToRegex(\DNFRegex')}{\ToRegex(\Sequence_n)} \Leftrightarrow \RegexOr{\ToRegex(\DNFRegexAlt')}{\ToRegex(\Sequence_n)}
}
\end{mathpar}
$\SemanticsOf{\OrLensOf{\Lens}{\Lens_n}}=\SetOf{(\String,\StringAlt)\SuchThat
(\String,\StringAlt)\in\Lens\BooleanOr(\String,\StringAlt)\in\Lens_n}$\\
\hspace*{4.6em}$=\SetOf{(\String,\StringAlt)\SuchThat
(\String,\StringAlt)\in\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_{n-1}}\\
\hspace*{8em}\BooleanOr(\String,\StringAlt)\in\DNFLensOf{\SequenceLens_n}}$\\
\hspace*{4.6em}$=\SetOf{(\String,\StringAlt)\SuchThat
(\String,\StringAlt)\in\SequenceLens_i}$.
\end{proof}
\end{lemma}

\begin{lemma}[Ineffectiveness of Permutation on DNF Regex Semantics]
\label{lem:dnfr-perm-sem-ineffective}
Let $\sigma\in S_n$, and $\DNFOf{\Sequence_1\ldots\Sequence_n}$ be a DNF regex.
$\LanguageOf{\DNFOf{\Sequence_1;\ldots;\Sequence_n}}=
\LanguageOf{\DNFOf{\Sequence_{\sigma(1)};\ldots;\Sequence_{\sigma(n)}}}$.
\end{lemma}
\begin{proof}
By inspection.
\end{proof}

\begin{lemma}[Ineffectiveness of Permutation on DNF Lens Semantics]
\label{lem:dnfl-perm-sem-ineffective}
Let $\sigma\in S_n$, and
$(\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n},\Identity) \OfType
\DNFOf{\Sequence_1;\ldots;\Sequence_n} \Leftrightarrow
\DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_n}$ be a typing of a DNF lens with
an identity permutation.
$\SemanticsOf{(\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n},\Identity)}
=\SemanticsOf{(\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n},\sigma)}$
\end{lemma}
\begin{proof}
By inspection
\end{proof}

\begin{lemma}[Rewrites Respecting Language]
\label{lem:rrl}
If $\DNFRegex\Rewrite\DNFRegexAlt$, then $\LanguageOf{\DNFRegex}=\LanguageOf{\DNFRegexAlt}$
\end{lemma}
\begin{proof}
Each of the rewrite rules are merely an application of one direction of one of
the regular expression star equivalences.
\end{proof}

\begin{lemma}[Soundness of DNF, Sequence, and Atom Lenses]\leavevmode
\label{lem:dnfcal}
\begin{enumerate}
\item Let \DNFRegex{} and \DNFRegexAlt{} be two dnf regular expressions, and $\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$.  Then there exists a \Lens{} such that $\Lens \OfType \ToRegex(\DNFRegex) \Leftrightarrow \ToRegex(\DNFRegexAlt)$, \SemanticsOf{\Lens}=\SemanticsOf{\DNFLens}

\item Let \Sequence{} and \SequenceAlt{} be two clauses, and $\SequenceLens \OfType \Sequence \Leftrightarrow \SequenceAlt$.  Then there exists a \Lens{} such that $\Lens \OfType \ToRegex(\Sequence) \Leftrightarrow \ToRegex(\SequenceAlt)$, \SemanticsOf{\Lens}=\SemanticsOf{\SequenceLens}.

\item Let \Atom{} and \AtomAlt{} be two atoms, and $\AtomLens \OfType \Atom \Leftrightarrow \AtomAlt$.  Then there exists a \Lens{}, such that $\Lens \OfType \ToRegex(\Atom) \Leftrightarrow \ToRegex(\AtomAlt)$, \SemanticsOf{\Lens}=\SemanticsOf{\AtomLens}.
\end{enumerate}
\begin{proof}
By mutual induction on the structure of the DNF Regex, Sequence, and
Atom lenses typing.\\ 
\\
Let $\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$ be formed from an
application of\\$\DNFRewriteLensRule{}$.
\begin{mathpar}
\inferrule*
{
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\DNFLens \OfType \DNFRegex' \Leftrightarrow \DNFRegexAlt'
}\\
\DNFRegex' \RewriteDNF \DNFRegex\\
\DNFRegexAlt' \RewriteDNF \DNFRegexAlt
}
{
\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt
}
\end{mathpar}
By induction assumption, there exists a
$\Lens \OfType \ToRegex(\DNFRegex') \Leftrightarrow \ToRegex(\DNFRegexAlt')$,
and from Lemma~\ref{lem:rrl}, we know
$\LanguageOf{\DNFRegex}=\LanguageOf{\DNFRegex'}$, and
$\LanguageOf{\DNFRegexAlt}=\LanguageOf{\DNFRegexAlt'}$.
Consider the derivation
\begin{mathpar}
\inferrule*
{
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens \OfType \ToRegex(\DNFRegex') \Leftrightarrow \ToRegex(\DNFRegexAlt')
}\\
\LanguageOf{\ToRegex(\DNFRegex')} = \LanguageOf{\ToRegex(\DNFRegex)}\\
\LanguageOf{\ToRegex(\DNFRegexAlt')} = \LanguageOf{\ToRegex(\DNFRegexAlt)}
}
{
\Lens \OfType \ToRegex(\DNFRegex) \Leftrightarrow \ToRegex(\DNFRegexAlt)
}
\end{mathpar}
This has the desired typing, and by induction assumption, has the desired semantics.\\
\\
Let $(\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n},\sigma) \OfType \DNFOf{\Sequence_1;\ldots;\Sequence_n} \Leftrightarrow \DNFOf{\SequenceAlt_{\sigma(1)};\ldots;\SequenceAlt_{\sigma(n)}}$ be formed from an application of $\DNFLensRule$.
By Induction assumption, for each $\SequenceLens_i \OfType \Sequence_i \Leftrightarrow \SequenceAlt_i$ there exists a $\Lens_i \OfType \ToRegex(\Sequence_i) \Leftrightarrow \ToRegex(\SequenceAlt_i)$.\\
By Lemma~\ref{lem:id-dnf} there exists a $\Lens \OfType \ToRegex(\DNFOf{\Sequence_1;\ldots;\Sequence_{n}}) \Leftrightarrow \ToRegex(\DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_{n}})$ such that $\SemanticsOf{\Lens}=\SemanticsOf{([\SequenceLens_1;\ldots\SequenceLens_n],id)}$,
By Lemma~\ref{lem:dnfl-perm-sem-ineffective},
$\SemanticsOf{(DNFOf{\SequenceLens_1;\ldots;\SequenceLens_n},id)}=
\SemanticsOf{(\DNFOf{\SequenceLens_1;\ldots;\SequenceLens_n},\sigma)}$.
By Lemma~\ref{lem:dnfr-perm-sem-ineffective},
$\LanguageOf{\DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_n}}=
\LanguageOf{\DNFOf{\SequenceAlt_{\sigma(1)};\ldots;\SequenceAlt_{\sigma(n)}}}$.
Consider the following typing

\begin{mathpar}
\inferrule*
{
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\Lens \OfType \ToRegex(\DNFOf{\Sequence_1;\ldots;\Sequence_{n}}) \Leftrightarrow \ToRegex(\DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_{n}})
}\\
\LanguageOf{\ToRegex(\DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_{n}})} =
\LanguageOf{\ToRegex(\DNFOf{\SequenceAlt_{\sigma(1)};\ldots;\SequenceAlt_{\sigma(n)}})}
}
{
\Lens \OfType \ToRegex(\DNFOf{\Sequence_1;\ldots;\Sequence_{n}}) \Leftrightarrow \ToRegex(\DNFOf{\SequenceAlt_{\sigma(1)};\ldots;\SequenceAlt_{\sigma(n)}})
}
\end{mathpar}
This has the typing and semantics as desired.\\
\\
Let $(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)},\sigma \in S_n) \OfType \SequenceOf{\String_0 ; \Atom_1 ; \ldots ; \Atom_n ; \String_n} \Leftrightarrow \SequenceOf{\StringAlt_0; \AtomAlt_{\sigma(1)} ; \ldots ; \AtomAlt_{\sigma(n)} ; \StringAlt_n}$ be formed from an
application of\\$\SequenceLensRule{}$.
By induction assumption, for each
$\AtomLens_i \OfType \Atom_i \Leftrightarrow \AtomAlt_i$ there exists a
$\Lens_i \OfType \ToRegex(\Regex_i) \Leftrightarrow \ToRegex(\RegexAlt_i)$.
By Lemma~\ref{lem:id-clause}, there exists a $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that $\SemanticsOf{\Lens}=\SemanticsOf{([(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)],id)}$,
$\Regex=\ToRegex(\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n})$, and
$\RegexAlt=\ToRegex(\SequenceOf{\StringAlt_0;\AtomAlt_1;\ldots;\AtomAlt_n;\StringAlt_n})$.
Define $\RegexAlt_{\Sep}$ as $\ToRegex(\SequenceOf{\Sep;\AtomAlt_1;\ldots;\AtomAlt_n;\Sep})$.
By Lemma~\ref{lem:boilerplate-alterations}, there exists a
$\Lens' \OfType \RegexAlt \Leftrightarrow \RegexAlt_{\Sep}$, with semantics of
merely changing the boilerplate.
By Lemma~\ref{lem:perm-exp}, there exists a $\Lens'' \OfType \RegexAlt_{\Sep}'
\Leftrightarrow \RegexAlt_{\Sep}''$ where
$\SemanticsOf{\RegexAlt_{\Sep}'}=\SemanticsOf{\RegexAlt_{\Sep}}$ and 
$\SemanticsOf{\RegexAlt_{\Sep}''}=\SemanticsOf{\SequenceOf{\Sep; \AtomAlt_{\sigma(1)} ; \ldots ; \AtomAlt_{\sigma(n)} ; \Sep}}$.
Lastly, with Lemma~\ref{lem:boilerplate-alterations}, there exists a
$\Lens''' \OfType \RegexAlt_{\Sep}'' \Leftrightarrow \RegexAlt'$, where
$\RegexAlt = \ToRegex(\SequenceOf{\StringAlt_0; \AtomAlt_{\sigma(1)} ; \ldots ; \AtomAlt_{\sigma(n)} ; \StringAlt_n})$.
Through composition of all these lenses, we finally get a lens with the desired type
and semantics.\\
\\
Let $\IterateLensOf{\DNFLens} \OfType \StarOf{\DNFRegex} \Leftrightarrow \StarOf{\DNFRegexAlt}$
be introduced through an application of \IterateAtomLensRule{}.
From induction assumption, I know that there exists $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$, such that
$\SemanticsOf{\DNFLens}=\SemanticsOf{\Lens}$,
\Regex=\ToRegex(\DNFRegex), and
$\RegexAlt=\ToRegex(\DNFRegexAlt)$.\\
Consider $\IterateLensOf{\Lens} \OfType \StarOf{\Regex} \Leftrightarrow \StarOf{\RegexAlt}$.\\
By definition, $\StarOf{\Regex}$ and $\StarOf{\RegexAlt}$ are $\ToRegex(\StarOf{\DNFRegex})$
and $\ToRegex(\StarOf{\Regex})$, respectively.

\begin{tabular}{RcL}
\SemanticsOf{\IterateLensOf{\Lens}} & = &
\SetOf{(\String_0\ldots\String_n,\StringAlt_0\ldots\StringAlt_n)\SuchThat
(\String_i,\StringAlt_i)\in\SemanticsOf{\Lens}}\\
& = &
\SetOf{(\String_0\ldots\String_n,\StringAlt_0\ldots\StringAlt_n)\SuchThat
(\String_i,\StringAlt_i)\in\SemanticsOf{\DNFLens}}\\
& = &
\SemanticsOf{\IterateLensOf{\DNFLens}}
\end{tabular}
\end{proof}
\end{lemma}

\dnfls*
\begin{proof}

The soundess of DNF lenses follows immediatley from Lemma~\ref{lem:dnfcal}

\end{proof}

\begin{theorem}[Strong DNF Lens Soundness]
Let $\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$, be the typing
of a DNF lens $\DNFLens$.
and let $\Regex$ and $\RegexAlt$ be regular expressions, such that
$\LanguageOf{\DNFRegex}=\LanguageOf{\Regex}$,
and $\LanguageOf{\DNFRegexAlt}=\LanguageOf{\RegexAlt}$.
There exists a lens $\Lens : \Regex \Leftrightarrow \RegexAlt$, such that
$\SemanticsOf{\Lens}=\SemanticsOf{\DNFLens}$.
\end{theorem}

\begin{proof}
By Theorem~\ref{thm:dnfls}, there exist regular expressions $\Regex'$,
$\RegexAlt'$, such that there exists a lens $\DNFLens$ such there is the
derivation for a typing.
\begin{mathpar}
\inferrule[]
{
\Derivation{}
}
{
\DNFLens \OfType \Regex' \Leftrightarrow \RegexAlt'
}
\end{mathpar}
\SemanticsOf{\DNFLens}=\SemanticsOf{\Lens},
\LanguageOf{\Regex'}=\LanguageOf{\DNFRegex},
and \LanguageOf{\RegexAlt'}=\LanguageOf{\DNFRegexAlt'}.
Because of this, $\Regex'\equiv\Regex$, and $\RegexAlt'\equiv\RegexAlt$.
Consider the typing
\begin{mathpar}
\inferrule*
{
\inferrule*
{
\Derivation{}
}
{
\DNFLens \OfType \Regex' \Leftrightarrow \RegexAlt'
}\\
\Regex'\equiv\Regex\\
\RegexAlt'\equiv\RegexAlt
}
{
\DNFLens \OfType \Regex \Leftrightarrow \RegexAlt
}
\end{mathpar}

This satisfies the needed requirements!
\end{proof}
%proof-dnfls end


%proof-dnflc start
%We will prove a couple of lemmas first.


\begin{lemma}[Completeness of Composition]\leavevmode
\label{lem:composition-completeness}
\begin{enumerate}
\item If there are two atom lenses
$\AtomLens_1 \OfType \Atom_1 \Leftrightarrow \Atom_2$ and
$\AtomLens_2 \OfType \Atom_2 \Leftrightarrow \Atom_3$,
then there exists an atom lens
$\AtomLens \OfType \Atom_1 \Leftrightarrow \Atom_3$, such that
$\SemanticsOf{\AtomLens}=\SetOf{(\String_1,\String_3)\SuchThat
\exists\String_2
(\String_1,\String_2)\in\SemanticsOf{\AtomLens_1}\BooleanAnd
(\String_2,\String_3)\in\SemanticsOf{\AtomLens_2}}$

\item If there are two sequence lenses
$\SequenceLens_1 \OfType \Sequence_1 \Leftrightarrow \Sequence_2$ and
$\SequenceLens_2 \OfType \Sequence_2 \Leftrightarrow \Sequence_3$,
then there exists an sequence lens
$\SequenceLens \OfType \Sequence_1 \Leftrightarrow \Sequence_3$, such that
$\SemanticsOf{\SequenceLens}=\SetOf{(\String_1,\String_3)\SuchThat
\exists\String_2
(\String_1,\String_2)\in\SemanticsOf{\SequenceLens_1}\BooleanAnd
(\String_2,\String_3)\in\SemanticsOf{\SequenceLens_2}}$

\item If there are two DNF lenses
$\DNFLens_1 \OfType \DNFRegex_1 \Leftrightarrow \DNFRegex_2$ and
$\DNFLens_2 \OfType \DNFRegex_2 \Leftrightarrow \DNFRegex_3$,
then there exists a DNF lens
$\DNFLens \OfType \DNFRegex_1 \Leftrightarrow \DNFRegex_3$, such that
$\SemanticsOf{\DNFLens}=\SetOf{(\String_1,\String_3)\SuchThat
\exists\String_2
(\String_1,\String_2)\in\SemanticsOf{\DNFLens_1}\BooleanAnd
(\String_2,\String_3)\in\SemanticsOf{\DNFLens_2}}$
\end{enumerate}
\end{lemma}

\begin{proof}
By mutual induction

Let $\StarOf{\DNFRegex_1}$, $\StarOf{\DNFRegex_2}$, $\StarOf{\DNFRegex_3}$
be three atoms, and $\IterateLensOf{\DNFLens_1} \OfType
\StarOf{\DNFRegex_1} \Leftrightarrow \StarOf{\DNFRegex_2}$ with
$\IterateLensOf{\DNFLens_2} \OfType
\StarOf{\DNFRegex_2} \Leftrightarrow \StarOf{\DNFRegex_3}$
lenses between them.
By induction assumption, there a typing of a lens

\begin{mathpar}
\inferrule[]
{
\Derivation{}
}
{
\DNFLens \OfType \DNFRegex_1 \Leftrightarrow \DNFRegex_3
}
\end{mathpar}

such that $\SemanticsOf{\DNFLens}=\SetOf{(\String_1,\String_3)\SuchThat
\exists \String_2
(\String_1,\String_2)\in\SemanticsOf{\DNFLens_1}\BooleanAnd
(\String_2,\String_3)\in\SemanticsOf{\DNFLens_2}}$

By inversion lemma (TODO), there exists a $\IterateLensOf{\DNFLens_1}$ and
$\IterateLensOf{\DNFLens_2}$ came from $\IterateLensRule$, so I know
$\UnambigItOf{\LanguageOf{\DNFRegex_1}}$,
$\UnambigItOf{\LanguageOf{\DNFRegex_2}}$, and
$\UnambigItOf{\LanguageOf{\DNFRegex_3}}$.

Consider the lens

\begin{mathpar}
\inferrule*
{
\inferrule*
{
\Derivation{}
}
{
\DNFLens \OfType \DNFRegex_1 \Leftrightarrow \DNFRegex_3
}\\
\UnambigItOf{\LanguageOf{\DNFRegex_1}}\\
\UnambigItOf{\LanguageOf{\DNFRegex_2}}
}
{
\IterateLensOf{\DNFLens} \OfType
\StarOf{\DNFRegex_1} \Leftrightarrow \StarOf{\DNFRegex_3}
}
\end{mathpar}

This lens has the semantics

\begin{tabular}{@{}L@{}L@{}}
\SemanticsOf{\IterateLensOf{\DNFLens}}
& = \SetOf{(\String_{1,1}\Concat\ldots\Concat\String_{1,n},
\String_{3,1}\Concat\ldots\Concat\String_{3,n})\\
& \hspace{2em}
\SuchThat(\String_{1,i},\String_{3,i})\in\SemanticsOf{\DNFLens}}\\
& =
\SetOf{(\String_{1,1}\Concat\ldots\Concat\String_{1,n},
\String_{3,1}\Concat\ldots\Concat\String_{3,n})\\
& \hspace{2em}
\SuchThat
\exists\String_{2,i} (\String_{1,i},\String_{2,i})\in\SemanticsOf{\DNFLens_1}\\
& \hspace{4em}
\BooleanAnd
(\String_{2,i},\String_{3,i})\in\SemanticsOf{\DNFLens_2}}\\
& =
\SetOf{(\String_{1,1}\Concat\ldots\Concat\String_{1,n},
\String_{3,1}\Concat\ldots\Concat\String_{3,n}) \\
& \hspace{2em}
\SuchThat
\exists\String_{2,1}\Concat\ldots\Concat\String_{2,n}\\
& \hspace{4em}
(\String_{1,1}\Concat\ldots\Concat\String_{1,n},
\String_{2,1}\Concat\ldots\Concat\String_{2,n})
\in\SemanticsOf{\IterateLensOf{\DNFLens}}\\
& \hspace{4em}
\BooleanAnd
(\String_{2,1}\Concat\ldots\Concat\String_{2,n},
\String_{3,1}\Concat\ldots\Concat\String_{3,n})
\in\SemanticsOf{\IterateLensOf{\DNFLens}}}\\
& =
\SetOf{(\String_1,\String_3)\SuchThat\exists\String_2
(\String_1,\String_2)\in\SemanticsOf{\IterateLensOf{\DNFLens_1}}\\
& \hspace{4em}\BooleanAnd
(\String_2,\String_3)\in\SemanticsOf{\IterateLensOf{\DNFLens_2}}}
\end{tabular}

Let $\SequenceOf{\String_{1,0}\SequenceSep\Atom_{1,1}\SequenceSep
\ldots\SequenceSep\Atom_{1,n}\SequenceSep\String_{1,n}}$,
$\SequenceOf{\String_{2,0}\SequenceSep\Atom_{2,\Permutation_1(1)}\SequenceSep
\ldots\SequenceSep\Atom_{2,\Permutation_1(n)}\SequenceSep\String_{2,n}}$,
and $\SequenceOf{\String_{3,0}\SequenceSep
\Atom_{3,\Permutation_2\Compose\Permutation_1(1)}\SequenceSep
\ldots\SequenceSep\Atom_{3,\Permutation_2\Compose\Permutation_1(n)}
\SequenceSep\String_{3,n}}$ be sequences,
with $(\SequenceLensOf{(\String_{1,0},\String_{2,0})\SequenceLensSep
\AtomLens_{1,1}\SequenceLensSep\ldots\SequenceLensSep\AtomLens_{1,n}
\SequenceLensSep(\String_{1,n},\String_{2,n})},\Permutation_1)$ and
$(\SequenceLensOf{(\String_{2,0},\String_{3,0})\SequenceLensSep
\AtomLens_{2,1}\SequenceLensSep\ldots\SequenceLensSep\AtomLens_{2,n}
\SequenceLensSep(\String_{2,n},\String_{3,n})},\Permutation_2)$ be lenses between them.
By induction assumption, there is a typing of lenses
\begin{mathpar}
\inferrule[]
{
\Derivation_i
}
{
\AtomLens_i \OfType \Atom_{1,i} \Leftrightarrow \Atom_{3,i}
}
\end{mathpar}
such that \SemanticsOf{\AtomLens_i} = \SetOf{(\String_1,\String_3)\SuchThat
\exists \String_2 (\String_1,\String_2)\in\SemanticsOf{\AtomLens_{1,i}}
\BooleanAnd (\String_2,\String_3)\in\SemanticsOf{\Atom_{2,i}}}
Define $\Permutation = \Permutation_2\Compose\Permutation_1$.

By inversion, I know that
$\SequenceUnambigConcatOf{\SequenceOf{\String_{1,0}\SequenceSep\Atom_{1,1}
\SequenceSep\ldots\SequenceSep\Atom_{1,n}\SequenceSep\String_{1,n}}}$
and
$\SequenceUnambigConcatOf{\SequenceOf{\String_{3,0}\SequenceSep
\Atom_{\Permutation(3),1}\SequenceSep\ldots
\SequenceSep\Atom_{\Permutation(3),n}\SequenceSep\String_{3,n}}}$.

Consider the typing of the lens
\begin{mathpar}
{
\inferrule{
\inferrule*
{
\Derivation_0
}
{
\AtomLens_0 \OfType \Atom_{1,0} \Leftrightarrow \Atom_{3,0}
}\\
\ldots\\
\inferrule*
{
\Derivation_n
}
{
\AtomLens_n \OfType \Atom_{1,n} \Leftrightarrow \Atom_{3,n}
}\\
\sigma\in\PermutationSetOf{n}\\
\SequenceUnambigConcatOf{\SequenceOf{\String_{1,0}\SequenceSep\Atom_{1,1}
\SequenceSep\ldots\SequenceSep\Atom_{1,n}\SequenceSep\String_{1,n}}}\\
\SequenceUnambigConcatOf{\SequenceOf{\String_{3,0}\SequenceSep
\Atom_{\Permutation(3),1}\SequenceSep\ldots
\SequenceSep\Atom_{\Permutation(3),n}\SequenceSep\String_{3,n}}}
}
{
(\SequenceLensOf{(\String_{1,0},\String_{3,0})\SequenceLensSep\AtomLens_1
\SequenceLensSep\ldots\SequenceLensSep\AtomLens_n
\SequenceLensSep(\String_{1,n},\String_{3,n})},\Permutation) \OfType\\
\SequenceOf{\String_{1,0}\SequenceSep\Atom_{1,1}\SequenceSep\ldots
\SequenceSep\Atom_{1,n}\SequenceSep\String_{1,n}} \Leftrightarrow
\SequenceOf{\String_{3,0}\SequenceSep\Atom_{3,\Permutation(1)}\SequenceSep\ldots
\SequenceSep\Atom_{3,\Permutation(n)}\SequenceSep\String_{3,n}}
}
}
\end{mathpar}

Furthermore, we can prove the desired property of the semantics.\\
\SemanticsOf{(\SequenceLensOf{(\String_{1,0},\String_{3,0})\SequenceLensSep
\AtomLens_1\SequenceLensSep\ldots\SequenceLensSep\AtomLens_n
\SequenceLensSep(\String_{1,n},\String_{3,n})},\Permutation)}=\\
\SetOf{(\String_{1,0}\Concat\String_1\Concat\ldots
\Concat\String_n\Concat\String_{1,n},
\String_{3,0}\Concat\StringAlt_{\Permutation(1)}\Concat\ldots
\Concat\StringAlt_{\Permutation(n)}\Concat\String_{1,n})\\
\hspace*{1em}\SuchThat(\String_i,\StringAlt_i)\in\SemanticsOf{\AtomLens_i}}=\\
\SetOf{(\String_{1,0}\Concat\String_1\Concat\ldots
\Concat\String_n\Concat\String_{1,n},
\String_{3,0}\Concat\StringAlt_{\Permutation(1)}\Concat\ldots
\Concat\StringAlt_{\Permutation(n)}\Concat\String_{1,n})\\
\hspace*{1em}\SuchThat\exists\String_i'\in\LanguageOf{\Atom_{2,i}}
(\String_i,\String_i')\in\SemanticsOf{\AtomLens_i}\BooleanAnd
(\String_i',\StringAlt_i)\in\SemanticsOf{\AtomLens_i}}\\
\SetOf{(\String_{1,0}\Concat\String_1\Concat\ldots
\Concat\String_n\Concat\String_{1,n},
\String_{3,0}\Concat\StringAlt_{\Permutation(1)}\Concat\ldots
\Concat\StringAlt_{\Permutation(n)}\Concat\String_{1,n})\\
\hspace*{1em}\SuchThat\exists
\String_{2,0}\Concat\String_{\Permutation_1(1)}'\Concat\ldots\Concat
\String_{\Permutation_1(n)}'\Concat\String_{2,n}\in\LanguageOf{\Atom_{2,i}}\\
\hspace*{2em}
(\String_{1,0}\Concat\String_1\Concat\ldots
\Concat\String_n\Concat\String_{1,n},\String_{2,0}\Concat
\String_{\Permutation_1(1)}'\Concat\ldots\Concat
\String_{\Permutation_1(n)}'\Concat\String_{2,n})\\
\hspace*{3em}\in\SemanticsOf{(\SequenceLensOf{(\String_{1,0},\String_{2,0})
\SequenceLensSep\AtomLens_{1,1}\SequenceLensSep\ldots\SequenceLensSep
\AtomLens_{1,n}\SequenceLensSep(\String_{1,n},\String_{2,n})},\Permutation_1)}
\BooleanAnd\\
\hspace*{2em}
(\String_{2,0}\Concat\String_{\Permutation_1(1)}'\Concat\ldots\Concat
\String_{\Permutation_1(n)}'\Concat\String_{2,n},\String_{3,0}\Concat\StringAlt_{\Permutation(1)}\Concat\ldots
\Concat\StringAlt_{\Permutation(n)}\Concat\String_{1,n})\\
\hspace*{3em}\in\SemanticsOf{(\SequenceLensOf{(\String_{2,0},\String_{3,0})\SequenceLensSep
\AtomLens_{2,1}\SequenceLensSep\ldots\SequenceLensSep\AtomLens_{2,n}
\SequenceLensSep(\String_{2,n},\String_{3,n})},\Permutation_2)}}\\
\SetOf{(\String_1,\String_3)\SuchThat\exists\String_2\\
\hspace*{2em}
(\String_1,\String_2)\\
\hspace*{3em}\in\SemanticsOf{(\SequenceLensOf{(\String_{1,0},\String_{2,0})
\SequenceLensSep\AtomLens_{1,1}\SequenceLensSep\ldots\SequenceLensSep
\AtomLens_{1,n}\SequenceLensSep(\String_{1,n},\String_{2,n})},\Permutation_1)}\\
\hspace*{2em}
(\String_2,\String_3)\\
\hspace*{3em}\in\SemanticsOf{(\SequenceLensOf{(\String_{2,0},\String_{3,0})
\SequenceLensSep\AtomLens_{2,1}\SequenceLensSep\ldots\SequenceLensSep
\AtomLens_{2,n}\SequenceLensSep(\String_{2,n},\String_{3,n})},\Permutation_2)}}

Let $\DNFRegex_1=\DNFOf{\Sequence_{1,1}\DNFSep\ldots\DNFSep\Sequence_{1,n}}$,
$\DNFRegex_2=\DNFOf{\Sequence_{2,\Permutation_1(1)}\DNFSep\ldots
\DNFSep\Sequence_{2,\Permutation_1(n)}}$,
and $\DNFRegex_3=\DNFOf{\Sequence_{3,\Permutation_2\Compose\Permutation_1(1)}
\DNFSep\ldots\DNFSep\Sequence_{3,\Permutation_2\Compose\Permutation_1(n)}}$
be three DNF regular expressions.
Let $\DNFLens_1=(\DNFLensOf{\SequenceLens_{1,1}\DNFLensSep\ldots
\DNFLensSep\SequenceLens_{1,n}},\Permutation_1)\OfType
\DNFRegex_1\Leftrightarrow\DNFRegex_2$ and
$\DNFLens_2=(\DNFLensOf{\SequenceLens_{2,1}\DNFLensSep\ldots
\DNFLensSep\SequenceLens_{2,n}},\Permutation_2)\OfType
\DNFRegex_2\Leftrightarrow\DNFRegex_3$ be lenses between them.
By induction assumption, there exists a typing of lenses
\begin{mathpar}
\inferrule*
{
\Derivation_i
}
{
\Sequence_i \OfType \Sequence_{1,i} \Leftrightarrow \Sequence_{3,i}
}
\end{mathpar}


\end{proof}

\begin{lemma}[Completeness of Identity on Strongly Unambiguous DNF Regex,
Clauses, and Atoms]
\leavevmode
\begin{enumerate}
\item If $\DNFRegex$ is a strongly unambiguous DNF Regular expression, then
there exists a DNF lens $\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegex$,
such that $\SemanticsOf{\DNFLens}=
\SetOf{(\String,\String)\SuchThat\String\in\LanguageOf{\DNFRegex}}$, where
\DNFLens{} typing includes no rewrite rules.
\item If $\Sequence$ is a strongly unambiguous sequence, then
there exists a sequence lens $\SequenceLens \OfType \Sequence \Leftrightarrow \Sequence$,
such that $\SemanticsOf{\SequenceLens}=
\SetOf{(\String,\String)\SuchThat\String\in\LanguageOf{\DNFRegex}}$, where
\SequenceLens{} typing includes no rewrite rules.
\item If $\Atom$ is a strongly unambiguous atom, then
there exists an atom lens $\AtomLens \OfType \Atom \Leftrightarrow \Atom$,
such that $\SemanticsOf{\AtomLens}=
\SetOf{(\String,\String)\SuchThat\String\in\LanguageOf{\DNFRegex}}$, where
\AtomLens{} typing includes no rewrite rules.
\end{enumerate}
\end{lemma}
\begin{proof}
By mutual induction on the structure of the DNF regular expression,
atom, and clause.

Let \DNFRegex{} be a DNF regular expression.

Let \Sequence{} be a sequence.

Let \Atom{} be an atom.
\end{proof}

Now we can do the proof of completeness.
\dnflc*

\begin{proof}
We will do by structural induction on the typing derivation.

Let the last rule be an application of \ConstantLensRule{}.
\begin{mathpar}
\inferrule[]
{
\String_1 \in \StarOf{\Sigma}\\
\String_2 \in \StarOf{\Sigma}
}
{
\ConstLensOf{\String_1}{\String_2} \OfType \String_1 \Leftrightarrow \String_2
}
\end{mathpar}
Consider the derivation
\begin{mathpar}
\inferrule[]
{
\inferrule[]
{
\String_1 \in \StarOf{\Sigma}\\
\String_2 \in \StarOf{\Sigma}
}
{
\SequenceLensOf{(\String_1,\String_2)} \OfType
\SequenceOf{\String_1} \Leftrightarrow \SequenceOf{\String_2}
}
}
{
\DNFLensOf{\SequenceLensOf{(\String_1,\String_2)}} \OfType
\DNFOf{\SequenceOf{\String_1}} \Leftrightarrow \DNFOf{\SequenceOf{\String_2}}
}
\end{mathpar}

\begin{tabular}{@{}L@{}L@{}}
\SemanticsOf{\DNFLensOf{\SequenceLensOf{(\String_1,\String_2)}}}
& = \SetOf{(\StringAlt_1,\StringAlt_2)
\SuchThat(\StringAlt_1,\StringAlt_2)\in\SequenceLensOf{(\String_1,\String_2)}}\\
& = \SetOf{(\StringAlt_1,\StringAlt_2)
\SuchThat(\StringAlt_1,\StringAlt_2)\in\SetOf{(\String_1,\String_2)}}\\
& = \SetOf{(\String_1,\String_2)}\\
& = \SemanticsOf{\ConstLensOf{\String_1}{\String_2}}\\
\end{tabular}

Let the last rule be an application of \IdentityLensRule{}.
We know that for each regular expression there exists a strongly unambiguous
regular expression~\cite{unambigregex}.
Because of that, if we have
$\IdentityLens \OfType \Regex \Leftrightarrow \Regex$,
then we have a strongly unambiguous DNF regular expression,
$\DNFRegex$, such that $\LanguageOf{\Regex}=\LanguageOf{\DNFRegex}$.
Then, by Lemma (TODO: ref), there exists a DNF lens
$\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$ such that
$\SemanticsOf{\DNFLens}=
\SetOf{(\String,\String)\SuchThat\String\in\LanguageOf{\DNFRegex}}$

Let the last rule be an application of \IterateLensRule{}.
\begin{mathpar}
\inferrule[]
{
\Lens \OfType \Regex \Leftrightarrow \RegexAlt \\
\UnambigItOf{\LanguageOf{\Regex}}\\
\UnambigItOf{\LanguageOf{\RegexAlt}}
}
{
\IterateLensOf{\Lens} \OfType \StarOf{\Regex} \Leftrightarrow \StarOf{\RegexAlt}
}
\end{mathpar}
By induction assumption, there exists a derivation
\begin{mathpar}
\inferrule[]
{
\Derivation{}
}
{
\DNFLens : \DNFRegex \Leftrightarrow \DNFRegexAlt
}
\end{mathpar}
such that \LanguageOf{\DNFRegex}=\LanguageOf{\Regex},
\LanguageOf{\RegexAlt}=\LanguageOf{\DNFRegexAlt}, and
\SemanticsOf{\DNFLens}=\SemanticsOf{\Lens}.
This means \UnambigItOf{\LanguageOf{\DNFRegex}}
and \UnambigItOf{\LanguageOf{\DNFRegexAlt}}

Consider the derivation
\begin{mathpar}
\inferrule[]
{
\Derivation
}
{
\inferrule[]
{
\DNFLens : \DNFRegex \Leftrightarrow \DNFRegexAlt
\UnambigItOf{\LanguageOf{\DNFRegex}}\\
\UnambigItOf{\LanguageOf{\DNFRegexAlt}}\\
}
{
\inferrule[]
{
\IterateLensOf{\DNFLens} \OfType
\StarOf{\DNFRegex} \Leftrightarrow \StarOf{\DNFRegexAlt}
}
{
\inferrule
{
\SequenceLensOf{\IterateLensOf{\DNFLens}} \OfType
\SequenceOf{\StarOf{\DNFRegex}}\Leftrightarrow \SequenceOf{\StarOf{\DNFRegexAlt}}
}
{
\DNFLensOf{\SequenceLensOf{\IterateLensOf{\DNFLens}}} \OfType
\DNFOf{\SequenceOf{\StarOf{\DNFRegex}}} \Leftrightarrow
\DNFOf{\SequenceOf{\StarOf{\DNFRegexAlt}}}
}
}
}
}
\end{mathpar}

By Lemma~(TODOREF), I know that, as \LanguageOf{\Regex}=\LanguageOf{\DNFRegex},
and as \LanguageOf{\RegexAlt}=\LanguageOf{\DNFRegexAlt}, then
\LanguageOf{\DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}}=
\LanguageOf{\StarOf{\Regex}}
and \LanguageOf{\DNFOf{\SequenceOf{\StarOf{\DNFRegexAlt}}}}=
\LanguageOf{\StarOf{\RegexAlt}}.

\begin{tabular}{@{}L@{}L@{}}
\SemanticsOf{\DNFLensOf{\SequenceLensOf{\IterateLensOf{\DNFLens}}}}
& = \SetOf{(\String,\StringAlt)
\SuchThat(\String,\StringAlt)\in\SemanticsOf{\SequenceLensOf{\IterateLensOf{\DNFLens}}}}\\
& = \SetOf{(\String,\StringAlt)
\SuchThat(\String,\StringAlt)\in\SemanticsOf{\IterateLensOf{\DNFLens}}}\\
& = \SetOf{(\String_1\Concat\ldots\Concat\String_n,
\StringAlt_1\Concat\ldots\Concat\StringAlt_n)
\SuchThat \String_i\in\SemanticsOf{\DNFLens}}\\
& = \SetOf{(\String_1\Concat\ldots\Concat\String_n,
\StringAlt_1\Concat\ldots\Concat\StringAlt_n)
\SuchThat \String_i\in\SemanticsOf{\Lens}}\\
& = \SemanticsOf{\IterateLensOf{\Lens}}
\end{tabular}

Let the last rule be an application of \ConcatLensRule{}.

Let the last rule be an application of \SwapLensRule{}.

Let the last rule be an application of \OrLensRule{}.
\begin{mathpar}
\inferrule[]
{
\Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1\\
\Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2\\
\UnambigOrOf{\LanguageOf{\Regex_1}}{\LanguageOf{\Regex_2}}\\
\UnambigOrOf{\LanguageOf{\RegexAlt_1}}{\LanguageOf{\RegexAlt_2}}
}
{
\OrLensOf{\Lens_1}{\Lens_2} \OfType
\RegexOr{\Regex_1}{\RegexAlt_1} \Leftrightarrow \RegexOr{\Regex_2'}{\RegexAlt_2'}
}
\end{mathpar}
By induction assumption, there exists a derivation
\begin{mathpar}
\inferrule[]
{
\Derivation
}
{
(\DNFLensOf{\SequenceLens_1,\ldots,\SequenceLens_n},\Permutation_1) \OfType\\
\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n} \Leftrightarrow
\DNFOf{\SequenceAlt_{\Permutation_1(1)}\DNFSep\ldots
\DNFSep\SequenceAlt_{\Permutation_1(n)}}
}
\end{mathpar}
and a derivation
\begin{mathpar}
\inferrule[]
{
\Derivation'
}
{
(\DNFLensOf{\SequenceLens_{n+1},\ldots,\SequenceLens_{n+m}},\Permutation_2) \OfType\\
\DNFOf{\Sequence_{n+1}'\DNFSep\ldots\DNFSep\Sequence_{n+m}} \Leftrightarrow
\DNFOf{\SequenceAlt_{n+\Permutation_2(1)'}\DNFSep\ldots
\DNFSep\SequenceAlt_{n+\Permutation_2(m)'}}
}
\end{mathpar}
such that, if we define:\\
\begin{tabular}{@{}L@{}L@{}}
\DNFRegex_1= &
\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}\\
\DNFRegexAlt_1= &
\DNFOf{\SequenceAlt_{\Permutation_1(1)}\DNFSep\ldots
\DNFSep\SequenceAlt_{\Permutation_1(n)}}\\
\DNFRegex_2= &
\DNFOf{\Sequence_{n+1}\DNFSep\ldots\DNFSep\Sequence_{n+m}}\\
\DNFRegexAlt_2= &
\DNFOf{\SequenceAlt_{n+\Permutation_2(1)}\DNFSep\ldots
\DNFSep\SequenceAlt_{n+\Permutation_2(m)}}\\
\end{tabular}
then we have
\LanguageOf{\DNFRegex}=\LanguageOf{\Regex},
\LanguageOf{\DNFRegexAlt}=\LanguageOf{\RegexAlt},
\LanguageOf{\DNFRegex'}=\LanguageOf{\Regex'},
\LanguageOf{\DNFRegexAlt'}=\LanguageOf{\RegexAlt'}.

By inversion (TODO: inversion lemma), we know that the last step of those derivations were applications
of \DNFLensRule{}, so we know that, for all $i\in\RangeIncInc{1}{m}$,
there exists derivations
\begin{mathpar}
\inferrule[]
{
\Derivation_i
}
{
(\SequenceLens_i \OfType
\Sequence_i \Leftrightarrow \SequenceAlt_i)
}
\end{mathpar}
For all $i\neq j$, $i,j\in\RangeIncInc{1}{n}$,
$\Sequence_i \Intersect \Sequence_j = \emptyset$, and
$\SequenceAlt_i \Intersect \SequenceAlt_j = \emptyset$.
For all $i\neq j$, $i,j\in\RangeIncInc{n+1}{n+m}$,
$\Sequence_i \Intersect \Sequence_j = \emptyset$, and
$\SequenceAlt_i \Intersect \SequenceAlt_j = \emptyset$.
Because $\LanguageOf{\Regex}\Intersect\LanguageOf{\RegexAlt}=\emptyset$,
and $\LanguageOf{\Regex'}\Intersect\LanguageOf{\RegexAlt'}=\emptyset$,
and because of the previously stated equivalences between regular expressions,
and DNF regular expressions, for each $i\in\RangeIncInc{1}{n}$,
$j\in\RangeIncInc{n+1}{m}$, $\Sequence_i\Intersect\Sequence_j=\emptyset$
and $\SequenceAlt_i\Intersect\SequenceAlt_j=\emptyset$.
So, we have for all $i\neq j$, $i,j\in\RangeIncInc{1,n+m}$,
$\Sequence_i \Intersect \Sequence_j = \emptyset$ and
$\SequenceAlt_i \Intersect \SequenceAlt_j = \emptyset$.
We can build a new permutation $\Permutation$ defined as
\[
\Permutation(x)=
\begin{cases}
\Permutation_1(x) & \text{ if $x\in\RangeIncInc{1}{n}$}\\
\Permutation_2(x-n)+n & \text{ if $x\in\RangeIncInc{n+1}{n+m}$}
\end{cases}
\]
Consider the derivation
\begin{mathpar}
\inferrule[]
{
\Derivation_1\\
\ldots\\
\Derivation_{n+m}\\
i\neq j\Rightarrow \Sequence_i\Intersect\Sequence_j=\emptyset\\
i\neq j\Rightarrow \Sequence_i\Intersect\SequenceAlt_j=\emptyset\\
}
{
(\DNFLensOf{\SequenceLens_1\SequenceLensSep\ldots
\SequenceLensSep\SequenceLens_{n+m}},\Permutation) \OfType\\
\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{n+m}} \Leftrightarrow
\DNFOf{\SequenceAlt_{\sigma(1)}\DNFSep\ldots\DNFSep\SequenceAlt_{\sigma(n+m)}}
}
\end{mathpar}

We can prove the resulting DNF regular expressions are equivalent to
the original regular expressions.

\begin{tabular}{@{}L@{}L@{}}
\DNFOf{\Sequence_0\DNFSep\ldots\DNFSep\Sequence_{n+m}} & =
\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}\OrDNF\\
& \hspace{1em}
\DNFOf{\Sequence_{n+1}\DNFSep\ldots\DNFSep\Sequence_{n+m}}\\
& =
\OrDNFOf{\DNFRegex_1}{\DNFRegex_2}
\end{tabular}\\
So by Lemma (TODO: find ref),
$\LanguageOf{\DNFOf{\Sequence_0\DNFSep\ldots\DNFSep\Sequence_{n+m}}}=
\LanguageOf{\RegexOr{\Regex_1}{\Regex_2}}$

\begin{tabular}{@{}L@{}L@{}}
\DNFOf{\SequenceAlt_{\Permutation(0)}\DNFSep\ldots\DNFSep
\SequenceAlt_{\Permutation(n+m)}} & =
\DNFOf{\SequenceAlt_{\Permutation(1)}\DNFSep\ldots\DNFSep
\SequenceAlt_{\Permutation(n)}}\OrDNF\\
& \hspace{1em}
\DNFOf{\Sequence_{\Permutation(n+1)}\DNFSep\ldots\DNFSep
\Sequence_{\Permutation(n+m)}}\\
& =
\DNFOf{\SequenceAlt_{\Permutation_1(1)}\DNFSep\ldots\DNFSep
\SequenceAlt_{\Permutation_1(n)}}\OrDNF\\
& \hspace{1em}
\DNFOf{\Sequence_{n+\Permutation_2(1)}\DNFSep\ldots\DNFSep
\Sequence_{n+\Permutation_2(m)}}\\
& =
\OrDNFOf{\DNFRegexAlt_1}{\DNFRegexAlt_2}
\end{tabular}\\
So by Lemma (TODO: find ref),
$\LanguageOf{\DNFOf{\SequenceAlt_{\Permutation(0)}\DNFSep\ldots\DNFSep
\SequenceAlt_{\Permutation(n+m)}}}=
\LanguageOf{\RegexOr{\RegexAlt_1}{\RegexAlt_2}}$

Furthermore, we can prove it has the same semantics.

\begin{tabular}{@{}L@{}L@{}}
\SemanticsOf{\DNFLensOf{\Sequence_1\DNFLensSep\ldots\DNFLensSep\Sequence_{n+m}},
\Permutation} & =
\SetOf{(\String,\StringAlt)\SuchThat
(\String,\StringAlt)\in\SemanticsOf{\Sequence_i}\\
& \hspace{3em}
\text{for some $i\in\RangeIncInc{1}{n+m}$}}\\
& =
\SetOf{(\String,\StringAlt)\SuchThat
(\String,\StringAlt)\in\SemanticsOf{\Sequence_i}\\
& \hspace{3em}
\text{for some $i\in\RangeIncInc{1}{n}$}\\
& \hspace{2em}\BooleanOr(\String,\StringAlt)\in\SemanticsOf{\Sequence_i}\\
& \hspace{3em}\text{for some $i\in\RangeIncInc{n+1}{n+m}$}}\\
& =
\SetOf{(\String,\StringAlt)\SuchThat
(\String,\StringAlt)\in\SemanticsOf{\Lens_1}\\
& \hspace{2em}\BooleanOr(\String,\StringAlt)\in\SemanticsOf{\Lens_2}}\\
& =
\SemanticsOf{\OrLensOf{\Lens_1}{\Lens_2}}
\end{tabular}

Let the last rule be an application of \ComposeLensRule{}, so we have
$\Lens_1 \OfType \Regex_1 \Leftrightarrow \Regex_2$, and
$\Lens_2 \OfType \Regex_2 \Leftrightarrow \Regex_3$,
and $\ComposeLensOf{\Lens_1}{\Lens_2} \OfType \Regex_1 \Leftrightarrow \Regex_3$.
By induction assumption, there is a typing of
$\DNFLens_1 \OfType \DNFRegex_1 \Leftrightarrow \DNFRegex_2$,
and $\DNFLens_2 \OfType \DNFRegex_2 \Leftrightarrow \DNFRegex_3$, where
$\SemanticsOf{\DNFLens_1}=\SemanticsOf{\Lens_1}$,
$\SemanticsOf{\DNFLens_2}=\SemanticsOf{\Lens_2}$,
$\LanguageOf{\DNFRegex_1}=\LanguageOf{\Regex_1}$,
$\LanguageOf{\DNFRegex_2}=\LanguageOf{\Regex_2}$, and
$\LanguageOf{\DNFRegex_3}=\LanguageOf{\Regex_3}$.
By Lemma~\ref{lem:composition-completeness},
there is a lens $\DNFLens \OfType \DNFRegex_1 \Leftrightarrow \DNFRegex_3$,
such that $\SemanticsOf{\DNFLens}=\SetOf{(\String_1,\String_3)\SuchThat
\exists \String_2 (\String_1,\String_2)\in\SemanticsOf{\DNFLens_1}\BooleanAnd
(\String_2,\String_3)\in\SemanticsOf{\DNFLens_2}}=
\SemanticsOf{\ComposeLensOf{\Lens_1}{\Lens_2}}$.

Let the last rule be an application of \RewriteRegexLensRule{}.
\begin{mathpar}
\inferrule[]
{
\Lens \OfType \Regex \Leftrightarrow \RegexAlt \\
\Regex \equiv \Regex'\\
\RegexAlt \equiv \RegexAlt'
}
{
\Lens \OfType \Regex' \Leftrightarrow \RegexAlt'
}
\end{mathpar}
By induction assumption, there exists a derivation

\begin{mathpar}
\inferrule[]
{
\Derivation
}
{
\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt
}
\end{mathpar}

where \LanguageOf{\DNFRegex}=\LanguageOf{\Regex}
and \LanguageOf{\DNFRegexAlt}=\LanguageOf{\RegexAlt},
and \SemanticsOf{\DNFLens}=\SemanticsOf{\Lens}.
Because \LanguageOf{\Regex'}=\LanguageOf{\Regex}
and \LanguageOf{\RegexAlt'}=\LanguageOf{\RegexAlt},
we know \LanguageOf{\Regex'}=\LanguageOf{\DNFRegex}
and \LanguageOf{\RegexAlt'}=\LanguageOf{\DNFRegexAlt'}.
\end{proof}

With some additional lemmas we can eventually prove a stronger theorem.

\begin{theorem}[Unambiguous Regex Equational Theory]
The Equational Theory for Unambiguous Regular Expressions is the Equational
Theory for Regular Expressions without \StarstarRule{}.
\end{theorem}
\begin{proof}
TODO: Same approach of showing things commute, maybe?  Need more thought here.
\end{proof}

\begin{definition}[Non-rewrite DNF Lens equivalence relation]
We say $\Regex\sim\RegexAlt$, if there exists a dnf lens $\DNFLens$, such that
$\DNFLens \OfType \ToDNFRegex(\Regex) \Leftrightarrow \ToDNFRegex(\RegexAlt)$.
\end{definition}

\begin{lemma}[Rewrites respect DNF Lens equivalence relation]
\label{lem:rewrite-respect}
If $\Regex\sim\RegexAlt$, $\Regex\Rewrite\Regex'$, and
$\RegexAlt\Rewrite\RegexAlt'$, then $\Regex'\sim\RegexAlt'$.
Because of this, we can extend \Rewrite{} to operate on \EquivRegexType{}.
\end{lemma}
\begin{proof}
\end{proof}

\begin{lemma}[Rewrites respect the equational theory of regular expressions]
If $\Regex\sim\RegexAlt$, $\Regex\equiv\Regex'$, and
$\RegexAlt\equiv\RegexAlt'$, then $\Regex'\equiv\RegexAlt'$.
Because of this, we can extend $\equiv{}$ to operate on \EquivRegexType{}.
\end{lemma}
\begin{proof}
\end{proof}

\begin{definition}[$\equiv_{\Rewrite}$]
Define $\equiv_{\Rewrite}$ as the equivalence relation generated by \Rewrite{}.
\end{definition}

\begin{lemma}[Equality of $\equiv_{\Rewrite}$ and $\equiv$ on
unambiguous \EquivRegexType{} unambiguous]
\label{lem:rewriteequivequivalence}
Let $\Regex,\Regex'\in\EquivRegexType$.
$\Regex\equiv_{\Rewrite}\Regex'$ if, and only if, $\Regex\equiv\Regex'$.
\end{lemma}
\begin{proof}
It's clear that it generates all, but it really needs theory of unambiguous
regular expressions.
\end{proof}

\begin{lemma}[Confluence of rewrites on \EquivRegexType{}]
\label{lem:rewrite-confluence}
Let $\Regex\Rewrite\RegexAlt$, and $\Regex\Rewrite\RegexAlt'$, then there
exists some $\Regex'$ such that $\RegexAlt\StarOf{\Rewrite}\Regex'$,
and $\RegexAlt'\StarOf{\Rewrite}\Regex'$.
\end{lemma}
\begin{proof}
\end{proof}

\begin{lemma}
If $\Regex, \Regex' \in \EquivRegexType$, then if $\Regex\equiv\Regex'$, then
there exists a $\Regex''$ such that $\Regex\StarOf{\Rewrite}\Regex''$ and
$\Regex'\StarOf{\Rewrite}\Regex''$.
\end{lemma}
\begin{proof}
By Lemma~\ref{lem:rewrite-confluence}, Church-Rosser, and
Lemma\ref{lem:rewriteequivequivalence}.
\end{proof}

\begin{lemma}[Semantics Retention through Rewrites]
\label{lem:rewrite-semantic-retention}
If $\Regex,\RegexAlt\in\EquivRegexType$, and
$\Regex\Rewrite\RegexAlt$, then if $\Regex_1,\Regex_2\in\Regex$, and
$\Lens \OfType \Regex_1 \Leftrightarrow \Regex_2$, then there exists
$\RegexAlt_1,\RegexAlt_2\in\RegexAlt$ such that $\Regex_1\Rewrite\RegexAlt_1$,
and $\Regex_2\Rewrite\RegexAlt_2$, and
$\Lens' \OfType \RegexAlt_1 \Leftrightarrow \RegexAlt_2$,
and $\SemanticsOf{\Lens'}=\SemanticsOf{\Lens}$.
\end{lemma}
\begin{proof}
\end{proof}

\begin{lemma}[Semantics Retention Within Equivalence Class]
\label{lem:eqclass-semantic-retention}
If $\Regex^{\sim}\in\EquivRegexType$, and
$\Regex,\RegexAlt\in\Regex^{\sim}$, and there exists a DNF Lens
$\DNFLens \OfType \ToDNFRegex(\Regex) \Leftrightarrow \ToDNFRegex(\RegexAlt)$,
then if $\Regex',\RegexAlt'\in\Regex^{\sim}$,
with $\LanguageOf{\Regex}=\LanguageOf{\Regex'}$,
and $\LanguageOf{\RegexAlt}=\LanguageOf{\RegexAlt'}$,
then there exists a DNF lens
$\DNFLens' \OfType \ToDNFRegex(\Regex') \Leftrightarrow \ToDNFRegex(\RegexAlt')$,
such that $\SemanticsOf{\DNFLens'}=\SemanticsOf{\DNFLens}$.
\end{lemma}
\begin{proof}
\end{proof}

Now we can prove the stronger result.
\begin{theorem}[Strong Completeness of DNF Lenses]
If there exists a derivation of
$\Lens \OfType \MapsBetweenTypeOf{\Regex}{\RegexAlt}$,
and $\Regex$ and $\RegexAlt$ are strongly unambiguous,
then there exists a derivation of
$\DNFLens \OfType \MapsBetweenTypeOf{\Regex}{\RegexAlt}$,
such that 
$\SemanticsOf{\DNFLens}=\SemanticsOf{\Lens}$.
\end{theorem}
\begin{proof}
By Theorem~\ref{thm:dnflc} (Weak Completeness), there exists a $\Regex_1, \RegexAlt_1, \DNFLens$
such that
$\DNFLens_1 \OfType \ToDNFRegex(\Regex_1) \Leftrightarrow \ToDNFRegex(\RegexAlt_1)$.
As such, $\Regex_1$ and $\RegexAlt_1$ are in the same equivalence class,
$\Regex_1^{\sim}$.

Let $\Regex^\sim$ and $\RegexAlt^\sim$ be the equivalence classes of
$\Regex$ and $\RegexAlt$, respectively.
$\Regex^{\sim}\equiv\Regex_1^{\sim}\equiv\RegexAlt^{\sim}$, so there exists
a $\Regex_2^{\sim}$ such that $\Regex^{\sim}\Rewrite\Regex_2^{\sim}$,
$\Regex_1^{\sim}\Rewrite\Regex_2^{\sim}$, and
$\RegexAlt^{\sim}\Rewrite\Regex_2^{\sim}$.

From Lemma~\ref{lem:rewrite-semantic-retention}, there exists a $\DNFLens_2 \OfType
\ToDNFRegex(\Regex_2) \Leftrightarrow \ToDNFRegex(\RegexAlt_2)$ such that
$\SemanticsOf{\DNFLens_2}=\SemanticsOf{\DNFLens_1}$.
Furthermore, there exists a $\Regex_3,\RegexAlt)3\in\Regex_2^{\sim}$
such that $\Regex\StarOf{\Rewrite}\Regex_3$,
and $\RegexAlt\StarOf{\Rewrite}\RegexAlt_3$.
By Lemma~\ref{lem:eqclass-semantic-retention}, there exists a lens
$\DNFLens_3 \OfType
\ToDNFRegex(\Regex_3) \Leftrightarrow \ToDNFRegex(\RegexAlt_3)$,
with $\SemanticsOf{\DNFLens_3}=\SemanticsOf{\Lens}$.

So we have the final typing derivation
\begin{mathpar}
\inferrule*[left=\Derivation]
{
\inferrule*
{
\inferrule*[vdots=1.5em]
{
}
{
}
}
{
\DNFLens_3 \OfType
\ToDNFRegex(\Regex_3) \Leftrightarrow \ToDNFRegex(\RegexAlt_3)
}
}
{
\DNFLens_3 \OfType \Regex_3 \Leftrightarrow \RegexAlt_3
}\\

\inferrule*
{
\Derivation\\
\Regex\StarOf{\Rewrite}\Regex_3\\
\DNFRegex\StarOf{\Rewrite}\DNFRegex_3
}
{
\DNFLens_3 \OfType \Regex \Leftrightarrow \RegexAlt
}
\end{mathpar}
\end{proof}


%proof-dnflc end

%%% Local Variables:
%%% TeX-master: "main"
%%% End: