\newif\ifdraft\drafttrue  % set true to show comments
\newif\ifanon\anontrue    % set true to suppress names, etc.
\newif\iffull\fullfalse   % set true for long version
\newif\ifappendices\appendicesfalse

\documentclass[numbers,10pt,preprint\ifanon ,nocopyrightspace\fi]{sigplanconf}

\listfiles

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\let\proof\relax
\let\endproof\relax

\usepackage{amsmath}
\usepackage[table]{xcolor}
\usepackage{mathtools}
\usepackage{bussproofs}
\usepackage{amsthm}
\usepackage{csvsimple}
\usepackage{thmtools,thm-restate}
\usepackage{changepage}
\usepackage{booktabs}
\usepackage{amssymb}
\usepackage[inline]{enumitem}
\usepackage{multirow,bigdelim}
\usepackage{siunitx}
\usepackage{listings}
\usepackage{sansmath}
\usepackage{url}
\usepackage{flushend}
\usepackage{microtype}
\usepackage[utf8]{inputenc}
\usepackage{mathpartir}
\usepackage{empheq}
\usepackage{array}
\usepackage{pgfplots}
\usepackage{stmaryrd}
\usepackage{courier}
\usepackage{qtree}
\usepackage[normalem]{ulem}
\usepackage{relsize}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage[noend]{algpseudocode}
\usepackage{graphicx}

\usetikzlibrary{matrix,shapes,arrows,positioning}

%%%% Hyperlinks â€“ must come late!
\usepackage[pdftex,%
            pdfpagelabels,%
            linkcolor=blue,%
            citecolor=blue,%
            filecolor=blue,%
            urlcolor=blue]
           {hyperref}

\input{macros}

\clubpenalty = 10000
\widowpenalty = 10000
\displaywidowpenalty = 10000

%\setlength{\belowcaptionskip}{-5pt}
%\setlength{\textfloatsep}{15pt}

% Creates a display mode for code in sans serif font
\lstnewenvironment{sflisting}[1][]
  {\lstset{%
    mathescape,
    basicstyle=\small\sffamily,
    aboveskip=5pt,
    belowskip=5pt,
    columns=flexible,
    frame=,
    xleftmargin=1em,#1}\sansmath}
  {}
% end

% Macros
\newcommand{\NameOf}[1]{\texttt{#1}}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}
\toappear{}

\conferenceinfo{POPL '16}{January 20--22, 2016, St. Petersburg, FL, USA} 
\copyrightyear{2016} 
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

\titlebanner{DRAFT---do not distribute}        % These are ignored unless
%\preprintfooter{to appear in POPL '16}   % 'preprint' option specified.

\title{Synthesizing Bijective Lenses
\ifanon\vspace*{-2cm}\fi
}

\ifanon
\authorinfo{}
           {}
           {}
\maketitle
% \vspace*{-6cm}
\else
\authorinfo{Anders Miltner}
           {Princeton University, USA}
           {}
%            {amiltner@cs.princeton.edu}
\authorinfo{Kathleen Fisher}
           {Tufts University, USA}
           {}
%            {kfisher@eecs.tufts.edu}
\authorinfo{Benjamin Pierce}
           {University of Pennsylvania, USA}
%            {bcpierce@cis.upenn.edu}
           {}
\authorinfo{David Walker}
           {Princeton University, USA}
           {}
%            {dpw@cs.princeton.edu}
\authorinfo{Steve Zdancewic}
           {University of Pennsylvania, USA}
           {}
%            {stevez@cis.upenn.edu}
\maketitle
\fi



\begin{abstract}
  % begin abstract 
  \emph{Lenses} are a bidirectional language for specifying
  conversions between data formats.  They provide invertibility
  guarantees, thus avoiding pernicious data-corrupting bugs.
  Unfortunately, lenses can be difficult to write because the typing
  that ensures invertibility heavily restricts the set of allowed
  programs.  To overcome this difficulty, we have developed an
  algorithm to automatically synthesize bijective lenses,  from pairs of
  regular expressions that represent the source and target data
  formats and a small number of examples.

  The rich structure of regular expressions makes lens
  synthesis more complicated than previous work on other forms of
  type-directed synthesis.  Specifically, finding a term to
  bi-directionally convert between regular expressions $A$ and $B$
  requires first finding equivalent regular expressions $A'$ and $B'$
  that are more algorithmically tractable.  We show how to manage this
  search by moving the search problem to a space of simplified (but fully
  expressive) lenses 
  governed by normalized regular expression types.  We then
  show how to search this reduced space for well-typed lenses that are
  consistent with user-supplied examples.  We demonstrate the
  effectiveness of our algorithm by evaluating it on a benchmark suite
  containing 23 examples comprising microbenchmarks, Flash Fill
  examples, and Augeas transformations of Linux configuration files.
  We are able to infer lenses for all benchmark programs
  in an average of 0.134 seconds.

\bcp{
A possible alternative structure for the abstract: 
\begin{itemize}
\item Bidirectional transformations between different representations of
data can be found everywhere in software systems---in serializers and
deserializers, parsers and pretty printers, database views and view update
functions, and a multitude of ad hoc data transformers.
\item Writing each direction of a bidirectional transformation as a separate
function is tedious and error-prone.  
\item Domain-specific languages that allow both directions to be written as
a single expression are better, but can be rather fiddly.  For example,
languages like Boomerang, based on the theory of {\em lenses}, tend to come
with restrictive typing constraints such as {\em unambiguity} that are
tricky for programmers to work with.
\item Fortunately, we can do better: We show how this programming task can
be automated using techniques of type-based program synthesis.  
\item Specifically, we present an algorithm for synthesizing bijective
lenses between 
pairs of string data formats.  Inputs to the algorithm are the
schemas for the two formats, expressed as regular expressions, plus a few
concrete examples to guide synthesis.  The output is a well-typed program
in the bijective subset of Boomerang that
transfors the examples as specified.  
\item (Briefly!) The main challenge is... We address it by...
\item We evaluate our algorithm by...
\end{itemize}
}
\end{abstract}

% \category{D.3.1}
% {Programming Languages}
% {Formal Definitions and Theory}
% [Semantics]
\ifanon\else
\category{F.4.1}
{Mathematical Logic and Formal Languages}
{Mathematical Logic}
[Proof Theory]
\category{I.2.2}
{Artificial Intelligence}
{Automatic Pro\-gramming}
[Program Synthesis]

\terms Languages, Theory

\keywords Functional Programming, Proof Search, Program Synthesis, Type Theory
\fi

% begin introduction
\section{Introduction}

The growing dependence on big data makes tools for reliably parsing,
printing, cleaning, and transforming data in {\em ad hoc} formats
increasingly important. 
One such class of tools is \emph{lenses}~\cite{Focal2005-long},
bidirectional programs that help users solve the classic ``view update
problem'' \cite{chen2010comparative}.\BCP{We persistently mix
  general [asymmetric or even symmetric] lenses with bijective lenses.
  Here, for example, it's true that asymmetric lenses are intended as a
  solution to the view-update problem, but 
  {\em bijective} lenses are not, really.}
More specifically, a lens provides a user with two functions:
\emph{get} and \emph{put}.  The \emph{get}
function translates source data into a target format, or \emph{view}, for
the user.  If the user updates the view, the corresponding
\emph{put} function can translate the edited data back into
the source format.

%Converting data back and forth between representations is a common problem.
%It arises in serializers and deserializers, models and views, picklers
%and unpicklers, and more.
%Bidirectional programs express both transformations in a single program, instead
%of requiring a program for each transformation.
%Bidirectional programming has begun to be used in practice for expressing some
%classes of back and forth transformations.

Lenses are useful because they provide strong guarantees about
round-trip behavior.  Such guarantees guard against data corruption
while reading, editing, and writing data sources.  Lenses are
typically implemented as domain-specific languages with strong type
systems~\cite{Focal2005-long, boomerang, symmetric-lenses} because
general-purpose languages do not admit bidirectional interpretations
nor do they have type systems strong enough to ensure desired round-tripping
laws.

Lens-like languages have been used successfully in a number of practical
applications.  For example, include Augeas~\cite{augeas}, a configuration
editing system for linux that uses lens combinators to provide editable
views of configuration files; the biXid~\cite{bixid} language that expresses
bidirectional XML transformations, and XSugar~\cite{xsugar} that converts
bidirectionally between XML and non-XML data and between
EpiDoc~\cite{epidoc} and Leiden+~\cite{leidenplus} formats for encoding
ancient documents~\cite{epidocleidenplus}.  \BCP{Some things to figure
  out... biXid and XSugar are not exactly lens languages.  And there are a
  whole bunch of other lens-like languages, e.g. from Tokyo, that we should
  mention.  One issue we'll need to deal with is that many of these
  languages do {\em not} have especially restrictive type systems; instead,
  they give up on totality.  E.g., instead of requiring unambiguity, they
  might simply declare that their lenses will signal an error if you ever
  supply them with a string that has two different parses.  I'm not
  completely sure how we want to frame the discussion, but I will think
  about it.}
%
However, these languages have not been widely adopted, for several reasons.
First, users must learn a lens language and its type system.  Second, they
must adopt its unorthodox programming style that requires thinking in two
directions at once.  Finally and most importantly, they must learn how to
work within the restrictive type system that ensures invertibility.  These
difficulties can disincentivize programmers from adopting the technology,
despite its advantages.
%
\BCP{IMHO, the third of these is the only really important one.  And, to be
  fair, our tool does not really save programmers from dealing with
  unambiguity, since they still have to write the types!}

One way to overcome these difficulties is to {\em synthesize} lenses from
types and examples.  We propose an algorithm for doing this, for the case of
bijective lenses between regular string languages.  Given a type
$\Regex \Leftrightarrow \RegexAlt$ (which describes lenses mapping
bijectively between $\Regex$ and $\RegexAlt$) and a small number of
examples, our algorithm will synthesize a well-typed lens whose behavior
matches the examples.

Our work continues a recent trend toward synthesizing programs in a variety
of domain-specific languages~\cite[etc.]{yag+:pldi16, osera+:pldi15,
  frankle+:popl16, armando+:pldi16}\bcp{Are these citations for ``program
  synthesis for DSLs''?  Seems very incomplete, if so.  Maybe we don't want
  to try to cite that whole literature, unless Steve knows enough about it
  to be sure that we're doing a good job of it.}, many guided by
types~\cite{osera+:pldi15,frankle+:popl16,armando+:pldi16}.  
\iffull
\bcp{I think the rest of the paragraph can probably go, even in the long
  version.} 
For instance,
to find an expression with type $A \rightarrow B$, such algorithms assume
that the expression in question is a function of the form
$\lambda x{:}A. e$.  These algorithms then search for an expression $e$ with
type $B$ under the hypothesis that the parameter $x$ has type $A$.
%
In
the case of the simply typed lambda calculus, such an approach reduces
the complexity of the search for terms inhabiting the type without
losing completeness.  This approach does not directly apply to the
problem of lens synthesis, however, because
lenses use a richer type system
than the simply typed lambda calculus.
Specifically, lenses use regular expression types, which means 
there are many equivalent ways to express the same type and a simple
syntax-directed algorithm will not work.
\fi

To explain our algorithm,
we use a running example that converts between citations given
in simplified fragments of BibTex and EndNote formats.  The BibTex format
specifies a list of authors on a single line:
\begin{lstlisting}
   author={Conway, John and Kleene, Stephen Cole}
\end{lstlisting}
The EndNote format contains the same information, but uses different separators,
rearranges the order of first and last names, and puts each author on
a separate line:
\begin{lstlisting}
   % A John Conway
   % A Stephen Cole Kleene
\end{lstlisting}

\begin{figure}
\begin{lstlisting}
Name = [A-Z][a-z]*
Names = (" " Name)*

(* BibTex definitions *)
BNames = Name ", " Name Names
BibTex = ""
       | "author={" BNames (" and " BNames)* "},"

(* EndNote definitions *)
ENames  = Name Names " " Name
EndNote = ("%A " ENames "\n")*

(* Synthesis Specification With 1 Example *)
BibEnd : BibTex <=> EndNote = {
"author={Conway, John and Kleene, Stephen Cole}"
<-> "%A John Conway\n%A Stephen Cole Kleene" }
\end{lstlisting}
  \caption{Synthesis Example: Idealized Bibtex to EndNote}
  \label{fig:bibend-spec}
\end{figure}

Figure~\ref{fig:bibend-spec} shows an example specification for a lens
\CF{BibEnd} that converts between the \CF{Bibtex} and \CF{EndNote} formats.
Giving names to intermediate regular expressions (\CF{Name}, \CF{Names},
etc.) facilitates construction of complex formats; we will see that they
also play an important role in the synthesis process.

\paragraph*{Challenge 1: Multi-dimensional Search Space.}
A central challenge facing our synthesis algorithm is illustrated
by the concatenation operator, $\ConcatLensOf{\Lens_1}{\Lens_2}$.
When viewed from left to right, this lens defines a
function \emph{get} that divides an input string $\String$ into two
substrings $\String_1$ and $\String_2$ and applies $\Lens_1$ to the first
and $\Lens_2$ to the second to yield $t_1$ and $t_2$.
When viewed from right to left, it defines a second
function \emph{put}, which maps from strings $t$ to strings $s$ in an
analogous way.  The type system for lenses ensures these \emph{get}
and \emph{put} functions form a bijection via this typing rule:
\[
  \inferrule
  {
    \Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1\\
    \Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2\\\\
    \UnambigConcatOf{\Regex_1}{\Regex_2}\\
    \UnambigConcatOf{\RegexAlt_1}{\RegexAlt_2}
  }
  {
    \ConcatLensOf{\Lens_1}{\Lens_2} \OfType \Regex_1\Concat\Regex_2
    \Leftrightarrow \RegexAlt_1\Concat\RegexAlt_2
  }
\]
The hypothesis $\UnambigConcatOf{\Regex_1}{\Regex_2}$ asserts that
$\Regex_1$ and $\Regex_2$ are \textit{unambiguously concatenable}, meaning
there is exactly one way to divide any string $\String$ in
$\LanguageOf{\Regex_1\Concat\Regex_2}$, the language of
$\Regex_1\Concat\Regex_2$, into $\String_1$ and $\String_2$ such that
$\String_1$ is in $\LanguageOf{\Regex_1}$ and $\String_2$ is in
$\LanguageOf{\Regex_2}$.  These constraints guarantee that the \emph{get}
and \emph{put} of $\Lens$ form a bijective pair if $\Lens_1$ and $\Lens_2$
are themselves bijective.

Consider searching for a lens with the type
$(A B) C \Leftrightarrow A' (B' C')$ assuming we know how to construct
lenses with types $A \Leftrightarrow A'$, $B \Leftrightarrow B'$, and
$C \Leftrightarrow C'$.  A straightforward syntax-directed search might try
applying the rule for concatenation (from bottom to top) and looking for two
simpler lenses with the types $A B \Leftrightarrow A'$ and
$C \Leftrightarrow B' C'$.  Clearly, this is not going to get us far.

We might next try introducing a type conversion rule like
\[
  \inferrule
  {
    \Lens \OfType \Regex_1 \Leftrightarrow \Regex_2\\
    \Regex_1 \equiv \Regex_1'\\
    \Regex_2 \equiv \Regex_2'
  }
  {
    \Lens \OfType \Regex_1' \Leftrightarrow \Regex_2'
  }
\]
into the synthesis procedure.  
This rule can be used to 
convert the type $(A B) C \Leftrightarrow A' (B' C')$
to the better-aligned $(A B) C \Leftrightarrow (A' B') C'$, from which two
applications of concatenation rule generate subproblems 
$A \Leftrightarrow A'$, $B \Leftrightarrow B'$, and 
$C \Leftrightarrow C'$,  which we know how to solve.

Since regular-expression equivalence is decideable, 
it is easy to \emph{check} whether a given lens $\Lens$ with type 
$\Regex_1 \Leftrightarrow \Regex_2$
also has type 
$\Regex_1' \Leftrightarrow \Regex_2'$. 
%
During synthesis, however, deciding when and how to use type conversion is
difficult because there are infinitely many regular expressions that are
equivalent to the source and target regular expressions.  Do we need to
consider all of them?  In what order?

A related challenge arises from the composition operator,
$\ComposeLensOf{\Lens_2}{\Lens_1}$.  The typing rule for composition
$$
    \inferrule[]%\ComposeLensRule{}
    {
      \Lens_1 \OfType \Regex_1 \Leftrightarrow \Regex_2\\
      \Lens_2 \OfType \Regex_2 \Leftrightarrow \Regex_3\\
    }
    {
      \ComposeLensOf{\Lens_2}{\Lens_1} \OfType \Regex_1 \Leftrightarrow \Regex_3
    }
$$
requires that the target type of $l_1$ be the source
type of $l_2$.  To synthesize a composition lens between
$\Regex_1$ and $\Regex_2$, we must find an intermediate type $\Regex_3$
and lenses with types $\Regex_1 \Leftrightarrow \Regex_3$ and
$\Regex_3 \Leftrightarrow \Regex_2$.  Searching for the correct
regular expression $\Regex_3$ is again problematic because
the search space is infinite.  


%Furthermore, Boomerang has a composition operator to compose multiple
%lenses.Removing the composition operator from Boomerang reduces
%expressivity.  That means, to have a synthesis procedure that can
%synthesize all lenses, the procedure must synthesize composition lenses.

Thus, naively applying type-directed synthesis techniques
involves searching \emph{in three infinite dimensions}:  we must
search for
(1) a \emph{type} consisting of two regular expressions equivalent to the
given ones but with an ``appropriate shape,'' 
(2) a lens \emph{expression} that has the given type and is consistent
with the user's examples, and 
(3) {\em intermediate} regular expressions for each use of the composition
operator.  

Our approach to this challenge is to define a new ``DNF syntax'' for types
and lenses that reduces the synthesis search space \emph{in all dimensions}.
In this language, regular expressions are written in disjunctive normal
form, where unions are fully distributed over concatenation and where binary
operators are replaced by $n$-ary ones, eliminating associativity rules.
For example, when presented with a synthesis problem with type
$(A B) C \Leftrightarrow A' (B' C')$, our algorithm will first convert this
type into $A \Concat B \Concat C \Leftrightarrow A' \Concat B' \Concat C'$.
\bcp{Maybe the latter should be presented in the DNF syntax.}

Normalization to DNF eliminates, many, but not all, of the regular expression
equivalences that may needed before applying a simple structural search that
follows the syntax of types.
Not all structural incongruities disappear because our normalized
regular expressions are only \emph{pseudo-canonical}.
For instance, our normal form
does not automatically unify regular expressions such as
$A B*$ and $A (\epsilon + BB*)$ that result from an
unrolling of Kleene Star.  \afm{Attempting to normalize by putting
the regular expressions in the smaller form on the left form prevents finding
transformations between $\EmptyString \Or (\Regex \Concat \StarOf{\Regex})$ and
$\EmptyString \Or (\Regex' \Concat \StarOf{\Regex})$, as the first form would be
able to be transformed, while the second could not.  Attempting to put the
regular expressions into the larger form on the right cannot be done, as that
rule can be applied an arbitrarily large number of times.}\bcp{This
explanation belongs in black!}
% \bcp{Why
%     couldn't we have built our algorithm by following the structure of a
%     proof of equivalence between the source and target types?  (I.e., why
%     did we have to use Conway's axioms or worry about confluence, given that
%     we know regular language equivalence is decidable?  Is it because that
%     proof is automata-theoretic?)}
%   \afm{The source and target types of lenses are not
%   necessarily language equivalent, so we cannot use standard equivalence
%   strategies to determine if lenses exist between them.  Furthermore, we cannot
%   even approach this problem by generating transducers between the languages;
%   lenses are able to swap data.  Commonly, data formats do not have all data in
%   the same locations, and swapping is important for expressing data
%   transformations between these formats.}
% BCP: OK, that was a dumb question.  
Consequently, we structure our synthesis algorithm in two parts.  The
first is a syntax-directed search for a lens based on the structure of the given
regular expression types. If that fails, the second is a search,
using a subset of Conway's axioms~\cite{conway}, for 
equivalent regular expression types that might allow a new search to succeed.

Like DNF regular expressions, DNF lenses are stratified, with disjunctions
outside of concatenations, and they use $n$-ary operators instead of binary
ones, further reducing the search space.  The DNF syntax also omits the lens
composition operator because (unlike the standard lens syntax) its other
operators are already closed under composition (any program that can be
written with composition can also be written without it).  This reduces the
search space by an entire dimension because the synthesis algorithm no
longer needs to search through possible intermediary regular expressions for
compositions.

\paragraph*{Challenge 2: Large Types}
In practice, the regular expressions describing complex {\em ad hoc} data
formats may be very large.  
%
The key to addressing this challenge is to observe that users naturally
construct large types incrementally, introducing named abbreviations for
major subcomponents.  We can exploit the structure inherent in these named
abbreviations to speed up the search dramatically.  For example, if the name
$A$ appears just once in both the source and the target types, the system
hypothesizes that the identity lens can be used to convert between
occurrences of $A$.  On the other hand, if the name $A$ appears in the
source but not in the target, the system replaces the name $A$ with its
definition.  Similarly, differing numbers of occurrences of the same name
can serve as a guide for applying equivalence axioms in the synthesis
algorithm.  We guide the transformation of regular expression types during
search using a pseudometric based on counting occurrences of names---this
heuristic turns out to perform much better than a simple breadth-first
search.

\paragraph*{Contributions.}  Our synthesis algorithm is intended to make
bidirectional programming more accessible to non-expert programmers.  We
offer the following technical contributions:

\begin{itemize}
\item We introduce DNF lenses, a variant of standard lenses designed
specifically for synthesis (\S \ref{sec:dnfre} and \S \ref{sec:dnf}).  This
language uses pseudo-canonical regular 
expressions to type the source and target data formats. Its term language
maps between the languages of these pseudo-canonical regular expressions.
We show how to convert back
and forth between ordinary regular expressions and lenses and the DNF forms,
and prove these translations sound and complete with respect to a high-level
lens syntax based on a bijective subset of the well-studied Boomerang
language~\cite{boomerang}.  \BCP{This claim is not entirely accurate, unless
  it's stated and read very carefully: our high-level lens syntax is just a
  subset of (the bijective subset of) Boomerang, because it doesn't have all
  the type equivalences.  I've tried to adjust the wording so it's true,
  but...} 
\item We develop a type-directed algorithm for synthesizing DNF lenses (\S
\ref{implementation}) and prove it correct and complete.
\item We evaluate this algorithm on 23 benchmarks, including examples from
FlashFill\bcp{explain what it is} and from the Augeas system for
transforming linux file formats (\S \ref{evaluation}).  Our tool succeeds on
all of our benchmarks, with an average synthesis time of 0.134
seconds\bcp{how many significant digits?}.
\end{itemize}
% end introduction

% begin background
\section{Background}

\SUBSECTION{Regular Expressions}
% \label{sec:regexp}

%\paragraph*{Languages and Alphabets}
%
%An \textit{alphabet}, written \Alphabet{}, is a finite set.
%A \textit{character} is an element of an alphabet.
%A \textit{string}, written \String{} or \StringAlt{}, is a sequence of characters.
%The empty string is written \EmptyString{}.
%The set of all strings is written \StarOf{\Alphabet}.
%A \textit{language}, written \Language{}, is a subset of \StarOf{\Alphabet}.
%
%If \String{} and \StringAlt{} are strings, with
%$\String=\Character_1\ldots\Character_n$,
%and $\StringAlt=\CharacterAlt_1\ldots\CharacterAlt_m$,
%then the \textit{concatenation} of \String{} and \StringAlt{},
%written \String{}\Concat\StringAlt{}, is defined as
%$\Character_1\ldots\Character_n\CharacterAlt_1\ldots\CharacterAlt_m$.
%At times, The $\Concat$ will be omitted, and $\String\StringAlt$ will be used in
%place of $\String\Concat\StringAlt$.
%
%\bcp{Why do we need unambiguity for languages (as opposed to REs)?}%
%If $\Language_1$ and $\Language_2$ are languages, such that
%for all strings $\String_1,\StringAlt_1 \in \Language_1$, and for all strings
%$\String_2,\StringAlt_2 \in \Language_2$, If $\String_1\Concat\String_2 =
%\StringAlt_1\Concat\StringAlt_2$, then $\Language_1$ is \textit{unambiguously
%  concatenable} with $\Language_2$, written
%$\UnambigConcatOf{\Language_1}{\Language_2}$.
%
%If $\Language$ is a language, such that
%for all $n\in\Nats$ and for all strings
%$\String_1,\ldots,\String_n\in\Language$, and for all strings
%$\StringAlt_1,\ldots,\StringAlt_m\in\Language$, if
%$\String_1\Concat\ldots\Concat\String_n=\StringAlt_1\Concat\ldots\Concat\StringAlt_m$
%then $n=m$ and $\String_i=\StringAlt_i$ for all $i$,
%that language is \textit{unambiguously iterable},
%written $\UnambigItOf{\Language}$.

% \BCP{When we remove stuff from the short version, we're not removing it
%   completely (i.e., commenting it out), but rather putting iffull...fi or
%   some such around it, right?  I had assumed that we were going to submit
%   (as ``supplemental material'') a long version containing both proofs and
%   all the stuff elided from the short version...}  \afm{for this I just
%   removed it, for a lot of things I moved it into the appendix.  In future I
%   will do the iffull strategy.}  \bcp{OK, for this bit I don't see much harm
%   in just losing things even in the long version.  Just wanted to make sure
%   we had the long version in mind.}

$\Sigma$ is the alphabet of individual characters; $s$ and $t$ range over
strings in $\StarOf{\Sigma}$.  Regular expressions over $\Sigma$ are: 
\begin{center}
\begin{tabular}{l@{\hspace*{5mm}}l@{\ }c@{\ }l@{\hspace*{5mm}}>{\itshape\/}l}
& \Regex{},\RegexAlt{} & \GEq{} & \hspace{1.06em}s & \BaseRegexType{} \\
          & & & \GBar{} $\emptyset$ & \EmptyRegexType{} \\
          & & & \GBar{} \Regex{}* & \StarRegexType{} \\
          & & & \GBar{} $\RegexConcat{\Regex_1}{\Regex_2}$ & \ConcatRegexType{} \\
          & & & \GBar{} $\RegexOr{\Regex_1}{\Regex_2}$ & \OrRegexType{} \\
\end{tabular}
\end{center}
$\LanguageOf{R}\subseteq \StarOf{\Sigma}$, the language of $R$, is
defined as usual. 

\paragraph*{\iffull Regular-Expression \fi Unambiguity}

%These regular expressions are used to inductively define languages.
%\[
%  \begin{array}{lcl}
%    \LanguageOf{\String} &=& \{\String\}\\
%    \LanguageOf{\emptyset} &=& \{\}\\
%    \LanguageOf{\RegexConcat{\Regex_1}{\Regex_2}} &=&
%                                                      \{\StringConcat{\String_1}{\String_2} \SuchThat
%                                                      \String_1\in\LanguageOf{\Regex_1} \BooleanAnd \String_2\in\LanguageOf{\Regex_2}\}\\
%    \LanguageOf{\RegexOr{\Regex_1}{\Regex_2}} &=&
%                                                  \{\String \SuchThat
%                                                  \String\in\LanguageOf{\Regex_1} \BooleanOr \String\in\LanguageOf{\Regex_2}\}\\
%    \LanguageOf{\StarOf{\Regex}} &=&
%                                     \{\String_1\Concat\ldots\Concat\String_n \SuchThat
%                                     n\in\Nats \wedge \String_i\in\LanguageOf{\Regex}\}
%  \end{array}
%\]

Regular expressions $\Regex$ and $\RegexAlt$ are 
\textit{unambiguously concatenable}, written
$\Regex\UnambigConcat\RegexAlt$ if, 
for all strings $\String_1,\StringAlt_1\in\LanguageOf{\Regex}$ and
$\String_2,\StringAlt_2\in\LanguageOf{\RegexAlt}$, whenever
$\String_1\Concat\String_2=\StringAlt_1\Concat\StringAlt_2$ we have
$\String_1=\StringAlt_1$ and $\String_2=\StringAlt_2$.
%
A regular expression $\Regex$ is said to be \textit{unambiguously iterable},
written $\UnambigItOf{\Regex}$ if,
for all $n,m\in\Nats$ and for all strings
$\String_1,\ldots,\String_n,\StringAlt_1,\ldots,\StringAlt_m\in\LanguageOf{\Regex}$,
whenever
$\String_1\Concat\ldots\Concat\String_n=\StringAlt_1\Concat\ldots\Concat\StringAlt_m$
it is the case that $n=m$ and $\String_i=\StringAlt_i$ for all $i$.

A regular expression $\Regex$ is \textit{strongly unambiguous} if one
of the following holds: 
\begin{enumerate*}[label=(\alph*) ]
\item $\Regex = \String$,  or
\item $\Regex = \emptyset$, or 
\item $\Regex = \Regex_1 \Concat \Regex_2$ with $\Regex_1 \UnambigConcat
  \Regex_2$, or
\item $\Regex = \Regex_1 \Or \Regex_2$ with $\Regex_1 \Intersect \Regex_2 =
  \emptyset$, 
or
\item $\Regex = \StarOf{(\Regex')}$ with $\UnambigItOf{(\Regex')}$.
\end{enumerate*}
Moreover, in the recursive cases, $\Regex_1$, $\Regex_2$, and $\Regex'$
must themselves be strongly unambiguous.

% fig:regex-equivalence-rules

% fig:definitional-equivalence-rules
\paragraph*{\iffull Regular-Expression \fi Equivalences}
$R$ and $T$ are \textit{equivalent}, written $\Regex\equiv\RegexAlt$, if 
$\LanguageOf{\Regex}=\LanguageOf{\RegexAlt}$.
There exists an equational theory for determining whether two regular expressions
are equivalent, presented by Conway \cite{conway}, and proven complete by Krob
\cite{Krob}.
%
Conway's axioms consist of the semiring axioms (associativity,
commutativity, identities, and distributivity for $|$ and $\cdot$) plus the following 
rules for equivalences involving $*$:
\begin{center}
\begin{tabular}{@{}r@{\hspace{1em}}c@{\hspace{1em}}l@{}r@{}}
  \StarOf{(\RegexOr{\Regex{}}{\RegexAlt{}})} & $\equiv$ & \RegexConcat{\StarOf{(\RegexConcat{\StarOf{\Regex{}}}{\RegexAlt{}})}}{\StarOf{\Regex{}}} & \SumstarRule{}\\
  \StarOf{(\RegexConcat{\Regex{}}{\RegexAlt{}})} & $\equiv$ & \RegexOr{\EmptyString{}}{(\RegexConcat{\RegexConcat{\Regex{}}{\StarOf{(\RegexConcat{\RegexAlt{}}{\Regex{}})}}}{\RegexAlt{}})} & \ProductstarRule{} \\
  ${(\Regex{}^*)}^*$ & $\equiv$ & \StarOf{\Regex{}} & \StarstarRule{} \\
  \StarOf{(\RegexOr{\Regex}{\RegexAlt})} & $\equiv$ & $\StarOf{(\RegexConcat{(\RegexOr{\Regex}{\RegexAlt})}{\RegexOr{\RegexAlt}{\RegexConcat{{(\RegexConcat{\Regex}{\StarOf{\RegexAlt}})}^n}{\Regex}}})}\Concat$ & \DicyclicityRule{}\\
                                             & & $(\EmptyString\Or(\RegexOr{\Regex}{\RegexAlt})\Concat$\\
                                             & & $({(\RegexConcat{\Regex}{\StarOf{\RegexAlt}})}^0\Or\ldots\Or{(\RegexConcat{\Regex}{\StarOf{\RegexAlt}})}^n))$
\end{tabular}
\end{center}



% There are a number of proof systems that are complete with respect to
% determining regular
% expression equivalence, but equational theories embed a straightforward search
% procedure for generating equivalent regular expressions, for they provide a
% rewrite relation that creates equivalent regular expressions.  \afm{Using a
%   different proof system would achieve the same result: we search through
%   equivalent regular expressions in synthesizing \RewriteRegexLensRule{},
%   we would just also be required to keep track of other information, like Horn
%   clauses.  An equational theory provides rewrite rules associated with the
%   application of an equivalence rule.}\BCP{This is
%   not a very strong reason for following this path, given that this complete
%   search procedure was precisely what we were unable to establish.}


% \BCP{This section confusingly blurs the distinction between equational
%   theories and systems of rewrite rules.  What I've always had in mind when
%   we've used the phrase ``rewrite rules'' has been an {\em oriented version}
% of the equational theory, where each equation is replaced by a single rule
% that rewrites from one side to the other (either left to right or right to
% left, but not both).}


% Can't naively add both directions.


% \SumstarRule{} 
% different regular expressions, and groups together when one regular expression occurs,
% separated by when the other regular expression occurs.  
% \ProductstarRule{} is an axiom corresponding to separating the
% zero case from the one or greater case in stars.
% \StarstarRule{}
% introduces ambiguity. 
%  \DicyclicityRule{} is used to separate out the iteration
% of two elements into a quotiented portion, and a remainder portion.


While this equational theory is complete, na\"{i}vely using it in the
context of lens synthesis presents several problems.  To understand
why, we need to see how the equational theory is used to type lenses. 


\SUBSECTION{Bijective Lenses}

% fig:lens-semantics

All bijections between languages are lenses.  We define Bijective Lenses to be
bijections created from the Boomerang lens combinators, mapping between
languages of regular expressions.
The syntax for these bijective lenses is given by:
\begin{center}
  \begin{tabular}{l@{\ }l@{\ }c@{\ }l@{\ }>{\itshape\/}r}
    % REGEX
    & \Lens{} & \GEq{} & $\ConstLensOf{s_1 \in \StarOf{\Alphabet}}{s_2 \in \StarOf{\Alphabet}}$ & Const \\
            & & & \GBar{} $\IterateLensOf{\Lens}$ & Iterate \\
            & & & \GBar{} $\ConcatLensOf{\Lens_1}{\Lens_2}$ & Concat \\
            & & & \GBar{} $\SwapLensOf{\Lens_1}{\Lens_2}$ & Swap\\
            & & & \GBar{} $\OrLensOf{\Lens_1}{\Lens_2}$ & Or\\
            & & & \GBar{} $\ComposeLensOf{\Lens_2}{\Lens_1}$ & Compose\\
            & & & \GBar{} $\IdentityLensOf{\Regex}$ & Identity
  \end{tabular}
\end{center}

\noindent The denotation of a lens $\Lens$ is  $\SemanticsOf{\Lens}
\subseteq \StringType \Cross \StringType$.  If $(\String_1,\String_2) \in
\SemanticsOf{\Lens}$, then $\Lens$ \emph{maps between} $\String_1$ and
$\String_2$.
\begin{center}
  \begin{tabular}{@{}rcl}
    $\SemanticsOf{const(\String_1,\String_2)}$ &=& $\SetOf{(\String_1,\String_2)}$\\
    
    $\SemanticsOf{\IterateLensOf{\Lens}}$ &=& $\SetOf{(\String_1\Concat\ldots\Concat\String_n,
                                            \StringAlt_1\Concat\ldots\Concat\StringAlt_n)\SuchThat$\\
 &&                                           $\hspace*{2em}(\String_i,\StringAlt_i)\in\SemanticsOf{\Lens}}$\\
    
    $\SemanticsOf{\ConcatLensOf{\Lens_1}{\Lens_2}}$ &=&
                                                      $\SetOf{(\String_1\Concat\String_2,\StringAlt_1\Concat\StringAlt_2)\SuchThat$\\
                                             & & $\hspace*{2em}(\String_1,\StringAlt_1)\in\SemanticsOf{\Lens_1}\BooleanAnd
                                                 (\String_2,\StringAlt_2)\in\SemanticsOf{\Lens_2}}$\\
    
    $\SemanticsOf{\SwapLensOf{\Lens_1}{\Lens_2}}$ &=&
                                                    $\SetOf{(\String_1\Concat\String_2,\StringAlt_2\Concat\StringAlt_1)\SuchThat$\\
                                             & & $\hspace*{2em}(\String_1,\StringAlt_1)\in\SemanticsOf{\Lens_1}\BooleanAnd
                                                 (\String_2,\StringAlt_2)\in\SemanticsOf{\Lens_2}}$\\
    
    $\SemanticsOf{\OrLensOf{\Lens_1}{\Lens_2}}$ &=&
                                                  $\SetOf{(\String,\StringAlt)
                                                  \SuchThat(\String,\StringAlt)\in\SemanticsOf{\Lens_1}
                                                  \BooleanOr(\String,\StringAlt)\in\SemanticsOf{\Lens_2}}$\\
    
    $\SemanticsOf{\ComposeLensOf{\Lens_2}{\Lens_1}}$ &=&
                                                       $\SetOf{(\String_1,\String_3)\SuchThat\exists\String_2$\\
                                             & & $\hspace*{2em}(\String_1,\String_2)\in\SemanticsOf{\Lens_1}\BooleanAnd
                                                 (\String_2,\String_3)\in\SemanticsOf{\Lens_2}}$\\
    
    $\SemanticsOf{\IdentityLensOf{\Regex}}$ &=& $\SetOf{(\String,\String)
                                              \SuchThat \String\in
                                              \LanguageOf{\Regex}}$
  \end{tabular}
\end{center}

The simplest lens in the combinator language is the the constant lens between
strings $\String$, and $\StringAlt$, $\ConstLensOf{\String}{\StringAlt}$.
The lens $\ConstLensOf{\String}{\StringAlt}$, when operated left-to-right,
replaces the string $\String$ with $\StringAlt$, and when operated
right-to-left, replaces string $\String_2$ with $\String_1$.  The identity lens
on a on a regular expression, $\IdentityLensOf{\Regex}$, operates in both
directions by applying the
identity function to strings in $\LanguageOf{\Regex}$.  The composition
combinator, 
$\ComposeLensOf{\Lens_2}{\Lens_1}$, operates by applying $\Lens_1$ then $\Lens_2$
when operating left to right, and applying $\Lens_2$ then $\Lens_1$ when
operating right to left.

Each of the other lenses manipulates structured data.  For instance,
$\ConcatLensOf{\Lens_1}{\Lens_2}$ operates by applying $\Lens_1$ to the left
portion of a string, and $\Lens_2$ to the right, and concatenating the results.
The combinator
$\SwapLensOf{\Lens_1}{\Lens_2}$ does the same as $\ConcatLensOf{\Lens_1}{\Lens_2}$
but it swaps the results before concatenating.
The combinator $\OrLensOf{\Lens_1}{\Lens_2}$ operates by applying either $\Lens_1$ or $\Lens_2$
to the string.  The combinator $\IterateLensOf{\Lens}$ operates by repeatedly
applying $\Lens$ to subparts of a string.

\paragraph{Lens Typing}

\begin{figure}
  \centering% \footnotesize
  \begin{mathpar}
    \inferrule[]% \ConstantLensRule{}
    {
      \String_1 \in \StarOf{\Sigma}\\
      \String_2 \in \StarOf{\Sigma}
    }
    {
      \ConstLensOf{\String_1}{\String_2} \OfType \String_1 \Leftrightarrow \String_2
    }

    \inferrule[]
    {
      \Lens \OfType \Regex \Leftrightarrow \RegexAlt\\
      \UnambigItOf{\Regex}\\
      \UnambigItOf{\RegexAlt}
    }
    {
      \IterateLensOf{\Lens} \OfType \StarOf{\Regex} \Leftrightarrow \StarOf{\RegexAlt}
    }

\iffull
    \inferrule[]%\ConcatLensRule{}
    {
      \Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1\\\\
      \Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2\\\\
      \UnambigConcatOf{\Regex_1}{\Regex_2}\\
      \UnambigConcatOf{\RegexAlt_1}{\RegexAlt_2}
    }
    {
      \ConcatLensOf{\Lens_1}{\Lens_2} \OfType \Regex_1\Regex_2 \Leftrightarrow \RegexAlt_1\RegexAlt_2
    }
\fi

    \inferrule[]%\SwapLensRule{}
    {
      \Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1\\\\
      \Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2\\\\
      \UnambigConcatOf{\Regex_1}{\Regex_2}\\
      \UnambigConcatOf{\RegexAlt_2}{\RegexAlt_1}
    }
    {
      \SwapLensOf{\Lens_1}{\Lens_2} \OfType \Regex_1\Regex_2 \Leftrightarrow \RegexAlt_2\RegexAlt_1
    }

    \inferrule[]%\OrLensRule{}
    {
      \Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1\\
      \Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2\\\\
      \UnambigOrOf{\LanguageOf{\Regex_1}}{\LanguageOf{\Regex_2}}\\ \UnambigOrOf{\LanguageOf{\RegexAlt_1}}{\LanguageOf{\RegexAlt_2}}
    }
    {
      \OrLensOf{\Lens_1}{\Lens_2} \OfType \Regex_1 | \RegexAlt_1 \Leftrightarrow \Regex_2 | \RegexAlt_2
    }

\iffull
    \inferrule[]%\ComposeLensRule{}
    {
      \Lens_1 \OfType \Regex_1 \Leftrightarrow \Regex_2\\
      \Lens_2 \OfType \Regex_2 \Leftrightarrow \Regex_3\\
    }
    {
      \ComposeLensOf{\Lens_2}{\Lens_1} \OfType \Regex_1 \Leftrightarrow \Regex_3
    }
\fi

    \inferrule[]%\IdentityLensRule{}
    {
      \Regex \text{ is strongly unambiguous}
    }
    {
      \IdentityLensOf{\Regex} \OfType \Regex \Leftrightarrow \Regex
    }

    \inferrule[]%\RewriteRegexLensRule{}
    {
      \Lens \OfType \Regex_1 \Leftrightarrow \Regex_2\\
      \Regex_1 \DefinitionalEquiv \Regex_1'\\
      \Regex_2 \DefinitionalEquiv \Regex_2'
    }
    {
      \Lens \OfType \Regex_1' \Leftrightarrow \Regex_2'
    }
  \end{mathpar}

  \caption{Lens Typing Rules \iffull\else (except $\mathit{concat}$ and $;$) \fi}
  \label{fig:lens-typing}
\end{figure}


A typing judgement of lenses is of the form $\Lens \OfType \Regex
\Leftrightarrow \RegexAlt$, which 
means that $\Lens$ bijectively maps between
$\LanguageOf{\Regex}$ and $\LanguageOf{\RegexAlt}$.  The typing relation is given in
Figure~\ref{fig:lens-typing}.  Many of the typing derivations require side
conditions about
unambiguity.  These side conditions guarantee that the semantics of the language
create a bijective function.  For example, if $\Lens_1 \OfType \Regex_1
\Leftrightarrow \RegexAlt_1$, and $\Lens_2 \OfType \Regex_2 \Leftrightarrow
\RegexAlt_2$, and $\Regex_1$ is not unambiguously concatenable with $\Regex_2$,
then there would exist $\String_1,\StringAlt_1\in\LanguageOf{\Regex_1}$, and
$\String_2,\StringAlt_2\in\LanguageOf{\Regex_2}$ where
$\String_1\Concat\String_2 = \StringAlt_1\Concat\StringAlt_2$, but $\String_1
\neq \StringAlt_1$, and $\String_2 \neq \StringAlt_2$.  The lens
$\ConcatLensOf{\Lens_1}{\Lens_2}$ would no longer necessarily act as a function
when applied from left to right, as
$\Lens_1$ could be applied to both $\String_1$ and to $\String_2$.

For $\IdentityLensOf{\Regex}$, we require the lens being applied to be strongly
unambiguous.  This unambiguity allows the identity lens to merely be syntactic sugar for
creating the identity lens from other lenses.\footnote{In practice, we allow regular
expressions that aren't strongly unambiguous to appear in $\IdentityLensOf{\Regex}$, provided that they are expressed as a user defined regular expression.
We elide such user-defined regular expression information
from the theory for the sake of simplicity.}  This requirement does not, however, reduce expressiveness, as any regular
expression is equivalent to a strongly unambiguous regular
expression~\cite{unambigregex}.

The last rule in Figure~\ref{fig:lens-typing} is a subsumption rule
that lets us consider a lens
$\Lens \OfType \Regex_1 \Leftrightarrow \Regex_2$ to have type
$\Regex_1' \Leftrightarrow \Regex_2'$ so long as
$\Regex_1 \DefinitionalEquiv \Regex_1$ and
$\Regex_2 \DefinitionalEquiv \Regex_2'$.  Ideally, this rule would use
the full power of the Conway axiomatization $\equiv$, since that
theory is complete for regular-expression equivalence.  However, for
the purposes of our synthesis algorithm we use a finer, but more
tractable notion of equivalence $\DefinitionalEquiv \subseteq \equiv$,
as we next explain.  We have not found this restriction to be limit
the expressivity of lenses in practice.

\SUBSECTION{Definitional Equivalence and Rewriting}

\saz{It could be that this discussion belongs after the example and
  closer to the definition of DNF lenses. In that case, we might want
  to use $\equiv$ in Figure~\ref{fig:lens-typing}.}
Type-directed synthesis seeks to construct a lens by searching for a
well-formed typing derivation using the rules in Figure~\ref{fig:lens-typing}.
The inputs to the algorithm include the intended source and target
regular expression type, along with some examples, and search proceeds
bottom up.  

Both composition and subsumption present obstacles 
since they each require a bottom-up search procedure to \textit{guess} an
arbitrary regular expression ($\Regex_2$ of the composition rule or
$\Regex_1$ and $\Regex_2$ of the subsumption rule).  Since there are,
in general, an infinite number of possible choices for these guesses,
na\"{i}ve enumeration is hopeless.
Our synthesis algorithm  solves the first problem by eliminating
composition altogether; instead it works with regular expressions in
disjunctive normal form (DNF lenses are described in detail in
Section~\ref{sec:dnf}).  Handling subsumption is more subtle.

One could try to search the space of regular expressions equivalent to
$\Regex$ by turning the Conway axioms into (undirected) rewrite rules
and then trying all possible combinations of rewrites.  Doing so would
be problematic because the Conway axiomatization itself is both highly
nondeterministic and infinitely branching (due to the choice of $n$ in
the dyclicity axiom).  Furthermore, since we have chosen to eliminate
composition by using DNF lenses, we only want to find equivalent
regular expressions that are themselves expressible as DNFs.  Clearly,
unfettered use of rewrites based on Conway's axioms will not satisfy
this latter property. 

We have shown \saz{Anders: did we prove that these two properties are
  sufficient?}  that two properties are sufficient to ensure that any
equational theory of regular expressions implemented via rewrite rules $\to$
is compatible with our lens synthesis strategy.  First, 
the rewrite system should be \textit{confluent}\bcp{spell out}.  Second,  whenever $\Lens \OfType{} \Regex \Leftrightarrow \RegexAlt$ and 
$\Regex \to \Regex'$, there should exist $\RegexAlt'$ and  $\Lens'$ such
that $\RegexAlt \to \RegexAlt'$ using the \textit{same} rewrite rule, 
$\Lens' \OfType{} \Regex' \Leftrightarrow \RegexAlt'$, and
$\SemanticsOf{\Lens} = \SemanticsOf{\Lens'}$.  We call this property \textit{mirroring}.

\saz{We might want to rename ``mirroring'' to ``simulating'' or
  something like that.}

%  There are a large number of rules that can be
% applied to some regular expressions,
% which makes the search space very wide (indeed infinite).

% Furthermore, we have found two important properties which are sufficient for a
% lens language to not require a composition operator.
% To not require a composition operator, it is important for the rewrite relation
% to be confluent\bcp{say why}.  \afm{If two lenses were composed together, and
%   in the typing of each of the sublenses, the central regular expression was
%   rewritten using non-confluent rewrites, there would be no way to build up a
%   new lens that did not use composition, but still had the same end type, as
%   there would be no way to combine the derivations.}\bcp{This seems like an
%   instance of the confusion I mentioned above: The typing rules use the
%   equivalence relation, not the rewrite rules.}
% It is also important that rewrites can be \emph{mirrored}.
% If there is a lens $\Lens$ which maps between $\Regex$ and $\RegexAlt$,
% and if $\Regex$ rewrites to
% $\Regex'$, then $\RegexAlt$ can be rewritten in the same way to $\RegexAlt'$,
% such that there is
% a lens $\Lens'$ with the same semantics as $\Lens$, which maps between
% $\Regex'$ and $\RegexAlt'$. 

%  While \afm{the rewrite rules corresponding to both
%   the forward and the backward directions of each equivalence of }Conway's
% axioms are confluent \afm{as the reverse rewrite can always be
%   taken}, they don't
% satisfy the second property\bcp{say why not}.  Given a lens between $A$ and $C$,
% There are lenses between
% $\StarOf{(\StarOf{A}\Concat B)}\Concat\StarOf{A}$ and
% $\StarOf{(\StarOf{A}\Concat B)}\Concat\StarOf{C}$, but
% $\StarOf{(\StarOf{A}\Concat B)}\Concat\StarOf{A}$ can be rewritten to
% $\StarOf{(A \Or B)}$, whereas there's no analogous transformation for
% $\StarOf{(\StarOf{A}\Concat B)}\Concat\StarOf{C}$.
% Furthermore, removing the rewrites that cannot be mirrored makes\bcp{say why}
% the rewrites no longer confluent \afm{as the approach of taking the reverse
%   rewrite can no longer be used, and some of the transformations alter the
%   structure in such different ways that they cannot be brought back together}!
% \bcp{...Or complete, I suppose.}  

% Because of these issues, instead of looking through all regular expressions
% that are
% language equivalence, we can search through regular expressions that are
% equivalent in other ways.  In particular,
% we are interested in equivalence rules that are \emph{finer} than Conway's,
% to maintain the invariant that
% equivalent regular expressions have the same language.  If we did not restrict
% ourselves to finer equivalence relations, then there would be some regular
% expression equivalent to another who both had different languages!  If a type
% rewrite rule was done based on such an equivalence, then we would break the
% invariant that a lens maps between the languages of the regular expressions of
% the type.

For our purposes, we take the \textit{definitional equivalence rules} $\DefinitionalEquiv$ to
 be the semiring axioms, plus two ``unrolling'' rules that
 replace the Conway axioms \SumstarRule{}, \ProductstarRule{}, \StarstarRule{}, and
 \DicyclicityRule{}:
\begin{center}
\begin{tabular}{@{}r@{\hspace{1em}}c@{\hspace{1em}}l@{\hspace{1em}}r@{}}
  \StarOf{\Regex{}} & $\DefinitionalEquiv$ & \RegexOr{\EmptyString{}}{(\RegexConcat{\Regex{}}{\StarOf{{\Regex{}}}})} & \UnrollstarLeftRule{} \\
  \StarOf{\Regex{}} & $\DefinitionalEquiv$ & \RegexOr{\EmptyString{}}{(\RegexConcat{\StarOf{{\Regex{}}}}{\Regex{}})} & \UnrollstarRightRule{} 
\end{tabular}
\end{center}

The corresponding rewriting relation, which orients these rules from
left to right is both confluent and mirroring.  \saz{What does the
  rewrite relation do on the semiring axioms?}   \saz{Can we state
  this as a lemma?}

This choice of definitional equivalence rules is the coarsest subset of the
regular expression equivalence rules we could find that still is confluent
and can be mirrored.  We have not been able to prove that it is the coarsest
such relation, but it is sufficient to cover all of the test cases that
appeared in our experiments (see \S\ref{evaluation}).


% In this subset, the full generality of \ProductstarRule{} is not present,
% \DicyclicityRule{} is not present, \StarstarRule{} is not present,
% and \SumstarRule{} is not present.  \StarstarRule{} is a rule that introduces
% ambiguity, so removing it no longer allows ambiguity to be introduced.
% The removal of \SumstarRule{} no longer allows for different choices of an
% interation to be grouped by when they occur.  \ProductstarRule{} is similar to
% \UnrollstarLeftRule{} and \UnrollstarRightRule, though different parts of a
% regular expression can be unrolled
% on different sides of the star, altering the ordering of the regular expression
% under the star.
% Removing \DicyclicityRule{} removes the ability to split the repetition of the
% star into a quotiented part, and a remainder.

% The primary difference between the regular expression equivalence rules and the
% definitional equivalence rules is that the regular expression equivalence
% rules allow for breaking up parts of the regular expression under a star by
% grouping together different parts of the repetition, whereas the definitional
% equivalence rules breaks parts of a regular expression under a star up only by
% how many times the already defined repetition occurs.

% end background

% begin extended-example
\section{Lens Synthesis by Example}

Recall the previous example of synthesizing a lens between \CF{BibTex} and
\CF{EndNote}, specified in Figure~\ref{fig:bibend-spec}.  Synthesizing a lens
between \CF{BibTex} and \CF{EndNote} is done in three steps.
\textbf{Step 1:
  Inlining Definitions} uses some built in deductive techniques to infer when
user defined regular expressions must be replaced by their definitions.
\textbf{Step 2: Traversing Equivalences} searches through various equivalences
of the regular expression types to find different representations of the types.
Finally, \textbf{Step 3: Creating Lenses} applies type directed synthesis to the
regular expression types to create the lenses.

\paragraph*{Step 1:  Inlining Definitions.}

\begin{figure}
  \Tree[.\textcolor{dkred}{\sout{\CF{BibTex}}}
  [.\textcolor{dkred}{\sout{\CF{BNames}}}
  \CF{Name}
  [.\CF{Names}
  \CF{Name} ]]]
  \Tree[.\textcolor{dkred}{\sout{\CF{EndNote}}}
  [.\textcolor{dkred}{\sout{\CF{ENames}}}
  \CF{Name}
  [.\CF{Names}
  \CF{Name} ]]]
  \caption{
    Trees of user defined regular expressions,
    with those that must be replaced by their definitions crossed out.
    \bcp{Suggest cutting this figure.}
  }
  \label{fig:expanded-defs}
\end{figure}

There is no lens that goes between \CF{BibTex} and \CF{EndNote}, so one of them must
be expanded.
Indeed, both of them must be expanded, as \CF{BibTex} will never be able to be
the source of any lens in this problem, nor will \CF{End} be able to be the
target.
This process can be generalized for the sub-expressions of \CF{BibTex} and \CF{EndNote},  
If any user defined data type does not exist in the possible types of the
other side, it must be expanded, shown in Figure~\ref{fig:expanded-defs}.  We do
not inline all definitions, as doing so in more complicated data formats can
create huge regular expressions.

\begin{figure}
\begin{lstlisting}[mathescape=true,columns=fixed]
BibTex':
  $\uline{\EmptyString}$  | ($\uline{\text{author=}}$ { Name $\uline{\text{,}}$ Name Names
       ($\uline{\text{ and }}$ (Name $\uline{\text{, }}$ Name Names))* $\uline{\text{\},}}$)

EndNote':
  ($\uline{\text{\%A }}$ (Name Names $\uline{\text{ }}$ Name) $\uline{\text{\\n}}$)*

DNFBib':
  $\uline{\EmptyString}$
  | $\uline{\text{author=\{}}$ Name $\uline{\text{, }}$ Name $\uline{\EmptyString}$ Names $\uline{\EmptyString}$
    ($\uline{\text{ and }}$ Name $\uline{\text{, }}$ Name $\uline{\EmptyString}$ Names $\uline{\EmptyString}$)* $\uline{\text{\},}}$

DNFEnd':
  $\uline{\EmptyString}$ ($\uline{\text{\%A }}$ Name $\uline{\EmptyString}$ Names $\uline{\text{ }}$ Name $\uline{\text{\\n}}$)* $\uline{\EmptyString}$

DNFEndUnroll:
  $\uline{\EmptyString}$
  | $\uline{\text{\%A }}$ Name $\uline{\EmptyString}$ Names $\uline{\text{ }}$ Name $\uline{\text{\\n}}$
    ($\uline{\text{\%A }}$ Name $\uline{\EmptyString}$ Names $\uline{\text{ }}$ Name $\uline{\text{\\n}}$)* $\uline{\EmptyString}$

DNFEndReplacement:
  ($\uline{\text{\%A }}$ Name $\uline{\EmptyString}$ ($\uline{\text{ }}$ Name)* $\uline{\text{ }}$ Name $\uline{\text{\\n}}$)* $\uline{\EmptyString}$
\end{lstlisting}
  \label{fig:examples-expanded}
  \caption{
    \CF{BibTex} and \CF{EndNotes} with various transformations performed.
\bcp{All the double quotes make the examples quite hard to read.  Could we
  simplify the formats to eliminate them, for purposes of this
  example?}\saz{I can't interpet the syntax in this figure.  Why not
  keep string constants in tt font?}\bcp{I think my suggestion pushed us in
  the wrong direction: quotes (maybe single quotes) around the literal
  strings in the definitions
  would be much easier to read than all the underlining.}
  }
\end{figure}
After completing these necessary expansions, the problem becomes synthesizing a
lens between the regular expressions \CF{BibTex'} and \CF{EndNote'} shown in
Figure~\ref{fig:examples-expanded}.

\paragraph*{Step 2:  Traversing Equivalences.}

A basic type-directed synthesis approach from here will quickly fail.
\CF{BibTex'} is of the form $\Regex_1\Or\Regex_2$, where \CF{EndNote'} is of the form
$\StarOf{\Regex'}$.

These issues can be handled by normalizing the regular expressions.
We put them in a form that normalizes away the equivalences involving
associativity, distributivity, and \EmptyString{}, shown in
Figure~\ref{fig:examples-expanded}

With those equivalences handled, one might think it is now possible to
synthesize the lens.
Unfortunately, we are still unable to perform any synthesis because the types
on the left and right are quite different, and the lens connectives require
similar types of the left and right.
For example, as \CF{DNFBib'} has an outer $\OrRegexType$, we know an $\OrLens$ lens must be
synthesized.
However, an $\OrLens$ lens requires an outer $\OrRegexType$ on both sides, and \CF{DNFEnd'} does
not have any outer $\OrRegexType$.

While, with normalization, certain equivalences have been handled, there are
still many equivalences that haven't been handled.
For example, the equivalences resulting from \StarRegexType{}s, like
$\StarOf{A}=\EmptyString \Or A\StarOf{A}$, have not been handled.
The equivalences resulting from the definitions of user defined regular
expressions have also not been handled. These can be applied to the star in
\CF{End'}, resulting in \CF{DNFEndUnroll} and \CF{DNFEndReplacement}, shown in
Figure~\ref{fig:examples-expanded}.

However, now a single problem of finding a lens between regular expression has
become two problems!  Furthermore, trying to find the lenses between either of these
two regular expressions could create even more problems.  Because of this
problem explosion, it is
important to find a way to find which subproblem should be approached next.
Finding which subproblem should be approached next can be solved by using a
priority queue, where the
elements in the queue are regular expression specifications.  The priority of
each specification is a combination of how many equivalence rewrites have been
applied,
and how different the two regular expressions in the specification are.  This
priority calculation is described in greater detail in
\S\ref{implementation}.
\CF{DNFEndUnroll} and \CF{DNFBib'} are very similar, in that they have the same
number of instances of \CF{Name} and \CF{Names}.  However, \CF{DNFEndReplacement} is
very different, with a different number of \CF{Name}, \CF{Names}, and a
different number of \StarRegexType{}s.  Because of this large difference, the
specification of \CF{DNFBib' <=> DNFEndUnroll} would get popped, instead of the
specification of \CF{DNFBib' <=> DNFEndReplacement}.

\paragraph*{Step 3: Creating Lenses.}
Because the regular expressions of  \CF{DNFBib'} and \CF{DNFEndUnroll} are so
similar, type-directed synthesis applies.
Following the types, the outer \CF{""}s
would get mapped to each other, and the sides of the disjunct with
\StarRegexType{}s
would get mapped to each other.  Within that side, \CF{Name} would map to
\CF{Name}, \CF{Names} would map to \CF{Names} and the \StarRegexType{}s would map to the
\StarRegexType{}s.

%\begin{figure}
%  \label{fig:lens-synth-ex}
%  \centering
%  \SmallCF{DNFBib' <=> DNFEndUnroll}
%  \begin{tikzpicture}
%    \matrix (m)
%    [matrix of nodes,
%    row sep=1em,
%    column sep=4em,
%    minimum width=2em]
%    {
%      \SmallCF{""} & $\Or$ & \SmallCF{BibSequence2} \\
%      \SmallCF{""} & $\Or$ & \SmallCF{EndSequence2} \\
%    };
%    \path[<->]
%    (m-1-1) edge node [left] {} (m-2-1);
%    \path[<->]
%    (m-1-3) edge node [right] {\SmallCF{lsequence}} (m-2-3);
%  \end{tikzpicture}
%
%  \SmallCF{lsequence : BibSequence2 <=> EndSequence2}
%  
%  \begin{tikzpicture}
%    \matrix (m) [matrix of nodes, row sep=1em, column sep=-.75em]
%    {
%      \SmallCF{"author=\{"} & \Concat{}\SmallCF{Name}\Concat{} & \SmallCF{", "} &
%      \Concat{}\SmallCF{Name}\Concat{} & \SmallCF{""} & \Concat{}\SmallCF{Names}\Concat{} & \SmallCF{""}
%      & \Concat{}\SmallCF{BibStar*}\Concat{} & \SmallCF{"\},"}\\
%      \SmallCF{"\%A "} & \Concat{}\SmallCF{Name}\Concat{} & \SmallCF{""} &
%      \Concat{}\SmallCF{Names}\Concat{} & \SmallCF{" "} & \Concat{}\SmallCF{Name}\Concat{} & \SmallCF{""}
%      & \Concat{}\SmallCF{EndStar*}\Concat{} & \SmallCF{""}\\
%    };
%    \path[<->]
%    (m-1-2) edge node [right] {} (m-2-6);
%    \path[<->]
%    (m-1-4) edge node [left] {} (m-2-2);
%    \path[<->]
%    (m-1-6) edge node [left] {} (m-2-4);
%    \path[<->]
%    (m-1-8) edge node [right] {\SmallCF{lstar}} (m-2-8);
%  \end{tikzpicture}
%
%  \SmallCF{lstar : BibStar <=> EndStar}
%  \begin{tikzpicture}
%    \matrix (m) [matrix of nodes, row sep=1em, column sep=-.75em]
%    {
%      \SmallCF{" and "} & \Concat{}\SmallCF{Name}\Concat{} & \SmallCF{", "} &
%      \Concat{}\SmallCF{Name}\Concat{} & \SmallCF{""} & \Concat{}\SmallCF{Names}\Concat{} &
%      \SmallCF{""}\\
%      \SmallCF{"\%A "} & \Concat{}\SmallCF{Name}\Concat{} & \SmallCF{""} &
%      \Concat{}\SmallCF{Names}\Concat{} & \SmallCF{" "} & \Concat{}\SmallCF{Name}\Concat{}
%      & \SmallCF{""}\\
%    };
%    \path[<->]
%    (m-1-2) edge node [right] {} (m-2-6);
%    \path[<->]
%    (m-1-4) edge node [left] {} (m-2-2);
%    \path[<->]
%    (m-1-6) edge node [left] {} (m-2-4);
%  \end{tikzpicture}
%  \caption{Synthesized Lens Mappings}
%\end{figure}

Unfortunately, in mapping like terms together, some ambiguity is introduced.
There are two
instances of \CF{Name} present outside a star, so which one should get mapped to
which?  The basic solution would be to map the first to the first, and the
second to the second.  This solution is not correct, however, as the generated
lens for
this mapping will not match the examples.  We can determine which maps to which, as they
must each match the same substrings.  The first \CF{Name} in \CF{DNFBib'}
matches \CF{"Conway"} and the second matches \CF{"John"}.  The first \CF{Name}
in \CF{DNFEndUnroll} matches \CF{"John"} and the second matches \CF{"Conway"}.
This parsing information means that the first \CF{Name} in \CF{DNFBib'} must map to the second
\CF{Name} in \CF{DNFEndUnroll}, and vice-versa.
%Applying these mappings will generate a lens
%that satisfies the type and the examples, shown in Figure~\ref{fig:lens-synth-ex}.


% end extended-example

% begin formalisms

\section{DNF Regular Expressions}
\label{sec:dnfre}


The first important step in our synthesis algorithm is to convert
regular expression types into \emph{disjunctive normal form} (DNF).
A DNF regular expression is, intuitively, a regular expression with
all terms fully distributed, and with associativity information removed.
Distributing terms and removing associativity information creates a mutually
recursive data structure, consisting of the types of
DNF regular expressions (\DNFRegex{},\DNFRegexAlt{}), 
sequences (\Sequence{},\SequenceAlt{}), and atoms (\Atom, \AtomAlt).

\begin{center}
  \begin{tabular}{l@{\ }c@{\ }l@{\ }>{\itshape\/}r}
    % DNF_REGEX
    \Atom{},\AtomAlt{} & \GEq{} & \StarOf{\DNFRegex{}} & \StarAtomType{}\\
    \Sequence{},\SequenceAlt{} & \GEq{} &
                                                       $\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}$ & \MultiConcatSequenceType{} \\
    \DNFRegex{},\DNFRegexAlt{} & \GEq{} & $\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}$ & \MultiOrDNFRegexType{} 
  \end{tabular}
\end{center}

Intuitively, a DNF regular expression is an n-ary disjunction of
sequences.  A sequence alternates between concrete strings and
atoms.  Notice that it is straightforward to convert an abitrary series
of atoms and strings into this form:  If there are multiple atoms between
concrete strings, the atoms 
may be separated by empty strings, and if there are multiple concrete strings 
between atoms, the strings may be concatenated into a single string.
The shorthand $\SequenceOf{\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n}$
stands for
$\SequenceOf{\EmptyString;\Atom_1;\ldots;\Atom_n;\EmptyString}$, the sequence
with every string in the sequence is the empty string.
Notice also that a simple string with no atoms may be represented as
a sequence.
An atom is an iteration of DNF Regular expressions.
In our implementation, names of user-defined regular expressions
are atoms; we elide such definitions from our theoretical analysis.

Intuitions about DNF regular expressions may confirmed
by their semantics, which we give by defining the language (set of strings)
that each regular expression denotes:

\begin{trivlist}
\item 
%\begin{center}
  \begin{tabular}{@{\ }R@{\ }L}
    \LanguageOf{\StarOf{\DNFRegex}} \ =\  &
                                        \{\String_1\Concat\ldots\Concat\String_n
                                        \SuchThat \forall i \String_i\in\LanguageOf{\DNFRegex}\}\\
    \LanguageOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}}\ =\  & 
%\\
%\multicolumn{2}{L}{\ \ \ \ 
\{\String_0\Concat\StringAlt_1\cdots\StringAlt_n\Concat\String_n \SuchThat \StringAlt_i\in\LanguageOf{\Atom_i}\}
%}
\\
    \LanguageOf{\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}}\ =\  &
%\\
%\multicolumn{2}{L}{\ \ \ \ 
\{\String \SuchThat \String \in \LanguageOf{\Sequence_i} \text{and $i\in\RangeIncInc{1}{n}$}\}
%}
  \end{tabular}
%\end{center}
\end{trivlist}

%% A DNF regular expression is a list of sequences.
%% We use the balanced delimiters of $\DNFLeft$ and $\DNFRight$
%% to show that a list of sequences creates a DNF regular expression.
%% A DNF regular expression corresponds to a regular expression consisting of many
%% \OrRegexType{}s.  
%% This correspondence is mirrored in the semantics, as the language of a DNF
%% regular expression
%% is the union of the sequences it is composed of.  This unioning is very similar
%% to the unioning in the definition of the
%% language of an
%% \OrRegexType{} regular expression.

%% A sequence is a list of atoms, with strings surrounding each atom.
%% We use the balanced delimiters of $\SequenceLeft$ and $\SequenceRight$ to show
%% that a list of atoms and strings creates a sequence.
%% A sequence corresponds to a regular expression consisting
%% of many \ConcatRegexType{}s.
%% This correspondence is mirrored in the semantics, as the language of a sequence is a
%% concatenation of strings, where each string is either the string in the
%% sequence, or a string belonging to the language of the atom.  This concatenation
%% is very
%% similar to the concatenation in the definition of the language of
%% a \ConcatRegexType{} regular expression.
%% A sequence can be put into this form, where every atom is separated by a string,
%% because if two atoms are next to each other, $\EmptyString$ can be placed
%% between them.  If there are multiple strings between atoms, those strings can be
%% concatenated into a single string.
%% The shorthand $\SequenceOf{\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n}$
%% stands for
%% $\SequenceOf{\EmptyString;\Atom_1;\ldots;\Atom_n;\EmptyString}$, the sequence
%% with every string in the sequence is the empty string.

%% An atom is an iteration of DNF Regular expression.  Atoms correspond very
%% closely to regular expression \StarRegexType{}s.  This correspondence is mirrored in the
%% semantics, as the language of an atom is constructed in the exact same way as a
%% \StarRegexType{}.  The only difference between atoms and \StarRegexType{}s
%% is that the iteration in atoms
%% corresponds to the iteration of languages of DNF regular expressions, while the
%% iteration in \StarRegexType{}s corresponds to the iteration of languages of
%% regular expressions.  In the implementation, user defined regular expressions
%% are atoms as well, turning atoms into a sum type of user defined regular
%% expressions, and \StarAtomType{}s.

A sequence of strings and atoms is \textit{sequence unambiguously
  concatenable},
written $\SequenceUnambigConcatOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}$,
if, when $\String_i',\StringAlt_i'\in\LanguageOf{\Atom_i}$ for all $i$, then
$\String_0\String_1'\ldots\String_n'\String_n=
\String_0\StringAlt_1'\ldots\StringAlt_n'\String_n$
implies $\String_i'=\StringAlt_i'$ for all $i$.
%
A DNF regular expression $\Regex$ is \textit{unambiguously iterable},
written $\UnambigItOf{\Regex}$ if,
for all $n,m\in\Nats$ and for all strings
$\String_1,\ldots,\String_n,\StringAlt_1,\ldots,\StringAlt_m\in\LanguageOf{\Regex}$,
if
$\String_1\Concat\ldots\Concat\String_n=\StringAlt_1\Concat\ldots\Concat\StringAlt_m$
then $n=m$ and $\String_i=\StringAlt_i$ for all $i$.

\paragraph*{Expressivity of DNF Regular Expressions}

% fig:dnf-regex-functions
\begin{figure}
  \ConcatSequence{} \OfType{} \ArrowTypeOf{\SequenceType{}}{\ArrowTypeOf{\SequenceType{}}{\SequenceType{}}}\\
  $\ConcatSequenceOf{[\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n]}{[\StringAlt_0\SequenceSep\AtomAlt_1\SequenceSep\ldots\SequenceSep\AtomAlt_m\SequenceSep\StringAlt_m]}=$\\
  \hspace*{2ex}$[\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n\Concat\StringAlt_0\SequenceSep\AtomAlt_1\SequenceSep\ldots\SequenceSep\AtomAlt_m\SequenceSep\StringAlt_m]$\\
  \\
  \ConcatDNF{} \OfType{} \ArrowTypeOf{\DNFRegexType{}}{\ArrowTypeOf{\DNFRegexType{}}{\DNFRegexType{}}}\\
  $\ConcatDNFOf{\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}}{\DNFOf{\SequenceAlt_1\DNFSep\ldots\DNFSep\SequenceAlt_m}}=$
\vspace*{-1.7ex}
  \[
    \begin{array}{rcccl}
      \DNFLeft & \ConcatSequenceOf{\Sequence_1}{\SequenceAlt_1}\DNFSep & \cdots
      & \ConcatSequenceOf{\Sequence_1}{\SequenceAlt_m}\DNFSep \\
      \cdots  & \ConcatSequenceOf{\Sequence_n}{\SequenceAlt_1}\DNFSep & \cdots & \ConcatSequenceOf{\Sequence_n}{\SequenceAlt_m} & \DNFRight
    \end{array}
  \]
  \\
  \OrDNF{} \OfType{}
  \ArrowTypeOf{\DNFRegexType{}}{\ArrowTypeOf{\DNFRegexType{}}{\DNFRegexType{}}
  }\\
  $\OrDNFOf{\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}}{\DNFOf{\SequenceAlt_1\DNFSep\ldots\DNFSep\SequenceAlt_m}}$=\\
  \hspace*{2ex}$\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n\DNFSep\SequenceAlt_1\DNFSep\ldots\DNFSep\SequenceAlt_m}$
  \\\\
  \AtomToDNF{} \OfType
  \ArrowTypeOf{\AtomType{}}{\DNFRegexType{}}\\
  $\AtomToDNFOf{\Atom} = \DNFOf{\SequenceOf{\EmptyString;\Atom;\EmptyString}}$
  \caption{DNF Regex Functions}
  \label{fig:dnf-regex-functions}
\end{figure}

Any regular expression may be converted into an equivalent DNF regular expression.  
To define the conversion function, we rely on several auxiliary functions defined in 
Figure~\ref{fig:dnf-regex-functions}.  Intuitively, $\DNFRegex{} \ConcatDNF \DNFRegex{}$ concatenates
two DNF regular expressions, producing a well-formed DNF regular expression as a result.
Similarly, $\DNFRegex{} \OrDNF{} \DNFRegex{}$ generates a new DNF regular expression representing the
union of two DNF regular expressions.  Finally, $\AtomToDNF{(\Atom)}$ converts a naked atom into a
well-formed DNF regular expression.
The conversion algorithm itself, written  \ToDNFRegex{\Regex}, is defined below.
\[
  \begin{array}{rcl}
    \ToDNFRegexOf{\String} & = & \DNFOf{\SequenceOf{\String}}\\
    \ToDNFRegexOf{\emptyset} & = & \DNFOf{}\\
    \ToDNFRegexOf{(\StarOf{\Regex})} & = & \AtomToDNFOf{\StarOf{(\ToDNFRegexOf{\Regex})}}\\
    \ToDNFRegexOf{(\RegexConcat{\Regex_1}{\Regex_2})} & = & \ToDNFRegexOf{\Regex_1} \ConcatDNF \ToDNFRegexOf{\Regex_2}\\
    \ToDNFRegexOf{(\RegexOr{\Regex_1}{\Regex_2})} & = & \ToDNFRegexOf{\Regex_1} \OrDNF \ToDNFRegexOf{\Regex_2}\\
  \end{array}
\]

%% Intuitively, the definition of $\ToDNFRegex$ states that the DNF regular
%% expression with no sequences
%% corresponds to the empty set.  A single sequence with only a string corresponds
%% to a \BaseRegexType{} regular expression string.
%% The stars of DNF regular expressions correspond to the stars
%% of atoms.  The function $\OrDNF$ corresponds to the regular expression
%% primitive \OrRegexType{}.  The function $\ConcatDNF$ corresponds to the regular
%% expression primitive \ConcatRegexType{}. 
\iffull
\noindent
We formalize the correspondence between regular expressions and
DNF regular expressions via the following theorem.
\fi

\begin{restatable}[Translation Soundness]{theorem}{dnfrc}
  \label{thm:completeness-dnf-lenses}
  For all regular expressions \Regex{},
  $\LanguageOf{\ToDNFRegexOf{\Regex}}=\LanguageOf{\Regex{}}$.
\end{restatable}

%% Furthermore, we can prove that DNF regular expressions are sound with respect to
%% regular expressions,
%% and that \ToDNFRegex{} is surjective, by providing a right inverse, $\ToRegex$.\\
%%   \begin{tabular}{r@{\ }c@{\ }l}
%%     $\ToRegexOf{(\StarOf{\DNFRegex})}$ & = & $\StarOf{(\ToRegexOf{\DNFRegex})}$\\
%%     $\ToRegexOf{\SequenceOf{\String_0}}$ & = & $\String_0$\\
%%     $\ToRegexOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
%%     \SequenceSep\Atom_n\SequenceSep\String_n}} $ & = & $
%%     \ToRegexOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
%%     \ldots\SequenceSep\Atom_{n-1}\SequenceSep\String_{n-1}}}$\\
%%                                        & &
%%     $\Concat \ToRegexOf{\Atom_n} \Concat \String_{n+1}$\\
%%     $\ToRegexOf{\DNFOf{}} $ & = & $\emptyset$\\
%%     $\ToRegexOf{\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}} $ & = &
%%     $(\ToRegexOf{\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{n-1}}})
%%     \,\Or\, (\ToRegexOf{\Sequence_n})$
%%   \end{tabular}

%% This function provides a way to find a regular expression which corresponds to a given
%% DNF regular expression.  We formalize this correspondence with the theorem
%% below.

%% \begin{restatable}[Soundness of DNF Regexs]{theorem}{dnfrs}
%%   \label{thm:dnfrs}
%%   $\ToDNFRegexOf{\,\ToRegexOf{\DNFRegex}} = \DNFRegex$
%% \end{restatable}

% fig:dnf-regex-rewrites
\begin{figure*}
  \begin{mathpar}
    \inferrule[\AtomUnrollstarLeftRule{}]
    {
    }
    {
      \StarOf{\DNFRegex}\RewriteAtom
      \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}{(\ConcatDNFOf{\DNFRegex}{\AtomToDNFOf{\StarOf{\DNFRegex}}})}
    }

    \inferrule[\AtomUnrollstarRightRule{}]
    {
    }
    {
      \StarOf{\DNFRegex}\RewriteAtom
      \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}{(\ConcatDNFOf{\AtomToDNFOf{\StarOf{\DNFRegex}}}{\DNFRegex})}
    }

    \inferrule[\AtomStructuralRewriteRule{}]
    {
      \DNFRegex \Rewrite \DNFRegex'
    }
    {
      \StarOf{\DNFRegex} \RewriteAtom \DNFOf{\SequenceOf{\StarOf{\DNFRegex'}}}
    }

    \inferrule[\DNFStructuralRewriteRule{}]
    {
      \Atom_j \RewriteAtom \DNFRegex
    }
    {
      \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
      \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}
      \ConcatDNF \AtomToDNFOf{\Atom_j} \ConcatDNF
      \DNFOf{\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m}}
      \OrDNF \DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n}\Rewrite\\
      \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
      \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}\ConcatDNF\DNFRegex\ConcatDNF\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m} \OrDNF
      \DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n}
    }
    
    % \inferrule[\ReflexivityRule{}]
    % {
    % }
    % {
    %   \DNFRegex \StarOf{\Rewrite} \DNFRegex
    % }

    % \inferrule[\BaseRule{}]
    % {
    %   \DNFRegex \Rewrite \DNFRegexAlt
    % }
    % {
    %   \DNFRegex \StarOf{\Rewrite} \DNFRegexAlt
    % }

    % \inferrule[\TransitivityRule{}]
    % {
    %   \DNFRegex_1 \StarOf{\Rewrite} \DNFRegex_2\\
    %   \DNFRegex_2 \StarOf{\Rewrite} \DNFRegex_3
    % }
    % {
    %   \DNFRegex_1 \StarOf{\Rewrite} \DNFRegex_3
    % }

  \end{mathpar}
  \caption{DNF Regex Rewrite Rules.\saz{Dropped the star
      relation. this figure still needs to be moved earlier}}
  \label{fig:dnf-regex-rewrites}
\end{figure*}


\paragraph*{DNF Regular Expression Rewrites}

There are many fewer DNF regular expressions than regular expressions, but there
still remain pairs of DNF regular expressions that while syntactically different,
are semantically identical.  
%% In order to search the space of equivalent DNF 
%% In our synthesis algorithm we need to allow for a rewrite system on DNF regular
%% expressions to search through the equivalences.
%% Using the star equivalences, the synthesis algorithm applies rewrites
%% to the stars in a DNF
%% regular expression for type-directed synthesis to eventually be applied to the
%% rewritten regular expressions.  These rewrites are the ones used in
%% \textbf{Step 2: Traversing Equivalences}.
Figure~\ref{fig:dnf-regex-rewrites} defines a collection of rewrite rules on DNF regular expressions
designed to search the space of equivalent DNF REs.  We write $\StarOf{\Rewrite}$ for
    the reflexive, transitive closure of $\Rewrite{}$.
This directed rewrite system help us limit
the search space more than the non-directional equivalence $\equiv_d$ relation.
However, because the rewrite rules are confluent, we will show that it is just as powerful as the
$\equiv_d$ relation.
 
%% Intuitively, applications of these rewrite rules correspond to traversing
%% through equivalences of the DNF regular expressions.
%% However, by having rewrite rules, instead of a rule similar to
%% \RewriteRegexLensRule{}, instead of having to try all equivalences, we are able
%% to limit the fan-out and only traverse a few.

These rewrite rules present ways for atoms to be rewritten to DNF regular
expressions, with rules like \AtomUnrollstarLeftRule{} and
\AtomUnrollstarRightRule{}.
These rewrite rules are similar to the equivalence rules for DNF regular
expressions, \UnrollstarLeftRule{} and \UnrollstarRightRule{}.
With the atoms rewritten to DNF regular expressions, \DNFStructuralRewriteRule{}
provides a way to combine the rewritten atom into the broader regular
expression\afm{, through singling out the atom, expanding it, and recombining it into
the regular expression}.
Similarly, if a DNF regular expression is rewritten to a different
DNF regular expression, the rewrite rule \AtomStructuralRewriteRule{} can extend
this rewrite to rewriting atoms containing those regular expressions.
The symbol $\StarOf{\Rewrite}$ is used to denote the transitive and reflexive
closure of $\Rewrite$.  \afm{These correspond closely with the definitional
equivalence rules.  Many of the semiring axioms are normalized in the regular
expression into this form, and these rewrites correspond to applications of the
rewrites associated with \StarRegexType{}.  This does not handle \OrRegexType{}
commutativity -- this commutativity is handled in the typing of the DNF lenses,
not in the rewrite rules, to make the search space narrower.}

\bcp{IMHO this section is needs some expansion---the rules are pretty
  complicated, and they need better explanation.}

\BCP{Also, a technical point: Don't we need to show that these rules
  correspond to (an oriented version of) the $\equiv_d$ relation?  We use
  the latter in the example section, but our implementation uses the
  former.  (I guess a proof of this must be buried in the proofs of 6.1 and
  6.2 (right?).  But it needs to be called out explicitly.)} 

\section{DNF Lenses}
\label{sec:dnf}

% fig:dnf-lens-typing
\begin{figure}
  \centering
  \begin{mathpar}
    \inferrule[\AtomLensRule{}]
    {
      \DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt\\
      \UnambigItOf{\DNFRegex}\\
      \UnambigItOf{\DNFRegexAlt}
    }
    {
      \IterateLensOf{\DNFLens} \OfRewritelessType \StarOf{\DNFRegex}
      \Leftrightarrow \StarOf{\DNFRegexAlt}
    }

    \inferrule[\SequenceLensRule{}]
    {
      \AtomLens_1 \OfRewritelessType \Atom_1 \Leftrightarrow \AtomAlt_1\\
      \ldots\\
      \AtomLens_n \OfRewritelessType \Atom_n \Leftrightarrow \AtomAlt_n\\
      \sigma \in \PermutationSetOf{n}\\
      \UnambigConcat\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}\\
      \UnambigConcat\SequenceOf{\StringAlt_0\SequenceSep\AtomAlt_{\sigma(1)}\SequenceSep\ldots\SequenceSep\AtomAlt_{\sigma(n)}\SequenceSep\StringAlt_n}
    }
    {
      (\SequenceLensOf{(\String_0,\StringAlt_0)\SequenceLensSep\AtomLens_1\SequenceLensSep\ldots\SequenceLensSep\AtomLens_n\SequenceLensSep(\String_n,\StringAlt_n)},\sigma) \OfRewritelessType\\
      \SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}\Leftrightarrow
      \SequenceOf{\StringAlt_0\SequenceSep\AtomAlt_{\sigma(1)}\SequenceSep\ldots\SequenceSep\AtomAlt_{\sigma(n)}\SequenceSep\StringAlt_n}
    }

    \inferrule[\DNFLensRule{}]
    {
      \SequenceLens_1 \OfRewritelessType \Sequence_1 \Leftrightarrow \SequenceAlt_1\\
      \ldots\\
      \SequenceLens_n \OfRewritelessType \Sequence_n \Leftrightarrow \SequenceAlt_n\\\\
      \sigma \in \PermutationSetOf{n}\\
      i \neq j \Rightarrow \LanguageOf{\Sequence_{i}} \cap \LanguageOf{\Sequence_{j}}=\emptyset\\
      i \neq j \Rightarrow \LanguageOf{\SequenceAlt_{i}} \cap \LanguageOf{\SequenceAlt_{j}}=\emptyset\\
    }
    {
      (\DNFLensOf{\SequenceLens_1\DNFLensSep\ldots\DNFLensSep\SequenceLens_n},\sigma) \OfRewritelessType\\
      \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}
      \Leftrightarrow \DNFOf{\SequenceAlt_{\sigma(1)}\DNFSep\ldots\DNFSep\SequenceAlt_{\sigma(n)}}
    }

    \inferrule[\RewriteDNFRegexLensRule{}]
    {
      \DNFLens \OfRewritelessType \MapsBetweenTypeOf{\DNFRegex}{\DNFRegexAlt}\\
      \DNFRegex' \Rewrite \DNFRegex\\
      \DNFRegexAlt' \Rewrite \DNFRegexAlt
    }
    {
      \DNFLens \OfType \MapsBetweenTypeOf{\DNFRegex'}{\DNFRegexAlt'}
    }

  \end{mathpar}
  \caption{DNF Lens Typing\bcp{We should drop the rule names, as we did before}}
  \label{fig:dnf-lens-typing}
\end{figure}

We can now define a syntax for DNF lenses between DNF regular
expressions.  
\begin{center}
  \begin{tabular}{@{}l@{\ }l@{\ }c@{}l@{\ }>{\itshape\/}r@{}}
    % REGEX
    (Atom Lenses) &\AtomLens{} & \GEq{} & $\IterateLensOf{\DNFLens}$ & Iterate\\
    (Sequence &\SequenceLens{} & \GEq{} &
                                                  $(\SequenceLensOf{(\String_0,\StringAlt_0)\SequenceLensSep\AtomLens_1\SequenceLensSep\ldots$, &\\
    Lenses)       & & & $\SequenceLensSep\AtomLens_n\SequenceLensSep(\String_n,\StringAlt_n)},\sigma \in S_n)$ & Sequence\SubN{}\\
    (DNF Lenses)& \DNFLens{} & \GEq{} & $(\DNFLensOf{\SequenceLens_1\DNFLensSep\ldots\DNFLensSep\SequenceLens_n}$,\\
                  & & & $\sigma \in S_n)$ & DNF\SubN{}\\
  \end{tabular}
\end{center}

DNF lenses are defined via 3 mutually recursive data structures, DNF lenses, sequence lenses,
and atom lenses.  Like lenses, DNF Lenses have denotational semantics to
express bijective mappings.
\begin{trivlist}
\item 
  $\SemanticsOf{\IterateLensOf{\DNFLens}}$=\\
  \hspace*{3em}$\SetOf{(\String_1\Concat\ldots\Concat\String_n,
    \StringAlt_1\Concat\ldots\Concat\StringAlt_n)\SuchThat
    n\in\Nats\BooleanAnd(\String_i,\StringAlt_i)\in\SemanticsOf{\DNFLens}}$\\
  $\SemanticsOf{(\SequenceLensOf{(\String_0,\StringAlt_0)\SequenceLensSep
      \AtomLens_1\SequenceLensSep\ldots\SequenceLensSep\AtomLens_n
      \SequenceLensSep(\String_n,\StringAlt_n)},\Permutation)}=$\\
  \hspace*{3em}$\SetOf{
    (\String_0\String_1'\ldots\String_n'\String_n,
    \StringAlt_0\StringAlt_{\Permutation(1)}'\ldots
    \StringAlt_{\Permutation(n)}'\StringAlt_n)\SuchThat
    (\String_i',\StringAlt_i')\in\SemanticsOf{\AtomLens_i}}$\\
  $\SemanticsOf{(\DNFLensOf{\SequenceLens_1\DNFLensSep\ldots\DNFLensSep
      \SequenceLens_n},\Permutation)}=$\\
  \hspace*{3em}$\SetOf{(\String,\StringAlt)\SuchThat
    (\String,\StringAlt)\in\SequenceLens_i\text{ for some $i$}}$
\end{trivlist}
A DNF lens is a list of sequence lenses.
We use the balanced delimiters of
$\DNFLensLeft$ and $\DNFLensRight$ to show that a list of sequence lenses
creates a DNF lens.
A DNF lens corresponds
to a lens consisting of many \OrLens{}s.  This correspondence is mirrored in the semantics, as the
bijection determined by a DNF lens corresponds to applying one of many sequence
lenses, just as the bijection determined by an \OrLens{} is determined through
applying one of two lenses.  Furthermore, if a DNF lens is defined on $n$,
elements, then a permutation on $n$ elements, $\sigma$, is also provided.  This
permutation term
does nothing for the semantics, but is used for typechecking, and eliminates the
need to have a rewrite rule corresponding to the commutativity of union.

A sequence lens is a list of atom lenses and pairs of strings.
We use the balanced delimiters of $\SequenceLensLeft$ and 
$\SequenceLensRight$ to show that a list of atom lenses and pairs of strings is
a sequence lens.
A sequence lens corresponds to a lens consisting of many \ConcatLens{}s,
\SwapLens{}s, and \ConstLens{}s.
Sequence lenses bear similarities to \ConcatLens{} and
\SwapLens{}, as they both are made for handling concatenated strings.  The
pairs of strings within a sequence lens correspond to the pairs of strings on
\ConstLens{}s.
To handle the reordering of lenses that comes from
\SwapLens{}, sequence lenses with $n$ atom lenses come with $\sigma$, a
permutation on $n$ elements.  This permutation permutes the output strings of
the atom lenses.

An atom lens is an iteration of a DNF lens.  Atom lenses correspond very closely to
the $\IterateLens$ present in lenses.  However, atom lens $\IterateLens$s
iterate DNF lenses,
whereas the $\IterateLens$ present in lenses iterate lenses.  In our
implementation, identity lenses which operate on user defined regular
expressions are also considered atom lenses.  Considering identities on
user defined regular expressions atom lenses makes atom lenses a sum type
in the implementation.

Similarly to the language of lenses, the typing of the lenses
correspond closely to the syntax for the lenses themselves.
The typing of these DNF lenses are defined in Figure~\ref{fig:dnf-lens-typing}.
The typing $\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$ means that
$\DNFLens$ maps bijectively between the languages of $\DNFRegex$ and
$\DNFRegexAlt$.  The typing $\DNFLens \OfRewritelessType \DNFRegex
\Leftrightarrow \DNFRegexAlt$ means that $\DNFLens$ maps bijectively between the
languages of $\DNFRegex$ and $\DNFRegexAlt$, and no rewrites were used in the
application of the typing.

\iffull
These DNF lenses only express bijections that are already expressible in the
language of lenses, and they can express everything expressible in the
language of lenses.
\fi

\begin{restatable}[Soundness of DNF Lenses]{theorem}{dnfls}
  \label{thm:dnfls}
  If there exists a derivation of $\DNFLens \OfType \MapsBetweenTypeOf{\DNFRegex}{\DNFRegexAlt}$,
  then there exists a derivation of $\Lens \OfType \MapsBetweenTypeOf{\Regex}{\RegexAlt}$ such that
  $\LanguageOf{\Regex}=\LanguageOf{\DNFRegex}$,
  $\LanguageOf{\RegexAlt}=\LanguageOf{\DNFRegexAlt}$, and
  $\SemanticsOf{\Lens}=\SemanticsOf{\DNFLens}$.
\end{restatable}

\begin{restatable}[Completeness of DNF Lenses]{theorem}{dnflc}
  \label{thm:dnflc}
  If there exists a derivation for $\Lens \OfType \Regex \Leftrightarrow
  \RegexAlt$,
  then there exists a derivation for
  $\DNFLens \OfType \ToDNFRegexOf{\Regex} \Leftrightarrow \ToDNFRegexOf{\RegexAlt}$
  such that $\SemanticsOf{\Lens}=\SemanticsOf{\DNFLens}$.
\end{restatable}

DNF lenses are much more suited to synthesis.
All rules except for \RewriteDNFRegexLensRule{} have a simple inductive
algorithm that comes from the type.  Furthermore, even
\RewriteDNFRegexLensRule{} can only be applied once at the end of the typing
derivation, and it is not computationally intensive to find what rewrites can
apply to a given DNF regular expression.
Furthermore, there is no composition operator, so
we have reduced the dimensions we are searching in from 3 to 2.  Before, given a
specification, multiple rules could be applicable, equivalent regular
expressions would have to be searched through, and regular expressions for
composition would need to be found.
For DNF lenses, only the correct rewrites for the regular expressions, and the
correct permutations for each rule application, must be found.
% end formalisms

% begin implementation
\section{Implementation}
\label{implementation}
We have implemented the lens synthesis algorithm in $n$\bcp{how many?} lines
of OCaml code. 

\paragraph*{Synthesis Overview}
Algorithm~\ref{alg:synthlens} shows an overview of the synthesis
algorithm.  The algorithm, \SynthLens{}, takes in a pair of
regular expressions ($\Regex$ and $\RegexAlt$), and examples ($\Examples$),
and uses $\ToDNFRegex$ to convert the
regular expressions into DNF regular expressions.
Then, \SynthDNFLens{} is called on these DNF regular expressions to create a
DNF lens.
This DNF lens is then converted into a lens with \ToLens{}, and finally
tweaked for readability with \Beautify{}.

\begin{algorithm}
  \caption{\SynthLens}
  \label{alg:synthlens}
  \begin{algorithmic}[1]
    \Function{SynthDNFLens}{$\DNFRegex,\DNFRegexAlt,\Examples$}
    \State $\Queue \gets \Call{\CreatePQueue}{(\DNFRegex,\DNFRegexAlt),0}$
    \While{$\True$}
    \State $(\QueueElement,\Queue) \gets \Call{\Pop}{\Queue}$
    \State $((\DNFRegex,\DNFRegexAlt),\ExpCount) \gets \QueueElement$
    \State $\DNFLensOption \gets
    \Call{\SynthRWLDNFLens}{\DNFRegex,\DNFRegexAlt,\Examples}$
    \Switch{\DNFLensOption}
    \Case {\None}
    \State $\DNFRegexs \gets \Call{\ExpandOnce}{\DNFRegex,\DNFRegexAlt}$
    \State $\ExpCount \gets \ExpCount+1$
    \State $\QueueElements \gets \Call{\Map}{\lambda x.(x,\ExpCount),\DNFRegexs}$
    \State $\Queue \gets \Call{\EnqueueMany}{\QueueElements,\Queue}$
    \EndCase
    \SecondCase {\SomeOf{\DNFLens}}
    \State $\ReturnVal{\DNFLens}$
    \EndSecondCase
    \EndSwitch
    \EndWhile
    \EndFunction
    \Statex
    \Function{SynthLens}{$\Regex,\RegexAlt,\Examples$}
    \State $(\DNFRegex,\DNFRegexAlt) \gets
    (\ToDNFRegexOf{\Regex},\ToDNFRegexOf{\RegexAlt})$
    \State $\DNFLens \gets \Call{SynthDNFLens}{\DNFRegex,\DNFRegexAlt,\Examples}$
    \State $\Lens \gets \Call{ToLens}{\DNFLens}$
    \State $\ReturnVal{\Call{Beautify}{\Lens}}$
    \EndFunction
  \end{algorithmic}
\bcp{Larger comment: Is this seriously using {\em null} to
  represent a failure result from a subroutine??  The reviewers are going to
  laugh at us.}\afm{is $\bot$ better?}\bcp{Still a bit horrible.}\afm{match
  statement?}
\end{algorithm}

In \SynthDNFLens{}, a singleton priority queue ($\Queue$) is created, consisting of the
two input DNF regular expressions and the number of expansions preformed $(0)$.
This priority queue is designed
such that lower priority typing constraints either have undergone a large number
of rewrites, or have typing constraints that are very difference in appearance
from each other.
Next a loop begins which pops the highest priority element from the queue.
This element is a tuple consisting of the DNF regular expressions, and a tracker
of how many expansions have been preformed ($\ExpCount$).
\SynthRWLDNFLens is then called on the DNF regular expressions and
the examples, to search for a rewriteless DNF lens.
If a rewriteless DNF lens is found, it is returned.
If no lens is found, a single rewrite is applied to either the left or the right
DNF regular expression in \ExpandOnce.  In other words, if $\DNFRegex$ and
$\DNFRegexAlt$ are the DNF regular expressions,
$\PCF{ExpandOnce}(\DNFRegex,\DNFRegexAlt) =
\SetOf{(\DNFRegex',\DNFRegexAlt) \SuchThat \DNFRegex \Rewrite \DNFRegex'}
\Union
\SetOf{(\DNFRegex,\DNFRegexAlt') \SuchThat \DNFRegexAlt \Rewrite \DNFRegexAlt'}$.
All the DNF regular expressions returned by this are enqueued, with the
information that an extra expansion has been preformed, and the loop continues.

\paragraph*{Priority Queue}
We say that the lower the priority value, the higher the priority.
The priority value of an element is based on two factors.  The first factor is
the number of expansions that have been performed.  If more expansions have been
preformed, the priority will be lower.  The inclusion of expansions preformed
forces some exploration of the
search space; if it were the only factor of priority, the search would be
entirely a breadth first search through the application of rewrite rules.
The second factor is how different the two regular expressions of the
specification are.  This difference is determined from our implementation of
a psuedometric $\Distance$.  Our distance $\Distance$ is
a pseudometric, as $\Distance$ satisfies the triangle property, $\Distance$ is
symmetric, and $\Distance(\DNFRegex,\DNFRegex) = 0$, but
$\Distance(\DNFRegex,\DNFRegexAlt) = 0$ does not imply $\DNFRegex =
\DNFRegexAlt$.  This pseudometric is implemented
as the sum of simpler pseudometrics,
$\Distance = \Distance_{size}+\Distance_{dist}$.

The size distance, $\Distance_{size}$ is defined as merely the difference in the
sizes of the DNF
regular expressions.  The size of a DNF regular expression is the sum of the
sizes of all lists present in the DNF regular expression data structure.
The size distance, $\Distance_{size}$ is formally defined as
$\Distance_{size}(\DNFRegex,\DNFRegexAlt)=\AbsOf{\Size(\DNFRegex)-\Size(\DNFRegexAlt)}$.
For two DNF regular expressions to have a rewriteless DNF lens between
them, they must be the same size, so using this pseudometric makes ones closer
in size popped sooner.

The distribution distance, $\Distance_{dist}$, captures how different the distributions of
user defined regular expressions in the two input regular expressions
are.
The distribution of user defined regular expressions can be viewed as
$\VectorSpace{}$, an
infinite dimensional vector space over the reals.
The set $\SetOf{1*(\RegexVariable,n) | n\in\Nats, \RegexVariable
  \text{ is a user defined regular expression}}$ serves as a basis for this
vector space.
DNF regular expressions with variables can map into this vector space with a function that
counts the number of user defined data types present at a given level.
This function, $\GetDist{}$ formalizes the mapping from DNF regular expressions
into $\VectorSpace$.
\begin{trivlist}
\item 
\begin{tabular}{@{}L@{}L@{}}
  \GetDist(\DNFOf{\Sequence_1;\ldots;\Sequence_n}) &
                                                     =\GetDist(\Sequence_1)+\ldots+\GetDist(\Sequence_n)\\
  \GetDist(\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}) &
                                                                      =\GetDist(\Atom_1)+\ldots+\GetDist(\Atom_n)\\
  \GetDist(\RegexVariable)&=1*(\RegexVariable,1)\\
  \GetDist(\IterateLensOf{\DNFLens})&=\phi(\GetDist(\DNFLens))
\end{tabular}
\end{trivlist}
The linear map $\phi$ is used to increment the number of nested stars, and is
defined by $\phi(a*(\RegexVariable,n)) = a*(\RegexVariable,n+1)$

If $\LOneNorm$ computes the Manhattan distance on $\VectorSpace$ the
distribution distance
$\Distance_{dist}(\DNFRegex,\DNFRegexAlt)=
\LOneNorm(\GetDist(\DNFRegex),\GetDist(\DNFRegexAlt))$.  This
distance calculates how different the distribution of user defined regular
expressions are in two DNF regular expressions.  Only when the distribution of
user defined regular expressions are equal can a lens between two DNF regular
expressions be synthesized.  This metric makes regular expressions with
similar distributions of user defined regular expressions be popped earlier.

The priority of a pair of DNF regular expressions, $(\DNFRegex{},\DNFRegexAlt{})$,
is $\Distance(\DNFRegex{},\DNFRegexAlt{})+8*\ExpCount$, where
$\ExpCount$ is the total number of expansions preformed.
Keeping track of expansion count is important as it allows for lower priority
expansions to be eventually popped, instead of getting stuck doing incorrect,
increasingly deep expansions whose DNF regular expressions have a low distance.
Experimentally, 8 is a good value for how much weight the expansion
count should get in the priority.  It allows for not getting stuck in a local
minima in the search space, while still allowing for the distance to choose the
correct expansion the majority of the time.

\paragraph*{\SynthRWLDNFLens}

While performing type directed synthesis on DNF regular expressions, both
synthesizing a rewriteless DNF lens and synthesizing a Sequence lens requires
the generation of a permutation.  Naively searching through all possible
permutations is incredibly inefficient.  Were we to naively search through all the
rewriteless DNF Lenses between
the DNF regular expressions $\DNFOf{\Sequence_1;\ldots;\Sequence_n}$ and
$\DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_n}$, there would be $n!$ permutations
processed.

It is a better approach to recognize which subcomponents of types 
recognize which subcomponents of the types can be mapped to each other, and
create the permutations based on those mappings, than to
search through all possible permutations.  To handle finding which
subcomponents can be mapped to each other, SynthRewritelessDNF further
normalizes the input regular expressions.
Ordering the sequence subcomponents of a DNF lens further normalizes it.
Ordering the atom subcomponents of a DNF lens further normalizes it.
After correctly ordering the sequences, we can synthesize a rewriteless DNF lens
between $\DNFOf{\Sequence_1;\ldots;\Sequence_n}$ and
$\DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_n}$ merely through finding a sequence
lens between $\Sequence_i$ and $\SequenceAlt_i$ for all $i$.  Similarly, after
correctly ordering the atoms, we can
synthesize a rewriteless sequence lens 
between $\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}$ and
$\SequenceOf{\StringAlt_0;\AtomAlt_1;\ldots;\AtomAlt_n;\StringAlt_n}$ through
merely finding atom lenses between $\Atom_i$ and $\AtomAlt_i$ for all $i$.

However, these ordering normalization techniques can change the semantics of the
regular
expressions.  To get around this issue, remembering the alterations taken for
normalization, and later applying them in reverse to the synthesized DNF lens
can retrieve a lens between the original DNF regular expressions.

%\begin{figure}
%  \label{fig:lens-synth-ordering-ex}
%  \centering
%  \SmallCF{DNFBib' <=> DNFEndUnroll}
%  \begin{tikzpicture}
%    \matrix (m) [matrix of nodes, row sep=1em, column sep=4em, minimum width=2em]
%    {
%      \SmallCF{""} & $\Or$ & \SmallCF{BibSequence2} \\
%      \SmallCF{""} & $\Or$ & \SmallCF{BibSequence2} \\
%      \SmallCF{""} & $\Or$ & \SmallCF{EndSequence2} \\
%      \SmallCF{""} & $\Or$ & \SmallCF{EndSequence2} \\
%    };
%    \path[<->]
%    (m-1-1) edge node [left] {} (m-2-1);
%    \path[<->]
%    (m-2-1) edge node [left] {} (m-3-1);
%    \path[<->]
%    (m-3-1) edge node [left] {} (m-4-1);
%    \path[<->]
%    (m-1-3) edge node [right] {} (m-2-3);
%    \path[<->]
%    (m-2-3) edge node [right] {\SmallCF{lsequence}} (m-3-3);
%    \path[<->]
%    (m-3-3) edge node [right] {} (m-4-3);
%  \end{tikzpicture}
%
%  \SmallCF{lsequence : BibSequence2 <=> EndSequence2}
%  \begin{tikzpicture}
%    \matrix (m) [matrix of nodes, row sep=1em, column sep=-.75em]
%    {
%      \SmallCF{"author=\{"} & \Concat{}\SmallCF{Name}\Concat{} & \SmallCF{", "} &
%      \Concat{}\SmallCF{Name}\Concat{} & \SmallCF{""} & \Concat{}\SmallCF{Names}\Concat{} & \SmallCF{""}
%      & \Concat{}\SmallCF{BibStar*}\Concat{} & \SmallCF{"\},"}\\
%      \SmallCF{"author=\{"} & \Concat{}\SmallCF{Name}\Concat{} & \SmallCF{", "} &
%      \Concat{}\SmallCF{Name}\Concat{} & \SmallCF{""} & \Concat{}\SmallCF{Names}\Concat{} & \SmallCF{""}
%      & \Concat{}\SmallCF{BibStar*}\Concat{} & \SmallCF{"\},"}\\
%      \SmallCF{"\%A "} & \Concat{}\SmallCF{Name}\Concat{} & \SmallCF{""} &
%      \Concat{}\SmallCF{Name}\Concat{} & \SmallCF{" "} & \Concat{}\SmallCF{Names}\Concat{} & \SmallCF{""}
%      & \Concat{}\SmallCF{EndStar*}\Concat{} & \SmallCF{""}\\
%      \SmallCF{"\%A "} & \Concat{}\SmallCF{Name}\Concat{} & \SmallCF{""} &
%      \Concat{}\SmallCF{Names}\Concat{} & \SmallCF{" "} & \Concat{}\SmallCF{Name}\Concat{} & \SmallCF{""}
%      & \Concat{}\SmallCF{EndStar*}\Concat{} & \SmallCF{""}\\
%    };
%    \path[<->]
%    (m-1-2) edge node [right] {} (m-2-4);
%    \path[<->]
%    (m-1-4) edge node [right] {} (m-2-2);
%    \path[<->]
%    (m-1-6) edge node [left] {} (m-2-6);
%    \path[<->]
%    (m-1-8) edge node [left] {} (m-2-8);
%    \path[<->]
%    (m-2-2) edge node [right] {} (m-3-2);
%    \path[<->]
%    (m-2-4) edge node [right] {} (m-3-4);
%    \path[<->]
%    (m-2-6) edge node [left] {} (m-3-6);
%    \path[<->]
%    (m-2-8) edge node [right] {\SmallCF{lstar}} (m-3-8);
%    \path[<->]
%    (m-3-2) edge node [right] {} (m-4-2);
%    \path[<->]
%    (m-3-4) edge node [right] {} (m-4-6);
%    \path[<->]
%    (m-3-6) edge node [left] {} (m-4-4);
%    \path[<->]
%    (m-3-8) edge node [right] {} (m-4-8);
%  \end{tikzpicture}
%
%  \SmallCF{lstar : BibStar <=> EndStar}
%  \begin{tikzpicture}
%    \matrix (m) [matrix of nodes, row sep=1em, column sep=-.75em]
%    {
%      \SmallCF{" and "} & \Concat{}\SmallCF{Name}\Concat{} & \SmallCF{", "} &
%      \Concat{}\SmallCF{Name}\Concat{} & \SmallCF{""} & \Concat{}\SmallCF{Names}\Concat{} &
%      \SmallCF{""}\\
%      \SmallCF{" and "} & \Concat{}\SmallCF{Name}\Concat{} & \SmallCF{", "} &
%      \Concat{}\SmallCF{Name}\Concat{} & \SmallCF{""} & \Concat{}\SmallCF{Names}\Concat{} &
%      \SmallCF{""}\\
%      \SmallCF{"\%A "} & \Concat{}\SmallCF{Name}\Concat{} & \SmallCF{""} &
%      \Concat{}\SmallCF{Name}\Concat{} & \SmallCF{" "} & \Concat{}\SmallCF{Names}\Concat{}
%      & \SmallCF{""}\\
%      \SmallCF{"\%A "} & \Concat{}\SmallCF{Name}\Concat{} & \SmallCF{""} &
%      \Concat{}\SmallCF{Names}\Concat{} & \SmallCF{" "} & \Concat{}\SmallCF{Name}\Concat{}
%      & \SmallCF{""}\\
%    };
%    \path[<->]
%    (m-1-2) edge node [right] {} (m-2-4);
%    \path[<->]
%    (m-1-4) edge node [left] {} (m-2-2);
%    \path[<->]
%    (m-1-6) edge node [left] {} (m-2-6);
%    \path[<->]
%    (m-2-2) edge node [right] {} (m-3-2);
%    \path[<->]
%    (m-2-4) edge node [left] {} (m-3-4);
%    \path[<->]
%    (m-2-6) edge node [left] {} (m-3-6);
%    \path[<->]
%    (m-3-2) edge node [right] {} (m-4-2);
%    \path[<->]
%    (m-3-4) edge node [left] {} (m-4-6);
%    \path[<->]
%    (m-3-6) edge node [left] {} (m-4-4);
%  \end{tikzpicture}
%  \caption{Synthesized Lens Mappings from Orderings}
%\end{figure}

%Consider the example of synthesizing a lens between \CF{DNFBib'} and
%\CF{DNFEndUnroll}, shown in Figure~\ref{fig:lens-synth-ordering-ex}.
%The top layer (the original DNF regular expression subparts for BibTex) maps
%into the second layer through an ordering of its subparts.
%The bottom layer (the original DNF regular expression subparts for EndNote) maps
%into the third layer through an ordering of its subparts.
%The second and third layer are mapped to each other by merely zipping together
%the subparts.
%The composition of the orderings done in each layer combines to make
%the permutations required for the lens between unordered BibTex and unordered
%EndNote.

Unfortunately, while this ordering and mapping procedure can find a well typed
DNF lens, it doesn't
necessarily find the one that matches the examples.  In the situation where
there are multiple valid sorted orderings, there are multiple different lenses
with potentially different semantics.  For example, in the
synthesis of a lens between \CF{BibStar} and \CF{EndStar}, there are two
instances of \CF{Name}.  Which of these should go first when ordered?  Instead
of iterating through all the possible sortings, and finding one that matches
the examples, we would like to
be able to immediately find only a sorting which satisfies the examples.

The key insight here is that certain invariants must hold for a DNF lens to have
semantics that match the examples.

\begin{enumerate}
\item If a source example string matches one of the sequences during parsing,
  it must be sent to the sequence the target example string matches during parsing.
\item If a source example string matches a user defined regular expression during
  parsing, the target must match the exact same string during parsing.
\item If a source example string matches an iteration, then the target must iterate
  the same number of times, and all the invariants must hold for each iterated part.
\end{enumerate}

We can hold these invariants by joining additional parsing information alongside
the regular
expression components, and creating an ordering on DNF regular expressions
with parsing information.  By attaching additional parsing information,
each \CF{Name} no longer is merely a \CF{Name}, it is \CF{Name} alongside
\CF{"Stephen"} or \CF{"Kleene"}.  With that additional information, the
\CF{Name}s can be ordered, and correctly mapped to the other
\CF{Name}s in a manner that satisfies the examples.


\paragraph*{Importance of User Defined Data Types}

User defined data types are critical to the performance of
the synthesis algorithm.  They help direct the search of
which expansions should be performed.  Furthermore, they help to reduce the
number of sequences we have to deal with.  There is a potentially exponentially
large blowup in converting regular expressions into DNF form, but keeping
certain portions of the regular expressions abstracted lessens that blowup,
as those regular expressions are kept atomic in converting into DNF form.

User defined data types are also critical in the applications of previously
defined lenses.  We restrict the application of previously defined lenses to
only on user defined data types in the synthesis algorithm.  We then group the
user defined data types based on which have previously defined lenses between
them.  This grouping allows for efficient recognition of when two user defined regular
expressions can be mapped to each other.  Removing the ability to use previously
defined lenses makes certain problems intractable, like xml.ls.

While we can simulate the use of user defined data types automatically, by
giving regular expressions which have the same syntax the same user defined data
type, manually inputting them performs better in practice.  The
procedure for automatically creating user defined data types creates far more
data types, which then creates a more complicated search problem.



% end implementation


% begin evaluation
\section{Evaluation}
\label{evaluation}

\begin{figure}
  \centering
  \begin{tabular}{|l|c|c|c|c|}
    \hline
    & & \bfseries Time
    & \bfseries Avg \# & \bfseries Max \#\\
    \bfseries Test & \bfseries Size & \bfseries (ms)
    & \bfseries Exmpl & \bfseries Exmpl
           \csvreader[head to column names]{generated-data/data.csv}{}
           {\\\hline\Test & \SpecSize & \ComputationTime  & \ExamplesRequired & \MaxExampleCount}
    \\\hline
  \end{tabular}
  \label{fig:evaluation-data}
  \caption{Empirical Results.  
  The benchmarks are sorted in increasing order by the sizes of
  the source and target regular expression types given in
  the \textbf{Size} column.   Column \textbf{Time} reports
  the average running time of 10~synthesis runs.  Column \textbf{Avg \#
  Exmpl} reports the average required number of randomly generated
  examples. Column \textbf{Max\# Exmpl} represents the maximum
  number of examples that the user would have to supply to force the
  synthesizer to explore all choices.
}
\end{figure}

We evaluated our synthesis algorithm by applying it to \ksf{25}
benchmark programs derived from practice.  We investigated the
correctness of the inferred lenses, how long it took to synthesize
each lens, and how many user-supplied examples synthesis required.
Figure~\ref{fig:evaluation-data} shows the results for each of our
benchmark programs.  The rows are sorted in increasing order by the
size of the source and target regular expression types.  The values
presented are the arithmetic means of 10 test runs.  The tests were
run on a 2.5 GHz Intel Core i7 processor with 16 GB of 1600 MHz DDR3
running Mac OS X Yosemite.  On average, synthesis required \ksf{0.134
seconds} and \ksf{0.94} user-supplied examples per lens.

\paragraph*{Benchmark Suite Construction}
We constructed our benchmarks by adapting examples from
Augeas~\cite{augeas} and 
FlashFill~\cite{gulwani-popl-2014} and by handcrafting specific
examples to test various 
features of the algorithm.
Specifically, we derived \ksf{17} of the benchmark tests by
adapting all of the lenses from the Augeas distribution that started
with the letter `A' as well as the lenses
\ksf{aug/xml-firstlevel} and \ksf{aug/xml} that were referenced
by the `A' lenses.  We derived \ksf{3} benchmarks from examples in the
FlashFill paper~\cite{gulwani-popl-2014} that were close to bijections.
We wrote \ksf{5} custom examples to test various features of the
algorithm.
In Figure~\ref{fig:evaluation-data}, examples derived from Augeas are
prefixed with \ksf{``aug''}, those from FlashFill with \ksf{``ff''}, and those
written by hand by \ksf{``cust.''}

Augeas is a configuration editing system for linux that uses lens
combinators similar to those in Boomerang. However, it transforms
strings on the left to structured trees on the right rather than
transforming strings to strings.
We adapted these Augeas lenses to our setting by converting the
right-hand sides to strings that correspond to serialized versions
of the tree formats.  
Augeas also supports {\em asymmetric lenses}~\cite{Focal2005-long},
which are more general than the bijective lenses we can synthesize.
We adapted these examples by adding extra fields to the
target to make the transfomations bijective and thus suitable
for our study.

% KSF: I believe this paragraph is no longer relevant because we are
% not including Boomerang benchmarks.
%Just like Augeas, Boomerang has combinators that go beyond the basic
%lens combinators, including keyed data and quotienting.  Keyed data
%has little impact on the output format, but merely changes how the
%invertibility laws behave.  Because we have bijective lenses, keyed
%data has no impact.  We treat quotienting similarly to non-bijective
%lenses.  Any part of the string that would be quotiented, instead is
%included in a different area of the string, to maintain bijectivity.

FlashFill is a system that allows users to specify common string
transformations by example~\cite{gulwani-popl-2014}.  
Many of the examples from FlashFill are non-bijective because
the user's goal is often to extract information.  We were able to
adapt some examples by adding information to the target so the
resulting transformation was bijective.

Finally, we hand-crafted examples to highlight weaknesses of
our algorithm (\ksf{cust/cap-prob} and \ksf{cust/2-cap-prob}) 
and to test situations for which we thought the tool would be
particularly useful (\ksf{cust/date-probs}, \ksf{cust/bib-prob},
and \ksf{cust/addr-probs}).   These examples convert between date
formats, bibliography formats, and address formats, respectively.


We consider the size of a benchmark program to be the total number of
tokens in the source and target regular expressions.  
For example, a \BaseRegexType{} regular expression counts as one
while the concatenation of regular expressions $R_1$ and $R_2$ counts
as one plus the sizes of $R_1$ and $R_2$.
This size gives an approximate metric for how complex the data formats are.


% KSF: This material seems to fit into a description of the algorithm,
% not the evaluation section. Furthermore, in larger synthesis
% problems, we build intermediary lenses between intermediary regular
% expressions as a sanity check for bijectivity.  These intermediary
% lenses are then used in the synthesis algorithm for mapping the
% intermediary sub-expressions, to avoid repeating the same synthesis
% algorithm. 

\paragraph*{Correctness}
To assess the correctness of the inferred lenses, we inspected each to
determine if the generated lens matched our understanding of the given
benchmark.  For all but cust/bib\_prob, the inferred lens was correct.
For bib\_prob, the inferred lens had the correct type and performed
correctly on all supplied examples, but would have been incorrect on
other examples.  When we refined one of the given examples to
highlight the previously unseen case and re-ran the algorithm, it
produced the correct lens. As further validation, we confirmed that the
synthesized lenses performed correctly on the supplied examples and on
additional examples not made available to the synthesis algorithm,
having held back approximately half of our example data for validation.


\paragraph*{Speed of Synthesis}
%
Figure~\ref{fig:evaluation-data} provides the runtime of our algorithm on our
benchmark suite. The column \textbf{Time} shows the runtime of the
synthesis algorithm in microseconds; smaller numbers are better.
Across all examples, the average synthesis time is \ksf{0.134
seconds}; the slowest example (\ksf{aug/xml}) completes in just under four 
seconds. 
The results show that the synthesis time is not strongly correlated
to the complexity of the source and target regular expressions.  Other
factors, such as the degree to which the source and target regular
expressions vary, have a large impact.

The example \ksf{aug/xml} takes as long as it does primarily because of the
complexity of the regular expressions that describe the source and
target data formats, \ksf{XXX tokens and YYY tokens,
respectively}.\footnote{Note that xml is not a regular language, so
    the source and target regular expressions describe only xml
    expressions up to depth 3.} 
A second challenge is that the system must apply a number of regular
expression expansions to get the source and target regular expressions
into alignment.  The large sizes of these regular expressions means
the system can perform many expansions and the search space is large.

We constructed the pathological example \ksf{cust/2-cap-prob} to
highlight the exponential blow-up that arises in expanding
disjunctions in the conversion to DNF form.  This example converts
between strings of lowercase letters to strings of uppercase letters
and vice versa, leading to source and target regular expression types
that contain disjunctions of 26 letters.  The source and target
regular expressions each contain two references to these disjunctions;
hence the name ``2-cap-prob.''  In this example, the conversion to DNF
form creates 676 sequences in the first expansion.  This number grows
to 17576 sequences in subsequent conversions. \ksf{We should add a
sentence explaining why we think this example won't occur for real.}

% If we take this problem to the logical extremes, we see that the the triple
% capitalization problem takes 6.974 seconds, and the quadruple capitalization
% problem takes 33 minutes and 54.730 seconds.

If a bijection that satisfies the examples does not exist between the
source and target regular expressions, our tool rarely terminates.
Instead, it performs increasibly complicated regular expression
transformations to try to find a bijective lens.  In practice, if the
system takes more than 10 seconds, we abort and revise the regular
expressions to make it easier to find a bijection.


\paragraph*{Importance of Examples}
To evaluate how many user-supplied examples the algorithm requires in
practice, we \textit{randomly} generated appropriate source/target
pairs, mimicking what a naive user might do.  We did not write the
examples by hand out of concern that our knowledge of the synthesis
algorithm might bias the selection.  In
Figure~\ref{fig:evaluation-data}, the column \textbf{Avg\# Exmpl} shows
the number of randomly generated examples it takes to synthesize the
correct lens averaged over ten runs.  Across all examples, the average
number of required examples is \ksf{0.94}. The mode is zero, and the
maximum is \ksf{21.5}.  We note that a clever user may be able to reduce the
number of required examples by selecting examples carefully.

These numbers are low because there are relatively few well-typed
bijective lenses between any two source and target regular expressions. 
As one would expected, the benchmarks where there are multiple ways to
map source data to the target (and vice versa) require the most examples.
For example, the benchmark \ksf{aug/addr-probs} requires examples because it
must differentiate between and first and last names in both the
source and target and map between them appropriately.

As the \ksf{bib\_prob} example illustrates, the average number of examples to
infer the correct lens does not tell the whole story.  The system will
stop as soon as it finds a correctly typed lens that correctly maps
all the supplied examples.  This inferred lens may or may not
correctly handle unseen examples that correspond to
unexercised portions of the source and target regular expressions.
Column \textbf{Max\# Exmpl} in Figure~\ref{fig:evaluation-data} lists
the number of examples that are required to exercise all choice
points.  Intuitively, this number represents the maximum number of
examples that a user must supply to guide the synthesis engine if it
always guesses the wrong mapping when multiple mappings are possible.
Note these examples must be carefully selected to exercise all
choices; a very large number of examples that all follow the same
pattern are no more helpful than a single such example.  We see an
example of this phenomenon in the example ff/extract-fname where the
average number of examples is greater than the Max number of examples
because the system randomly generated redundant examples.

The average number of examples is so much lower than the maximum
number of required examples because of correspondances in how we wrote
the regular expressions for the source and target data formats. 
Specifically, when we had corresponding disjunctions in both the
source and the target, we ordered them the same way.  The algorithm
uses the supplied ordering to guide its search, and so the system
requires fewer examples.   We did not write the examples in this style
to facilitate synthesis, but rather because maintaining similar
subparts in similar orderings makes the types much easier to 
read. We expect that most users would do the same.


\paragraph*{Impact of Incompleteness}

In synthesizing the lenses for our benchmark suite, we did not miss
the ability to use retyping with full regular expression equivalence.
The only regular expression equivalences that arose were ones that we
had already incorporated in our reduced set of equivalences.
For example, the only places where synthesis
used \StarRegexType{} equivalences were in varying the number
of iterations and in placing separators, both of 
which we accounted for in $\DefinitionalEquiv$.

%We believe the full generality is not necessary because 
%This lack of impact is likely because, when the languages of two
%regular expressions have 
%bijective lenses between them, the data is naturally grouped in similar ways on each
%side of the regular expression.  If there was a block of text, it would likely
%be written on both sides as \CF{Character*}, instead of \CF{(A*notA)*A*}, where
%\CF{A} is the character \CF{A}, and \CF{notA} is all characters except for
%\CF{A}.  If for some reason it were important that \CF{A} and \CF{notA} were
%separated, we found that it would be important in both data
%representations.  

% end evaluation



% begin related-work
\section{Related Work}
\paragraph*{FlashFill}
FlashFill~\cite{gulwani-popl-2014} is another string transformation
tool.  FlashFill takes input and 
output examples as its only form of specification.  For FlashFill's primary use
case, providing easy transformations of Excel data, input and output examples as
the only specification makes a lot of sense.  Our tool is intended for use for
programmers to use, who already know regular expressions.  Our tool is oriented
towards a situation where a programmer would check the generated code into a
repository.  From requiring this extra information, our tool is able to handle
synthesize complicated functions that go beyond what FlashFill can synthesize.
For example, given 21 examples of extracting the first author, with the names
reversed, FlashFill still gave incorrect outputs for a number of inputs, even
when those inputs are a similar form to the provided examples.

Furthermore, even if FlashFill were to synthesize the correct program, it would
be foolhardy to check the generated code into a repository.  FlashFill does not
fail on inputs it doesn't know how to handle, rather it tries to provide an
output.  This model is different from the generated lenses, which will quickly
fail on inputs that do not match it's intended specification.  Furthermore, the
specification of what inputs should be handled are provided by the user, not
inferred from the examples, giving it more reliability.

Furthermore, FlashFill is unable to synthesize programs with nexted loops
without custom configuration.  The lack of nested loops was a pragmatic choice
in allowing FlashFill
to efficiently find many correct transformations very quickly.  However, in
many complicated data formats, nested loops are inevitable. 

\paragraph*{FlashExtract}
FlashExtract~\cite{le-pldi-2014} is a program that takes an input of a string, and a partial
labeling of substrings within that string, to try to label the rest of the
substrings.  FlashExtract was able to label some amounts of the strings, but was
unable to handle reorderings of the data well.  While it would do well in
extracting data when the data came in the same form, for example, when given a
Bibtex file where the fields come in a specific order, the data would do well,
however, FlashExtract was unable to handle when fields were given in different
orders, even if previous examples in that order were given.

The schemas for FlashExtract are not customized for data formats which have many
\OrRegexType{}s.  In particular, there is no \OrRegexType{} schema at all!  The
only way that \OrRegexType{}s can be simulated is through the concatenation of
all the choices, where all but one of the choices becomes \CF{null} on each
application.  However, this concatenation strategy is only a hack, and as such,
FlashExtract preforms badly on
circumstances that require \OrRegexType{}s.
Indeed, after providing 30 examples of BibTex
examples, FlashExtract was still unable to generalize to correctly extract
the fields of a BibTex example.
% end related-work

% begin conclusion
\section{Conclusion}

We have coded up an implementation of type-directed synthesis on a domain
specific language of bijective lenses.  This program allows users to input two
regular expressions, and a few input/output examples, and will synthesize a
bijective lens between those regular expressions, matching those input/output
examples.  While lenses are very useful for their guarantees, they are a
difficult domain specific language to code in, in practice.  This program
provides an easier interaction model for the creation of lenses through using
synthesis as the way to interact with the programmer.

This synthesis algorithm is competitive with state of the art tools for
synthesis on strings transformations, and is better at synthesizing very
complicated transformations.  The additional capabilities are gained through requiring a
larger amount of user interaction with the synthesis algorithm.  However,
for this increased interaction, the program provides the capabilities of
synthesizing very complicated transformations, and provides stronger guarantees
about correctness on inputs dissimilar to those provided in the
examples.


%%We found that in practice, requiring a user to put in more
%%information for the synthesis of a string transformation creates a
%%more reliable algorithm, which also requires fewer examples.
%%However, these benefits comes at a few costs: the user needs to know
%%how to write out regular expressions, and the user must spend the
%%time writing out the regular expressions, and must do so correctly.
%%However, for our use case of a programmer working on enterprise
%%software, these additional costs are minor.

%%The largest difficulty the use of this program is the restriction to
%%bijective lenses.  Oftentimes, we find the need to hide information
%%away in some alternate form.  For example, there is oftentimes
%%whitespace in the definition of a regular expression.  This
%%whitespace must be copied somehow over to the other side.
%%Oftentimes copying whitespace requires the use of having a portion
%%of the string dedicated to holding the whitespace information of the
%%other side.


\paragraph*{Future Work}
Some of the issues seen in this work have already been noted.  For example, in the
quotient lens paper, the issue of having to hack a place in the source string to
move whitespace information from the view to the source was noted.  An extension
we would like to work on would be able to synthesize quotient lenses.

Another approach to having disparate information on each side of the lens is
through the use of symmetric lenses.  Symmetric lenses could be another approach to the
whitespace problem.

% end conclusion

\appendix

\ifanon\else
\acks 
% Expeditions in Computer Augmented Program Engineering (ExCAPE, NSF
% Award CCF-1138996).
% Acknowledgments, if needed.
\finish{Write me.  Mention all relevant grants, esp. DARPA.}
\fi

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\bibliography{local}

% Appendices.
\ifappendices



\onecolumn
% begin proofs
\section{Proofs}
% proof-dnfrc start
% First we will prove some lemmas.

\begin{definition}[Conway's Regular Expression Equivalences]
  \centering
  \begin{tabular}{@{}r@{\hspace{1em}}c@{\hspace{1em}}l@{}r@{}}
    \RegexOr{\Regex}{\emptyset} & $\equiv$ & \Regex{} & \OrIdentityRule{} \\
    $\RegexConcat{\Regex}{\emptyset}$ & $\equiv$ & $\emptyset$ & \EmptyProjectionRightRule{} \\
    $\RegexConcat{\emptyset}{\Regex}$ & $\equiv$ & $\emptyset$ & \EmptyProjectionLeftRule{} \\
    \RegexConcat{(\RegexConcat{\Regex{}}{\Regex'})}{\Regex''} & $\equiv$ & \RegexConcat{\Regex{}}{(\RegexConcat{\Regex'}{\Regex''})} & \ConcatAssocRule{}  \\
    \RegexOr{(\RegexOr{\Regex}{\Regex'})}{\Regex''} & $\equiv$ & \RegexOr{\Regex}{(\RegexOr{\Regex'}{\Regex''})} & \OrAssociativityRule{}  \\
    \RegexOr{\Regex{}}{\RegexAlt{}} & $\equiv$ & \RegexOr{\RegexAlt{}}{\Regex{}} & \OrCommutativityRule{}\\
    \RegexConcat{\Regex{}}{(\RegexOr{\Regex{}'}{\Regex{}''})} & $\equiv$ & \RegexOr{(\RegexConcat{\Regex{}}{\Regex{}'})}{(\RegexConcat{\Regex{}}{\Regex{}''})} & \DistributivityLeftRule{} \\
    \RegexConcat{(\RegexOr{\Regex{}'}{\Regex{}''})}{\Regex{}} & $\equiv$ & \RegexOr{(\RegexConcat{\Regex{}'}{\Regex{}})}{(\RegexConcat{\Regex{}''}{\Regex{}})} & \DistributivityRightRule{} \\
    \RegexConcat{\EmptyString{}}{\Regex{}} & $\equiv$ & \Regex{} & \ConcatIdentityLeftRule{} \\
    \RegexConcat{\Regex{}}{\EmptyString{}} & $\equiv$ & \Regex{} & \ConcatIdentityRightRule{} \\
    \StarOf{(\RegexOr{\Regex{}}{\RegexAlt{}})} & $\equiv$ & \RegexConcat{\StarOf{(\RegexConcat{\StarOf{\Regex{}}}{\RegexAlt{}})}}{\StarOf{\Regex{}}} & \SumstarRule{}\\
    \StarOf{(\RegexConcat{\Regex{}}{\RegexAlt{}})} & $\equiv$ & \RegexOr{\EmptyString{}}{(\RegexConcat{\RegexConcat{\Regex{}}{\StarOf{(\RegexConcat{\RegexAlt{}}{\Regex{}})}}}{\RegexAlt{}})} & \ProductstarRule{} \\
    ${(\Regex{}^*)}^*$ & $\equiv$ & \StarOf{\Regex{}} & \StarstarRule{} \\
    \StarOf{(\RegexOr{\Regex}{\RegexAlt})} & $\equiv$ & $\StarOf{(\RegexConcat{(\RegexOr{\Regex}{\RegexAlt})}{\RegexOr{\RegexAlt}{\RegexConcat{{(\RegexConcat{\Regex}{\StarOf{\RegexAlt}})}^n}{\Regex}}})}\Concat$ & \DicyclicityRule{}\\
             & & $(\EmptyString\Or(\RegexOr{\Regex}{\RegexAlt})\Concat$\\
             & & $({(\RegexConcat{\Regex}{\StarOf{\RegexAlt}})}^0\Or\ldots\Or{(\RegexConcat{\Regex}{\StarOf{\RegexAlt}})}^n))$
  \end{tabular}
%  \caption{Regular Expression Equivalences}
%  \label{fig:regex-equivalence-rules}
\end{definition}


\begin{definition}[Definitional Regular Expression Equivalences]
  \centering
  \begin{tabular}{@{}r@{\hspace{1em}}c@{\hspace{1em}}l@{}r@{}}
    \RegexOr{\Regex}{\emptyset} & $\DefinitionalEquiv$ & \Regex{} & \OrIdentityRule{} \\
    $\RegexConcat{\Regex}{\emptyset}$ & $\DefinitionalEquiv$ & $\emptyset$ & \EmptyProjectionRightRule{} \\
    $\RegexConcat{\emptyset}{\Regex}$ & $\DefinitionalEquiv$ & $\emptyset$ & \EmptyProjectionLeftRule{} \\
    \RegexConcat{(\RegexConcat{\Regex{}}{\Regex'})}{\Regex''} & $\DefinitionalEquiv$ & \RegexConcat{\Regex{}}{(\RegexConcat{\Regex'}{\Regex''})} & \ConcatAssocRule{}  \\
    \RegexOr{(\RegexOr{\Regex}{\Regex'})}{\Regex''} & $\DefinitionalEquiv$ & \RegexOr{\Regex}{(\RegexOr{\Regex'}{\Regex''})} & \OrAssociativityRule{}  \\
    \RegexOr{\Regex{}}{\RegexAlt{}} & $\DefinitionalEquiv$ & \RegexOr{\RegexAlt{}}{\Regex{}} & \OrCommutativityRule{}\\
    \RegexConcat{\Regex{}}{(\RegexOr{\Regex{}'}{\Regex{}''})} & $\DefinitionalEquiv$ & \RegexOr{(\RegexConcat{\Regex{}}{\Regex{}'})}{(\RegexConcat{\Regex{}}{\Regex{}''})} & \DistributivityLeftRule{} \\
    \RegexConcat{(\RegexOr{\Regex{}'}{\Regex{}''})}{\Regex{}} & $\DefinitionalEquiv$ & \RegexOr{(\RegexConcat{\Regex{}'}{\Regex{}})}{(\RegexConcat{\Regex{}''}{\Regex{}})} & \DistributivityRightRule{} \\
    \RegexConcat{\Regex{}}{\EmptyString{}} & $\DefinitionalEquiv$ & \Regex{} & \ConcatIdentityLeftRule{} \\
    \RegexConcat{\Regex{}}{\EmptyString{}} & $\DefinitionalEquiv$ & \Regex{} & \ConcatIdentityRightRule{} \\
    \StarOf{\Regex{}} & $\DefinitionalEquiv$ & \RegexOr{\EmptyString{}}{(\RegexConcat{\Regex{}}{\StarOf{{\Regex{}}}})} & \UnrollstarLeftRule{} \\
    \StarOf{\Regex{}} & $\DefinitionalEquiv$ & \RegexOr{\EmptyString{}}{(\RegexConcat{\StarOf{{\Regex{}}}}{\Regex{}})} & \UnrollstarRightRule{} 
  \end{tabular}
%  \caption{Definitional Regular Expression Equivalences}
%  \label{fig:definitional-equivalence-rules}
\end{definition}


\begin{definition}[Unambiguous Concatenation Language]
  If $\Language_1$ and $\Language_2$ are languages, such that
  for all strings $\String_1,\StringAlt_1 \in \Language_1$, and for all strings
  $\String_2,\StringAlt_2 \in \Language_2$, If $\String_1\Concat\String_2 =
  \StringAlt_1\Concat\StringAlt_2$, then $\Language_1$ is \textit{unambiguously
    concatenable} with $\Language_2$, written
  $\UnambigConcatOf{\Language_1}{\Language_2}$.
\end{definition}


\begin{lemma}[Equivalence of \ConcatSequence{} and \Concat{}]
  If $\LanguageOf{\Regex}=\LanguageOf{\Sequence}$,
  and $\LanguageOf{\RegexAlt}=\LanguageOf{\SequenceAlt}$,
  then $\LanguageOf{\RegexConcat{\Regex}{\RegexAlt}}=\LanguageOf{\ConcatSequenceOf{\Sequence}{\SequenceAlt}}$.
\end{lemma}
\begin{proof}
  Let $\Sequence=\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
    \SequenceSep\Atom_n\SequenceSep\String_n}$, and
  let\\ $\SequenceAlt=[\StringAlt_0\SequenceSep\AtomAlt_1\SequenceSep\ldots
  \SequenceSep\AtomAlt_m\SequenceSep\StringAlt_m]$\\
  \begin{tabular}{@{}L@{}L@{}}
    \LanguageOf{\ConcatSequenceOf{\Sequence}{\SequenceAlt}} & = 
                                                              \LanguageOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
                                                              \SequenceSep\Atom_n\SequenceSep\String_n\Concat\StringAlt_0\SequenceSep{}
                                                              \AtomAlt_1\SequenceSep\ldots\SequenceSep\AtomAlt_m\SequenceSep\StringAlt_m}} \\
                                                            & = 
                                                              \{\String_0\Concat\String_1'\Concat\ldots\Concat\String_n'\Concat\String_n
                                                              \Concat\StringAlt_0\Concat\StringAlt_1'\Concat\ldots
                                                              \Concat\StringAlt_m'\Concat\StringAlt_m \\
                                                            & \hspace{5em} \SuchThat{} \String_i'\in\LanguageOf{\Atom_i} \BooleanAnd{}
                                                              \StringAlt_i'\in\LanguageOf{\AtomAlt_i}\}\\
                                                            & = 
                                                              \{\String\Concat\StringAlt{} \SuchThat{} \String\in\LanguageOf{\Sequence}
                                                              \BooleanAnd{} \StringAlt\in\LanguageOf{\SequenceAlt}\}\\
                                                            & =
                                                              \{\String\Concat\StringAlt{} \SuchThat{} \String\in\LanguageOf{\Regex}
                                                              \BooleanAnd{} \StringAlt\in\LanguageOf{\RegexAlt}\}\\
                                                            & =
                                                              \LanguageOf{\RegexConcat{\Regex}{\RegexAlt}}
  \end{tabular}
\end{proof}

\begin{lemma}
  \label{lem:lens-bij}
  If $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$, then
  $\SemanticsOf{\Lens}$ is a bijection between $\LanguageOf{\Regex}$ and
  $\LanguageOf{\RegexAlt}$.
\end{lemma}
\begin{proof}
  TODO
\end{proof}

\begin{lemma}
  \label{lem:rw-dnf-lens-bij}
  If $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt$, then
  $\SemanticsOf{\DNFLens}$ is a bijection between $\LanguageOf{\DNFRegex}$ and
  $\LanguageOf{\DNFRegexAlt}$.
\end{lemma}

\begin{lemma}[Equivalence of \ConcatDNF{} and \Concat{}]
  \label{lem:cdnfeq}
  If $\LanguageOf{\Regex}=\LanguageOf{\DNFRegex}$,
  and $\LanguageOf{\RegexAlt}=\LanguageOf{\DNFRegexAlt}$,
  then $\LanguageOf{\RegexConcat{\Regex}{\RegexAlt}}=
  \LanguageOf{\ConcatDNFOf{\DNFRegex}{\DNFRegexAlt}}$.
\end{lemma}
\begin{proof}
  Let $\DNFRegex=\DNFOf{\Sequence_0\DNFSep\ldots\DNFSep\Sequence_n}$, and
  let $\DNFRegexAlt=\DNFOf{\SequenceAlt_0\DNFSep\ldots\DNFSep\SequenceAlt_m}$
  \begin{tabular}{@{}L@{}L@{}}
    \LanguageOf{\ConcatDNFOf{\DNFRegex}{\DNFRegexAlt}} & = 
                                                         \LanguageOf{\DNFOf{\ConcatSequenceOf{\Sequence_i}{\SequenceAlt_j}
                                                         \text{ for $i\in\RangeIncInc{1}{n}$, $j\in\RangeIncInc{1}{m}$}}} \\
                                                       & = 
                                                         \{\String\SuchThat \String\in\ConcatSequenceOf{\Sequence_i}{\SequenceAlt_j}\\
                                                       & \hspace{5em}
                                                         \text{ where $i\in\RangeIncInc{1}{n}$, $j\in\RangeIncInc{1}{m}$}\}\\
                                                       & = 
                                                         \{\String\Concat\StringAlt{} \SuchThat{} \String\in\LanguageOf{\Sequence_i}
                                                         \BooleanAnd{} \StringAlt\in\LanguageOf{\SequenceAlt_j}\}\\
                                                       & \hspace{5em}
                                                         \text{ where $i\in\RangeIncInc{1}{n}$, $j\in\RangeIncInc{1}{m}$}\}\\
                                                       & =
                                                         \{\String\Concat\StringAlt{} \SuchThat{} \String\in\LanguageOf{\DNFRegex}
                                                         \BooleanAnd{} \StringAlt\in\LanguageOf{\DNFRegexAlt}\}\\
                                                       & =
                                                         \{\String\Concat\StringAlt{} \SuchThat{} \String\in\LanguageOf{\Regex}
                                                         \BooleanAnd{} \StringAlt\in\LanguageOf{\RegexAlt}\}\\
                                                       & =
                                                         \LanguageOf{\RegexConcat{\Regex}{\RegexAlt}}
  \end{tabular}
\end{proof}

\begin{lemma}[Equivalence of $\Atom$ and $\AtomToDNFOf{\Atom}$]
  \label{lem:atomtodnfeq}
  $\LanguageOf{\Atom} = \LanguageOf{\AtomToDNFOf{\Atom}}$
\end{lemma}
\begin{proof}
  $\LanguageOf{\AtomToDNFOf{\Atom}} =
  \LanguageOf{\DNFOf{\SequenceOf{\EmptyString;\Atom;\EmptyString}}}$

  $\LanguageOf{\DNFOf{\SequenceOf{\EmptyString;\Atom;\EmptyString}}} =
  \SetOf{\String \SuchThat \String \in
    \LanguageOf{\SequenceOf{\EmptyString;\Atom;\EmptyString}}}$.

  $\LanguageOf{\SequenceOf{\EmptyString;\Atom;\EmptyString}} =
  \SetOf{\EmptyString\Concat\String\Concat\EmptyString \SuchThat \String \in
    \LanguageOf{\Atom}} = \SetOf{\String \SuchThat \String \in
    \LanguageOf{\Atom}} = \LanguageOf{\Atom}$.

  This means $\LanguageOf{\DNFOf{\SequenceOf{\EmptyString;\Atom;\EmptyString}}}
  = \SetOf{\String \SuchThat \String \in \LanguageOf{\Atom}} =
  \LanguageOf{\Atom}$.
\end{proof}

\begin{lemma}[Equivalence of \OrDNF{} and \Or{}]
  \label{lem:odnfeq}
  If $\LanguageOf{\Regex}=\LanguageOf{\DNFRegex}$,
  and $\LanguageOf{\RegexAlt}=\LanguageOf{\DNFRegexAlt}$,
  then $\LanguageOf{\RegexOr{\Regex}{\RegexAlt}}=
  \LanguageOf{\OrDNFOf{\DNFRegex}{\DNFRegexAlt}}$.
\end{lemma}
\begin{proof}
  Let $\DNFRegex=\DNFOf{\Sequence_0\DNFSep\ldots\DNFSep\Sequence_n}$, and
  let $\DNFRegexAlt=\DNFOf{\SequenceAlt_0\DNFSep\ldots\DNFSep\SequenceAlt_m}$
  \begin{tabular}{@{}L@{}L@{}}
    \LanguageOf{\OrDNFOf{\DNFRegex}{\DNFRegexAlt}} & = 
                                                     \LanguageOf{\DNFOf{\Sequence_0\DNFSep\ldots\DNFSep\Sequence_n\DNFSep
                                                     \SequenceAlt_1\DNFSep\ldots\DNFSep\SequenceAlt_m}}\\
                                                   & = 
                                                     \{\String\SuchThat{} \String\in\Sequence_i\vee\String\in\SequenceAlt_j\\
                                                   & \hspace{5em}
                                                     \text{ where $i\in\RangeIncInc{1}{n}$, $j\in\RangeIncInc{1}{m}$}\}\\
                                                   & = 
                                                     \{\String{} \SuchThat{} \String\in\LanguageOf{\DNFRegex}
                                                     \BooleanOr{} \String\in\LanguageOf{\DNFRegexAlt}\}\\
                                                   & =
                                                     \{\String \SuchThat{} \String\in\LanguageOf{\Regex}
                                                     \BooleanOr{} \String\in\LanguageOf{\RegexAlt}\}\\
                                                   & =
                                                     \LanguageOf{\RegexOr{\Regex}{\RegexAlt}}
  \end{tabular}\\
\end{proof}

\dnfrc*
\begin{proof}
  By structural induction.

  Let $\Regex=\String$.
  $\LanguageOf{\ToDNFRegex(\String)}=\LanguageOf{\DNFOf{\SequenceOf{\String}}}=
  \{\String\}=\LanguageOf{\String}$

  Let $\Regex=\emptyset$.
  $\LanguageOf{\ToDNFRegex(\emptyset)}=\LanguageOf{\DNFOf{}} =
  \{\} = \LanguageOf{\emptyset}$.

  Let $\Regex=\StarOf{\Regex'}$.
  By induction assumption, $\LanguageOf{\ToDNFRegex(\Regex')}=
  \LanguageOf{\Regex'}$.\\
  \begin{tabular}{@{}L@{}L@{}}
    \LanguageOf{\ToDNFRegex(\StarOf{\DNFRegex'})} & =
                                                    \LanguageOf{\DNFOf{\SequenceOf{\StarOf{\ToDNFRegex(\Regex')}}}}\\
                                                  & =
                                                    \{\String\SuchThat\String\in
                                                    \LanguageOf{\SequenceOf{\StarOf{\ToDNFRegex(\Regex')}}}\}\\
                                                  & = 
                                                    \{\String\SuchThat{} \String\in\LanguageOf{\StarOf{\ToDNFRegex(\Regex')}}\}\\
                                                  & =
                                                    \{\String_1\Concat\ldots\Concat\String_n\SuchThat{}
                                                    n\in\Nats\\
                                                  & \hspace*{3em}\BooleanAnd\String_i\in\LanguageOf{\ToDNFRegex(\Regex')}\}\\
                                                  & =
                                                    \{\String_1\Concat\ldots\Concat\String_n\SuchThat{}
                                                    n\in\Nats\BooleanAnd\String_i\in\LanguageOf{\Regex'}\}\\
                                                  & = \LanguageOf{\StarOf{\Regex'}}
  \end{tabular}

  Let $\Regex=\RegexConcat{\Regex_1}{\Regex_2}$.
  By induction assumption,
  $\LanguageOf{\ToDNFRegex(\Regex_1)}=\LanguageOf{\Regex_1}$, and
  $\LanguageOf{\ToDNFRegex(\Regex_2)}=\LanguageOf{\Regex_2}$.
  $\ToDNFRegex(\RegexConcat{\Regex_1}{\Regex_2})=
  \ConcatDNFOf{\ToDNFRegex(\Regex_1)}{\ToDNFRegex(\Regex_2)}$.
  By Lemma~\ref{lem:cdnfeq},
  $\RegexConcat{\Regex_1}{\Regex_2}=
  \ConcatDNFOf{\ToDNFRegex(\Regex_1)}{\ToDNFRegex(\Regex_2)}$.

  Let $\Regex=\RegexOr{\Regex_1}{\Regex_2}$.
  By induction assumption,
  $\LanguageOf{\ToDNFRegex(\Regex_1)}=\LanguageOf{\Regex_1}$, and
  $\LanguageOf{\ToDNFRegex(\Regex_2)}=\LanguageOf{\Regex_2}$.
  $\ToDNFRegex(\RegexOr{\Regex_1}{\Regex_2})=
  \OrDNFOf{\ToDNFRegex(\Regex_1)}{\ToDNFRegex(\Regex_2)}$.
  By Lemma~\ref{lem:odnfeq},
  $\RegexOr{\Regex_1}{\Regex_2}=
  \OrDNFOf{\ToDNFRegex(\Regex_1)}{\ToDNFRegex(\Regex_2)}$.
\end{proof}
% proof-dnfrc end



% proof-dnfrs start
% First we will prove some lemmas.
\begin{lemma}
  \label{lem:sequence-rx}
  Let $\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
    \ldots\Atom_n\SequenceSep\String_n}$ be a sequence,
  and\\
  $\ToDNFRegex(\ToRegex(\Atom_i))=\DNFOf{\SequenceOf{\Atom_i}}$.
  Then,\\$\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
    \ldots\Atom_n\SequenceSep\String_n}))=$\\
  $\DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
      \ldots\Atom_n\SequenceSep\String_n}}$.
\end{lemma}
\begin{proof}
  By induction on $n$.

  Let $n=0$.
  $\Sequence=\SequenceOf{\String_0}$.\\
  $\ToDNFRegex(\ToRegex(\SequenceOf{\String_0}))=
  \ToDNFRegex(\String_0)=\DNFOf{\SequenceOf{\String_0}}$

  Let $n>0$,
  $\Sequence=\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
    \ldots\Atom_n\SequenceSep\String_n}$.\\
  $\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
    \ldots\Atom_n\SequenceSep\String_n}))$\\
  $\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
    \ldots\Atom_{n-1}\SequenceSep\String_{n-1}})\Concat\ToRegex(\Atom_n)
  \Concat\String_n)$=\\
  $\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
    \ldots\Atom_{n-1}\SequenceSep\String_{n-1}}))
  \ConcatDNF
  \ToDNFRegex(\ToRegex(\Atom_n))
  \ConcatDNF\\
  \ToDNFRegex(\String_{n-1})$=
  $\DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
      \ldots\Atom_{n-1}\SequenceSep\String_{n-1}}}
  \ConcatDNF\\
  \DNFOf{\SequenceOf{\Atom_n}}
  \ConcatDNF
  \DNFOf{\SequenceOf{\String_n}}$=
  $\DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
      \ldots\Atom_n\SequenceSep\String_n}}$.
\end{proof}



\begin{lemma}
  \label{lem:dnf-rx}
  Let $\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}$ be a sequence,
  and\\ $\ToDNFRegex(\ToRegex(\Sequence_i))=\DNFOf{\Sequence_i}$.
  Then,\\ $\ToDNFRegex(\ToRegex(\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}))=
  \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}$.
\end{lemma}
\begin{proof}

  By induction on $n$.

  Let $n=0$
  $\ToDNFRegex(\ToRegex(\DNFOf{}))=\ToDNFRegex(\emptyset)=\DNFOf{}$.

  Let $n>0$
  $\ToDNFRegex(\ToRegex(\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_n}))=
  \ToDNFRegex(\ToRegex(\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_{n-1}})
  \Concat\ToRegex(\Sequence_n))$=
  $\ToDNFRegex(\ToRegex(\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_{n-1}}))
  \ConcatDNF\\\ToDNFRegex(\ToRegex(\Sequence_n))$=
  $\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_n}$
\end{proof}

\begin{lemma}[Elimination of $\ToDNFRegex\Compose\ToRegex$]\leavevmode
  \begin{enumerate}
  \item $\ToDNFRegex(\ToRegex(\Atom))=\DNFOf{\SequenceOf{\Atom}}$
  \item $\ToDNFRegex(\ToRegex(\Sequence))=\DNFOf{\Sequence}$
  \item $\ToDNFRegex(\ToRegex(\DNFRegex))=\DNFRegex$
  \end{enumerate}
\end{lemma}
\begin{proof}
  By mutual induction

  Let $\StarOf{\DNFRegex}$ be an atom.
  $\ToDNFRegex(\ToRegex(\StarOf{\DNFRegex}))=
  \ToDNFRegex(\StarOf{\ToRegex(\DNFRegex)})=
  \DNFOf{\SequenceOf{\StarOf{\ToDNFRegex(\ToRegex(\DNFRegex))}}}=
  \DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}$

  Let $\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
    \SequenceSep\Atom_n\SequenceSep\String_n}$ be a sequence.
  $\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
    \SequenceSep\Atom_n\SequenceSep\String_n}))$.
  By induction assumption, for each $\Atom_i$,
  $\ToDNFRegex(\ToRegex(\Atom_i))=\DNFOf{\SequenceOf{\Atom_i}}$.
  By Lemma~\ref{lem:sequence-rx},
  $\ToDNFRegex(\ToRegex(\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
    \SequenceSep\Atom_n\SequenceSep\String_n}))=
  \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots
      \SequenceSep\Atom_n\SequenceSep\String_n}}$.

  Let $\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_n}$ be a DNF
  regular expression.
  By induction assumption, for each $\Sequence_i$,
  $\ToDNFRegex(\ToRegex(\Sequence_i))=\DNFOf{\Sequence_i}$.
  By Lemma~\ref{lem:dnf-rx},
  $\ToDNFRegex(\ToRegex(\DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_n}))=
  \DNFOf{\Sequence_1\SequenceSep\ldots\SequenceSep\Sequence_n}$.

\end{proof}
% proof-dnfrs end




% proof-dnfls start
% We will prove a couple of lemmas first.

\begin{lemma}
  \label{lem:unambig-concat-equiv}
  Let $\Language_1,\ldots,\Language_n,\Language_1',\ldots,\Language_m'$ be
  nonempty languages. $\SequenceUnambigConcatOf{\Language_1;\ldots;\Language_n}$,
  $\SequenceUnambigConcatOf{\Language_1';\ldots;\Language_m'}$, and
  $\SetOf{\String_1\Concat\ldots\Concat\String_n \SuchThat \String_i \in
    \Language_i} \UnambigConcat
  \SetOf{\String_1\Concat\ldots\Concat\String_m \SuchThat \String_i \in
    \Language_i'}$ if, and only if
  $\SequenceUnambigConcatOf{\Language_1;\ldots;\Language_n;\Language_1';\ldots;\Language_n'}$
\end{lemma}
\begin{proof}
  \begin{case}[$\Rightarrow$]
    Let $\SequenceUnambigConcatOf{\Language_1;\ldots;\Language_n}$,
    $\SequenceUnambigConcatOf{\Language_1';\ldots;\Language_m'}$, and
    $\SetOf{\String_1\Concat\ldots;\String_n \SuchThat \String_i \in
      \Language_i} \UnambigConcat
    \SetOf{\String_1\Concat\ldots\Concat\String_m \SuchThat \String_i \in
      \Language_i'}$
    Let $\String_i,\StringAlt_i\in\Language_i$,
    $\String_i',\StringAlt_i'\in\Language_i'$.
    Let
    $\String_1\Concat\ldots\Concat\String_n\Concat\String_1'\Concat\ldots\Concat\String_m'
    =
    \StringAlt_1\Concat\ldots\Concat\StringAlt_n\Concat\StringAlt_1'\Concat\ldots\Concat\StringAlt_m'$.
    Because $\SetOf{\String_1\Concat\ldots;\String_n \SuchThat \String_i \in
      \Language_i} \UnambigConcat
    \SetOf{\String_1\Concat\ldots\Concat\String_m \SuchThat \String_i \in
      \Language_i'}$, we know
    $\String_1\Concat\ldots\Concat\String_n =
    \StringAlt_1\Concat\ldots\Concat\StringAlt_n$ and
    $\String_1'\Concat\ldots\Concat\String_m' =
    \StringAlt_1'\Concat\ldots\Concat\StringAlt_m'$.
    Because $\SequenceUnambigConcatOf{\Language_1;\ldots;\Language_n}$,
    $\String_i = \StringAlt_i$.
    Because $\SequenceUnambigConcatOf{\Language_1';\ldots;\Language_n'}$,
    $\String_i' = \StringAlt_i'$.
    So
    $\SequenceUnambigConcatOf{\Language_1;\ldots;\Language_n;\Language_1';\ldots;\Language_n'}$
  \end{case}
  
  \begin{case}[$\Leftarrow$]
    Let $\String,\StringAlt\in
    \SetOf{\String_1\Concat\ldots\Concat\String_n \SuchThat \String_i \in
      \Language_i}$.
    Let $\String',\StringAlt'\in
    \SetOf{\String_1\Concat\ldots\Concat\String_m \SuchThat \String_i \in
      \Language_i'}$.
    Let $\String\Concat\String' = \StringAlt\Concat\StringAlt'$.
    $\String=\String_1\Concat\ldots\Concat\String_n$ where
    $\String_i \in \Language_i$,
    $\StringAlt=\StringAlt_1\Concat\ldots\Concat\StringAlt_n$ where
    $\StringAlt_i \in \Language_i$,
    $\String'=\String_1'\Concat\ldots\Concat\String_m'$ where
    $\String_i' \in \Language_i'$, and
    $\StringAlt'=\StringAlt_1'\Concat\ldots\Concat\StringAlt_m'$ where
    $\StringAlt_i' \in \Language_i'$.
    $\String\Concat\String'=\String_1\Concat\ldots\Concat\String_n
    \Concat\String_1'\Concat\ldots\Concat\String_m'$ and
    $\StringAlt\Concat\StringAlt'=\String_1\Concat\ldots\Concat\String_n
    \Concat\String_1'\Concat\ldots\Concat\String_m'$.
    
    By assumption $\String_i=\StringAlt_i$ and $\String_i'=\StringAlt_i'$.
    This means $\String=\StringAlt$ and $\String'=\StringAlt'$.

    Let $\String_i,\StringAlt_i\in\Language_i$, and let
    $\String_1\Concat\ldots\Concat\String_n =
    \StringAlt_1\Concat\ldots\Concat\StringAlt_n$.
    Consider some strings $\String_i'\in\Language_i'$.
    $\String_1\Concat\ldots\Concat\String_n\Concat
    \String_1'\Concat\ldots\Concat\String_n' =
    \StringAlt_1\Concat\ldots\Concat\StringAlt_n\Concat
    \String_1'\Concat\ldots\Concat\String_n'$.
    
    By assumption, $\String_i=\StringAlt_i$, as desired.
  \end{case}
\end{proof}

\begin{lemma}
  \label{lem:unambig-concat-union-equiv}
  Let $\Language_1,\ldots,\Language_n,\Language_1',\ldots,\Language_m'$ be
  languages.
  Let $\Language_{i,j} =
  \SetOf{\String \Concat \StringAlt \SuchThat \String\in\Language_i \BooleanAnd
    \StringAlt\in\Language_j'}$.
  Let $A = \BigUnion_{i\in\RangeIncInc{1}{n}}\Language_i \neq \SetOf{}$.
  Let $B = \BigUnion_{i\in\RangeIncInc{1}{m}}\Language_i' \neq \SetOf{}$.
  $i \neq j \BooleanImplies \Language_i \Intersect \Language_j = \SetOf{}$
  $i \neq j \BooleanImplies \Language_i' \Intersect \Language_j' = \SetOf{}$
  and
  $\UnambigConcatOf{A}{B}$
  if, and only if
  $(i_1,j_1) \neq (i_2,j_2) \BooleanImplies \Language_{i_1,j_1}'' \Intersect
  \Language_{i_2,j_2}'' = \SetOf{}$ and for all $i\in\RangeIncInc{1}{n}$,
  $j\in\RangeIncInc{1}{m}$, we have
  $\UnambigConcatOf{\Language_i}{\Language_j'}$.
\end{lemma}
\begin{proof}
  \begin{case}[$\Rightarrow$]
    Let $i \neq j \BooleanImplies \Language_i \neq \Language_j$
    $i \neq j \BooleanImplies \Language_i' \neq \Language_j'$
    and
    $\UnambigConcatOf{A}{B}$

    We shall prove $(i_1,j_1) \neq (i_2,j_2) \BooleanImplies
    \Language_{i_1,j_1}''
    \Intersect
    \Language_{i_2,j_2}'' = \SetOf{}$ by contrapositive.
    Let $\String \in \Language_{i_1,j_1}''
    \Intersect
    \Language_{i_2,j_2}''$.  This means that $\String =
    \String_{i_1}\Concat\String_{j_1}$ for some
    $\String_{i_1}\in\Language_{i_1}$ and some
    $\String_{j_1}\in\Language_{j_1}$, and that
    $\String =\String_{i_2}\Concat\String_{j_2}$ for some
    $\String_{i_2}\in\Language_{i_2}$ and some
    $\String_{j_2}\in\Language_{j_2}$.

    Because 
    $\UnambigConcatOf{A}{B}$
    $\String_{i_1} = \String_{i_2}$ and $\String_{j_1} = \String_{j_2}$.
    Because each of $A$ and $B$ are pairwise disjoint, this means
    $i_1 = i_2$ and $j_1 = j_2$.

    Let $\String_i,\StringAlt_i \in \Language_i$.
    Let $\String_j,\StringAlt_j \in \Language_j'$.
    Let $\String_i \Concat \String_j = \StringAlt_i \Concat \StringAlt_j$
    By definition, $\String_i,\StringAlt_i\in A$ and
    $\String_j,\StringAlt_j\in B$.
    By assumption, 
    $\UnambigConcatOf{A}{B}$, so $\String_i = \StringAlt_i$ and $\String_j =
    \StringAlt_j$.
  \end{case}

  \begin{case}[$\Leftarrow$]
    Let
    $(i_1,j_1) \neq (i_2,j_2) \BooleanImplies \Language_{i_1,j_1}'' \Intersect
    \Language_{i_2,j_2}'' = \SetOf{}$ and for all $i\in\RangeIncInc{1}{n}$,
    $j\in\RangeIncInc{1}{m}$, we have
    $\UnambigConcatOf{\Language_i}{\Language_j'}$.

    We prove $i \neq j \BooleanImplies \Language_i \Intersect \Language_j =
    \SetOf{}$ by contrapositive.
    Let $\Language_i \Intersect \Language_j \neq \SetOf{}$.
    Let $\String \in \Language_i \Intersect \Language_j$
    Let $\StringAlt \in B$.
    $\StringAlt \in \Language_k'$ for some $k \in \RangeIncInc{1}{m}$.
    $\String \Concat \StringAlt \in \Language_{i,k}''$ and
    $\String \Concat \StringAlt \in \Language_{j,k}''$.
    By assumption $(i,k) = (j,k)$, so $i = j$.
    
    We prove $i \neq j \BooleanImplies \Language_i' \Intersect \Language_j' =
    \SetOf{}$ in the same way.
    
    Let $\String_1,\String_2 \in A$, $\StringAlt_1,\StringAlt_2 \in B$, and
    $\String_1 \Concat \StringAlt_1 = \String_2 \Concat \StringAlt_2$.
    $\String_1 \in \Language_i$ for some $i$, and $\String_2 \in \Language_j$
    for some $j$, $\StringAlt_1 \in \Language_k'$ for some $k$, and
    $\StringAlt_2 \in \Language_l'$ for some $l$.
    This means $\String_1 \Concat \StringAlt_1 \in \Language_{i,k}''$,
    $\String_2 \Concat \StringAlt_2 \in \Language_{j,l}''$.
    Because $\String_1 \Concat \StringAlt_1 = \String_2 \Concat \StringAlt_2$,
    $(i,k) = (j,l)$.
    So as $\String_1 \in \Language_i, \String_2 \in \Language_i$,
    $\StringAlt_1 \in \Language_k, \StringAlt_2 \in \Language_k'$,
    and $\UnambigConcatOf{\Language_i}{\Language_k'}$, $\String_1 = \String_2$
    and $\StringAlt_2 = \StringAlt_2$.
  \end{case}
\end{proof}

\begin{lemma}
  \label{lem:unambig-union-equiv}
  Let $A = \SetOf{\Language_1,\ldots,\Language_n}$,
  $B = \SetOf{\Language_1',\ldots,\Language_m'}$,
  $C = \SetOf{\Language_1'',\ldots,\Language_{n+m}''}$, be sets of languages
  Such that $A \Union B = C$.
  $(\BigUnion_{i\in\RangeIncInc{1}{n}}\Language_i) \Intersect
  (\BigUnion_{i\in\RangeIncInc{1}{m}}\Language_i') = \emptyset$,
  for all $i,j\in\RangeIncInc{1}{n}$, $i \neq j \BooleanImplies Language_i \Intersect
  \Language_j = \emptyset$, and for all $i,j\in\RangeIncInc{1}{m}$, $i \neq j
  \BooleanImplies \Language_i' \Intersect \Language_j' = \emptyset$ if, and only
  if for all $i,j\in\RangeIncInc{1}{n+m}$, $i \neq j \BooleanImplies \Language_i''
  \Intersect \Language_j'' = \emptyset$.
\end{lemma}
\begin{proof}
  \begin{case}[$\Rightarrow$]
    Let $\Language_i'',\Language_j''\in C$, where $i \neq j$.
    If $\Language_i''\in A$ and $\Language_j''\in A$, then, by pigeonhole
    principle, there exists an $i', j'$ where $i' \neq j'$ such that
    $\Language_i'' = \Language_{i'}$ and $\Language_j''=\Language_{j'}$.
    By assumption, $\Language_{i'} \Intersect \Language_{j'} = \SetOf{}$, so
    $|Language_i'' \Intersect \Language_j'' = \SetOf{}$.
    
    Similarly for if $\Language_i''\in B$ and $\Language_j'' \in B$.
    
    If $\Language_i''\in A$, and $\Language_j'' \in B$.
    $(\BigUnion_{i\in\RangeIncInc{1}{n}}\Language_i) \Intersect
    (\BigUnion_{i\in\RangeIncInc{1}{m}}\Language_i') = \emptyset$.
    By application of distributivity
    $\BigUnion_{(k,l)\in\RangeIncInc{1}{n}\Cross\RangeIncInc{1}{m}}
    \Language_k'' \Intersect \Language_l'' = \SetOf{}$.
    This means that for all
    $(k,l)\in\RangeIncInc{1}{n}\Cross\RangeIncInc{1}{m}$,
    $\Language_k \Intersect \Language_l' = \SetOf{}$.
    In particular, $\Language_i'' \Intersect \Language_j'' = \SetOf{}$.
  \end{case}

  \begin{case}[$\Leftarrow$]
    Let $i,j\in\RangeIncInc{1}{n}$ and $i \neq j$.
    By pigeonhole principle, there exists some $i',j'$ where $i' \neq j'$
    such that
    $\Language_i = \Language_{i'}''$ and $\Language_j = \Language_{j'}''$.
    By assumption, $\Language_{i'}'' \Intersect \Language_{j'}'' = \SetOf{}$,
    so $\Language_i \Intersect \Language_j = \SetOf{}$.

    Similarly for $i,j\in\RangeIncInc{1}{m}$.

    Assume there exists some $\String \in
    (\BigUnion_{i\in\RangeIncInc{1}{n}}\Language_i) \Intersect
    (\BigUnion_{i\in\RangeIncInc{1}{m}}\Language_i')$.
    Then $\String\in\Language_i$ for some $i\in\RangeIncInc{1}{n}$, and
    $\String\in\Language_j'$ for some $j\in\RangeIncInc{1}{m}$.
    There exists some $i',j'$ where $i' \neq j'$ in $\RangeIncInc{1}{n+m}$
    such that $\Language_i = \Language_{i'}''$ and
    $\Language_j = \Language_{j'}''$.  But, by assumption,
    $\Language_{i'}'' \Intersect \Language_{j'}''$, so we have a contraction.
    So there is no $\String \in (\BigUnion_{i\in\RangeIncInc{1}{n}}\Language_i)
    \Intersect (\BigUnion_{i\in\RangeIncInc{1}{m}}\Language_i')$, so
    $(\BigUnion_{i\in\RangeIncInc{1}{n}}\Language_i) \Intersect
    (\BigUnion_{i\in\RangeIncInc{1}{m}}\Language_i') = \SetOf{}$.
  \end{case}
\end{proof}




\begin{lemma}[Expressibility of Safe Boilerplate Alterations]
  \label{lem:boilerplate-alterations}
  Suppose
  \begin{enumerate}
  \item $\UnambigConcat\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}$
  \item $\UnambigConcat\SequenceOf{\StringAlt_0;\Atom_1;\ldots;\Atom_n;\StringAlt_n}$
  \end{enumerate}
  Then there exists a lens
  $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that
  \begin{enumerate}
  \item $\Regex = \ToRegex(\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n})$
  \item $\RegexAlt = \ToRegex(\SequenceOf{\StringAlt_0;\Atom_1;\ldots;\Atom_n;\StringAlt_n})$
  \item $\SemanticsOf{\Lens}=\SetOf{(\String,\StringAlt)\SuchThat
      \String=\String_0\Concat\String_1'\Concat\ldots\Concat\String_n'\Concat\String_n
      \BooleanAnd\\
      \hspace*{6.1em}\StringAlt=\StringAlt_0\Concat\String_1'\Concat\ldots\Concat\String_n'\Concat\StringAlt_n
      \BooleanAnd\\
      \hspace*{6.1em}\String_i\in\LanguageOf{\Atom_i}}$
  \end{enumerate}
\end{lemma}
\begin{proof}
  By induction on $n$.

  Let $n=0$.
  Consider the Lens
  \begin{mathpar}
    \inferrule*
    {
    }
    {
      \ConstLensOf{\String_0}{\StringAlt_0} \OfType \String_0 \Leftrightarrow \StringAlt_0
    }
  \end{mathpar}
  By inspection, this satisfies the desired properties.

  Let $n>0$.
  By induction, there exists a lens $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$
  satisfying the desired properties.
  Consider the lens
  \begin{mathpar}
    \inferrule*[left=\Derivation]
    {
      \Lens \OfType \Regex \Leftrightarrow \RegexAlt\\
      \inferrule*
      {
      }
      {
        \ConstLensOf{\String_n}{\StringAlt_n} \OfType \String_n \Leftrightarrow \StringAlt_n
      }
    }
    {
      \ConcatLensOf{\Lens}{\ConstLensOf{\String_n}{\StringAlt_n}}
      \OfType
      \Regex \Concat \String_n \Leftrightarrow
      \RegexAlt \Concat \StringAlt_n
    }

    \inferrule*
    {
      \Derivation\\
      \IdentityLensOf{\ToRegex(\Atom_n)} \OfType \ToRegex(\Atom_n) \Leftrightarrow \ToRegex(\Atom_n)
    }
    {
      \ConcatLensOf{\ConcatLensOf{\Lens}{\ConstLensOf{\String_n}{\StringAlt_n}}}{\IdentityLensOf{\ToRegex(\Atom_n)}}
      \OfType\\
      \Regex \Concat \String_n \Concat \ToRegex(\Atom_n) \Leftrightarrow
      \Regex \Concat \StringAlt_n \Concat \ToRegex(\Atom_n)
    }
  \end{mathpar}
  By inspection, this satisfies the desired properties.
\end{proof}

\begin{lemma}[Creation of Lens from Identity Perm Sequence Lens]
  \label{lem:id-clause}
  Suppose
  \begin{enumerate}
  \item $\Sequence=\SequenceOf{\String_0 ; \Atom_1 ; \ldots ; \Atom_n; \String_n}$
  \item $\SequenceAlt=\SequenceOf{\StringAlt_0 ; \AtomAlt_1 ; \ldots ; \AtomAlt_n ; \StringAlt_n}$
  \item $(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1 ; \ldots ;
      \AtomLens_n;(\String_n,\StringAlt_n)},id) \OfType
    \Sequence \Leftrightarrow \SequenceAlt$
  \item For each $\AtomLens_i \OfType \Atom_i \Leftrightarrow \AtomAlt_i$,
    there exists a $\Lens_i \OfType \ToRegex(\Atom_i) \Leftrightarrow
    \ToRegex(\AtomAlt_i)$ such that $\SemanticsOf{\Lens_i}=\SemanticsOf{\AtomLens_i}$
  \end{enumerate}
  then there exists a $\Lens \OfType \ToRegex(\Sequence) \Leftrightarrow \ToRegex(\DNFRegexAlt)$ such that
  $\SemanticsOf{\Lens} =
  \SemanticsOf{(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1 ; \ldots ; \AtomLens_n;(\String_n,\StringAlt_n)},id)}$.
  \begin{proof}
    By induction on $n$.

    Let $n=0$, $(\SequenceLensOf{(\String_0,\StringAlt_0)},id) \OfType
    \SequenceOf{\String_0} \Leftrightarrow \SequenceOf{\StringAlt_0}$.
    Then consider
    \begin{mathpar}
      \inferrule[]
      {
      }
      {
        \ConstLensOf{\String_0}{\StringAlt_0}\OfType\String_0\Leftrightarrow\StringAlt_0
      }
    \end{mathpar}

    $\String_0=\ToRegex(\SequenceOf{\String_0})$,
    and
    $\StringAlt_0=\ToRegex(\SequenceOf{\StringAlt_0})$.
    $\SemanticsOf{\ConstLensOf{\String_0}{\StringAlt_0}}=
    \SetOf{\String_0,\StringAlt_0}=
    \SemanticsOf{\SequenceOf{(\String_0,\StringAlt_0)},id)}$.

    Let $n>0$.
    Let $\Sequence'=\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep
      \ldots\SequenceSep\Atom_{n-1}\SequenceSep\String_{n-1}}$,
    and $\SequenceAlt'=\SequenceOf{\StringAlt_0\SequenceSep\AtomAlt_1\SequenceSep
      \ldots\SequenceSep\AtomAlt_{n-1}\SequenceSep\StringAlt_{n-1}}$
    By induction assumption, there exists a typing derivation
    \begin{mathpar}
      \Lens\OfType\ToRegex(\Sequence')\Leftrightarrow\ToRegex(\SequenceAlt')
    \end{mathpar}
    satisfying $\SemanticsOf{\Lens}=\\
    \SemanticsOf{(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1 ;
        \ldots ; \AtomLens_{n-1};(\String_{n-1},\StringAlt_{n-1})},id)}$

    By problem statement, there exists a typing derivation
    \begin{mathpar}
      \Lens_{\AtomLens_{n}} \OfType
      \ToRegex(\Atom_{n}) \Leftrightarrow \ToRegex(\AtomAlt_{n})
    \end{mathpar}
    satisfying $\SemanticsOf{\Lens_{\Atom_n}}
    =\SemanticsOf{\Atom_n}$.

    Consider the following lens typing
    \begin{mathpar}
      \inferrule*[left=\Derivation{}]
      {
        \Derivation_n\\
        \inferrule*
        {
        }
        {
          \ConstLensOf{\String_n}{\StringAlt_n}
          \OfType
          \String_n \Leftrightarrow \StringAlt_n
        }
      }
      {
        \ConcatLensOf{\Lens_{\AtomLens_n}}{\ConstLensOf{\String_n}{\StringAlt_n}}
        \OfType
        \ToRegex(\Atom_n)\Concat\String_n \Leftrightarrow
        \ToRegex(\AtomAlt_n)\Concat\StringAlt_n
      }

      \inferrule*
      {
        \Lens\OfType\ToRegex(\Sequence) \Leftrightarrow \ToRegex(\SequenceAlt)\\
        \Derivation{}
      }
      {
        \ConcatLensOf
        {\Lens}
        {\ConcatLensOf{\Lens_{\AtomLens_n}}{\ConstLensOf{\String_n}{\StringAlt_n}}}
        \OfType\\
        \ToRegex(\Sequence)\Concat\ToRegex(\Atom_n)\Concat\String_n \Leftrightarrow
        \ToRegex(\SequenceAlt)\Concat\ToRegex(\AtomAlt_n)\Concat\StringAlt_n
      }
    \end{mathpar}

    \SemanticsOf{\ConcatLensOf
      {\Lens}
      {\ConcatLensOf{\Lens_{\AtomLens_n}}{\ConstLensOf{\String_n}{\StringAlt_n}}}}\\
    \hspace*{3em}=\SetOf{(\String,\StringAlt)
      \SuchThat
      \String = \String'\Concat\String''\Concat\String_n\BooleanAnd
      \StringAlt = \StringAlt'\Concat\StringAlt''\Concat\StringAlt_n\BooleanAnd\\
      \hspace*{7em}
      (\String',\StringAlt')\in\SemanticsOf{\Lens}\BooleanAnd
      (\String'',\StringAlt'')\in\SemanticsOf{\Lens_{\AtomLens_n}}}\\
    \hspace*{3em}=\SetOf{
      (\String,\StringAlt)\SuchThat
      \String=
      \String_0\Concat\String_0'\Concat\ldots
      \Concat\String_{n-1}'\Concat\String_{n-1}
      \Concat \String_n \Concat \String_n'\BooleanAnd\\
      \hspace*{7em}\StringAlt=\StringAlt_0\Concat\StringAlt_0'\Concat\ldots
      \Concat\StringAlt_{n-1}'\Concat\StringAlt_{n-1}
      \Concat \StringAlt_n \Concat \StringAlt_n'\BooleanAnd\\
      \hspace*{7em}\String_i'\in\Atom_i\BooleanAnd\StringAlt_i'\in\AtomAlt_i}\\
    \hspace*{3em}=\SemanticsOf{(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1 ;
        \ldots ; \AtomLens_n;(\String_n,\StringAlt_{n-1})},id)}
  \end{proof}
\end{lemma}

\begin{theorem}[Unambiguity of $\Sep$]
  Let $\Alphabet$ be an alphabet.  Let $\Alphabet_{\Sep}=\Alphabet\Union\SetOf{\Sep}$,
  where \Sep{} is a character not in \Alphabet{}.
  If $\Language_1, \ldots,
  \Language_n$, are languages in $\StarOf{\Alphabet}$, then
  $\UnambigConcat\SequenceOf{\LanguageOf{\Sep};\Language_1;\LanguageOf{\Sep};
    \ldots;\LanguageOf{\Sep};\Language_n;\LanguageOf{\Sep}}$.
\end{theorem}
\begin{proof}
  We prove this by induction on $n$.

  Let $n=0$.  $\UnambigConcat\SequenceOf{\LanguageOf{\Sep}}$, as
  $\UnambigConcat\SequenceOf{\Language}$, for any language $\Language$.

  Let $n>0$.
  Let $\String_i, \StringAlt_i\in\Language_i$ for all $i\in\RangeIncInc{1}{n}$,
  and let $\Sep\String_1\Sep\ldots\Sep\String_n\Sep=\Sep\StringAlt_1\Sep\ldots\Sep\StringAlt_n\Sep$.
  We want to show that $\String_n\Sep=\StringAlt_n\Sep$.
  If they were not equal, then one string is strictly contained in the other, say without
  loss of generality $\String_n\Sep$ is strictly contained in $\StringAlt_n\Sep$.
  Because of that $\Sep\String_n\Sep$ is contained in $\StringAlt_n\Sep$, so $\Sep$
  is contained in $\StringAlt_n\in\StarOf{\Sigma}$.  This is a contradiction,
  as $\Sep\notin\Sigma$, so we know $\String_n\Sep=\StringAlt_n\Sep$, and so $\String_n=\StringAlt_n$.
  This means that
  $\Sep\String_0\Sep\ldots\Sep\String_{n-1}\Sep=\Sep\StringAlt_0\Sep\ldots\Sep\StringAlt_{n-1}$,
  so by induction, I know $\String_i=\StringAlt_i$ for all $i$.
\end{proof}

\begin{definition}[Adjacent Swapping Permutation]
  Let $\sigma_{i} \in S_n$ be the permutation where
  $\sigma_{i}(i) = i+1$, $\sigma_{i}(i+1) = i$, $\sigma_{i}(k) = k$
  when $k\neq i$, and $k\neq i+1$.
\end{definition}

\begin{lemma}[Expressibility of Adjacent Swapping Permutation Lens]
  \label{lem:adj-perm-exp}
  Suppose
  \begin{enumerate}
  \item $\sigma_i$ is an adjacent element swapping permutation
  \item $\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep}$ is a sequence with
    all base strings equal to $\Sep$.
  \end{enumerate}
  Then there exists a typing of a lens $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that
  \begin{enumerate}
  \item $\LanguageOf{\Regex}=\LanguageOf{[\Sep;\Atom_1;\ldots;\Atom_n;\Sep]}$
  \item $\LanguageOf{\RegexAlt}=\LanguageOf{[\Sep;\Atom_{\sigma_i(1)};\ldots;\Atom_{\sigma_i(n)};\Sep]}$
  \item $\SemanticsOf{\Lens}=
    \SetOf{(\String,\StringAlt)\SuchThat\String=\Sep\Concat\String_1\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_n\Concat\Sep
      \BooleanAnd\\
      \hspace*{6em}\StringAlt=\Sep\Concat\String_{\sigma_i(1)}\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_{\sigma_i(n)}\Sep\BooleanAnd\\
      \hspace*{6em}\String_i\in\LanguageOf{\Atom_i}}$
  \end{enumerate}
  \begin{proof}
    By the soundness of regular expressions, define regular expressions
    $\Regex_1, \Regex_2, \Regex_3, \Regex_4$ as
    $\Regex_1=\ToRegex([\Sep;\Atom_1;\ldots;\Atom_{i-1};\Sep])$,
    $\Regex_2=\ToRegex(\Atom_i)$,
    $\Regex_3=\ToRegex(\Atom_{i+1})$, and
    $\Regex_4=\ToRegex([\Sep;\Atom_{i+1};\ldots;\Atom_{n};\Sep])$.
    Consider the following deduction
    \begin{mathpar}

      \inferrule*[left=\Derivation{}]
      {
        \inferrule*
        {
        }
        {
          \IdentityLensOf{\Sep} \OfType \Sep \Leftrightarrow \Sep
        }
        \inferrule*
        {
        }
        {
          \IdentityLensOf{\Regex_3} \OfType \Regex_3 \Leftrightarrow \Regex_3
        }
      }
      {
        \SwapLensOf{\IdentityLensOf{\Sep}}{\IdentityLensOf{\Regex_3}} \OfType 
        \Sep\Concat\Regex_3 \Leftrightarrow \Regex_3\Concat\String_i
      }

      \inferrule*[left=\Derivation{}']
      {
        \inferrule*
        {
        }
        {
          \IdentityLensOf{\Regex_2} \OfType \Regex_2 \Leftrightarrow \Regex_2
        }\\
        \Derivation
      }
      {
        \SwapLensOf{\IdentityLensOf{\Regex_2}}{\SwapLensShortOf{\IdentityLensShortOf{\Sep}}{\IdentityLensShortOf{\Regex_3}}} \OfType
        \Regex_2\Concat\Sep\Concat\Regex_3 \Leftrightarrow \Regex_3\Concat\Sep\Concat\Regex_2
      }

      \inferrule*[left=\Derivation{}'']
      {
        \inferrule*
        {
        }
        {
          \IdentityLensOf{\Regex_1} \OfType \Regex_1 \Leftrightarrow \Regex_1
        }\\
        \Derivation{}'
      }
      {
        \ConcatLensOf{\IdentityLensOf{\Regex_1}}{\SwapLensShortOf{\IdentityLensShortOf{\Regex_2}}{\SwapLensShortOf{\IdentityLensShortOf{\Sep}}{\IdentityLensShortOf{\Regex_3}}}} \OfType\\
        \Regex_1\Concat\Regex_2\Concat\Sep\Concat\Regex_3 \Leftrightarrow \Regex_1\Concat\Regex_3\Concat\Sep\Concat\Regex_2
      }


      \inferrule*
      {
        \Derivation{}''\\
        \inferrule*
        {
        }
        {
          \IdentityLensOf{\Regex_4} \OfType \Regex_4 \Leftrightarrow \Regex_4
        }
      }
      {
        \ConcatLensOf{\ConcatLensShortOf{\IdentityLensShortOf{\Regex_1}}{\SwapLensShortOf{\IdentityLensShortOf{\Regex_2}}{\SwapLensShortOf{\IdentityLensShortOf{\Sep}}{\IdentityLensShortOf{\Regex_3}}}}}{\IdentityLensOf{\Regex_4}} \OfType\\
        \Regex_1\Concat\Regex_2\Concat\Sep\Concat\Regex_3\Concat\Regex_4 \Leftrightarrow \Regex_1\Concat\Regex_3\Concat\Sep\Concat\Regex_2\Concat\Regex_4
      }
    \end{mathpar}

    By inspection, the final lens
    $\ConcatLensShortOf{\ConcatLensShortOf{\IdentityLensShortOf{\Regex_1}}{\SwapLensShortOf{\IdentityLensShortOf{\Regex_2}}{\SwapLensShortOf{\IdentityLensShortOf{\Sep}}{\IdentityLensShortOf{\Regex_3}}}}}{\IdentityLensShortOf{\Regex_4}} \OfType
    \Regex_1\Concat\Regex_2\Concat\Sep\Concat\Regex_3\Concat\Regex_4 \Leftrightarrow \Regex_1\Concat\Regex_3\Concat\Sep\Concat\Regex_2\Concat\Regex_4$
    satisfies $\LanguageOf{\Regex_1\Concat\Regex_2\Concat\String_i\Concat\Regex_3\Concat\Regex_4}=\LanguageOf{\SequenceOf{\Sep;\Atom_1;\Sep;\ldots;\Sep;\Atom_n;\Sep}}$ and
    $\LanguageOf{\Regex_1\Concat\Regex_3\Concat\String_i\Concat\Regex_2\Concat\Regex_4}=\LanguageOf{\SequenceOf{\Sep;\Atom_{\sigma_i(1)};\ldots;\Atom_{\sigma_i(n)};\Sep}}$
    and has the desired semantics of swapping the strings at spots $i$ and $i+1$.
  \end{proof}
\end{lemma}

\begin{lemma}[Expressibility of Adjacent Swapping Permutation Composition]
  \label{lem:adj-comp-perm-exp}
  Suppose
  \begin{enumerate}
  \item $\sigma=\sigma_{i_1}\Compose\ldots\Compose\sigma_{i_m}$ 
  \item $\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep}$ is a sequence with
    all base strings equal to $\Sep$.
  \end{enumerate}
  Then there exists a typing of a lens $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that
  \begin{enumerate}
  \item $\LanguageOf{\Regex}=\LanguageOf{[\Sep;\Atom_1;\ldots;\Atom_n;\Sep]}$
  \item $\LanguageOf{\RegexAlt}=\LanguageOf{[\Sep;\Atom_{\sigma(1)};\ldots;\Atom_{\sigma(n)};\Sep]}$
  \item $\SemanticsOf{\Lens}=
    \SetOf{(\String,\StringAlt)\SuchThat\String=\Sep\Concat\String_1\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_n\Concat\Sep
      \BooleanAnd\\
      \hspace*{6em}\StringAlt=\Sep\Concat\String_{\sigma(1)}\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_{\sigma(n)}\Sep\BooleanAnd\\
      \hspace*{6em}\String_i\in\LanguageOf{\Atom_i}}$
  \end{enumerate}
  \begin{proof}
    By induction on $m$.

    Let $m=0$.  Then $\sigma=\Identity$.  Consider the lens
    $\IdentityLensOf{\ToRegex(\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep})} \OfType
    \ToRegex(\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep}) \Leftrightarrow
    \ToRegex(\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep})$.
    By inspection, this lens satisfies the requirements.

    Let $m>0$.  Let $\sigma'=\sigma_{i_1}\Compose\ldots\Compose\sigma_{i_{m-1}}$.
    Let $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ be the lens obtained by an
    application of the induction assumption on $\sigma'$.
    Let $\Lens_m \OfType \RegexAlt' \Leftrightarrow \RegexAlt''$ be the lens obtained by
    an application of Lemma~\ref{lem:adj-perm-exp} to the permutation $\sigma_m$ and
    the sequence $\SequenceOf{\Sep;\Atom_{\sigma'(1)};\ldots;\Atom_{\sigma'(n)};\Sep}$.
    From the induction assumption and the previous lemmas,
    we know $\LanguageOf{\RegexAlt}=
    \LanguageOf{\SequenceOf{\Sep;\Atom_{\sigma'(1)};\ldots;\Atom_{\sigma'(n)};\Sep}}=
    \LanguageOf{\RegexAlt'}$.
    Consider the following Lens typing

    \begin{mathpar}
      \inferrule*
      {
        \inferrule*
        {
          \Lens \OfType \Regex \Leftrightarrow \RegexAlt\\
          \LanguageOf{\RegexAlt}=\LanguageOf{\RegexAlt'}
        }
        {
          \Lens \OfType \Regex \Leftrightarrow \RegexAlt'
        }\\
        \Lens_m \OfType \RegexAlt' \Leftrightarrow \RegexAlt''
      }
      {
        \ComposeLensOf{\Lens_m}{\Lens} \OfType \Regex \Leftrightarrow \RegexAlt''
      }
    \end{mathpar}

    The language of \Regex{} is already as desired, and
    $\LanguageOf{\RegexAlt''}=
    \LanguageOf{\SequenceOf{\Sep;\Atom_{\sigma_m\Compose\sigma'(1)};\ldots;\Atom_{\sigma_m\Compose\sigma'(n)}}}=
    \LanguageOf{\SequenceOf{\Sep;\Atom_{\sigma(1)};\ldots;\Atom_{\sigma(n)}}}$, as desired.
    Furthermore, the composition of the lenses composes the permutations of strings,
    giving the semantics as desired.
  \end{proof}
\end{lemma}

\begin{lemma}[Expressibility of Permutation]
  \label{lem:perm-exp}
  Suppose
  \begin{enumerate}
  \item $\sigma$ is a permutation in $S_n$
  \item $\SequenceOf{\Sep;\Atom_1;\Sep\ldots\Sep;\Atom_n;\Sep}$ is a sequence with
    all base strings equal to $\Sep$.
  \end{enumerate}
  Then there exists a typing of a lens $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that
  \begin{enumerate}
  \item $\LanguageOf{\Regex}=\LanguageOf{[\Sep;\Atom_1;\ldots;\Atom_n;\Sep]}$
  \item $\LanguageOf{\RegexAlt}=\LanguageOf{[\Sep;\Atom_{\sigma(1)};\ldots;\Atom_{\sigma(n)};\Sep]}$
  \item $\SemanticsOf{\Lens}=
    \SetOf{(\String,\StringAlt)\SuchThat\String=\Sep\Concat\String_1\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_n\Concat\Sep
      \BooleanAnd\\
      \hspace*{6em}\StringAlt=\Sep\Concat\String_{\sigma(1)}\Concat\Sep\Concat\ldots\Concat\Sep\Concat\String_{\sigma(n)}\Sep\BooleanAnd\\
      \hspace*{6em}\String_i\in\LanguageOf{\Atom_i}}$
  \end{enumerate}
\end{lemma}
\begin{proof}
  By algebra, any permutation can be expressed as the composition of adjacent swapping permutations.
  As such, $\sigma=\sigma_{i_1}\Compose\ldots\Compose\sigma_{i_m}$ for some adjacency swapping
  permutations $\sigma_{i_j}$.
  By Lemma~\ref{lem:adj-comp-perm-exp}, we obtain a lens with the properties desired.
\end{proof}

\begin{lemma}[Creation of Lens from Identity Perm DNF Lens]
  \label{lem:id-dnf}
  Suppose
  \begin{enumerate}
  \item $\DNFRegex = \DNFOf{\Sequence_1 ; \ldots ; \Sequence_n}$
  \item $\DNFRegexAlt = \DNFOf{\SequenceAlt_1 ; \ldots ; \SequenceAlt_n}$
  \item $(\DNFLensOf{\SequenceLens_1 ; \ldots ; \SequenceLens_n},id) \OfType
    \DNFRegex \Leftrightarrow \DNFRegexAlt$
  \item For each $\SequenceLens_i \OfType \Sequence_i \Leftrightarrow \SequenceAlt_i$,
    there exists a $\Lens_i$ such that $\SemanticsOf{\Lens_i}=\SemanticsOf{\SequenceLens_i}$.
  \end{enumerate}
  then there exists a $\Lens \OfType \ToRegex(\DNFRegex) \Leftrightarrow \ToRegex(\DNFRegexAlt)$ such that $\SemanticsOf{\Lens} = \SemanticsOf{([\SequenceLens_1 ; \ldots ; \SequenceLens_n],id)}$.
  \begin{proof}
    By induction on n

    Let $n=0$.
    $\DNFLensOf{} \OfType \DNFOf{} \Leftrightarrow \DNFOf{}$.  Then consider
    \begin{mathpar}
      \inferrule*
      {
      }
      {
        \IdentityLensOf{\ToRegex(\DNFOf{})} \OfType
        \ToRegex(\DNFOf{}) \Leftrightarrow \ToRegex(\DNFOf{})
      }
    \end{mathpar}
    This has the desired typing, and
    $\SemanticsOf{\IdentityLensOf{\ToRegex(\DNFOf{})}}
    =\SemanticsOf{\IdentityLensOf{\emptyset}}
    =\SetOf{}=\SemanticsOf{\DNFLensOf{}}$.

    Let $n>0$.
    Let $\DNFRegex' = \DNFOf{\Sequence_1;\ldots;\Sequence_{n-1}}$, and
    $\DNFRegexAlt' = \DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_{n-1}}$.
    By induction assumption, there exists a derivation of 
    $\Lens \OfType \ToRegex(\DNFRegex') \Leftrightarrow \ToRegex(\DNFRegexAlt')$.
    By problem statement, there exists a typing derivation
    $\Lens_n \OfType \ToRegex(\Sequence_n) \Leftrightarrow \ToRegex(\SequenceAlt_n)$
    Consider the following derivation
    \begin{mathpar}
      \inferrule*
      {
        \Lens \OfType \ToRegex(\DNFRegex') \Leftrightarrow \ToRegex(\DNFRegexAlt')\\
        \Lens_n \OfType \ToRegex(\Sequence_n) \Leftrightarrow \ToRegex(\SequenceAlt_n)
      }
      {
        \OrLensOf{\Lens_n}{\Lens} \OfType \RegexOr{\ToRegex(\DNFRegex')}{\ToRegex(\Sequence_n)} \Leftrightarrow \RegexOr{\ToRegex(\DNFRegexAlt')}{\ToRegex(\Sequence_n)}
      }
    \end{mathpar}
    $\SemanticsOf{\OrLensOf{\Lens}{\Lens_n}}=\SetOf{(\String,\StringAlt)\SuchThat
      (\String,\StringAlt)\in\Lens\BooleanOr(\String,\StringAlt)\in\Lens_n}$\\
    \hspace*{4.6em}$=\SetOf{(\String,\StringAlt)\SuchThat
      (\String,\StringAlt)\in\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_{n-1}}\\
      \hspace*{8em}\BooleanOr(\String,\StringAlt)\in\DNFLensOf{\SequenceLens_n}}$\\
    \hspace*{4.6em}$=\SetOf{(\String,\StringAlt)\SuchThat
      (\String,\StringAlt)\in\SequenceLens_i}$.
  \end{proof}
\end{lemma}

\begin{lemma}[Ineffectiveness of Permutation on DNF Regex Semantics]
  \label{lem:dnfr-perm-sem-ineffective}
  Let $\sigma\in S_n$, and $\DNFOf{\Sequence_1\ldots\Sequence_n}$ be a DNF regex.
  $\LanguageOf{\DNFOf{\Sequence_1;\ldots;\Sequence_n}}=
  \LanguageOf{\DNFOf{\Sequence_{\sigma(1)};\ldots;\Sequence_{\sigma(n)}}}$.
\end{lemma}
\begin{proof}
  By inspection.
\end{proof}

\begin{lemma}[Ineffectiveness of Permutation on DNF Lens Semantics]
  \label{lem:dnfl-perm-sem-ineffective}
  Let $\sigma\in S_n$, and
  $(\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n},\Identity) \OfType
  \DNFOf{\Sequence_1;\ldots;\Sequence_n} \Leftrightarrow
  \DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_n}$ be a typing of a DNF lens with
  an identity permutation.
  $\SemanticsOf{(\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n},\Identity)}
  =\SemanticsOf{(\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n},\sigma)}$
\end{lemma}
\begin{proof}
  By inspection
\end{proof}

\begin{lemma}[Single Rewrites Respecting Language]
  \label{lem:single-rrl}
  \leavevmode
  \begin{itemize}
  \item If $\Atom\RewriteAtom\DNFRegex$, then $\LanguageOf{\Atom} = \LanguageOf{\DNFRegex}$
  \item If $\DNFRegex\Rewrite\DNFRegexAlt$, then $\LanguageOf{\DNFRegex}=\LanguageOf{\DNFRegexAlt}$
  \end{itemize}
\end{lemma}
\begin{proof}
  By mutual induction on the derivation of $\Rewrite$ and $\RewriteAtom$
  \begin{case}[\AtomUnrollstarLeftRule{}]
    \[
      \inferrule*
      {
      }
      {
        \StarOf{\DNFRegex}\RewriteAtom
        \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}{(\ConcatDNFOf{\DNFRegex}{\AtomToDNFOf{\StarOf{\DNFRegex}}})}
      }
    \]

    Let $\ToRegexOf{\DNFRegex} = \Regex$.

    $\StarOf{\Regex} \equiv \EmptyString \Or (\Regex \Concat
    \StarOf{\Regex})$, by Lemma~\ref{lem:defequiv-finer-equiv}.
    By Theorem~\ref{thm:dnfrs},
    $\LanguageOf{\ToDNFRegexOf{\StarOf{\Regex}}} =
    \LanguageOf{\ToDNFRegexOf{(\EmptyString \Or (\Regex \Concat
        \StarOf{\Regex}))}}$.
    So $\LanguageOf{\AtomToDNFOf{\StarOf{(\ToDNFRegexOf{\Regex})}}} =
    \LanguageOf{\ToDNFRegexOf{(\EmptyString \Or (\Regex \Concat
        \StarOf{\Regex}))}}$.
    So by Lemma~\ref{lem:atomtodnfeq}, and application of $\ToDNFRegex$,
    $\LanguageOf{\StarOf{\DNFRegex}} =
    \LanguageOf{\DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      \DNFRegex \ConcatDNF \AtomToDNFOf{(\StarOf{\DNFRegex})}}$, as desired.
  \end{case}
  
  \begin{case}[\AtomUnrollstarRightRule{}]
    \[
      \inferrule*
      {
      }
      {
        \StarOf{\DNFRegex}\RewriteAtom
        \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}{(\ConcatDNFOf{\AtomToDNFOf{\StarOf{\DNFRegex}}}{\DNFRegex})}
      }
    \]

    Let $\ToRegexOf{\DNFRegex} = \Regex$.

    $\StarOf{\Regex} \equiv \EmptyString \Or (\Regex \Concat
    \StarOf{\Regex})$, by Lemma~\ref{lem:defequiv-finer-equiv}.
    By Theorem~\ref{thm:dnfrs},
    $\LanguageOf{\ToDNFRegexOf{\StarOf{\Regex}}} =
    \LanguageOf{\ToDNFRegexOf{(\EmptyString \Or (\StarOf{\Regex} \Concat
        \Regex))}}$.
    So $\LanguageOf{\AtomToDNFOf{\StarOf{(\ToDNFRegexOf{\Regex})}}} =
    \LanguageOf{\ToDNFRegexOf{(\EmptyString \Or (\StarOf{\Regex} \Concat
        \Regex))}}$.
    So by Lemma~\ref{lem:atomtodnfeq}, and application of $\ToDNFRegex$,
    $\LanguageOf{\StarOf{\DNFRegex}} =
    \LanguageOf{\DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      \AtomToDNFOf{(\StarOf{\DNFRegex})} \ConcatDNF \DNFRegex}$, as desired.
  \end{case}

  \begin{case}[\AtomStructuralRewriteRule{}]
    \[
      \inferrule*
      {
        \DNFRegex \Rewrite \DNFRegexAlt
      }
      {
        \StarOf{\DNFRegex} \RewriteAtom \AtomToDNFOf{\StarOf{\DNFRegexAlt}}
      }
    \]

    $\LanguageOf{\DNFRegex} = \LanguageOf{\DNFRegexAlt}$,
    so $\LanguageOf{\StarOf{\DNFRegex}} = \LanguageOf{\StarOf{\DNFRegexAlt}}$.
    Through application of Lemma~\ref{lem:atomtodnfeq},
    $\LanguageOf{\StarOf{\DNFRegex}} =
    \LanguageOf{\AtomToDNFOf{\StarOf{\DNFRegexAlt}}}$.
  \end{case}

  \begin{case}[\DNFStructuralRewriteRule]
    \[
      \inferrule*
      {
        \Atom_j \RewriteAtom \DNFRegex
      }
      {
        \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
        \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}
        \ConcatDNF \AtomToDNFOf{\Atom_j} \ConcatDNF
        \DNFOf{\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m}}
        \OrDNF \DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n}\Rewrite\\
        \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
        \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}\ConcatDNF\DNFRegex\ConcatDNF\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m} \OrDNF
        \DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n}
      }
    \]

    As $\LanguageOf{\AtomToDNFOf{\Atom_j}} = \LanguageOf{\DNFRegex}$, by IH and
    Lemma~\ref{lem:atomtodnfeq}, and because the left side is the same as the
    right, except with $\AtomToDNFOf{\Atom_j}$ replacing $\DNFRegex$, the two
  languages are the same.

  \end{case}
\end{proof}

\begin{lemma}[Rewrites Respecting Language]
  \label{lem:rrl}
  If $\DNFRegex \StarOf{\Rewrite} \DNFRegexAlt$, then
  $\LanguageOf{\DNFRegex} = \LanguageOf{\DNFRegexAlt}$
\end{lemma}
\begin{proof}
  By induction on the derivation of $\StarOf{\Rewrite}$

  \begin{case}[\ReflexivityRule{}]
    \[
      \inferrule*
      {
      }
      {
        \DNFRegex \StarOf{\Rewrite} \DNFRegex
      }
    \]

    $\LanguageOf{\DNFRegex} = \LanguageOf{\DNFRegex}$ so we're done.
  \end{case}

  \begin{case}[\BaseRule{}]
    \[
      \inferrule*
      {
        \DNFRegex \Rewrite \DNFRegexAlt
      }
      {
        \DNFRegex \StarOf{\Rewrite} \DNFRegexAlt
      }
    \]
    
    By Lemma~\ref{lem:single-rrl}, as $\DNFRegex \Rewrite \DNFRegexAlt$,
    $\LanguageOf{\DNFRegex} = \LanguageOf{\DNFRegexAlt}$.
  \end{case}

  \begin{case}
    \[
      \inferrule*
      {
        \DNFRegex \StarOf{\Rewrite} \DNFRegex'\\
        \DNFRegex' \StarOf{\Rewrite} \DNFRegexAlt
      }
      {
        \DNFRegex \StarOf{\Rewrite} \DNFRegexAlt
      }
    \]

    By IH, $\LanguageOf{\DNFRegex} = \LanguageOf{\DNFRegex'}$.
    By IH, $\LanguageOf{\DNFRegex'} = \LanguageOf{\DNFRegexAlt}$.
    So $\LanguageOf{\DNFRegex} = \LanguageOf{\DNFRegexAlt}$.
  \end{case}
\end{proof}

\begin{lemma}
  If $\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$, then
  $\SemanticsOf{\DNFLens}$ is a bijection between $\LanguageOf{\DNFRegex}$ and
  $\LanguageOf{\DNFRegexAlt}$.
\end{lemma}
\begin{proof}
  TODO
\end{proof}

\begin{lemma}[Soundness of DNF, Sequence, and Atom Lenses]\leavevmode
  \label{lem:dnfcal}
  \begin{enumerate}
  \item Let \DNFRegex{} and \DNFRegexAlt{} be two dnf regular expressions, and $\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$.  Then there exists a \Lens{} such that $\Lens \OfType \ToRegex(\DNFRegex) \Leftrightarrow \ToRegex(\DNFRegexAlt)$, \SemanticsOf{\Lens}=\SemanticsOf{\DNFLens}

  \item Let \Sequence{} and \SequenceAlt{} be two clauses, and $\SequenceLens \OfType \Sequence \Leftrightarrow \SequenceAlt$.  Then there exists a \Lens{} such that $\Lens \OfType \ToRegex(\Sequence) \Leftrightarrow \ToRegex(\SequenceAlt)$, \SemanticsOf{\Lens}=\SemanticsOf{\SequenceLens}.

  \item Let \Atom{} and \AtomAlt{} be two atoms, and $\AtomLens \OfType \Atom \Leftrightarrow \AtomAlt$.  Then there exists a \Lens{}, such that $\Lens \OfType \ToRegex(\Atom) \Leftrightarrow \ToRegex(\AtomAlt)$, \SemanticsOf{\Lens}=\SemanticsOf{\AtomLens}.
  \end{enumerate}
  \begin{proof}
    By mutual induction on the structure of the DNF Regex, Sequence, and
    Atom lenses typing.\\ 
    \\
    Let $\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$ be formed from an
    application of\\$\RewriteDNFRegexLensRule{}$.
    \begin{mathpar}
      \inferrule*
      {
        \DNFLens \OfType \DNFRegex' \Leftrightarrow \DNFRegexAlt'\\
        \DNFRegex' \Rewrite \DNFRegex\\
        \DNFRegexAlt' \Rewrite \DNFRegexAlt
      }
      {
        \DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt
      }
    \end{mathpar}
    By induction assumption, there exists a
    $\Lens \OfType \ToRegex(\DNFRegex') \Leftrightarrow \ToRegex(\DNFRegexAlt')$,
    and from Lemma~\ref{lem:rrl}, we know
    $\LanguageOf{\DNFRegex}=\LanguageOf{\DNFRegex'}$, and
    $\LanguageOf{\DNFRegexAlt}=\LanguageOf{\DNFRegexAlt'}$.
    Consider the derivation
    \begin{mathpar}
      \inferrule*
      {
        \Lens \OfType \ToRegex(\DNFRegex') \Leftrightarrow \ToRegex(\DNFRegexAlt')\\
        \LanguageOf{\ToRegex(\DNFRegex')} = \LanguageOf{\ToRegex(\DNFRegex)}\\
        \LanguageOf{\ToRegex(\DNFRegexAlt')} = \LanguageOf{\ToRegex(\DNFRegexAlt)}
      }
      {
        \Lens \OfType \ToRegex(\DNFRegex) \Leftrightarrow \ToRegex(\DNFRegexAlt)
      }
    \end{mathpar}
    This has the desired typing, and by induction assumption, has the desired semantics.\\
    \\
    Let $(\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n},\sigma) \OfType \DNFOf{\Sequence_1;\ldots;\Sequence_n} \Leftrightarrow \DNFOf{\SequenceAlt_{\sigma(1)};\ldots;\SequenceAlt_{\sigma(n)}}$ be formed from an application of $\DNFLensRule$.
    By Induction assumption, for each $\SequenceLens_i \OfType \Sequence_i \Leftrightarrow \SequenceAlt_i$ there exists a $\Lens_i \OfType \ToRegex(\Sequence_i) \Leftrightarrow \ToRegex(\SequenceAlt_i)$.\\
    By Lemma~\ref{lem:id-dnf} there exists a $\Lens \OfType \ToRegex(\DNFOf{\Sequence_1;\ldots;\Sequence_{n}}) \Leftrightarrow \ToRegex(\DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_{n}})$ such that $\SemanticsOf{\Lens}=\SemanticsOf{([\SequenceLens_1;\ldots\SequenceLens_n],id)}$,
    By Lemma~\ref{lem:dnfl-perm-sem-ineffective},
    $\SemanticsOf{(DNFOf{\SequenceLens_1;\ldots;\SequenceLens_n},id)}=
    \SemanticsOf{(\DNFOf{\SequenceLens_1;\ldots;\SequenceLens_n},\sigma)}$.
    By Lemma~\ref{lem:dnfr-perm-sem-ineffective},
    $\LanguageOf{\DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_n}}=
    \LanguageOf{\DNFOf{\SequenceAlt_{\sigma(1)};\ldots;\SequenceAlt_{\sigma(n)}}}$.
    Consider the following typing

    \begin{mathpar}
      \inferrule*
      {
        \Lens \OfType \ToRegex(\DNFOf{\Sequence_1;\ldots;\Sequence_{n}}) \Leftrightarrow \ToRegex(\DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_{n}})\\
        \LanguageOf{\ToRegex(\DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_{n}})} =
        \LanguageOf{\ToRegex(\DNFOf{\SequenceAlt_{\sigma(1)};\ldots;\SequenceAlt_{\sigma(n)}})}
      }
      {
        \Lens \OfType \ToRegex(\DNFOf{\Sequence_1;\ldots;\Sequence_{n}}) \Leftrightarrow \ToRegex(\DNFOf{\SequenceAlt_{\sigma(1)};\ldots;\SequenceAlt_{\sigma(n)}})
      }
    \end{mathpar}
    This has the typing and semantics as desired.\\
    \\
    Let $(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)},\sigma \in S_n) \OfType \SequenceOf{\String_0 ; \Atom_1 ; \ldots ; \Atom_n ; \String_n} \Leftrightarrow \SequenceOf{\StringAlt_0; \AtomAlt_{\sigma(1)} ; \ldots ; \AtomAlt_{\sigma(n)} ; \StringAlt_n}$ be formed from an
    application of\\$\SequenceLensRule{}$.
    By induction assumption, for each
    $\AtomLens_i \OfType \Atom_i \Leftrightarrow \AtomAlt_i$ there exists a
    $\Lens_i \OfType \ToRegex(\Regex_i) \Leftrightarrow \ToRegex(\RegexAlt_i)$.
    By Lemma~\ref{lem:id-clause}, there exists a $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ such that $\SemanticsOf{\Lens}=\SemanticsOf{([(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)],id)}$,
    $\Regex=\ToRegex(\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n})$, and
    $\RegexAlt=\ToRegex(\SequenceOf{\StringAlt_0;\AtomAlt_1;\ldots;\AtomAlt_n;\StringAlt_n})$.
    Define $\RegexAlt_{\Sep}$ as $\ToRegex(\SequenceOf{\Sep;\AtomAlt_1;\ldots;\AtomAlt_n;\Sep})$.
    By Lemma~\ref{lem:boilerplate-alterations}, there exists a
    $\Lens' \OfType \RegexAlt \Leftrightarrow \RegexAlt_{\Sep}$, with semantics of
    merely changing the boilerplate.
    By Lemma~\ref{lem:perm-exp}, there exists a $\Lens'' \OfType \RegexAlt_{\Sep}'
    \Leftrightarrow \RegexAlt_{\Sep}''$ where
    $\SemanticsOf{\RegexAlt_{\Sep}'}=\SemanticsOf{\RegexAlt_{\Sep}}$ and 
    $\SemanticsOf{\RegexAlt_{\Sep}''}=\SemanticsOf{\SequenceOf{\Sep; \AtomAlt_{\sigma(1)} ; \ldots ; \AtomAlt_{\sigma(n)} ; \Sep}}$.
    Lastly, with Lemma~\ref{lem:boilerplate-alterations}, there exists a
    $\Lens''' \OfType \RegexAlt_{\Sep}'' \Leftrightarrow \RegexAlt'$, where
    $\RegexAlt = \ToRegex(\SequenceOf{\StringAlt_0; \AtomAlt_{\sigma(1)} ; \ldots ; \AtomAlt_{\sigma(n)} ; \StringAlt_n})$.
    Through composition of all these lenses, we finally get a lens with the desired type
    and semantics.\\
    \\
    Let $\IterateLensOf{\DNFLens} \OfType \StarOf{\DNFRegex} \Leftrightarrow \StarOf{\DNFRegexAlt}$
    be introduced through an application of \AtomLensRule{}.
    From induction assumption, I know that there exists $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$, such that
    $\SemanticsOf{\DNFLens}=\SemanticsOf{\Lens}$,
    \Regex=\ToRegex(\DNFRegex), and
    $\RegexAlt=\ToRegex(\DNFRegexAlt)$.\\
    Consider $\IterateLensOf{\Lens} \OfType \StarOf{\Regex} \Leftrightarrow \StarOf{\RegexAlt}$.\\
    By definition, $\StarOf{\Regex}$ and $\StarOf{\RegexAlt}$ are $\ToRegex(\StarOf{\DNFRegex})$
    and $\ToRegex(\StarOf{\Regex})$, respectively.

    \begin{tabular}{RcL}
      \SemanticsOf{\IterateLensOf{\Lens}} & = &
                                                \SetOf{(\String_0\ldots\String_n,\StringAlt_0\ldots\StringAlt_n)\SuchThat
                                                (\String_i,\StringAlt_i)\in\SemanticsOf{\Lens}}\\
                                          & = &
                                                \SetOf{(\String_0\ldots\String_n,\StringAlt_0\ldots\StringAlt_n)\SuchThat
                                                (\String_i,\StringAlt_i)\in\SemanticsOf{\DNFLens}}\\
                                          & = &
                                                \SemanticsOf{\IterateLensOf{\DNFLens}}
    \end{tabular}
  \end{proof}
\end{lemma}

\dnfls*
\begin{proof}

  The soundess of DNF lenses follows immediatley from Lemma~\ref{lem:dnfcal}

\end{proof}

\begin{theorem}[Strong DNF Lens Soundness]
  Let $\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$, be the typing
  of a DNF lens $\DNFLens$.
  and let $\Regex$ and $\RegexAlt$ be regular expressions, such that
  $\LanguageOf{\DNFRegex}=\LanguageOf{\Regex}$,
  and $\LanguageOf{\DNFRegexAlt}=\LanguageOf{\RegexAlt}$.
  There exists a lens $\Lens : \Regex \Leftrightarrow \RegexAlt$, such that
  $\SemanticsOf{\Lens}=\SemanticsOf{\DNFLens}$.
\end{theorem}

\begin{proof}
  By Theorem~\ref{thm:dnfls}, there exist regular expressions $\Regex'$,
  $\RegexAlt'$, such that there exists a lens $\DNFLens$ such there is the
  derivation for a typing.
  \begin{mathpar}
    \inferrule[]
    {
      \Derivation{}
    }
    {
      \DNFLens \OfType \Regex' \Leftrightarrow \RegexAlt'
    }
  \end{mathpar}
  \SemanticsOf{\DNFLens}=\SemanticsOf{\Lens},
  \LanguageOf{\Regex'}=\LanguageOf{\DNFRegex},
  and \LanguageOf{\RegexAlt'}=\LanguageOf{\DNFRegexAlt'}.
  Because of this, $\Regex'\equiv\Regex$, and $\RegexAlt'\equiv\RegexAlt$.
  Consider the typing
  \begin{mathpar}
    \inferrule*
    {
      \inferrule*
      {
        \Derivation{}
      }
      {
        \DNFLens \OfType \Regex' \Leftrightarrow \RegexAlt'
      }\\
      \Regex'\equiv\Regex\\
      \RegexAlt'\equiv\RegexAlt
    }
    {
      \DNFLens \OfType \Regex \Leftrightarrow \RegexAlt
    }
  \end{mathpar}

  This satisfies the needed requirements!
\end{proof}
% proof-dnfls end


% proof-dnflc start
% We will prove a couple of lemmas first.

\begin{lemma}[DNF Lens Inversion]
  \label{lem:dnf-lens-inversion}
  \leavevmode
  \begin{enumerate}
  \item If $\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$, then there
    exists some $\DNFRegex'$, $\DNFRegexAlt'$ such that
    $\DNFLens \OfRewritelessType \DNFRegex' \Leftrightarrow \DNFRegexAlt'$,
    $\DNFRegex \StarOf{\Rewrite} \DNFRegex'$, and $\DNFRegexAlt
    \StarOf{\Rewrite} \DNFRegexAlt'$.
  \item If $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt$,
    then there exists some $n\in\Nats$, $\Sequence_1,\ldots,\Sequence_n$,
    $\SequenceAlt_1,\ldots\SequenceAlt_n$, $\sigma\in\PermutationSetOf{n}$, and
    $\SequenceLens_1;\ldots;\SequenceLens_n$ such that
    for all $i\in\RangeIncInc{1}{n}$, $\SequenceLens_i \OfRewritelessType
    \Sequence_i \Leftrightarrow \SequenceAlt_i$, $\DNFLens =
    (\DNFLensOf{\Sequence_0;\ldots;\Sequence_n},\sigma)$, $\DNFRegex =
    \DNFOf{\Sequence_1;\ldots;\Sequence_n}$, and $\DNFRegexAlt =
    \DNFOf{\SequenceAlt_{\sigma(1)};\ldots;\SequenceAlt_{\sigma(n)}}$.
  \item If $\SequenceLens \OfRewritelessType \Sequence \Leftrightarrow
    \SequenceAlt$, there exists some $n \in \Nats$,
    $\Atom_1,\ldots,\Atom_n$, $\AtomAlt_1,\ldots,\AtomAlt_n$,
    $String_0,\ldots,\String_n$, $\StringAlt_0,\ldots,\StringAlt_n$,
    $\sigma\in\PermutationSetOf{n}$, and $\AtomLens_1,\ldots,\AtomLens_n$ such that
    for all $i\in\RangeIncInc{1}{n}$, $\AtomLens_i \OfRewritelessType \Atom_i
    \Leftrightarrow \AtomAlt_i$, $\SequenceLens =
    (\SequenceLensOf{(\String_0,\StringAlt_0);\Atom_1;\ldots;
      \Atom_n;(\String_n,\StringAlt_n)},\sigma)$, $\Sequence =
    \SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}$, and $\SequenceAlt =
    \SequenceOf{\StringAlt_0;\Atom_{\sigma(1)};\ldots;\Atom_{\sigma(n)};\StringAlt_n}$.
  \item If $\AtomLens \OfRewritelessType \Atom \Leftrightarrow \AtomAlt$, then
    there exists some $\DNFLens$, $\DNFRegex$, $\DNFRegexAlt$, such that
    $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt$,
    $\AtomLens = \IterateLensOf{\DNFLens}$, $\Atom = \StarOf{\DNFRegex}$, and
    $\AtomAlt = \StarOf{\DNFRegexAlt}$.
  \end{enumerate}
\end{lemma}
\begin{proof}\leavevmode
  \begin{enumerate}
  \item
    Let $\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$.  The
    only rule that introduces a typing of this form is
    \RewriteDNFRegexLensRule{}.  Because of this, there
    exists some $\DNFRegex'$, $\DNFRegexAlt'$ such that
    $\DNFLens \OfRewritelessType \DNFRegex' \Leftrightarrow \DNFRegexAlt'$,
    $\DNFRegex \StarOf{\Rewrite} \DNFRegex'$, and $\DNFRegexAlt
    \StarOf{\Rewrite} \DNFRegexAlt'$, to build up the typing
    \[
      \inferrule*
      {
        \DNFLens \OfRewritelessType \DNFRegex' \Leftrightarrow \DNFRegexAlt'\\
        \DNFRegex \StarOf{\Rewrite} \DNFRegex'\\
        \DNFRegexAlt \StarOf{\Rewrite} \DNFRegexAlt'
      }
      {
        \DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt
      }
    \]
  \item
    Let $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt$.
    The only rule that introduces a typing of this form is \DNFLensRule{}.
    Because of this there exists some $n\in\Nats$, $\Sequence_1,\ldots,\Sequence_n$,
    $\SequenceAlt_1,\ldots\SequenceAlt_n$, $\sigma\in\PermutationSetOf{n}$, and
    $\SequenceLens_1;\ldots;\SequenceLens_n$ such that
    for all $i\in\RangeIncInc{1}{n}$, $\SequenceLens_i \OfRewritelessType
    \Sequence_i \Leftrightarrow \SequenceAlt_i$, $\DNFLens =
    (\DNFLensOf{\Sequence_0;\ldots;\Sequence_n},\sigma)$, $\DNFRegex =
    \DNFOf{\Sequence_1;\ldots;\Sequence_n}$, $\DNFRegexAlt =
    \DNFOf{\SequenceAlt_{\sigma(1)};\ldots;\SequenceAlt_{\sigma(n)}}$,
    $i \neq j \BooleanImplies \Sequence_i \Intersect \Sequence_j = \emptyset$,
    and
    $i \neq j \BooleanImplies \SequenceAlt_i \Intersect \SequenceAlt_j = \emptyset$,
    to build up the typing
    \[
      \inferrule*
      {
        \SequenceLens_i \OfRewritelessType \Sequence_i \Leftrightarrow
        \SequenceAlt_i\\
        i \neq j \BooleanImplies \Sequence_i \Intersect \Sequence_j =
        \emptyset\\
        i \neq j \BooleanImplies \SequenceAlt_i \Intersect \SequenceAlt_j =
        \emptyset
      }
      {
        \DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt
      }
    \]
  \item
    Let $\SequenceLens \OfRewritelessType \Sequence \Leftrightarrow \SequenceAlt$.
    The only rule that introduces a typing of this form is \SequenceLensRule{}.
    Because of this there exists some $n \in \Nats$,
    $\Atom_1,\ldots,\Atom_n$, $\AtomAlt_1,\ldots,\AtomAlt_n$,
    $String_0,\ldots,\String_n$, $\StringAlt_0,\ldots,\StringAlt_n$,
    $\sigma\in\PermutationSetOf{n}$, and $\AtomLens_1,\ldots,\AtomLens_n$ such that
    for all $i\in\RangeIncInc{1}{n}$, $\AtomLens_i \OfRewritelessType \Atom_i
    \Leftrightarrow \AtomAlt_i$, $\SequenceLens =
    (\SequenceLensOf{(\String_0,\StringAlt_0);\Atom_1;\ldots;
      \Atom_n;(\String_n,\StringAlt_n)},\sigma)$, $\Sequence =
    \SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}$, and $\SequenceAlt =
    \SequenceOf{\StringAlt_0;\Atom_{\sigma(1)};\ldots;\Atom_{\sigma(n)};\StringAlt_n}$
    to build up the typing
    \[
      \inferrule*
      {
        \AtomLens_i \OfRewritelessType \Atom_i \Leftrightarrow \AtomAlt_i\\
        \SequenceUnambigConcatOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}\\
        \SequenceUnambigConcatOf{\StringAlt_0;\AtomAlt_{\sigma(1)};\ldots;\AtomAlt_{\sigma(n)};\StringAlt_n}
      }
      {
        (\SequenceLensOf{(\String_0,\StringAlt_0);\Atom_1;\ldots;
          \Atom_n;(\String_n,\StringAlt_n)},\sigma) \OfRewritelessType
        \SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n} \Leftrightarrow
        \SequenceOf{\StringAlt_0;\Atom_{\sigma(1)};\ldots;\Atom_{\sigma(n)};\StringAlt_n}
      }
    \]
  \item
    Let $\AtomLens \OfRewritelessType \Atom \Leftrightarrow \AtomAlt$.
    The only rule that introduces a typing of this form is
    \AtomLensRule{}.
    Because of this, there exists some $\DNFLens$, $\DNFRegex$, $\DNFRegexAlt$, such that
    $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt$,
    $\AtomLens = \IterateLensOf{\DNFLens}$, $\Atom = \StarOf{\DNFRegex}$, and
    $\AtomAlt = \StarOf{\DNFRegexAlt}$ to build up the typing
    \[
      \inferrule*
      {
        \DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt\\
        \UnambigItOf{DNFRegex}\\
        \UnambigItOf{DNFRegexAlt}
      }
      {
        \IterateLensOf{\DNFLens} \OfRewritelessType
        \StarOf{\DNFRegex} \Leftrightarrow \StarOf{\DNFRegexAlt}
      }
    \]
  \end{enumerate}
\end{proof}

\begin{lemma}
  \label{lem:dnf-or-assoc}
  $(\DNFRegex_1 \OrDNF \DNFRegex_2) \OrDNF \DNFRegex_3 =
  \DNFRegex_1 \OrDNF (\DNFRegex_2 \OrDNF \DNFRegex_3)$
\end{lemma}
\begin{proof}
  Let $\DNFRegex_1 = \DNFOf{\Sequence_{1,1};\ldots;\Sequence_{1,n_1}}$,
  $\DNFRegex_2 = \DNFOf{\Sequence_{2,1};\ldots;\Sequence_{2,n_2}}$, and
  $\DNFRegex_3 = \DNFOf{\Sequence_{3,1};\ldots;\Sequence_{3,n_3}}$.
  \[
    \begin{array}{rcl}
      (\DNFRegex_1 \OrDNF \DNFRegex_2) \OrDNF \DNFRegex_3
      & = & \DNFOf{\Sequence_{1,1};\ldots;\Sequence_{1,n_1};
            \Sequence_{2,1};\ldots;\Sequence_{2,n_2}} \OrDNF \DNFRegex_3\\
      & = & \DNFOf{\Sequence_{1,1};\ldots;\Sequence_{1,n_1};
            \Sequence_{2,1};\ldots;\Sequence_{2,n_2};
            \Sequence_{3,1};\ldots;\Sequence_{3,n_3}}\\
      & = & \DNFRegex_1 \OrDNF
            \DNFOf{\Sequence_{2,1};\ldots;\Sequence_{2,n_2};
            \Sequence_{3,1};\ldots;\Sequence_{3,n_3}}\\
      & = & \DNFRegex_1 \OrDNF (\DNFRegex_2 \OrDNF \DNFRegex_3)
    \end{array}
  \]
\end{proof}

\begin{lemma}
  \label{lem:sequence-concat-assoc}
  $(\Sequence_1 \ConcatSequence \Sequence_2) \ConcatSequence \Sequence_3 =
  \Sequence_1 \ConcatSequence (\Sequence_2 \ConcatSequence \Sequence_3)$
\end{lemma}
  Let $\Sequence_1 =
  \SequenceOf{\String_{1,0};\Atom_{1,1};\ldots;\Atom_{1,n_1};\String_{1,n_1}}$,
  $\Sequence_2 =
  \SequenceOf{\String_{2,1};\Atom_{2,1};\ldots;\Atom_{2,n_2};\String_{2,n_2}}$,
  and $\Sequence_3 =
  \SequenceOf{\String_{3,1};\Atom_{3,1};\ldots;\Atom_{3,n_3};\String_{3,n_3}}$.
  \[
    \begin{array}{rcl}
      (\Sequence_1 \ConcatSequence \Sequence_2) \ConcatSequence \Sequence_3
      & = & \SequenceOf{\String_{1,1};\Atom_{1,1};\ldots;\Atom_{1,n_1};
            \String_{1,n_1}\Concat\String_{2,1};
            \Atom_{2,1};\ldots;\Atom_{2,n_2};\String_{2,n_2}}
            \ConcatSequence \Sequence_3\\
      & = & \SequenceOf{\String_{1,1};\Atom_{1,1};\ldots;\Atom_{1,n_1};
            \String_{1,n_1}\Concat\String_{2,0};
            \Atom_{2,1};\ldots;\Atom_{2,n_2};
            \String_{2,n_2}\Concat\String_{3,0};
            \Atom_{3,1};\ldots;\Atom_{3,n_3};\String_{3,n_3}}\\
      & = & \Sequence_1 \ConcatSequence
            \SequenceOf{\String_{2,0};
            \Atom_{2,1};\ldots;\Atom_{2,n_2};
            \String_{2,n_2}\Concat\String_{3,0};
            \Atom_{3,1};\ldots;\Atom_{3,n_3};\String_{3,n_3}}\\
      & = & \Sequence_1 \ConcatSequence (\Sequence_2 \ConcatSequence \Sequence_3)
    \end{array}
  \]
\begin{proof}
  
\end{proof}

\begin{lemma}
  \label{lem:dnf-concat-assoc}
  $(\DNFRegex_1 \ConcatDNF \DNFRegex_2) \ConcatDNF \DNFRegex_3 =
  \DNFRegex_1 \ConcatDNF (\DNFRegex_2 \ConcatDNF \DNFRegex_3)$
\end{lemma}
\begin{proof}
  Let $\DNFRegex_1 = \DNFOf{\Sequence_{1,1};\ldots;\Sequence_{1,n_1}}$,
  $\DNFRegex_2 = \DNFOf{\Sequence_{2,1};\ldots;\Sequence_{2,n_2}}$, and
  $\DNFRegex_3 = \DNFOf{\Sequence_{3,1};\ldots;\Sequence_{3,n_3}}$.
  \[
    \begin{array}{ccc}
      (\DNFRegex_1 \ConcatDNF \DNFRegex_2) \ConcatDNF \DNFRegex_3
      & = & \DNFOf{\Sequence_{1,1}\ConcatSequence\Sequence_{2,1};
            \ldots;\ldots;\Sequence_{1,n_1}\ConcatSequence\Sequence_{2,n_2}}\\
      & = &
            \DNFOf{(\Sequence_{1,1}\ConcatSequence\Sequence_{2,1})\ConcatSequence\Sequence_{3,1};
            \ldots;\ldots;\ldots
            (\Sequence_{1,n_1}\ConcatSequence\Sequence_{2,n_2})\ConcatSequence\Sequence_{3,n_3}}\\
      & = &
            \DNFOf{\Sequence_{1,1}\ConcatSequence(\Sequence_{2,1}\ConcatSequence\Sequence_{3,1});
            \ldots;\ldots;\ldots
            \Sequence_{1,n_1}\ConcatSequence(\Sequence_{2,n_2}\ConcatSequence\Sequence_{3,n_3})}\\
      & = &
            \DNFRegex_1 \ConcatSequence
            \DNFOf{\Sequence_{2,1}\ConcatSequence\Sequence_{3,1};
            \ldots;\ldots;\Sequence_{2,n_2}\ConcatSequence\Sequence_{3,n_3}}\\
      & = &
            \DNFRegex_1 \ConcatDNF (\DNFRegex_2 \ConcatDNF \DNFRegex_3)
    \end{array}
  \]
\end{proof}

\begin{lemma}
  \label{lem:dnf-or-identity-left}
  $\DNFOf{} \OrDNF \DNFRegex_1 = \DNFRegex_1$
\end{lemma}
\begin{proof}
  By inspection.
\end{proof}

\begin{lemma}
  \label{lem:dnf-or-identity-right}
  $\DNFRegex_1 \OrDNF \DNFOf{} = \DNFRegex_1$
\end{lemma}
\begin{proof}
  By inspection.
\end{proof}

\begin{lemma}
  \label{lem:dnf-concat-identity-left}
  $\DNFOf{\SequenceOf{\EmptyString}} \ConcatDNF \DNFRegex = \DNFRegex$
\end{lemma}
\begin{proof}
  By inspection,
  $\SequenceOf{\EmptyString} \ConcatSequence \Sequence = \Sequence$.

  Let $\DNFRegex = \DNFOf{\Sequence_1;\ldots;\Sequence_n}$.

  \[
    \begin{array}{ccc}
      \DNFOf{\SequenceOf{\EmptyString}} \ConcatDNF \DNFRegex
      & = & \DNFOf{\SequenceOf{\EmptyString}\ConcatSequence\Sequence_1;
            \ldots;\SequenceOf{\EmptyString}\ConcatSequence\Sequence_n}\\
      & = & \DNFOf{\Sequence_1;\ldots;\Sequence_n}\\
      & = & \DNFRegex
    \end{array}
  \]
\end{proof}

\begin{lemma}
  \label{lem:dnf-concat-identity-right}
  $\DNFRegex \ConcatDNF \DNFOf{\SequenceOf{\EmptyString}} = \DNFRegex$
\end{lemma}
\begin{proof}
  Done similarly to Lemma~\ref{lem:dnf-concat-identity-left}.
\end{proof}

\begin{lemma}
  \label{lem:dnf-concat-projection-left}
  $\DNFOf{} \ConcatDNF \DNFRegex = \DNFOf{}$
\end{lemma}
\begin{proof}
  By inspection.
\end{proof}

\begin{lemma}
  \label{lem:dnf-concat-projection-right}
  $\DNFRegex \ConcatDNF \DNFOf{} = \DNFOf{}$
\end{lemma}
\begin{proof}
  By inspection.
\end{proof}

\begin{lemma}
  \label{lem:dnf-distribute-right}
  $(\DNFRegex_1 \OrDNF \DNFRegex_2) \ConcatDNF \DNFRegex_3 =
  (\DNFRegex_1 \ConcatDNF \DNFRegex_3) \OrDNF
  (\DNFRegex_2 \ConcatDNF \DNFRegex_3)$
\end{lemma}
\begin{proof}
  Let $\DNFRegex_1 = \DNFOf{\Sequence_{1,1};\ldots;\Sequence_{1,n_1}}$.
  Let $\DNFRegex_2 = \DNFOf{\Sequence_{2,1};\ldots;\Sequence_{2,n_2}}$.
  Let $\DNFRegex_3 = \DNFOf{\Sequence_{3,1};\ldots;\Sequence_{3,n_3}}$.

  $(\DNFRegex_1 \OrDNF \DNFRegex_2) \ConcatDNF \DNFRegex_3 =
  (\Sequence_{1,1};\ldots;\Sequence_{1,n_1};
  \Sequence_{2,1};\ldots;\Sequence_{2,n_2}) \ConcatDNF
  \DNFOf{\Sequence_{3,1};\ldots;\Sequence_{3,n_3}}$.
  So, through application of $\ConcatDNF$,
  $\DNFOf{\Sequence_{1,1}\ConcatSequence\Sequence_{3,1};\ldots;
    \Sequence_{1,1}\ConcatSequence\Sequence_{3,n_3};
    \Sequence_{2,n_2}\ConcatSequence\Sequence_{3,1};\ldots;
    \Sequence_{2,n_2}\ConcatSequence\Sequence_{3,n_3}}$.  This equals
  $\DNFOf{\Sequence_{1,1}\ConcatSequence\Sequence_{3,1};\ldots;
    \Sequence_{1,1}\ConcatSequence\Sequence_{3,n_3};
    \Sequence_{1,n_1}\ConcatSequence\Sequence_{3,1};\ldots;
    \Sequence_{1,n_1}\ConcatSequence\Sequence_{3,n_3}} \OrDNF
  \DNFOf{\Sequence_{2,1}\ConcatSequence\Sequence_{3,1};\ldots;
    \Sequence_{2,1}\ConcatSequence\Sequence_{3,n_3};
    \Sequence_{2,n_2}\ConcatSequence\Sequence_{3,1};\ldots;
    \Sequence_{2,n_2}\ConcatSequence\Sequence_{3,n_3}}$, which is
  $(\DNFRegex_1 \ConcatDNF \DNFRegex_2) \OrDNF
  (\DNFRegex_1 \ConcatDNF \DNFRegex_3)$
\end{proof}

\begin{lemma}
  \label{lem:dnf-distribute-singleton-left}
  $\DNFOf{\Sequence} \ConcatDNF (\DNFRegex_1 \OrDNF \DNFRegex_2) =
  (\DNFOf{\Sequence} \ConcatDNF \DNFRegex_1) \OrDNF
  (\DNFOf{\Sequence} \ConcatDNF \DNFRegex_2)$
\end{lemma}
\begin{proof}
  Let $\DNFRegex_1 = \DNFOf{\Sequence_{1,1};\ldots;\Sequence_{1,n_1}}$.
  Let $\DNFRegex_2 = \DNFOf{\Sequence_{2,1};\ldots;\Sequence_{2,n_2}}$.

  $\DNFOf{\Sequence} \ConcatDNF (\DNFRegex_1 \OrDNF \DNFRegex_2) =
  \DNFOf{\Sequence} \ConcatDNF
  (\DNFOf{\Sequence_{1,1};\ldots;\Sequence_{1,n_1}} \OrDNF
  \DNFOf{\Sequence_{2,1};\ldots;\Sequence_{2,n_2}})$.
  So, through application of $\ConcatDNF$,
  $\DNFOf{\Sequence\ConcatSequence\Sequence_{1,1};\ldots;
    \Sequence\ConcatSequence\Sequence_{1,n_1};
    \Sequence\ConcatSequence\Sequence_{2,1};\ldots
    \Sequence\ConcatSequence\Sequence_{2,n_2}}$.
  This equals
  $\DNFOf{\Sequence\ConcatSequence\Sequence_{1,1};\ldots;
    \Sequence\ConcatSequence\Sequence_{1,n_1}} \OrDNF
  \DNFOf{\Sequence\ConcatSequence\Sequence_{2,1};\ldots
    \Sequence\ConcatSequence\Sequence_{2,n_2}}$, which through the definitions,
  equals
  $(\DNFOf{\Sequence} \ConcatDNF \DNFRegex_1) \OrDNF
  (\DNFOf{\Sequence} \ConcatDNF \DNFRegex_2)$.
\end{proof}

\begin{definition}[Permutation Functions]\leavevmode\\
  $\ConcatPermutation{} \OfType{}
  \ArrowTypeOf{\PermutationSetOf{n}}
  {\ArrowTypeOf{\PermutationSetOf{m}}{\PermutationSetOf{n+m}}}$\\
  $(\ConcatPermutationOf{\sigma_1}{\sigma_2})(i) =
  \begin{cases*}
    \sigma_1(i) & if $i \leq n$\\
    \sigma_2(i-n)+n & otherwise
  \end{cases*}$\\
  \\\\
  $\SwapPermutation{} \OfType{}
  \ArrowTypeOf{\PermutationSetOf{n}}
  {\ArrowTypeOf{\PermutationSetOf{m}}{\PermutationSetOf{n+m}}}$\\
  $(\SwapPermutationOf{\sigma_1}{\sigma_2})(i) =
  \begin{cases*}
    \sigma_1(i)+m & if $i \leq n$\\
    \sigma_2(i-n) & otherwise
  \end{cases*}$\\
  \\\\
  $\DistributePermutation{} \OfType{}
  \ArrowTypeOf{\PermutationSetOf{n}}
  {\ArrowTypeOf{\PermutationSetOf{m}}{\PermutationSetOf{n\times m}}}$\\
  $(\DistributePermutationOf{\sigma_1}{\sigma_2})(i,j) =
  (\sigma_1(i),\sigma_2(j))$
\end{definition}

\begin{definition}[DNF Lens Functions]\leavevmode\\
  $\ConcatSequenceLens{} \OfType{}
  \ArrowTypeOf{\SequenceLensType{}}
  {\ArrowTypeOf{\SequenceLensType{}}{\SequenceLensType{}}}$\\
  $\ConcatSequenceLensOf
  {(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)},\sigma_1)}
  {(\SequenceLensOf{(\String_0',\StringAlt_0');\AtomLens_1';\ldots;\AtomLens_m';(\String_m',\StringAlt_m')},\sigma_2)}=$\\
  \hspace*{2ex}$(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;
    (\String_n\Concat\String_0',\StringAlt_n\Concat\StringAlt_0');\AtomLens_1';
    \ldots;\AtomLens_m';(\String_m',\StringAlt_m')},\ConcatPermutationOf{\sigma_1}{\sigma_2})$\\
  \\
  \\$\SwapSequenceLens{} \OfType{}
  \ArrowTypeOf{\SequenceLensType{}}
  {\ArrowTypeOf{\SequenceLensType{}}{\SequenceLensType{}}}$\\
  Let $\String_i'' =
  \begin{cases*}
    \String_i & for $i \in \RangeIncInc{0}{n-1}$ \\
    \String_n \Concat \String_0 & for $i = n$\\
    \String_i' & for $i \in \RangeIncInc{n+1}{n+m}$
  \end{cases*}$
  Let $\StringAlt_i'' =
  \begin{cases*}
    \StringAlt_i' & for $i \in \RangeIncInc{0}{m-1}$ \\
    \StringAlt_m' \Concat \StringAlt_0 & for $i = m$\\
    \StringAlt_i & for $i \in \RangeIncInc{m+1}{m+n}$
  \end{cases*}$\\
  $\SwapSequenceLensOf
  {(\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n;(\String_n,\StringAlt_n)},\sigma_1)}
  {(\SequenceLensOf{(\String_0',\StringAlt_0');\AtomLens_1';\ldots;\AtomLens_m';(\String_m',\StringAlt_m')},\sigma_2)}=$\\
  \hspace*{2ex}$(\SequenceLensOf{(\String_0'',\StringAlt_0'');\AtomLens_1;\ldots;\AtomLens_n;
    (\String_n'',\StringAlt_n'');\AtomLens_1';(\String_{n+1}'',\StringAlt_n'')
    \ldots;\AtomLens_n';(\String_{n+m}'',\StringAlt_{n+m}'')},\SwapPermutationOf{\sigma_1}{\sigma_2})$\\
  \\
  \\\ConcatDNFLens{} \OfType{}
  \ArrowTypeOf{\DNFLensType{}}{\ArrowTypeOf{\DNFLensType{}}{\DNFLensType{}}}\\
  $\ConcatDNFLensOf{(\DNFLensOf{\SequenceLens_1\DNFSep\ldots\DNFSep\SequenceLens_n},\sigma_1)}
  {(\DNFLensOf{\SequenceLens_1';\ldots;\SequenceLens_m'},\sigma_2)}=$
  \[
    \begin{array}{rcccl}
      (\DNFLensLeft & \ConcatSequenceLensOf{\SequenceLens_1}{\SequenceLens_1'}\DNFSep & \cdots & \ConcatSequenceLensOf{\SequenceLens_1}{\SequenceLens_m'}\DNFSep \\
          \cdots    & \ConcatSequenceLensOf{\SequenceLens_n}{\SequenceLens_1'}\DNFSep & \cdots & \ConcatSequenceLensOf{\SequenceLens_n}{\SequenceLens_m'} & \DNFLensRight,\DistributePermutationOf{\sigma_1}{\sigma_1})
    \end{array}
  \]
  \\
  \\\SwapDNFLens{} \OfType{}
  \ArrowTypeOf{\DNFLensType{}}{\ArrowTypeOf{\DNFLensType{}}{\DNFLensType{}}}\\
  $\SwapDNFLensOf{(\DNFLensOf{\SequenceLens_1\DNFSep\ldots\DNFSep\SequenceLens_n},\sigma_1)}
  {(\DNFLensOf{\SequenceLens_1';\ldots;\SequenceLens_m'},\sigma_2)}=$
  \[
    \begin{array}{rcccl}
      (\DNFLensLeft & \SwapSequenceLensOf{\SequenceLens_1}{\SequenceLens_1'}\DNFSep & \cdots & \SwapSequenceLensOf{\SequenceLens_1}{\SequenceLens_m'}\DNFSep \\
          \cdots    & \SwapSequenceLensOf{\SequenceLens_n}{\SequenceLens_1'}\DNFSep & \cdots & \SwapSequenceLensOf{\SequenceLens_n}{\SequenceLens_m'} & \DNFLensRight,\DistributePermutationOf{\sigma_1}{\sigma_1})
    \end{array}
  \]
  \\
  \\\OrDNFLens{} \OfType{}
  \ArrowTypeOf{\DNFLensType{}}{\ArrowTypeOf{\DNFLensType{}}{\DNFLensType{}}
  }\\
  $\OrDNFLensOf{(\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n},\sigma_1)}
  ({\DNFLensOf{\SequenceLens_1';\ldots;\Sequence_m'},\sigma_2)}$=\\
  \hspace*{2ex}$(\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n;
    \SequenceLens_1';\ldots;\Sequence_m'},\ConcatPermutationOf{\sigma_1}{\sigma_2})$\\
  \\
  \\\AtomToDNFLens{} \OfType{}
  \ArrowTypeOf{\AtomLensType{}}{\DNFLensType{}}\\
  $\AtomToDNFLensOf{\AtomLens} = (\DNFLensOf{(\SequenceLensOf{(\EmptyString,\EmptyString);\AtomLens;(\EmptyString,\EmptyString)},\Identity)},\Identity)$
\end{definition}

\begin{lemma}
  \label{lem:dnf-lens-concat-identity-left}
  $(\DNFLensOf{(\SequenceLensOf{(\EmptyString,\EmptyString)},\Identity_0)},\Identity_1)
  \ConcatDNFLens
  \DNFLens = \DNFLens$,
  where $\Identity_0$ is the identity permutation on $0$ elements, and
  $\Identity_1$ is the identity permutation on $1$ element.
\end{lemma}
\begin{proof}
  Let $\DNFLens = (\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n},\sigma)$.
  By definition, $(\Identity_1 \DistributePermutation \sigma)(1,i) = (1,\sigma(i))$.
  By definition, $\Identity_0 \ConcatPermutation \sigma = \sigma$.
  Let $\SequenceLens_i =
  (\SequenceLensOf{(\String_{i,0},\StringAlt_{i,0});\AtomLens_{i,1};\ldots
    \AtomLens_{i,n_i};(\String_{i,n_i},\StringAlt_{i,n_i})},\sigma_i)$.
  So $(\SequenceLensOf{(\EmptyString,\EmptyString)},\Identity_0)
  \ConcatSequenceLens\SequenceLens_i =
  (\SequenceLensOf{(\EmptyString\Concat\String_{i,0},\EmptyString\Concat\StringAlt_{i,0});\AtomLens_{i,1};\ldots
    \AtomLens_{i,n_i};(\String_{i,n_i},\StringAlt_{i,n_i})},\sigma_i) =
  \SequenceLens_i$.
  So
  $(\DNFLensOf{(\SequenceLensOf{(\EmptyString,\EmptyString)},\Identity_0)},\Identity_1)
  \ConcatDNFLens \DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n} =
  (\DNFLensOf{(\SequenceLensOf{(\EmptyString,\EmptyString)},\Identity_0)
    \ConcatSequenceLens \SequenceLens_1; \ldots ;
    (\SequenceLensOf{(\EmptyString,\EmptyString)},\Identity_0) \ConcatSequenceLens
    \SequenceLens_n},\Identity_1 \DistributePermutation \sigma) =
  (\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n,\sigma})$.
\end{proof}

\begin{lemma}
  \label{lem:dnf-lens-concat-identity-right}
  $\DNFLens \ConcatDNFLens
  \DNFLensOf{\SequenceLensOf{(\EmptyString,\EmptyString)}} = \DNFLens$
\end{lemma}
\begin{proof}
Done similarly to Lemma~\ref{lem:dnf-lens-concat-identity-left}.
\end{proof}

\begin{lemma}[Typing and Semantics of $\ConcatSequenceLens$]
  Let $\SequenceLens_1 \OfType \Sequence_1 \Leftrightarrow \SequenceAlt_1$ and
  $\SequenceLens_2 \OfType \Sequence_2 \Leftrightarrow \SequenceAlt_2$ be the typing of
  two sequence lenses, where
  $\UnambigConcatOf{\LanguageOf{\Sequence_1}}{\LanguageOf{\Sequence_2}}$ and
  $\UnambigConcatOf{\LanguageOf{\SequenceAlt_1}}{\LanguageOf{\SequenceAlt_2}}$.
  Then $\ConcatSequenceLensOf{\SequenceLens_1}{\SequenceLens_2} \OfType
  \ConcatSequenceOf{\Sequence_1}{\Sequence_2} \Leftrightarrow
  \ConcatSequenceOf{\SequenceAlt_1}{\SequenceAlt_2}$ and
  $\SemanticsOf{\ConcatSequenceLensOf{\SequenceLens_1}{\SequenceLens_2}} =
  \SetOf{(\String_1\Concat\String_2,\StringAlt_1\Concat\StringAlt_2) \SuchThat
    (\String_1,\StringAlt_1)\in\SemanticsOf{\SequenceLens_1}
    \BooleanAnd(\String_2,\StringAlt_2)\in\SemanticsOf{\SequenceLens_2}}$
\end{lemma}
\begin{proof}
  By assumption, there exists typing derivations

  \[
    \SequenceLens_1 \OfRewritelessType \Sequence_1 \Leftrightarrow \SequenceAlt_1
  \]
  and
  \[
    \SequenceLens_2 \OfRewritelessType \Sequence_2 \Leftrightarrow \Sequence_2
  \]

  By inversion, we know that the last rule application on each side was
  \DNFLensRule{}, giving

  \[
    \inferrule*
    {
      \AtomLens_i \OfType \Atom_i \Leftrightarrow \AtomAlt_i\\
      \sigma_1 \in \PermutationSetOf{n}\\
      \SequenceUnambigConcatOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}\\
      \SequenceUnambigConcatOf{\StringAlt_0\SequenceSep\AtomAlt_{\sigma_1(1)}\SequenceSep\ldots\SequenceSep\AtomAlt_{\sigma_1(n)}\SequenceSep\StringAlt_n}
    }
    {
      (\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n},\sigma_1)
      \OfRewritelessType
      \SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n} \Leftrightarrow
      \SequenceOf{\StringAlt_0;\AtomAlt_{\sigma_1(1)};\ldots;\AtomAlt_{\sigma_1(n)};\StringAlt_n}
    }
  \]
  and
  \[
    \inferrule*
    {
      \AtomLens_i' \OfType \Atom_i' \Leftrightarrow \AtomAlt_i'\\
      \sigma_2 \in \PermutationSetOf{m}\\
      \SequenceUnambigConcatOf{\String_0'\SequenceSep\Atom_1'\SequenceSep\ldots\SequenceSep\Atom_m'\SequenceSep\String_m'}\\
      \SequenceUnambigConcatOf{\StringAlt_0'\SequenceSep\AtomAlt_{\sigma_2(1)}'\SequenceSep\ldots\SequenceSep\AtomAlt_{\sigma_2(n)}'\SequenceSep\StringAlt_n'}
    }
    {
      (\SequenceLensOf{(\String_0',\StringAlt_0');\AtomLens_1';\ldots;\AtomLens_m';(\String_m',\StringAlt_m')},\sigma_2)
      \OfRewritelessType
      \SequenceOf{\String_0';\Atom_1';\ldots;\Atom_m';\String_m'} \Leftrightarrow
      \SequenceOf{\StringAlt_0';\AtomAlt_{\sigma_2(1)}';\ldots;\AtomAlt_{\sigma_2(m)}';\StringAlt_m'}
    }
  \]
  where
  \[
    \begin{array}{rcl}
      \SequenceLens_1 & = &
                            (\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n},
                            \sigma_1)\\
      \Sequence_1 & = &
                        \SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}\\
      \SequenceAlt_1 & = &
                           \SequenceOf{\StringAlt_0;\AtomAlt_{\sigma_1(1)};\ldots;\AtomAlt_{\sigma_1(n)};\StringAlt_n}\\
      \SequenceLens_2 & = &
                            (\SequenceLensOf{(\String_0',\StringAlt_0');\AtomLens_1';\ldots;\AtomLens_m';(\String_m',\StringAlt_m')},\sigma_2)\\
      \Sequence_2 & = &
                        \SequenceOf{\String_0';\Atom_1';\ldots;\Atom_m';\String_m'}\\
      \SequenceAlt_2 & = &
                           \SequenceOf{\StringAlt_0';\AtomAlt_{\sigma_2(1)}';\ldots;\AtomAlt_{\sigma_2(m)}';\StringAlt_m'}
    \end{array}
  \]

  Define $\String_i''$ as $\String_i$ for $i \in \RangeIncInc{1}{n-1}$, and as
  $\String_{i-n}'$ for $i \in \RangeIncInc{n+1}{n+m}$, and as
  $\String_n\Concat\String_0'$ for $i=n$.

  Define $\StringAlt_i''$ as $\StringAlt_i$ for $i \in \RangeIncInc{1}{n-1}$,
  and as $\StringAlt_i'$ as $\StringAlt_{i-n}$ for $i \in
  \RangeIncInc{n+1}{n+m}$, and as $\StringAlt_n\Concat\StringAlt_0$ for $i=n$.

  Define $\Atom_i''$ as $\Atom_i$ for $i \in \RangeIncInc{1}{n}$, and as
  $\Atom_{i-n}'$ for $i \in \RangeIncInc{n+1}{n+m}$.

  Define $\AtomAlt_i''$ as $\Atom_i$ for $i \in \RangeIncInc{1}{n}$, and as
  $\AtomAlt_{i-n}'$ for $i \in \RangeIncInc{n+1}{n+m}$.

  Define $\AtomLens_i$ as $\AtomLens_i$ for $i \in \RangeIncInc{1}{n}$, and as
  $\AtomLens_{i-n}'$ for $i \in \RangeIncInc{n+1}{n+m}$.

  From Lemma~\ref{lem:unambig-concat-equiv}, as
  $\SequenceUnambigConcatOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}$,
  $\SequenceUnambigConcatOf{\String_0';\Atom_1';\ldots;\Atom_m';\String_m'}$,
  and
  $\UnambigConcatOf
  {\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}}
  {\SequenceOf{\String_0';\Atom_1';\ldots;\Atom_m';\String_m'}}$,
  then $\SequenceUnambigConcatOf{\String_0;\Atom_1;\ldots;\Atom_n;
    \String_n\Concat\String_0';
    \Atom_1';\ldots;\Atom_m';\String_m'}$, so
  $\SequenceUnambigConcatOf{\String_0'';\Atom_1'';\ldots;\Atom_{n+m}'';\String_{n+m}''}$.

  From Lemma~\ref{lem:unambig-concat-equiv}, as
  $\SequenceUnambigConcatOf{\StringAlt_0;\AtomAlt_{\sigma_1(1)}';\ldots;\AtomAlt_{\sigma_1(n)};\StringAlt_n}$,
  $\SequenceUnambigConcatOf{\StringAlt_0';\AtomAlt_{\sigma_2(1)}';\ldots;\AtomAlt_{\sigma_2(m)}';\StringAlt_m'}$,
  and
  $\UnambigConcatOf
  {\SequenceOf{\StringAlt_0;\AtomAlt_{\sigma_1(1)};\ldots;\AtomAlt_{\sigma_1(n)};\StringAlt_n}}
  {\SequenceOf{\StringAlt_0';\AtomAlt_{\sigma_2(1)}';\ldots;\AtomAlt_{\sigma_2(m)}';\StringAlt_m'}}$, then
  $\SequenceUnambigConcatOf{\StringAlt_0;\AtomAlt_{\sigma_1(1)};\ldots;\AtomAlt_{\sigma_1(n)};
    \StringAlt_n\Concat\StringAlt_0';
    \AtomAlt_{\sigma_2(1)}';\ldots;\AtomAlt_{\sigma_2(m)}';\StringAlt_m'}$, so
  $\SequenceUnambigConcatOf{\StringAlt_0'';
    \AtomAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(1)}'';\ldots;
    \AtomAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(n+m)}'';\StringAlt_{n+m}''}$.

  Consider the derivation

  \[
    \inferrule*
    {
      \AtomLens_i \OfType \Atom_i \Leftrightarrow \AtomAlt_i\\
      \ConcatPermutationOf{\sigma_1}{\sigma_2} \in \PermutationSetOf{n+m}\\
      \SequenceUnambigConcatOf{\String_0'';\Atom_1'';\ldots;\Atom_{n+m}'';\String_{n+m}''}\\
      \SequenceUnambigConcatOf{\StringAlt_0'';
        \AtomAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(1)}'';\ldots;
        \AtomAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(n+m)}'';\StringAlt_{n+m}''}
    }
    {
      (\SequenceLensOf{(\String_0'',\StringAlt_0'');\SequenceLens_1;
        \ldots;
        \SequenceLens_{n+m};(\String_{n+m}'',\StringAlt_{n+m}'')},
      \ConcatPermutationOf{\sigma_1}{\sigma_2})
      \OfRewritelessType
      \SequenceOf{\String_0'';\Atom_1'';\ldots;\Atom_{n+m}'';\String_{n+m}''}
      \Leftrightarrow
      \SequenceUnambigConcatOf{\StringAlt_0'';
        \AtomAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(1)}'';\ldots;
        \AtomAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(n+m)}'';\StringAlt_{n+m}''}
    }
  \]

  We wish to show that this is a derivation of
  $\ConcatSequenceLensOf{\SequenceLens_1}{\SequenceLens_2} \OfType
  \ConcatSequenceOf{\Sequence_1}{\Sequence_2} \Leftrightarrow
  \ConcatSequenceOf{\SequenceAlt_1}{\SequenceAlt_2}$.

  \[
    \begin{array}{rcl}
      (\SequenceLensOf{(\String_0'',\StringAlt_0'');\SequenceLens_1'';
      \ldots;
      \SequenceLens_{n+m}'';(\String_{n+m}'',\StringAlt_{n+m}'')},
      \ConcatPermutationOf{\sigma_1}{\sigma_2})
      & = & (\SequenceLensOf{(\String_0'',\StringAlt_0'');\SequenceLens_1'';
            \ldots;\SequenceLens_n'';(\String_n'',\StringAlt_n'');\\
      & & \hspace*{4.5em}\SequenceLens_{n+1}'';
          \ldots;\SequenceLens_{n+m}'';(\String_{n+m}'',\StringAlt_{n+m}'')},
          \ConcatPermutationOf{\sigma_1}{\sigma_2})\\
      & = & (\SequenceLensOf{(\String_0,\StringAlt_0);\SequenceLens_1;
            \ldots;\SequenceLens_n;(\String_n\Concat\String_0',\StringAlt_n\Concat\StringAlt_0');\\
      & & \hspace*{4.5em}\SequenceLens_0';
          \ldots;\SequenceLens_m';(\String_m',\StringAlt_m')},
          \ConcatPermutationOf{\sigma_1}{\sigma_2})\\
      & = & \ConcatSequenceLensOf{\SequenceLens_1}{\SequenceLens_2}
    \end{array}
  \]


  \[
    \begin{array}{rcl}
      \SequenceOf{\String_0'';\Atom_1'';\ldots;\Atom_{n+m}'';\String_{n+m}''}
      & = & \SequenceOf{\String_0'';\Atom_1'';\ldots;\Atom_n'';\String_n'';\Atom_{n+1}'';
            \ldots\Atom_{n+m}'';\String_{n+m}''}\\
      & = & \SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;(\String_n\Concat\String_0');\Atom_1';
            \ldots\Atom_m';\String_m'}\\
      & = & \ConcatSequenceOf{\Sequence_1}{\Sequence_2}
    \end{array}
  \]


  \[
    \begin{array}{rcl}
      \SequenceOf{\StringAlt_0'';\AtomAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(1)}'';\ldots;
      \AtomAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(n+m)}'';\StringAlt_{n+m}''}
      & = &
            \SequenceOf{\StringAlt_0'';\AtomAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(1)}'';
            \ldots;\AtomAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(n)}'';
            \StringAlt_n'';\AtomAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(n+1)}'';
            \ldots;
            \AtomAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(n+m)}'';\SequenceAlt_{n+m}''}\\
      & = &
            \SequenceOf{\StringAlt_0'';\AtomAlt_{\sigma_1(1)}'';
            \ldots;\AtomAlt_{\sigma_1(n)}'';
            \StringAlt_n'';\AtomAlt_{\sigma_2(1)+n}'';
            \ldots;
            \AtomAlt_{\sigma_2(m)+n}'';\StringAlt_{n+m}''}\\
      & = &
            \SequenceOf{\StringAlt_0;\AtomAlt_{\sigma_1(1)};
            \ldots;\AtomAlt_{\sigma_1(n)};
            \StringAlt_n\Concat\StringAlt_0';\AtomAlt_{\sigma_2(1)}';
            \ldots;
            \AtomAlt_{\sigma_2(m)}';\StringAlt_m'}\\
      & = & \ConcatSequenceOf{\SequenceAlt_1}{\SequenceAlt_2}
    \end{array}
  \]

  So we have a derivation of $\ConcatSequenceLensOf{\SequenceLens_1}{\SequenceLens_2} \OfType
  \ConcatSequenceOf{\Sequence_1}{\Sequence_2} \Leftrightarrow
  \ConcatSequenceOf{\SequenceAlt_1}{\SequenceAlt_2}$

  We also wish to have the desired semantics.

  \[
    \begin{array}{l}
      \SemanticsOf{(\SequenceLensOf{(\String_0'',\StringAlt_0'');\SequenceLens_1'';
      \ldots;
      \SequenceLens_{n+m}'';(\String_{n+m}'',\StringAlt_{n+m}'')},
      \ConcatPermutationOf{\sigma_1}{\sigma_2})}\\
      = \SetOf{(\String_0''\Concat\overline{\String_1}\Concat
      \ldots\Concat\overline{\String_{n+m}}\Concat\String_{n+m}'',
      \StringAlt_0''\Concat\overline{\StringAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(1)}}\Concat
      \ldots\Concat\overline{\StringAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(n+m)}}\Concat\StringAlt_{n+m}''))\SuchThat
      \forall i\in\RangeIncInc{1}{n+m}.(\overline{\String_i},\overline{\StringAlt_i})\in\SequenceLens_i''}\\
      = \SetOf{(\String_0\Concat\overline{\String_1}\Concat\ldots\Concat
      \overline{\String_n}\Concat\String_n\Concat\String_0'\Concat\overline{\String_{0}'}\Concat
      \ldots\Concat\overline{\String_m'}\Concat\String_m',
      \StringAlt_0\Concat\overline{\StringAlt_{\sigma_1(1)}}\Concat\ldots\Concat
      \overline{\StringAlt_{\sigma_1(n)}}\Concat\StringAlt_n\Concat\StringAlt_0'
      \Concat\overline{\StringAlt_{\sigma_2(0)}'}\Concat
      \ldots\Concat\overline{\StringAlt_{\sigma_2(m)}'}\Concat\StringAlt_m'))\\
      \hspace*{3em}\SuchThat
      (\forall i\in\RangeIncInc{1}{n}.
      (\overline{\String_i},\overline{\StringAlt_i})\in\SequenceLens_i
      \BooleanAnd
      \forall i\in\RangeIncInc{1}{m}.
      (\overline{\String_i'},\overline{\StringAlt_i'})\in\SequenceLens_i'}\\
      = \SetOf{(\String\Concat\String',\StringAlt\Concat\StringAlt')\SuchThat
      (\String,\StringAlt)\in\SemanticsOf{\SequenceLens_1}
      \BooleanAnd
      (\String',\StringAlt')\in\SemanticsOf{\SequenceLens_2}}
    \end{array}
  \]

\end{proof}

\begin{lemma}[Typing and Semantics of $\SwapSequenceLens$]
  Let $\SequenceLens_1 \OfType \Sequence_1 \Leftrightarrow \SequenceAlt_1$ and
  $\SequenceLens_2 \OfType \Sequence_2 \Leftrightarrow \SequenceAlt_2$ be the typing of
  two sequence lenses, where
  $\UnambigConcatOf{\LanguageOf{\Sequence_1}}{\LanguageOf{\Sequence_2}}$ and
  $\UnambigConcatOf{\LanguageOf{\SequenceAlt_2}}{\LanguageOf{\SequenceAlt_1}}$
  Then $\ConcatSequenceLensOf{\SequenceLens_1}{\SequenceLens_2} \OfType
  \ConcatSequenceOf{\Sequence_1}{\Sequence_2} \Leftrightarrow
  \ConcatSequenceOf{\SequenceAlt_1}{\SequenceAlt_2}$ and
  $\SemanticsOf{\ConcatSequenceLensOf{\SequenceLens_1}{\SequenceLens_2}} =
  \SetOf{(\String_1\Concat\String_2,\StringAlt_1\Concat\StringAlt_2) \SuchThat
    (\String_1,\StringAlt_1)\in\SemanticsOf{\SequenceLens_1}
    \BooleanAnd(\String_2,\StringAlt_2)\in\SemanticsOf{\SequenceLens_2}}$
\end{lemma}
\begin{proof}
  By assumption, there exists typing derivations

  \[
    \SequenceLens_1 \OfRewritelessType \Sequence_1 \Leftrightarrow \SequenceAlt_1
  \]
  and
  \[
    \SequenceLens_2 \OfRewritelessType \Sequence_2 \Leftrightarrow \Sequence_2
  \]

  By inversion, we know that the last rule application on each side was
  \DNFLensRule{}, giving

  \[
    \inferrule*
    {
      \AtomLens_i \OfType \Atom_i \Leftrightarrow \AtomAlt_i\\
      \sigma_1 \in \PermutationSetOf{n}\\
      \SequenceUnambigConcatOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}\\
      \SequenceUnambigConcatOf{\StringAlt_0\SequenceSep\AtomAlt_{\sigma_1(1)}\SequenceSep\ldots\SequenceSep\AtomAlt_{\sigma_1(n)}\SequenceSep\StringAlt_n}
    }
    {
      (\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n},\sigma_1)
      \OfRewritelessType
      \SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n} \Leftrightarrow
      \SequenceOf{\StringAlt_0;\AtomAlt_{\sigma_1(1)};\ldots;\AtomAlt_{\sigma_1(n)};\StringAlt_n}
    }
  \]
  and
  \[
    \inferrule*
    {
      \AtomLens_i' \OfType \Atom_i' \Leftrightarrow \AtomAlt_i'\\
      \sigma_2 \in \PermutationSetOf{m}\\
      \SequenceUnambigConcatOf{\String_0'\SequenceSep\Atom_1'\SequenceSep\ldots\SequenceSep\Atom_m'\SequenceSep\String_m'}\\
      \SequenceUnambigConcatOf{\StringAlt_0'\SequenceSep\AtomAlt_{\sigma_2(1)}'\SequenceSep\ldots\SequenceSep\AtomAlt_{\sigma_2(n)}'\SequenceSep\StringAlt_n'}
    }
    {
      (\SequenceLensOf{(\String_0',\StringAlt_0');\AtomLens_1';\ldots;\AtomLens_m';(\String_m',\StringAlt_m')},\sigma_2)
      \OfRewritelessType
      \SequenceOf{\String_0';\Atom_1';\ldots;\Atom_m';\String_m'} \Leftrightarrow
      \SequenceOf{\StringAlt_0';\AtomAlt_{\sigma_2(1)}';\ldots;\AtomAlt_{\sigma_2(m)}';\StringAlt_m'}
    }
  \]
  where
  \[
    \begin{array}{rcl}
      \SequenceLens_1 & = &
                            (\SequenceLensOf{(\String_0,\StringAlt_0);\AtomLens_1;\ldots;\AtomLens_n},
                            \sigma_1)\\
      \Sequence_1 & = &
                        \SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}\\
      \SequenceAlt_1 & = &
                           \SequenceOf{\StringAlt_0;\AtomAlt_{\sigma_1(1)};\ldots;\AtomAlt_{\sigma_1(n)};\StringAlt_n}\\
      \SequenceLens_2 & = &
                            (\SequenceLensOf{(\String_0',\StringAlt_0');\AtomLens_1';\ldots;\AtomLens_m';(\String_m',\StringAlt_m')},\sigma_2)\\
      \Sequence_2 & = &
                        \SequenceOf{\String_0';\Atom_1';\ldots;\Atom_m';\String_m'}\\
      \SequenceAlt_2 & = &
                           \SequenceOf{\StringAlt_0';\AtomAlt_{\sigma_2(1)}';\ldots;\AtomAlt_{\sigma_2(m)}';\StringAlt_m'}
    \end{array}
  \]

  Define $\String_i''$ as $\String_i$ for $i \in \RangeIncInc{1}{n-1}$, and as
  $\String_{i-n}'$ for $i \in \RangeIncInc{n+1}{n+m}$, and as
  $\String_n\Concat\String_0'$ for $i=n$.

  Define $\StringAlt_i''$ as $\StringAlt_i'$ for $i \in \RangeIncInc{1}{m-1}$,
  and as $\StringAlt_{i-m}$ for $i \in
  \RangeIncInc{m+1}{m+n}$, and as $\StringAlt_m'\Concat\StringAlt_0$ for $i=m$.

  Define $\Atom_i''$ as $\Atom_i$ for $i \in \RangeIncInc{1}{n}$, and as
  $\Atom_{i-n}'$ for $i \in \RangeIncInc{n+1}{n+m}$.

  Define $\AtomAlt_i''$ as $\AtomAlt_i'$ for $i \in \RangeIncInc{1}{m}$, and as
  $\AtomAlt_{i-m}$ for $i \in \RangeIncInc{m+1}{m+n}$.

  Define $\AtomLens_i$ as $\AtomLens_i$ for $i \in \RangeIncInc{1}{n}$, and as
  $\AtomLens_{i-n}'$ for $i \in \RangeIncInc{n+1}{n+m}$.

  From Lemma~\ref{lem:unambig-concat-equiv}, as
  $\SequenceUnambigConcatOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}$,
  $\SequenceUnambigConcatOf{\String_0';\Atom_1';\ldots;\Atom_m';\String_m'}$,
  and
  $\UnambigConcatOf
  {\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}}
  {\SequenceOf{\String_0';\Atom_1';\ldots;\Atom_m';\String_m'}}$,
  then $\SequenceUnambigConcatOf{\String_0;\Atom_1;\ldots;\Atom_n;
    \String_n\Concat\String_0';
    \Atom_1';\ldots;\Atom_m';\String_m'}$, so
  $\SequenceUnambigConcatOf{\String_0'';\Atom_1'';\ldots;\Atom_{n+m}'';\String_{n+m}''}$.

  From Lemma~\ref{lem:unambig-concat-equiv}, as
  $\SequenceUnambigConcatOf{\StringAlt_0';\AtomAlt_{\sigma_2(1)}';\ldots;\AtomAlt_{\sigma_2(m)}';\StringAlt_m'}$,
  $\SequenceUnambigConcatOf{\StringAlt_0;\AtomAlt_{\sigma_1(1)}';\ldots;\AtomAlt_{\sigma_1(n)};\StringAlt_n}$,
  and
  $\UnambigConcatOf
  {\SequenceOf{\StringAlt_0';\AtomAlt_{\sigma_2(1)}';\ldots;\AtomAlt_{\sigma_2(m)}';\StringAlt_m'}}
  {\SequenceOf{\StringAlt_0;\AtomAlt_{\sigma_1(1)};\ldots;\AtomAlt_{\sigma_1(n)};\StringAlt_n}}$, then
  $\SequenceUnambigConcatOf{\StringAlt_0';\AtomAlt_{\sigma_2(1)}';\ldots;\AtomAlt_{\sigma_2(m)}';
    \StringAlt_m'\Concat\StringAlt_0;
    \AtomAlt_{\sigma_1(1)};\ldots;\AtomAlt_{\sigma_1(n)};\StringAlt_n}$, so
  $\SequenceUnambigConcatOf{\StringAlt_0'';
    \AtomAlt_{\SwapPermutationOf{\sigma_1}{\sigma_2}(1)}'';\ldots;
    \AtomAlt_{\SwapPermutationOf{\sigma_1}{\sigma_2}(n+m)}'';\StringAlt_{n+m}''}$.

  Consider the derivation

  \[
    \inferrule*
    {
      \AtomLens_i \OfType \Atom_i \Leftrightarrow \AtomAlt_i\\
      \SwapPermutationOf{\sigma_1}{\sigma_2} \in \PermutationSetOf{n+m}\\
      \SequenceUnambigConcatOf{\String_0'';\Atom_1'';\ldots;\Atom_{n+m}'';\String_{n+m}''}\\
      \SequenceUnambigConcatOf{\StringAlt_0'';
        \AtomAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(1)}'';\ldots;
        \AtomAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(n+m)}'';\StringAlt_{n+m}''}
    }
    {
      (\SequenceLensOf{(\String_0'',\StringAlt_0'');\SequenceLens_1;
        \ldots;
        \SequenceLens_{n+m};(\String_{n+m}'',\StringAlt_{n+m}'')},
      \SwapPermutationOf{\sigma_1}{\sigma_2})
      \OfRewritelessType
      \SequenceOf{\String_0'';\Atom_1'';\ldots;\Atom_{n+m}'';\String_{n+m}''}
      \Leftrightarrow
      \SequenceUnambigConcatOf{\StringAlt_0'';
        \AtomAlt_{\SwapPermutationOf{\sigma_1}{\sigma_2}(1)}'';\ldots;
        \AtomAlt_{\SwapPermutationOf{\sigma_1}{\sigma_2}(n+m)}'';\StringAlt_{n+m}''}
    }
  \]

  We wish to show that this is a derivation of
  $\SwapSequenceLensOf{\SequenceLens_1}{\SequenceLens_2} \OfType
  \ConcatSequenceOf{\Sequence_1}{\Sequence_2} \Leftrightarrow
  \ConcatSequenceOf{\SequenceAlt_2}{\SequenceAlt_1}$.

  TODO: redefine so different if $n>m$ or $n<=m$.

  \[
    \begin{array}{rcl}
      (\SequenceLensOf{(\String_0'',\StringAlt_0'');\SequenceLens_1'';
      \ldots;
      \SequenceLens_{n+m}'';(\String_{n+m}'',\StringAlt_{n+m}'')},
      \SwapPermutationOf{\sigma_1}{\sigma_2})
      & = & (\SequenceLensOf{(\String_0'',\StringAlt_0'');\SequenceLens_1'';
            \ldots;\SequenceLens_m'';(\String_m'',\StringAlt_m'');\\
      & & \hspace*{4.5em}\SequenceLens_{m+1}'';
          \ldots;\SequenceLens_{m+n}'';(\String_{m+n}'',\StringAlt_{m+n}'')},
          \SwapPermutationOf{\sigma_1}{\sigma_2})\\
      & = & (\SequenceLensOf{(\String_0,\StringAlt_0');\SequenceLens_1;
            \ldots;\SequenceLens_n;(\String_n\Concat\String_0',\StringAlt_n\Concat\StringAlt_0');\\
      & & \hspace*{4.5em}\SequenceLens_0';
          \ldots;\SequenceLens_m';(\String_m',\StringAlt_m')},
          \SwapPermutationOf{\sigma_1}{\sigma_2})\\
      & = & \ConcatSequenceLensOf{\SequenceLens_1}{\SequenceLens_2}
    \end{array}
  \]


  \[
    \begin{array}{rcl}
      \SequenceOf{\String_0'';\Atom_1'';\ldots;\Atom_{n+m}'';\String_{n+m}''}
      & = & \SequenceOf{\String_0'';\Atom_1'';\ldots;\Atom_n'';\String_n'';\Atom_{n+1}'';
            \ldots\Atom_{n+m}'';\String_{n+m}''}\\
      & = & \SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;(\String_n\Concat\String_0');\Atom_1';
            \ldots\Atom_m';\String_m'}\\
      & = & \ConcatSequenceOf{\Sequence_1}{\Sequence_2}
    \end{array}
  \]


  \[
    \begin{array}{rcl}
      \SequenceOf{\StringAlt_0'';\AtomAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(1)}'';\ldots;
      \AtomAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(n+m)}'';\StringAlt_{n+m}''}
      & = &
            \SequenceOf{\StringAlt_0'';\AtomAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(1)}'';
            \ldots;\AtomAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(n)}'';
            \StringAlt_n'';\AtomAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(n+1)}'';
            \ldots;
            \AtomAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(n+m)}'';\SequenceAlt_{n+m}''}\\
      & = &
            \SequenceOf{\StringAlt_0'';\AtomAlt_{\sigma_1(1)}'';
            \ldots;\AtomAlt_{\sigma_1(n)}'';
            \StringAlt_n'';\AtomAlt_{\sigma_2(1)+n}'';
            \ldots;
            \AtomAlt_{\sigma_2(m)+n}'';\StringAlt_{n+m}''}\\
      & = &
            \SequenceOf{\StringAlt_0;\AtomAlt_{\sigma_1(1)};
            \ldots;\AtomAlt_{\sigma_1(n)};
            \StringAlt_n\Concat\StringAlt_0';\AtomAlt_{\sigma_2(1)}';
            \ldots;
            \AtomAlt_{\sigma_2(m)}';\StringAlt_m'}\\
      & = & \ConcatSequenceOf{\SequenceAlt_1}{\SequenceAlt_2}
    \end{array}
  \]

  So we have a derivation of $\ConcatSequenceLensOf{\SequenceLens_1}{\SequenceLens_2} \OfType
  \ConcatSequenceOf{\Sequence_1}{\Sequence_2} \Leftrightarrow
  \ConcatSequenceOf{\SequenceAlt_1}{\SequenceAlt_2}$

  We also wish to have the desired semantics.

  \[
    \begin{array}{l}
      \SemanticsOf{(\SequenceLensOf{(\String_0'',\StringAlt_0'');\SequenceLens_1'';
      \ldots;
      \SequenceLens_{n+m}'';(\String_{n+m}'',\StringAlt_{n+m}'')},
      \ConcatPermutationOf{\sigma_1}{\sigma_2})}\\
      = \SetOf{(\String_0''\Concat\overline{\String_1}\Concat
      \ldots\Concat\overline{\String_{n+m}}\Concat\String_{n+m}'',
      \StringAlt_0''\Concat\overline{\StringAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(1)}}\Concat
      \ldots\Concat\overline{\StringAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(n+m)}}\Concat\StringAlt_{n+m}''))\SuchThat
      \forall i\in\RangeIncInc{1}{n+m}.(\overline{\String_i},\overline{\StringAlt_i})\in\SequenceLens_i''}\\
      = \SetOf{(\String_0\Concat\overline{\String_1}\Concat\ldots\Concat
      \overline{\String_n}\Concat\String_n\Concat\String_0'\Concat\overline{\String_{0}'}\Concat
      \ldots\Concat\overline{\String_m'}\Concat\String_m',
      \StringAlt_0\Concat\overline{\StringAlt_{\sigma_1(1)}}\Concat\ldots\Concat
      \overline{\StringAlt_{\sigma_1(n)}}\Concat\StringAlt_n\Concat\StringAlt_0'
      \Concat\overline{\StringAlt_{\sigma_2(0)}'}\Concat
      \ldots\Concat\overline{\StringAlt_{\sigma_2(m)}'}\Concat\StringAlt_m'))\\
      \hspace*{3em}\SuchThat
      (\forall i\in\RangeIncInc{1}{n}.
      (\overline{\String_i},\overline{\StringAlt_i})\in\SequenceLens_i
      \BooleanAnd
      \forall i\in\RangeIncInc{1}{m}.
      (\overline{\String_i'},\overline{\StringAlt_i'})\in\SequenceLens_i'}\\
      = \SetOf{(\String\Concat\String',\StringAlt\Concat\StringAlt')\SuchThat
      (\String,\StringAlt)\in\SemanticsOf{\SequenceLens_1}
      \BooleanAnd
      (\String',\StringAlt')\in\SemanticsOf{\SequenceLens_2}}
    \end{array}
  \]
\end{proof}

\begin{lemma}[Typing and Semantics of $\ConcatDNFLens$]
  \label{lem:typ_sem_concat}
  Let $\DNFLens_1 \OfType \DNFRegex_1 \Leftrightarrow \DNFRegexAlt_1$ and
  $\DNFLens_2 \OfType \DNFRegex_2 \Leftrightarrow \DNFRegexAlt_2$ be the typing of
  two DNF lenses, where
  $\UnambigConcatOf{\LanguageOf{\DNFRegex_1}}{\LanguageOf{\DNFRegex_2}}$ and
  $\UnambigConcatOf{\LanguageOf{\DNFRegexAlt_1}}{\LanguageOf{\DNFRegexAlt_2}}$.
  Then $\ConcatDNFLensOf{\DNFLens_1}{\DNFLens_2} \OfType
  \ConcatDNFOf{\DNFRegex_1}{\DNFRegex_2} \Leftrightarrow
  \ConcatDNFOf{\DNFRegexAlt_1}{\DNFRegexAlt_2}$ and
  $\SemanticsOf{\ConcatDNFLensOf{\DNFLens_1}{\DNFLens_2}} =
  \SetOf{(\String_1\Concat\String_2,\StringAlt_1\Concat\StringAlt_2) \SuchThat
    (\String_1,\StringAlt_1)\in\SemanticsOf{\DNFLens_1}
    \BooleanAnd(\String_2,\StringAlt_2)\in\SemanticsOf{\DNFLens_2}}$
\end{lemma}
\begin{proof}
  TODO:
\end{proof}

\begin{lemma}[Typing and Semantics of $\SwapDNFLens$]
  \label{lem:typ_sem_swap}
  Let $\DNFLens_1 \OfType \DNFRegex_1 \Leftrightarrow \DNFRegexAlt_1$ and
  $\DNFLens_2 \OfType \DNFRegex_2 \Leftrightarrow \DNFRegexAlt_2$ be the typing of
  two DNF lenses, where
  $\UnambigConcatOf{\LanguageOf{\DNFRegex_1}}{\LanguageOf{\DNFRegex_2}}$ and
  $\UnambigConcatOf{\LanguageOf{\DNFRegexAlt_2}}{\LanguageOf{\DNFRegexAlt_1}}$.
  Then $\ConcatDNFLensOf{\DNFLens_1}{\DNFLens_2} \OfType
  \ConcatDNFOf{\DNFRegex_1}{\DNFRegex_2} \Leftrightarrow
  \ConcatDNFOf{\DNFRegexAlt_1}{\DNFRegexAlt_2}$ and
  $\SemanticsOf{\ConcatDNFLensOf{\DNFLens_1}{\DNFLens_2}} =
  \SetOf{(\String_1\Concat\String_2,\StringAlt_1\Concat\StringAlt_2) \SuchThat
    (\String_1,\StringAlt_1)\in\SemanticsOf{\DNFLens_1}
    \BooleanAnd(\String_2,\StringAlt_2)\in\SemanticsOf{\DNFLens_2}}$
\end{lemma}
\begin{proof}
  TODO:
\end{proof}

%\begin{definition}[Adjacent Swapping Permutation]
%  Let $\sigma_{i} \in S_n$ be the permutation where
%  $\sigma_{i}(i) = i+1$, $\sigma_{i}(i+1) = i$, $\sigma_{i}(k) = k$
%  when $k\neq i$, and $k\neq i+1$.
%\end{definition}

\begin{lemma}[Typing and Semantics of $\OrDNFLens$]
  \label{lem:typ_sem_or}
  Let $\DNFLens_1 \OfType \DNFRegex_1 \Leftrightarrow \DNFRegexAlt_1$ and
  $\DNFLens_2 \OfType \DNFRegex_2 \Leftrightarrow \DNFRegexAlt_2$ be the typing of
  two DNF lenses, where
  $\LanguageOf{\DNFRegex_1} \Intersect \LanguageOf{\DNFRegex_2} = \emptyset$
  Then $\OrDNFLensOf{\DNFLens_1}{\DNFLens_2} \OfType
  \OrDNFOf{\DNFRegex_1}{\DNFRegex_2} \Leftrightarrow
  \OrDNFOf{\DNFRegexAlt_1}{\DNFRegexAlt_2}$ and
  $\SemanticsOf{\OrDNFLensOf{\DNFLens_1}{\DNFLens_2}} =
  \SetOf{(\String,\StringAlt) \SuchThat
    (\String,\StringAlt)\in\SemanticsOf{\DNFLens_1}
    \BooleanOr(\String,\StringAlt)\in\SemanticsOf{\DNFLens_2}}$
\end{lemma}
\begin{proof}
  By assumption, there exists typing derivations

  \[
    \DNFLens_1 \OfRewritelessType \DNFRegex_1 \Leftrightarrow \DNFRegexAlt_1
  \]
  and
  \[
    \DNFLens_2 \OfRewritelessType \DNFRegex_2 \Leftrightarrow \DNFRegexAlt_2
  \]

  By inversion, we know that the last rule application on each side was
  \DNFLensRule{}, giving

  \[
    \inferrule*
    {
      \SequenceLens_i \OfType \Sequence_i \Leftrightarrow \SequenceAlt_i\\
      \sigma_1 \in \PermutationSetOf{n}\\
      i \neq j \BooleanImplies \Sequence_{i} \cap \Sequence_{j}=\emptyset\\
      i \neq j \BooleanImplies \SequenceAlt_{i} \cap \SequenceAlt_{j}=\emptyset\\
    }
    {
      (\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n},\sigma_1)
      \OfRewritelessType
      \DNFOf{\Sequence_1;\ldots;\Sequence_n} \Leftrightarrow
      \DNFOf{\SequenceAlt_{\sigma_1(1)};\ldots;\SequenceAlt_{\sigma_1(n)}}
    }
  \]
  and
  \[
    \inferrule*
    {
      \SequenceLens_i' \OfType \Sequence_i' \Leftrightarrow \SequenceAlt_i'\\
      \sigma_2 \in \PermutationSetOf{m}\\
      i \neq j \BooleanImplies \Sequence_{i}' \cap \Sequence_{j}'=\emptyset\\
      i \neq j \BooleanImplies \SequenceAlt_{i}' \cap \SequenceAlt_{j}'=\emptyset\\
    }
    {
      (\DNFLensOf{\SequenceLens_1';\ldots;\SequenceLens_m'},\sigma_2)
      \OfRewritelessType
      \DNFOf{\Sequence_1';\ldots;\Sequence_m'} \Leftrightarrow
      \DNFOf{\SequenceAlt_{\sigma_2(1)}';\ldots;\SequenceAlt_{\sigma_2(m)}'}
    }
  \]
  where
  $\DNFLens_1 = (\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n},\sigma_1)$,
  $\DNFRegex_1 = \DNFOf{\Sequence_1;\ldots;\Sequence_n}$,
  $\DNFRegexAlt_1 = \DNFOf{\SequenceAlt_{\sigma_1(1)};\ldots;\SequenceAlt_{\sigma_1(n)}}$,
  $\DNFLens_2 = (\DNFLensOf{\SequenceLens_1';\ldots;\SequenceLens_m'},\sigma_2)$,
  $\DNFRegex_2 = \DNFOf{\Sequence_1';\ldots;\Sequence_m'}$, and
  $\DNFRegexAlt_2 =
  \DNFOf{\SequenceAlt_{\sigma_2(1)}';\ldots;\SequenceAlt_{\sigma_2(m)}'}$.

  Define $\Sequence_i$ as $\Sequence_{i-n}'$ for
  $i \in \RangeIncInc{n+1}{n+m}$.
  Define $\SequenceAlt_i$ as $\SequenceAlt_{i-n}$ for $i \in
  \RangeIncInc{n+1}{n+m}$.
  Define $\SequenceLens_i$ as $\SequenceLens_{i-n}'$ for $i \in
  \RangeIncInc{n+1}{n+m}$.

  If $i \neq j$, and $i,j\in\RangeIncInc{1}{n}$, then $\Sequence_i \cap
  \Sequence_j = \emptyset$ by the derivation of $\DNFLens_1$.
  If $i \neq j$, and $i,j\in\RangeIncInc{n+1}{n+m}$, then $\Sequence_i \cap
  \Sequence_j = \emptyset$ by the derivation of $\DNFLens_2$.
  If $i \neq j$ and $i\in\RangeIncInc{1}{n}$ and $j\in\RangeIncInc{n+1}{n+m}$,
  then $\Sequence_i \cap \Sequence_j = \emptyset$ as $\DNFRegex_1 \cap
  \DNFRegex_2 = \emptyset$, and $\LanguageOf{\Sequence_i} \subset
  \LanguageOf{\DNFRegex_1}$, and $\LanguageOf{\Sequence_j} \subset
  \LanguageOf{\DNFRegex_1}$.
  If $i \neq j$ and $i\in\RangeIncInc{n+1}{n+m}$ and $j\in\RangeIncInc{1}{n}$,
  then $\Sequence_i \cap \Sequence_j = \emptyset$ as $\cap$ is commutative.
  Because of these cases, if $i \neq j$, then $\Sequence_i \cap \Sequence_j = \emptyset$ for all $i,j
  \in \RangeIncInc{1}{n+m}$.

  For a symmetric reason, if $i \neq j$, then $\SequenceAlt_i \cap
  \SequenceAlt_j = \emptyset$, for all $i,j \in \RangeIncInc{1}{n+m}$.

  Consider the derivation

  \[
    \inferrule*
    {
      \SequenceLens_i \OfType \Sequence_i \Leftrightarrow \SequenceAlt_i\\
      \ConcatPermutationOf{\sigma_1}{\sigma_2} \in \PermutationSetOf{n}\\
      i \neq j \BooleanImplies \Sequence_{i} \cap \Sequence_{j}=\emptyset\\
      i \neq j \BooleanImplies \SequenceAlt_{i} \cap \SequenceAlt_{j}=\emptyset\\
    }
    {
      (\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_{n+m}},
      \ConcatPermutationOf{\sigma_1}{\sigma_2})
      \OfRewritelessType
      \DNFOf{\Sequence_1;\ldots;\Sequence_{n+m}} \Leftrightarrow
      \DNFOf{\SequenceAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(1)};\ldots
        ;\SequenceAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(1)(n+m)}}
    }
  \]

  We wish to show that this is a derivation of
  $\OrDNFLensOf{\DNFLens_1}{\DNFLens_2} \OfType
  \OrDNFOf{\DNFRegex_1}{\DNFRegex_2} \Leftrightarrow
  \OrDNFOf{\DNFRegexAlt_1}{\DNFRegexAlt_2}$.

  \[
    \begin{array}{rcl}
      (\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_{n+m}},
      \ConcatPermutationOf{\sigma_1}{\sigma_2})
      & = & (\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n;
            \SequenceLens_1';\ldots;\SequenceLens_m'},
            \ConcatPermutationOf{\sigma_1}{\sigma_2})\\
      & = & \OrDNFLensOf{\DNFLens_1}{\DNFLens_2}
    \end{array}
  \]


  \[
    \begin{array}{rcl}
      \DNFOf{\Sequence_1;\ldots;\Sequence_{n+m}}
      & = & \DNFOf{\Sequence_1;\ldots;\Sequence_n;
            \Sequence_1';\ldots\Sequence_n'}\\
      & = & \OrDNFOf{\DNFRegex_1}{\DNFRegex_2}
    \end{array}
  \]


  \[
    \begin{array}{rcl}
      \DNFOf{\SequenceAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(1)};\ldots;
      \SequenceAlt_{\ConcatPermutationOf{\sigma_1}{\sigma_2}(n+m)}}
      & = & \DNFOf{\SequenceAlt_{\sigma_1(1)};\ldots;\SequenceAlt_{\sigma_1(n)};
            \SequenceAlt_{\sigma_2(n+1-n)+n};\SequenceAlt_{\sigma_2(n+m-n)+n}}\\
      & = & \DNFOf{\SequenceAlt_{\sigma_1(1)};\ldots;\SequenceAlt_{\sigma_1(n)};
            \SequenceAlt_{\sigma_2(1)+n};\SequenceAlt_{\sigma_2(m)+n}}\\
      & = & \DNFOf{\SequenceAlt_{\sigma_1(1)};\ldots;\SequenceAlt_{\sigma_1(n)};
            \SequenceAlt_{\sigma_2(1)}';\SequenceAlt_{\sigma_2(m)}'}\\
      & = & \OrDNFOf{\DNFRegexAlt_1}{\DNFRegexAlt_2}
    \end{array}
  \]

  So we have a derivation of $\OrDNFLensOf{\DNFLens_1}{\DNFLens_2} \OfType
  \OrDNFOf{\DNFRegex_1}{\DNFRegex_2} \Leftrightarrow
  \OrDNFOf{\DNFRegexAlt_1}{\DNFRegexAlt_2}$

  We also wish to have the desired semantics.

  \[
    \begin{array}{rcl}
      \SemanticsOf{(\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_{n+m}},
      \ConcatPermutationOf{\sigma_1}{\sigma_2})}
      & = & \SetOf{(\String,\StringAlt)\SuchThat
            (\String,\StringAlt)\in\SequenceLens_i\text{ for some $i$}}\\
      & = & \SetOf{(\String,\StringAlt)\SuchThat
            (\String,\StringAlt)\in\SequenceLens_i
            \text{ for some $i\in\RangeIncInc{1}{n}$} \BooleanOr
            (\String,\StringAlt)\in\SequenceLens_i
            \text{ for some $i\in\RangeIncInc{n+1}{n+m}$}}\\
      & = & \SetOf{(\String,\StringAlt)\SuchThat
            (\String,\StringAlt)\in\SequenceLens_i
            \text{ for some $i\in\RangeIncInc{1}{n}$} \BooleanOr
            (\String,\StringAlt)\in\SequenceLens_i'
            \text{ for some $i\in\RangeIncInc{1}{m}$}}\\
      & = & \SetOf{(\String,\StringAlt) \SuchThat
            (\String,\StringAlt)\in\SemanticsOf{\DNFLens_1}
            \BooleanOr(\String,\StringAlt)\in\SemanticsOf{\DNFLens_2}}
    \end{array}
  \]

\end{proof}

\begin{lemma}[Typing and Semantic of $\AtomToDNFLens$]
  \label{lem:typ_sem_todnflens}
  If $\AtomLens \OfRewritelessType \Atom \Leftrightarrow \AtomAlt$ is the
  typing of a rewriteless Atom lens, then
  $\AtomToDNFLensOf{\AtomLens} \OfRewritelessType \AtomToDNFOf{\Atom}
  \Leftrightarrow \AtomToDNFOf{\AtomAlt}$, and
  $\SemanticsOf{\AtomToDNFLensOf{\AtomLens}} = \SemanticsOf{\AtomLens}$.
\end{lemma}
\begin{proof}
  Let $\AtomLens \OfRewritelessType \Atom \Leftrightarrow \AtomAlt$.
  
  $\SequenceUnambigConcatOf{(\EmptyString;\Atom;\EmptyString)}$ because
  $\LanguageOf{\EmptyString} = \SetOf{\EmptyString}$.
  $\SequenceUnambigConcatOf{(\EmptyString;\AtomAlt;\EmptyString)}$ because
  $\LanguageOf{\EmptyString} = \SetOf{\EmptyString}$.

  As there is only one sequence, the pointwise disjoint condition for DNF lenses
  are true vacuously.
  
  Consider the typing derivation
  \[
    \inferrule*
    {
      \inferrule*
      {
        \AtomLens \OfRewritelessType \Atom \Leftrightarrow \AtomAlt\\
        \SequenceUnambigConcatOf{(\EmptyString;\Atom;\EmptyString)}\\
        \SequenceUnambigConcatOf{(\EmptyString;\AtomAlt;\EmptyString)}
      }
      {
        (\SequenceLensOf{(\EmptyString,\EmptyString);\AtomLens;(\EmptyString,\EmptyString)},\Identity)
        \OfRewritelessType
        \SequenceOf{\EmptyString;\Atom;\EmptyString} \Leftrightarrow
        \SequenceOf{\EmptyString;\AtomAlt;\EmptyString}
      }\\
      i \neq j \BooleanImplies \LanguageOf{\Sequence_i} \Intersect
      \LanguageOf{\Sequence_j} = \emptyset
    }
    {
      (\DNFLensOf{(\SequenceLensOf{(\EmptyString,\EmptyString);\AtomLens;(\EmptyString,\EmptyString)},\Identity)},\Identity)
      \OfRewritelessType
      \DNFOf{\SequenceOf{\EmptyString;\Atom;\EmptyString}} \Leftrightarrow
      \DNFOf{\SequenceOf{\EmptyString;\AtomAlt;\EmptyString}}
    }
  \]
  
  $\AtomToDNFLensOf{\AtomLens} =
  (\DNFLensOf{(\SequenceLensOf{(\EmptyString,\EmptyString);\AtomLens;(\EmptyString,\EmptyString)},\Identity)},\Identity)$.
  
  $\SemanticsOf{\SequenceLensOf{(\EmptyString,\EmptyString);\AtomLens;(\EmptyString,\EmptyString)}}
  =
  \SetOf{(\EmptyString,\String,\EmptyString,\EmptyString,\StringAlt,\EmptyString)
    \SuchThat (\String,\StringAlt) \in \LanguageOf{\AtomLens}} =
  \SemanticsOf{\AtomLens}$.

  $\SemanticsOf{(\DNFLensOf{(\SequenceLensOf{(\EmptyString,\EmptyString);\AtomLens;(\EmptyString,\EmptyString)},\Identity)},\Identity)}
  =
  \SetOf{(\String,\StringAlt) \SuchThat (\String,\StringAlt) \in
    \SemanticsOf{\SequenceLensOf{(\EmptyString,\EmptyString);\AtomLens;(\EmptyString,\EmptyString)}}}
  = \SetOf{(\String,\StringAlt) \SuchThat (\String,\StringAlt) \in
    \SemanticsOf{\AtomLens}}
  = \SemanticsOf{\AtomLens}$
\end{proof}

\begin{lemma}[Typing and Semantics of $\AtomToDNFLensOf{\IterateLensOf{\cdot}}$]
  \label{lem:typ_sem_it}
  Let $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt$ be
  the typing of a rewriteless DNF lens, where
  $\UnambigItOf{\DNFRegex}$ and $\UnambigItOf{\DNFRegexAlt}$.
  $\DNFLensOf{\SequenceLensOf{\IterateLensOf{\DNFLens}}} \OfRewritelessType
  \DNFOf{\SequenceOf{\StarOf{\DNFRegex}}} \Leftrightarrow
  \DNFOf{\SequenceOf{\StarOf{\DNFRegexAlt}}}$ and
  $\SemanticsOf{\DNFLensOf{\SequenceLensOf{\IterateLensOf{\DNFLens}}}} =
  \SetOf{
    (\String_1\Concat\ldots\Concat\String_n,\StringAlt_1\Concat\ldots\Concat\StringAlt_n)
    \SuchThat
    (\String_i,\StringAlt_i)\in\SemanticsOf{\DNFLens}}$
\end{lemma}
\begin{proof}
  By assumption, there exists a typing derivation

  \[
    \DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt
  \]

  Consider the typing derivation

  \[
    \inferrule*
    {
      \inferrule*
      {
        \inferrule*
        {
          \DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt\\
          \UnambigItOf{\DNFRegex}\\
          \UnambigItOf{\DNFRegexAlt}
        }
        {
          \IterateLensOf{\DNFLens} \OfRewritelessType
          \StarOf{\DNFRegex} \Leftrightarrow \StarOf{\DNFRegexAlt}
        }\\
        \SequenceUnambigConcatOf{\EmptyString;\DNFRegex;\EmptyString}\\
        \SequenceUnambigConcatOf{\EmptyString;\DNFRegexAlt;\EmptyString}
      }
      {
        \SequenceLensOf{(\EmptyString,\EmptyString);\IterateLensOf{\DNFLens};(\EmptyString,\EmptyString)}
        \OfRewritelessType \SequenceOf{\EmptyString;\DNFRegex;\EmptyString}
        \Leftrightarrow \SequenceOf{\EmptyString;\DNFRegex;\EmptyString}
      }
    }
    {
      \DNFLensOf{\SequenceLensOf{\IterateLensOf{\DNFLens}}} \OfRewritelessType
      \DNFOf{\SequenceOf{\StarOf{\DNFRegex}}} \Leftrightarrow
      \DNFOf{\SequenceOf{\StarOf{\DNFRegexAlt}}}
    }
  \]

  And the semantics are shown to be equal to the desired semantics.

  \[
    \begin{array}{rcl}
      \SemanticsOf{\DNFLensOf{\SequenceLensOf{\IterateLensOf{\DNFLens}}}}
      & = &
            \SetOf{
            (\String,\StringAlt)
            \SuchThat
            (\String,\StringAlt)\in\SemanticsOf{\SequenceLensOf{\IterateLensOf{\DNFLens}}}}\\
      & = &
            \SetOf{
            (\EmptyString\Concat\String\Concat\EmptyString,\EmptyString\Concat\StringAlt\Concat\EmptyString)
            \SuchThat
            (\String,\StringAlt)\in\SemanticsOf{\IterateLensOf{\DNFLens}}}\\
      & = &
            \SetOf{
            (\String_1\Concat\ldots\Concat\String_n,\StringAlt_1\Concat\ldots\Concat\StringAlt_n)
            \SuchThat
            (\String_i,\StringAlt_i)\in\SemanticsOf{\DNFLens}}
    \end{array}
  \]
\end{proof}

\begin{lemma}[Commutativity of $\OrDNF$]
  \label{lem:or-dnf-commutativity}
  If there exists a lens $\DNFLens \OfRewritelessType \DNFRegex_1 \OrDNF \DNFRegex_2
  \Leftrightarrow \DNFRegexAlt_1 \OrDNF \DNFRegexAlt_2$, then there exists a
  lens
  $\DNFLens \OfRewritelessType \DNFRegex_1 \OrDNF \DNFRegex_2
  \Leftrightarrow \DNFRegexAlt_2 \OrDNF \DNFRegexAlt_1$.
\end{lemma}
\begin{proof}
  TODO
\end{proof}

\begin{lemma}[Left Unrolling of $\IterateLens$]
  \label{lem:iterate-lens-unroll-left}
  If $\IterateLensOf{\DNFLens}$ is an atom lens, then
  $\DNFLens' = \DNFLensOf{\SequenceLensOf{(\EmptyString,\EmptyString)}} \OrDNFLens (\DNFLens
  \ConcatDNFLens \AtomToDNFLensOf{\IterateLensOf{\DNFLens}})$ is a DNF Lens with
  $\SemanticsOf{\IterateLensOf{\DNFLens}} = \SemanticsOf{\DNFLens'}$
\end{lemma}
\begin{proof}
  TODO
\end{proof}

\begin{lemma}[Right Unrolling of $\IterateLens$]
  \label{lem:iterate-lens-unroll-right}
  If $\IterateLensOf{\DNFLens}$ is an atom lens, then
  $\DNFLens' = \DNFLensOf{\SequenceLensOf{(\EmptyString,\EmptyString)}} \OrDNFLens (\AtomToDNFLensOf{\IterateLensOf{\DNFLens}}
  \ConcatDNFLens \DNFLens)$ is a DNF Lens with
  $\SemanticsOf{\IterateLensOf{\DNFLens}} = \SemanticsOf{\DNFLens'}$
\end{lemma}
\begin{proof}
  TODO
\end{proof}

\begin{lemma}[Left Unrolling of $\IterateLens$ DNF]
  \label{lem:iterate-lens-unroll-left-dnf}
  If $\AtomToDNFLensOf{\IterateLensOf{\DNFLens}}$ is a DNF lens, then
  $\DNFLens' = \DNFLensOf{\SequenceLensOf{(\EmptyString,\EmptyString)}} \OrDNFLens (\DNFLens
  \ConcatDNFLens \AtomToDNFLensOf{\IterateLensOf{\DNFLens}})$ is a DNF Lens with
  $\SemanticsOf{\IterateLensOf{\DNFLens}} = \SemanticsOf{\DNFLens'}$
\end{lemma}
\begin{proof}
  TODO
\end{proof}

\begin{lemma}[Right Unrolling of $\IterateLens$ DNF]
  \label{lem:iterate-lens-unroll-right-dnf}
  If $\AtomToDNFLensOf{\IterateLensOf{\DNFLens}}$ is a DNF lens, then
  $\DNFLens' = \DNFLensOf{\SequenceLensOf{(\EmptyString,\EmptyString)}} \OrDNFLens (\AtomToDNFLensOf{\IterateLensOf{\DNFLens}}
  \ConcatDNFLens \DNFLens)$ is a DNF Lens with
  $\SemanticsOf{\IterateLensOf{\DNFLens}} = \SemanticsOf{\AtomToDNFLensOf{\DNFLens'}}$
\end{lemma}
\begin{proof}
  By Lemma~\ref{}
\end{proof}

\begin{lemma}[Closure of Rewriteless Regular Expressions under Composition]
  \leavevmode
  \label{lem:composition-completeness}
  \begin{enumerate}
  \item If there are two atom lenses
    $\AtomLens_1 \OfRewritelessType \Atom_1 \Leftrightarrow \Atom_2$ and
    $\AtomLens_2 \OfRewritelessType \Atom_2 \Leftrightarrow \Atom_3$,
    then there exists an atom lens
    $\AtomLens \OfRewritelessType \Atom_1 \Leftrightarrow \Atom_3$, such that
    $\SemanticsOf{\AtomLens}=\SetOf{(\String_1,\String_3)\SuchThat
      \exists\String_2
      (\String_1,\String_2)\in\SemanticsOf{\AtomLens_1}\BooleanAnd
      (\String_2,\String_3)\in\SemanticsOf{\AtomLens_2}}$

  \item If there are two sequence lenses
    $\SequenceLens_1 \OfRewritelessType \Sequence_1 \Leftrightarrow \Sequence_2$ and
    $\SequenceLens_2 \OfRewritelessType \Sequence_2 \Leftrightarrow \Sequence_3$,
    then there exists an sequence lens
    $\SequenceLens \OfRewritelessType \Sequence_1 \Leftrightarrow \Sequence_3$, such that
    $\SemanticsOf{\SequenceLens}=\SetOf{(\String_1,\String_3)\SuchThat
      \exists\String_2
      (\String_1,\String_2)\in\SemanticsOf{\SequenceLens_1}\BooleanAnd
      (\String_2,\String_3)\in\SemanticsOf{\SequenceLens_2}}$

  \item If there are two DNF lenses
    $\DNFLens_1 \OfRewritelessType \DNFRegex_1 \Leftrightarrow \DNFRegex_2$ and
    $\DNFLens_2 \OfRewritelessType \DNFRegex_2 \Leftrightarrow \DNFRegex_3$,
    then there exists a DNF lens
    $\DNFLens \OfRewritelessType \DNFRegex_1 \Leftrightarrow \DNFRegex_3$, such that
    $\SemanticsOf{\DNFLens}=\SetOf{(\String_1,\String_3)\SuchThat
      \exists\String_2
      (\String_1,\String_2)\in\SemanticsOf{\DNFLens_1}\BooleanAnd
      (\String_2,\String_3)\in\SemanticsOf{\DNFLens_2}}$
  \end{enumerate}
\end{lemma}

\begin{proof}
  By mutual induction

  Let $\StarOf{\DNFRegex_1}$, $\StarOf{\DNFRegex_2}$, $\StarOf{\DNFRegex_3}$
  be three atoms, and $\IterateLensOf{\DNFLens_1} \OfType
  \StarOf{\DNFRegex_1} \Leftrightarrow \StarOf{\DNFRegex_2}$ with
  $\IterateLensOf{\DNFLens_2} \OfType
  \StarOf{\DNFRegex_2} \Leftrightarrow \StarOf{\DNFRegex_3}$
  lenses between them.
  By induction assumption, there exists the typing of a lens

  \[
    \inferrule[]
    {
      \Derivation{}
    }
    {
      \DNFLens \OfType \DNFRegex_1 \Leftrightarrow \DNFRegex_3
    }
  \]

  such that $\SemanticsOf{\DNFLens}=\SetOf{(\String_1,\String_3)\SuchThat
    \exists \String_2
    (\String_1,\String_2)\in\SemanticsOf{\DNFLens_1}\BooleanAnd
    (\String_2,\String_3)\in\SemanticsOf{\DNFLens_2}}$

  $\IterateLensOf{\DNFLens_1}$ and
  $\IterateLensOf{\DNFLens_2}$ came from $\AtomLensRule$, so
  $\UnambigItOf{\DNFRegex_1}$,
  $\UnambigItOf{\DNFRegex_2}$, and
  $\UnambigItOf{\DNFRegex_3}$.

  Consider the lens

  \[
    \inferrule*
    {
      \inferrule*
      {
        \Derivation{}
      }
      {
        \DNFLens \OfType \DNFRegex_1 \Leftrightarrow \DNFRegex_3
      }\\
      \UnambigItOf{\DNFRegex_1}\\
      \UnambigItOf{\DNFRegex_2}
    }
    {
      \IterateLensOf{\DNFLens} \OfType
      \StarOf{\DNFRegex_1} \Leftrightarrow \StarOf{\DNFRegex_3}
    }
  \]

  This lens has the semantics

  \begin{tabular}{@{}L@{}L@{}}
    \SemanticsOf{\IterateLensOf{\DNFLens}}
    & = \SetOf{(\String_{1,1}\Concat\ldots\Concat\String_{1,n},
      \String_{3,1}\Concat\ldots\Concat\String_{3,n})\\
    & \hspace{2em}
      \SuchThat(\String_{1,i},\String_{3,i})\in\SemanticsOf{\DNFLens}}\\
    & =
      \SetOf{(\String_{1,1}\Concat\ldots\Concat\String_{1,n},
      \String_{3,1}\Concat\ldots\Concat\String_{3,n})\\
    & \hspace{2em}
      \SuchThat
      \exists\String_{2,i} (\String_{1,i},\String_{2,i})\in\SemanticsOf{\DNFLens_1}\\
    & \hspace{4em}
      \BooleanAnd
      (\String_{2,i},\String_{3,i})\in\SemanticsOf{\DNFLens_2}}\\
    & =
      \SetOf{(\String_{1,1}\Concat\ldots\Concat\String_{1,n},
      \String_{3,1}\Concat\ldots\Concat\String_{3,n}) \\
    & \hspace{2em}
      \SuchThat
      \exists\String_{2,1}\Concat\ldots\Concat\String_{2,n}\\
    & \hspace{4em}
      (\String_{1,1}\Concat\ldots\Concat\String_{1,n},
      \String_{2,1}\Concat\ldots\Concat\String_{2,n})
      \in\SemanticsOf{\IterateLensOf{\DNFLens}}\\
    & \hspace{4em}
      \BooleanAnd
      (\String_{2,1}\Concat\ldots\Concat\String_{2,n},
      \String_{3,1}\Concat\ldots\Concat\String_{3,n})
      \in\SemanticsOf{\IterateLensOf{\DNFLens}}}\\
    & =
      \SetOf{(\String_1,\String_3)\SuchThat\exists\String_2
      (\String_1,\String_2)\in\SemanticsOf{\IterateLensOf{\DNFLens_1}}\\
    & \hspace{4em}\BooleanAnd
      (\String_2,\String_3)\in\SemanticsOf{\IterateLensOf{\DNFLens_2}}}
  \end{tabular}

  Let $\SequenceOf{\String_{1,0}\SequenceSep\Atom_{1,1}\SequenceSep
    \ldots\SequenceSep\Atom_{1,n}\SequenceSep\String_{1,n}}$,
  $\SequenceOf{\String_{2,0}\SequenceSep\Atom_{2,\Permutation_1(1)}\SequenceSep
    \ldots\SequenceSep\Atom_{2,\Permutation_1(n)}\SequenceSep\String_{2,n}}$,
  and $\SequenceOf{\String_{3,0}\SequenceSep
    \Atom_{3,\Permutation_2\Compose\Permutation_1(1)}\SequenceSep
    \ldots\SequenceSep\Atom_{3,\Permutation_2\Compose\Permutation_1(n)}
    \SequenceSep\String_{3,n}}$ be sequences,
  with $(\SequenceLensOf{(\String_{1,0},\String_{2,0})\SequenceLensSep
    \AtomLens_{1,1}\SequenceLensSep\ldots\SequenceLensSep\AtomLens_{1,n}
    \SequenceLensSep(\String_{1,n},\String_{2,n})},\Permutation_1)$ and
  $(\SequenceLensOf{(\String_{2,0},\String_{3,0})\SequenceLensSep
    \AtomLens_{2,1}\SequenceLensSep\ldots\SequenceLensSep\AtomLens_{2,n}
    \SequenceLensSep(\String_{2,n},\String_{3,n})},\Permutation_2)$ be lenses between them.
  By induction assumption, there is a typing of lenses
  \begin{mathpar}
    \inferrule[]
    {
      \Derivation_i
    }
    {
      \AtomLens_i \OfType \Atom_{1,i} \Leftrightarrow \Atom_{3,i}
    }
  \end{mathpar}
  such that \SemanticsOf{\AtomLens_i} = \SetOf{(\String_1,\String_3)\SuchThat
    \exists \String_2 (\String_1,\String_2)\in\SemanticsOf{\AtomLens_{1,i}}
    \BooleanAnd (\String_2,\String_3)\in\SemanticsOf{\Atom_{2,i}}}
  Define $\Permutation = \Permutation_2\Compose\Permutation_1$.


  $(\SequenceLensOf{(\String_{1,0},\String_{2,0})\SequenceLensSep
    \AtomLens_{1,1}\SequenceLensSep\ldots\SequenceLensSep\AtomLens_{1,n}
    \SequenceLensSep(\String_{1,n},\String_{2,n})},\Permutation_1)$
  and
  $(\SequenceLensOf{(\String_{2,0},\String_{3,0})\SequenceLensSep
    \AtomLens_{2,1}\SequenceLensSep\ldots\SequenceLensSep\AtomLens_{2,n}
    \SequenceLensSep(\String_{2,n},\String_{3,n})},\Permutation_2)$
  came from
  \SequenceLensRule{}, so 
  $\SequenceUnambigConcatOf{\SequenceOf{\String_{1,0}\SequenceSep\Atom_{1,1}
      \SequenceSep\ldots\SequenceSep\Atom_{1,n}\SequenceSep\String_{1,n}}}$ and
  $\SequenceUnambigConcatOf{\SequenceOf{\String_{3,0}\SequenceSep
      \Atom_{\Permutation(3),1}\SequenceSep\ldots
      \SequenceSep\Atom_{\Permutation(3),n}\SequenceSep\String_{3,n}}}$.

  Consider the typing of the lens
  \[
    \inferrule{
      \inferrule*
      {
        \Derivation_0
      }
      {
        \AtomLens_0 \OfType \Atom_{1,0} \Leftrightarrow \Atom_{3,0}
      }\\
      \ldots\\
      \inferrule*
      {
        \Derivation_n
      }
      {
        \AtomLens_n \OfType \Atom_{1,n} \Leftrightarrow \Atom_{3,n}
      }\\
      \sigma\in\PermutationSetOf{n}\\
      \SequenceUnambigConcatOf{\SequenceOf{\String_{1,0}\SequenceSep\Atom_{1,1}
          \SequenceSep\ldots\SequenceSep\Atom_{1,n}\SequenceSep\String_{1,n}}}\\
      \SequenceUnambigConcatOf{\SequenceOf{\String_{3,0}\SequenceSep
          \Atom_{\Permutation(3),1}\SequenceSep\ldots
          \SequenceSep\Atom_{\Permutation(3),n}\SequenceSep\String_{3,n}}}
    }
    {
      (\SequenceLensOf{(\String_{1,0},\String_{3,0})\SequenceLensSep\AtomLens_1
        \SequenceLensSep\ldots\SequenceLensSep\AtomLens_n
        \SequenceLensSep(\String_{1,n},\String_{3,n})},\Permutation) \OfType\\
      \SequenceOf{\String_{1,0}\SequenceSep\Atom_{1,1}\SequenceSep\ldots
        \SequenceSep\Atom_{1,n}\SequenceSep\String_{1,n}} \Leftrightarrow
      \SequenceOf{\String_{3,0}\SequenceSep\Atom_{3,\Permutation(1)}\SequenceSep\ldots
        \SequenceSep\Atom_{3,\Permutation(n)}\SequenceSep\String_{3,n}}
    }
  \]

  Furthermore, we can prove the desired property of the semantics.\\
  \SemanticsOf{(\SequenceLensOf{(\String_{1,0},\String_{3,0})\SequenceLensSep
      \AtomLens_1\SequenceLensSep\ldots\SequenceLensSep\AtomLens_n
      \SequenceLensSep(\String_{1,n},\String_{3,n})},\Permutation)}=\\
  \SetOf{(\String_{1,0}\Concat\String_1\Concat\ldots
    \Concat\String_n\Concat\String_{1,n},
    \String_{3,0}\Concat\StringAlt_{\Permutation(1)}\Concat\ldots
    \Concat\StringAlt_{\Permutation(n)}\Concat\String_{1,n})\\
    \hspace*{1em}\SuchThat(\String_i,\StringAlt_i)\in\SemanticsOf{\AtomLens_i}}=\\
  \SetOf{(\String_{1,0}\Concat\String_1\Concat\ldots
    \Concat\String_n\Concat\String_{1,n},
    \String_{3,0}\Concat\StringAlt_{\Permutation(1)}\Concat\ldots
    \Concat\StringAlt_{\Permutation(n)}\Concat\String_{1,n})\\
    \hspace*{1em}\SuchThat\exists\String_i'\in\LanguageOf{\Atom_{2,i}}
    (\String_i,\String_i')\in\SemanticsOf{\AtomLens_i}\BooleanAnd
    (\String_i',\StringAlt_i)\in\SemanticsOf{\AtomLens_i}}\\
  \SetOf{(\String_{1,0}\Concat\String_1\Concat\ldots
    \Concat\String_n\Concat\String_{1,n},
    \String_{3,0}\Concat\StringAlt_{\Permutation(1)}\Concat\ldots
    \Concat\StringAlt_{\Permutation(n)}\Concat\String_{1,n})\\
    \hspace*{1em}\SuchThat\exists
    \String_{2,0}\Concat\String_{\Permutation_1(1)}'\Concat\ldots\Concat
    \String_{\Permutation_1(n)}'\Concat\String_{2,n}\in\LanguageOf{\Atom_{2,i}}\\
    \hspace*{2em}
    (\String_{1,0}\Concat\String_1\Concat\ldots
    \Concat\String_n\Concat\String_{1,n},\String_{2,0}\Concat
    \String_{\Permutation_1(1)}'\Concat\ldots\Concat
    \String_{\Permutation_1(n)}'\Concat\String_{2,n})\\
    \hspace*{3em}\in\SemanticsOf{(\SequenceLensOf{(\String_{1,0},\String_{2,0})
        \SequenceLensSep\AtomLens_{1,1}\SequenceLensSep\ldots\SequenceLensSep
        \AtomLens_{1,n}\SequenceLensSep(\String_{1,n},\String_{2,n})},\Permutation_1)}
    \BooleanAnd\\
    \hspace*{2em}
    (\String_{2,0}\Concat\String_{\Permutation_1(1)}'\Concat\ldots\Concat
    \String_{\Permutation_1(n)}'\Concat\String_{2,n},\String_{3,0}\Concat\StringAlt_{\Permutation(1)}\Concat\ldots
    \Concat\StringAlt_{\Permutation(n)}\Concat\String_{1,n})\\
    \hspace*{3em}\in\SemanticsOf{(\SequenceLensOf{(\String_{2,0},\String_{3,0})\SequenceLensSep
        \AtomLens_{2,1}\SequenceLensSep\ldots\SequenceLensSep\AtomLens_{2,n}
        \SequenceLensSep(\String_{2,n},\String_{3,n})},\Permutation_2)}}\\
  \SetOf{(\String_1,\String_3)\SuchThat\exists\String_2\\
    \hspace*{2em}
    (\String_1,\String_2)\\
    \hspace*{3em}\in\SemanticsOf{(\SequenceLensOf{(\String_{1,0},\String_{2,0})
        \SequenceLensSep\AtomLens_{1,1}\SequenceLensSep\ldots\SequenceLensSep
        \AtomLens_{1,n}\SequenceLensSep(\String_{1,n},\String_{2,n})},\Permutation_1)}\\
    \hspace*{2em}
    (\String_2,\String_3)\\
    \hspace*{3em}\in\SemanticsOf{(\SequenceLensOf{(\String_{2,0},\String_{3,0})
        \SequenceLensSep\AtomLens_{2,1}\SequenceLensSep\ldots\SequenceLensSep
        \AtomLens_{2,n}\SequenceLensSep(\String_{2,n},\String_{3,n})},\Permutation_2)}}

  Let $\DNFRegex_1=\DNFOf{\Sequence_{1,1}\DNFSep\ldots\DNFSep\Sequence_{1,n}}$,
  $\DNFRegex_2=\DNFOf{\Sequence_{2,\Permutation_1(1)}\DNFSep\ldots
    \DNFSep\Sequence_{2,\Permutation_1(n)}}$,
  and $\DNFRegex_3=\DNFOf{\Sequence_{3,\Permutation_2\Compose\Permutation_1(1)}
    \DNFSep\ldots\DNFSep\Sequence_{3,\Permutation_2\Compose\Permutation_1(n)}}$
  be three DNF regular expressions.
  Let $\DNFLens_1=(\DNFLensOf{\SequenceLens_{1,1}\DNFLensSep\ldots
    \DNFLensSep\SequenceLens_{1,n}},\Permutation_1)\OfType
  \DNFRegex_1\Leftrightarrow\DNFRegex_2$ and
  $\DNFLens_2=(\DNFLensOf{\SequenceLens_{2,1}\DNFLensSep\ldots
    \DNFLensSep\SequenceLens_{2,n}},\Permutation_2)\OfRewritelessType
  \DNFRegex_2\Leftrightarrow\DNFRegex_3$ be lenses between them.
  By induction assumption, there exists a typing of lenses
  \begin{mathpar}
    \inferrule*
    {
      \Derivation_i
    }
    {
      \Sequence_i \OfRewritelessType \Sequence_{1,i} \Leftrightarrow \Sequence_{3,i}
    }
  \end{mathpar}
\end{proof}


\begin{lemma}[Expressibility of Adjacency Swapping Permutation of Separated Concat List]
  Let for all $i \in \RangeIncInc{1}{n}, \DNFLens_i \OfRewritelessType
  \DNFRegex_i \Leftrightarrow \DNFRegexAlt_i$
  Let $\sigma_i$ be an adjacency swapping permutation, where $1 \leq i < n$.
  There exists a DNF lens $\DNFLens \OfRewritelessType \DNFOf{\SequenceOf{\Sep}}
  \DNFRegex_1 \ConcatDNF \DNFOf{\SequenceOf{\Sep}} \ConcatDNF
  \ldots \ConcatDNF \DNFOf{\SequenceOf{\Sep}} \ConcatDNF
  \DNFOf{\SequenceOf{\Sep}} \DNFRegex_n \DNFOf{\SequenceOf{\Sep}} \Leftrightarrow
  \DNFRegexAlt_{\sigma_i(1)} \ConcatDNF \ldots \ConcatDNF
  \DNFRegexAlt_{\sigma_i(n)}$, where $\SemanticsOf{\DNFRegex} =
  \SetOf{(\Sep\Concat\String_1\Concat\Sep\Concat\ldots\Concat\Sep\String_n\Concat\Sep,
    \Sep\Concat\StringAlt_{\sigma_i(1)}\Concat\Sep\Concat\ldots\Concat\Sep\Concat\StringAlt_{\sigma_i(n)}\Concat\Sep)
    \SuchThat
  (\String_i,\StringAlt_i) \in \SemanticsOf{\DNFLens_i}}$.
\end{lemma}
\begin{proof}
  As $\DNFRegex_i$ and
  $\DNFRegexAlt_i$ are strongly unambiguous, by
  Lemma~\ref{lem:strong-unambig-dnf-lens-types}, and as
  $\UnambigConcatOf{\DNFOf{\SequenceOf{\Sep}}}{\Language}$, and
  $\UnambigConcatOf{\Language}{\DNFOf{\SequenceOf{\Sep}}}$, for all $\Language$,
  we have that $\DNFOf{\SequenceOf{\Sep}} \ConcatDNF \DNFRegex_1 \ConcatDNF \DNFOf{\SequenceOf{\Sep}} \ConcatDNF
  \ldots \ConcatDNF \DNFOf{\SequenceOf{\Sep}} \ConcatDNF
  \DNFOf{\SequenceOf{\Sep}} \DNFRegex_n \DNFOf{\SequenceOf{\Sep}}$ is strongly
  unambiguous.

  Consider the lens
  $\DNFOf{\SequenceOf{\Sep}} \ConcatDNFLens \DNFLens_1 \ConcatDNFLens
  \ConcatDNFLens ((\DNFOf{\SequenceOf{\Sep}} \ConcatDNFLens \DNFLens_i)
  \SwapDNFLens (\DNFOf{\SequenceOf{\Sep}} \ConcatDNFLens \DNFLens_{i+1}))$,
  with the desired semantics.
\end{proof}

\begin{lemma}[Expressibility of Permutation of Separated Concat List]
  Let for all $i \in \RangeIncInc{1}{n}, \DNFLens_i \OfRewritelessType
  \DNFRegex_i \Leftrightarrow \DNFRegexAlt_i$
  Let $\sigma$ be a permutation, where $1 \leq i < n$.
  There exists a DNF lens $\DNFLens \OfRewritelessType \DNFOf{\SequenceOf{\Sep}}
  \DNFRegex_1 \ConcatDNF \DNFOf{\SequenceOf{\Sep}} \ConcatDNF
  \ldots \ConcatDNF \DNFOf{\SequenceOf{\Sep}} \ConcatDNF
  \DNFOf{\SequenceOf{\Sep}} \DNFRegex_n \DNFOf{\SequenceOf{\Sep}} \Leftrightarrow
  \DNFRegexAlt_{\sigma(1)} \ConcatDNF \ldots \ConcatDNF
  \DNFRegexAlt_{\sigma(n)}$, where $\SemanticsOf{\DNFRegex} =
  \SetOf{(\Sep\Concat\String_1\Concat\Sep\Concat\ldots\Concat\Sep\String_n\Concat\Sep,
    \Sep\Concat\StringAlt_{\sigma(1)}\Concat\Sep\Concat\ldots\Concat\Sep\Concat\StringAlt_{\sigma(n)}\Concat\Sep)
    \SuchThat
  (\String_i,\StringAlt_i) \in \SemanticsOf{\DNFLens_i}}$.
\end{lemma}
\begin{proof}
  As $\DNFRegex_i$ and
  $\DNFRegexAlt_i$ are strongly unambiguous, by
  Lemma~\ref{lem:strong-unambig-dnf-lens-types}, and as
  $\UnambigConcatOf{\DNFOf{\SequenceOf{\Sep}}}{\Language}$, and
  $\UnambigConcatOf{\Language}{\DNFOf{\SequenceOf{\Sep}}}$, for all $\Language$,
  we have that $\DNFOf{\SequenceOf{\Sep}} \ConcatDNF \DNFRegex_1 \ConcatDNF \DNFOf{\SequenceOf{\Sep}} \ConcatDNF
  \ldots \ConcatDNF \DNFOf{\SequenceOf{\Sep}} \ConcatDNF
  \DNFOf{\SequenceOf{\Sep}} \DNFRegex_n \DNFOf{\SequenceOf{\Sep}}$ is strongly
  unambiguous.

  From algebra, $\sigma$ can be decomposed into a series of $\sigma_{i_1}
  \Compose \ldots \Compose \sigma_{i_j}$.

TODO
\end{proof}

\begin{lemma}[Expressibility of Concat Permutation]
  \label{lem:conat-perms}
  Let for all $i \in \RangeIncInc{1}{n}, \DNFLens_i \OfRewritelessType
  \DNFRegex_i \Leftrightarrow \DNFRegexAlt_i$.
  Let (unambiguity condition)
  Let $\sigma$ be a permutation, where $1 \leq i < n$.
  There exists a DNF lens $\DNFLens \OfRewritelessType \DNFOf{\SequenceOf{\Sep}}
  \DNFRegex_1 \ConcatDNF \DNFOf{\SequenceOf{\Sep}} \ConcatDNF
  \ldots \ConcatDNF \DNFOf{\SequenceOf{\Sep}} \ConcatDNF
  \DNFOf{\SequenceOf{\Sep}} \DNFRegex_n \DNFOf{\SequenceOf{\Sep}} \Leftrightarrow
  \DNFRegexAlt_{\sigma(1)} \ConcatDNF \ldots \ConcatDNF
  \DNFRegexAlt_{\sigma(n)}$, where $\SemanticsOf{\DNFRegex} =
  \SetOf{(\Sep\Concat\String_1\Concat\Sep\Concat\ldots\Concat\Sep\String_n\Concat\Sep,
    \Sep\Concat\StringAlt_{\sigma(1)}\Concat\Sep\Concat\ldots\Concat\Sep\Concat\StringAlt_{\sigma(n)}\Concat\Sep)
    \SuchThat
  (\String_i,\StringAlt_i) \in \SemanticsOf{\DNFLens_i}}$.
\end{lemma}
\begin{proof}
TODO
\end{proof}

\begin{lemma}[Reordering of $\OrDNF$ Right]
  \label{lem:or-dnf-reordering-right}
  If there exists a DNF lens $\DNFLens \OfRewritelessType \DNFRegex_1 \OrDNF \ldots
  \OrDNF \DNFRegex_n \Leftrightarrow
  \DNFRegexAlt_1 \OrDNF \ldots \OrDNF \DNFRegexAlt_n$, then for all permutations
  $\sigma \in \PermutationSetOf{n}$, there exists a DNF lens $\DNFLens'
  \OfRewritelessType \DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n
  \Leftrightarrow
  \DNFRegexAlt_{\sigma(1)} \OrDNF \ldots \OrDNF \DNFRegexAlt_{\sigma(n)}$ where
  $\SemanticsOf{\DNFLens'} = \SemanticsOf{\DNFLens}$.
\end{lemma}
\begin{proof}
  TODO
\end{proof}

\begin{lemma}[Closure of Rewriteless DNF Lenses Under Inversion]
  \label{lem:closure-inversion}
  \leavevmode
  \begin{enumerate}
  \item If
    $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt$,
    then there exists a dnf lens
    $\InverseOf{\DNFLens} \OfRewritelessType
    \DNFRegexAlt \Leftrightarrow \DNFRegex$
    such that
    $\SemanticsOf{\InverseOf{\DNFRegex}} =
    \SetOf{(\StringAlt,\String) \SuchThat (\String,\StringAlt) \in
      \SemanticsOf{\DNFLens}}$
  \item If
    $\SequenceLens \OfRewritelessType \Sequence \Leftrightarrow \SequenceAlt$,
    then there exists a sequence lens
    $\InverseOf{\SequenceLens} \OfRewritelessType
    \SequenceAlt \Leftrightarrow \Sequence$ such that
    $\SemanticsOf{\InverseOf{\SequenceLens}} =
    \SetOf{(\StringAlt,\String) \SuchThat (\String,\StringAlt) \in
      \SemanticsOf{\SequenceLens}}$
  \item If
    $\AtomLens \OfRewritelessType \Atom \Leftrightarrow \AtomAlt$,
    then there exists an atom lens
    $\InverseOf{\AtomLens} \OfRewritelessType
    \AtomAlt \Leftrightarrow \Atom$ such that
    $\SemanticsOf{\InverseOf{\AtomLens}} =
    \SetOf{(\StringAlt,\String) \SuchThat (\String,\StringAlt) \in
      \SemanticsOf{\AtomLens}}$
  \end{enumerate}
\end{lemma}
\begin{proof}
  By mutual induction on the typing derivation of $\DNFLens$, $\SequenceLens$,
  and $\AtomLens$.

  \begin{case}[\DNFLensRule{}]
    \[
      \inferrule*
      {
        \SequenceLens_1 \OfRewritelessType \Sequence_1 \Leftrightarrow \SequenceAlt_1\\
        \ldots\\
        \SequenceLens_n \OfRewritelessType \Sequence_n \Leftrightarrow \SequenceAlt_n\\\\
        \sigma \in \PermutationSetOf{n}\\
        i \neq j \Rightarrow \LanguageOf{\Sequence_{i}} \cap \LanguageOf{\Sequence_{j}}=\emptyset\\
        i \neq j \Rightarrow \LanguageOf{\SequenceAlt_{i}} \cap \LanguageOf{\SequenceAlt_{j}}=\emptyset\\
      }
      {
        (\DNFLensOf{\SequenceLens_1\DNFLensSep\ldots\DNFLensSep\SequenceLens_n},\sigma) \OfRewritelessType
        \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}
        \Leftrightarrow \DNFOf{\SequenceAlt_{\sigma(1)}\DNFSep\ldots\DNFSep\SequenceAlt_{\sigma(n)}}
      }
    \]

    By IH, there exists
    $\InverseOf{\SequenceLens_i} \OfRewritelessType
    \SequenceAlt_i \Leftrightarrow \Sequence_i$ where
    $\SemanticsOf{\InverseOf{\SequenceLens_i}} =
    \SetOf{(\StringAlt,\String) \SuchThat
      (\String,\StringAlt) \in \SemanticsOf{\SequenceLens_i}}$.

    Consider the typing
    \[
      \inferrule*
      {
        \InverseOf{\SequenceLens_{\sigma(1)}} \OfRewritelessType
        \SequenceAlt_{\sigma(1)} \Leftrightarrow \Sequence_{\sigma(1)}\\
        \ldots\\
        \InverseOf{\SequenceLens_{\InverseOf{\sigma(n)}}} \OfRewritelessType
        \SequenceAlt_{\sigma(n)} \Leftrightarrow \Sequence_{\sigma(n)}\\\\
        \InverseOf{\sigma} \in \PermutationSetOf{n}\\
        i \neq j \Rightarrow \LanguageOf{\SequenceAlt_{i}} \cap \LanguageOf{\SequenceAlt_{j}}=\emptyset\\
        i \neq j \Rightarrow \LanguageOf{\Sequence_{i}} \cap \LanguageOf{\Sequence_{j}}=\emptyset\\
      }
      {
        (\DNFLensOf{\InverseOf{\SequenceLens_{\sigma(1)}}
          \DNFLensSep\ldots\DNFLensSep
          \InverseOf{\SequenceLens_{\sigma(n)}}},\InverseOf{\sigma}) \OfRewritelessType
        \DNFOf{\SequenceAlt_{\sigma(1)}\DNFSep\ldots\DNFSep\SequenceAlt_{\sigma(n)}}
        \Leftrightarrow
        \DNFOf{\Sequence_{\InverseOf{\sigma}(\sigma(1))}\DNFSep\ldots\DNFSep\Sequence_{\InverseOf{\sigma}(\sigma(n)})}
      }
    \]

    So $(\DNFLensOf{\InverseOf{\SequenceLens_{\sigma(1)}}
      \DNFLensSep\ldots\DNFLensSep
      \InverseOf{\SequenceLens_{\sigma(n)}}},\InverseOf{\sigma}) \OfRewritelessType
    \DNFOf{\SequenceAlt_{\sigma(1)}\DNFSep\ldots\DNFSep\SequenceAlt_{\sigma(n)}}
    \Leftrightarrow
    \DNFOf{\Sequence_{1}\DNFSep\ldots\DNFSep\Sequence_{n})}$, or in other words
    $(\DNFLensOf{\SequenceLens_{\sigma(1)}
      \DNFLensSep\ldots\DNFLensSep
      \SequenceLens_{\sigma(n)}},\InverseOf{\sigma}) \OfRewritelessType
    \DNFRegexAlt
    \Leftrightarrow
    \DNFRegex$, as desired.
    
    $\SemanticsOf{(\DNFLensOf{\InverseOf{\SequenceLens_{\sigma(1)}}
        \DNFLensSep\ldots\DNFLensSep
        \InverseOf{\SequenceLens_{\sigma(n)}}},\InverseOf{\sigma})} =
    \SetOf{(\String,\StringAlt) \SuchThat \exists i.
      (\String,\StringAlt) \in \SemanticsOf{\InverseOf{\SequenceLens_{\sigma(i)}}}} =
    \SetOf{(\StringAlt,\String) \SuchThat \exists i.
      (\String,\StringAlt) \in \SemanticsOf{\SequenceLens_i}} =
    \SetOf{(\StringAlt,\String) \SuchThat
      (\String,\StringAlt) \in \SemanticsOf{\DNFLens}}$, as desired.
  \end{case}

  \begin{case}[\SequenceLensRule{}]
    \[
      \inferrule*
      {
        \AtomLens_1 \OfRewritelessType \Atom_1 \Leftrightarrow \AtomAlt_1\\
        \ldots\\
        \AtomLens_n \OfRewritelessType \Atom_n \Leftrightarrow \AtomAlt_n\\
        \sigma \in \PermutationSetOf{n}\\
        \UnambigConcat\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}\\
        \UnambigConcat\SequenceOf{\StringAlt_0\SequenceSep\AtomAlt_1\SequenceSep\ldots\SequenceSep\AtomAlt_n\SequenceSep\StringAlt_n}
      }
      {
        (\SequenceLensOf{(\String_0,\StringAlt_0)\SequenceLensSep\Atom_1\SequenceLensSep\ldots\SequenceLensSep\Atom_n\SequenceLensSep(\String_n,\StringAlt_n)},\sigma) \OfRewritelessType
        \SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}\Leftrightarrow
        \SequenceOf{\StringAlt_0\SequenceSep\AtomAlt_{\sigma(1)}\SequenceSep\ldots\SequenceSep\AtomAlt_{\sigma(n)}\SequenceSep\StringAlt_n}
      }
    \]

    By IH, there exists
    $\InverseOf{\AtomLens_i} \OfRewritelessType
    \AtomAlt_i \Leftrightarrow \Atom_i$ where
    $\SemanticsOf{\InverseOf{\AtomLens_i}} =
    \SetOf{(\StringAlt,\String) \SuchThat
      (\String,\StringAlt) \in \SemanticsOf{\AtomLens_i}}$.

    Consider the typing
    \[
      \inferrule*
      {
        \InverseOf{\AtomLens_{\sigma(1)}} \OfRewritelessType
        \AtomAlt_{\sigma(1)} \Leftrightarrow \Atom_{\sigma(n)}\\
        \ldots\\
        \InverseOf{\AtomLens_{\sigma(n)}} \OfRewritelessType
        \AtomAlt_{\sigma(n)} \Leftrightarrow \Atom_{\sigma(n)}\\
        \InverseOf{\sigma} \in \PermutationSetOf{n}\\
        \UnambigConcat\SequenceOf{\StringAlt_0\SequenceSep\AtomAlt_1\SequenceSep\ldots\SequenceSep\AtomAlt_n\SequenceSep\StringAlt_n}
        \UnambigConcat\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}\\
      }
      {
        (\SequenceLensOf{(\StringAlt_0,\String_0)\SequenceLensSep\Atom_1\SequenceLensSep\ldots\SequenceLensSep\Atom_n\SequenceLensSep(\StringAlt_n,\String_n)},\sigma) \OfRewritelessType
        \SequenceOf{\StringAlt_0\SequenceSep\AtomAlt_{\sigma(1)}\SequenceSep\ldots\SequenceSep\AtomAlt_{\sigma(n)}\SequenceSep\StringAlt_n}
        \Leftrightarrow
        \SequenceOf{\String_0\SequenceSep\Atom_{\InverseOf{\sigma}(\sigma(1))}\SequenceSep\ldots\SequenceSep\Atom_{\InverseOf{\sigma}(\sigma(n))}\SequenceSep\String_n}
      }
    \]

    So $(\SequenceLensOf{(\StringAlt_0,\String_0);
      \InverseOf{\AtomLens_{\sigma(1)}}
      \SequenceLensSep\ldots\SequenceLensSep
      \InverseOf{\AtomLens_{\sigma(n)}};
      (\StringAlt_n,\String_n)},\InverseOf{\sigma}) \OfRewritelessType
    \SequenceOf{\StringAlt_0;\SequenceAlt_{\sigma(1)}
      \SequenceSep\ldots\SequenceSep
      \SequenceAlt_{\sigma(n)};\StringAlt_n}
    \Leftrightarrow
    \SequenceOf{\String_0;\Sequence_{1}\DNFSep\ldots\DNFSep\Sequence_{n})}$, or in other words
    $(\SequenceLensOf{(\StringAlt_0,\String_0);
      \InverseOf{\AtomLens_{\sigma(1)}}
      \SequenceLensSep\ldots\SequenceLensSep
      \InverseOf{\AtomLens_{\sigma(n)}};
      (\StringAlt_n,\String_n)},\InverseOf{\sigma}) \OfRewritelessType
    \SequenceAlt
    \Leftrightarrow
    \Sequence$, as desired.
    
    $\SemanticsOf{(\SequenceLensOf{(\StringAlt_0,\String_0);
      \InverseOf{\AtomLens_{\sigma(1)}}
      \SequenceLensSep\ldots\SequenceLensSep
      \InverseOf{\AtomLens_{\sigma(n)}};
      (\StringAlt_n,\String_n)},\InverseOf{\sigma})} =
    \SetOf{(\StringAlt_0\String_1'\ldots\String_n'\StringAlt_n,
      \String_0\StringAlt_{\InverseOf{\sigma}(1)}'\ldots\StringAlt_{\InverseOf{\sigma(n)}}'\String_n)
      \SuchThat \forall i.
      (\String_i',\StringAlt_i') \in \SemanticsOf{\InverseOf{\AtomLens_{\sigma(i)}}}} =
    \SetOf{(\StringAlt_0\StringAlt_{\sigma(1)}'\ldots\StringAlt_{\sigma(n)}'\StringAlt_n,
      \String_0\String_1'\ldots\String_n'\String_n) \SuchThat \forall i.
      (\String',\StringAlt') \in \SemanticsOf{\AtomLens_i}} =
    \SetOf{(\StringAlt,\String) \SuchThat
      (\String,\StringAlt) \in \SemanticsOf{\SequenceLens}}$, as desired.
  \end{case}

  \begin{case}[\AtomLensRule{}]
    \[
      \inferrule*
      {
        \DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt
        \UnambigItOf{\DNFRegex}\\
        \UnambigItOf{\DNFRegexAlt}
      }
      {
        \IterateLensOf{\DNFLens} \OfRewritelessType
        \StarOf{\DNFRegex} \Leftrightarrow \StarOf{\DNFRegexAlt}
      }
    \]

    By IH, there exists
    $\InverseOf{\DNFLens} \OfRewritelessType
    \DNFRegexAlt \Leftrightarrow \DNFRegex$ where
    $\SemanticsOf{\InverseOf{\DNFLens}} =
    \SetOf{(\StringAlt,\String) \SuchThat
      (\String,\StringAlt) \in \SemanticsOf{\DNFLens}}$.

    Consider the typing
    \[
      \inferrule*
      {
        \InverseOf{\DNFLens} \OfRewritelessType \DNFRegexAlt \Leftrightarrow \DNFRegex
        \UnambigItOf{\DNFRegexAlt}\\
        \UnambigItOf{\DNFRegex}
      }
      {
        \IterateLensOf{\InverseOf{\DNFLens}} \OfRewritelessType
        \StarOf{\DNFRegexAlt} \Leftrightarrow \StarOf{\DNFRegex}
      }
    \]

    So
    $\IterateLensOf{\InverseOf{\DNFLens}} \OfRewritelessType
    \StarOf{\DNFRegexAlt}
    \Leftrightarrow
    \StarOf{\DNFRegex}$, or in other words
    $(\IterateLensOf{\InverseOf{\DNFLens}}) \OfRewritelessType
    AtomAlt
    \Leftrightarrow
    Atom$
    as desired.
    
    $\SemanticsOf{\IterateLensOf{\InverseOf{\DNFLens}}} =
    \SetOf{(\String_0\ldots\String_n,
      \StringAlt_0\ldots\StringAlt_n)
      \SuchThat \forall i.
      (\String_i,\StringAlt_i) \in \SemanticsOf{\InverseOf{\DNFLens}}} =
    \SetOf{(\StringAlt_0\ldots\StringAlt_n,\String_0\ldots\String_n)
      \SuchThat \forall i.
      (\String_i,\StringAlt_i) \in \SemanticsOf{\DNFLens}} =
    \SetOf{(\StringAlt,\String) \SuchThat
      (\String,\StringAlt) \in \SemanticsOf{\SequenceLens}}$, as desired.
  \end{case}
\end{proof}

\begin{lemma}[$\DefinitionalEquiv$ is finer than $\equiv$]
  \label{lem:defequiv-finer-equiv}
  If $\Regex \DefinitionalEquiv \RegexAlt$, then $\Regex \equiv \RegexAlt$
\end{lemma}
\begin{proof}
  By induction on the derivation of $\DefinitionalEquiv$
  
  \begin{case}[\OrIdentityRule{}]
    Through the use of $\equiv$'s \OrIdentityRule{}.
  \end{case}
  
  \begin{case}[\EmptyProjectionRightRule{}]
    Through the use of $\equiv$'s \EmptyProjectionRightRule{}.
  \end{case}
  
  \begin{case}[\EmptyProjectionLeftRule{}]
    Through the use of $\equiv$'s \EmptyProjectionLeftRule{}.
  \end{case}
  
  \begin{case}[\ConcatAssocRule{}]
    Through the use of $\equiv$'s \ConcatAssocRule{}.
  \end{case}
  
  \begin{case}[\OrAssociativityRule{}]
    Through the use of $\equiv$'s \OrAssociativityRule{}.
  \end{case}

  \begin{case}[\OrCommutativityRule{}]
    Through the use of $\equiv$'s \OrCommutativityRule{}.
  \end{case}

  \begin{case}[\DistributivityLeftRule{}]
    Through the use of $\equiv$'s \DistributivityLeftRule{}.
  \end{case}

  \begin{case}[\DistributivityRightRule{}]
    Through the use of $\equiv$'s \DistributivityRightRule{}.
  \end{case}

  \begin{case}[\ConcatIdentityLeftRule{}]
    Through the use of $\equiv$'s \ConcatIdentityLeftRule{}.
  \end{case}

  \begin{case}[\ConcatIdentityRightRule{}]
    Through the use of $\equiv$'s \ConcatIdentityRightRule{}.
  \end{case}

  \begin{case}[\UnrollstarLeftRule{}]
    Let $\Regex \DefinitionalEquiv \RegexAlt$ through an application of
    \UnrollstarLeftRule{}.

    So, without loss of generality, from symmetry, we can say
    $\Regex = \StarOf{\Regex'}$ and
    $\RegexAlt = \EmptyString \Or (\Regex' \Concat \StarOf{\Regex'})$.

    Consider the derivations
    \[
      \inferrule*
      {
        \inferrule*
        {
        }
        {
          \Regex' \equiv \Regex' \Concat \EmptyString
        }
      }
      {
        \StarOf{\Regex'} \equiv \StarOf{(\Regex' \Concat \EmptyString)}
      }
    \]

    \[
      \inferrule*
      {
      }
      {
        \StarOf{\Regex' \Concat \EmptyString}
        \equiv
        \EmptyString \Or
        (\Regex' \Concat
        \StarOf{(\EmptyString \Concat \Regex')} \Concat \EmptyString)
      }
    \]

    \[
      \inferrule*
      {
        \inferrule*
        {
        }
        {
          \Regex' \Concat
          \StarOf{(\EmptyString \Concat \Regex')}
          \Concat \EmptyString
          \equiv
          \Regex' \Concat
          \StarOf{(\EmptyString \Concat \Regex')}
        }
      }
      {
        \EmptyString \Or
        (\Regex' \Concat
        \StarOf{(\EmptyString \Concat \Regex')}
        \Concat \EmptyString)
        \equiv
        \EmptyString \Or
        (\Regex' \Concat
        \StarOf{(\EmptyString \Concat \Regex')})
      }
    \]

    \[
      \inferrule*
      {
        \inferrule*[vdots=1.5em]
        {
        }
        {
          \Regex' \Concat \EmptyString
          \equiv
          \Regex'
        }
      }
      {
        \EmptyString \Or
        (\Regex' \Concat
        \StarOf{(\EmptyString \Concat \Regex')})
        \equiv
        \EmptyString \Or
        (\Regex' \Concat
        \StarOf{\Regex'})
      }
    \]

    Through repeated application of equational theory transitivity,
    $\Regex \equiv \RegexAlt$.
  \end{case}

  \begin{case}[\UnrollstarRightRule{}]
    Let $\Regex \DefinitionalEquiv \RegexAlt$ through an application of
    \UnrollstarLeftRule{}.

    So, without loss of generality, from symmetry, we can say
    $\Regex = \StarOf{\Regex'}$ and
    $\RegexAlt = \EmptyString \Or (\StarOf{\Regex'} \Concat \Regex')$.

    Consider the derivations
    \[
      \inferrule*
      {
        \inferrule*
        {
        }
        {
          \Regex' \equiv \EmptyString \Concat \Regex'
        }
      }
      {
        \StarOf{\Regex'} \equiv \StarOf{(\EmptyString \Concat \Regex')}
      }
    \]

    \[
      \inferrule*
      {
      }
      {
        \StarOf{\EmptyString \Concat \Regex'}
        \equiv
        \EmptyString \Or
        (\EmptyString \Concat
        \StarOf{(\Regex' \Concat \EmptyString)} \Concat \Regex')
      }
    \]

    \[
      \inferrule*
      {
        \inferrule*
        {
        }
        {
          \EmptyString \Concat
          \StarOf{(\Regex' \Concat \EmptyString)}
          \Concat \Regex'
          \equiv
          \StarOf{(\Regex' \Concat \EmptyString)}
          \Concat \Regex'
        }
      }
      {
        \EmptyString \Or
        (\EmptyString \Concat
        \StarOf{(\Regex' \Concat \EmptyString)}
        \Concat \Regex')
        \equiv
        \EmptyString \Or
        (\Regex'
        \StarOf{(\Regex' \Concat \EmptyString)})
      }
    \]

    \[
      \inferrule*
      {
        \inferrule*[vdots=1.5em]
        {
        }
        {
          \Regex' \Concat \EmptyString
          \equiv
          \Regex'
        }
      }
      {
        \EmptyString \Or
        (\StarOf{(\Regex' \Concat \EmptyString)} \Concat \Regex')
        \equiv
        \EmptyString \Or
        (\Regex' \Concat
        \StarOf{\Regex'})
      }
    \]

    Through repeated application of equational theory transitivity,
    $\Regex \equiv \RegexAlt$.
  \end{case}
\end{proof}

\begin{lemma}
  \label{lem:strong_unambig_or}
  If $\Regex \Or \RegexAlt$ be strongly unambiguous, then
  $\LanguageOf{\Regex} \Intersect \LanguageOf{\RegexAlt} = \SetOf{}$,
  and both $\Regex$ and $\RegexAlt$ are strongly unambiguous.
\end{lemma}
\begin{proof}
  If $\Regex \Or \RegexAlt$ is strongly unambiguous, then either
  $\LanguageOf{\Regex \Or \RegexAlt} = \SetOf{}$, or
  $\LanguageOf{\Regex} \Intersect \LanguageOf{\RegexAlt} = \SetOf{}$, and
  $\Regex$ and $\RegexAlt$ are both strongly unambiguous.

  If the latter, then we are done.

  If the former, then both $\LanguageOf{\Regex} = \SetOf{}$ and
  $\LanguageOf{\RegexAlt} = \SetOf{}$.
  This means they are both strongly unambiguous.  Furthermore,
  $\SetOf{} \Intersect \SetOf{} = \SetOf{}$, so
  $\LanguageOf{\Regex} \Intersect \LanguageOf{\RegexAlt} = \SetOf{}$.
\end{proof}

\begin{lemma}
  Let $\Regex \DefinitionalEquiv \RegexAlt$.
  If $\Regex$ is strongly unambiguous, then $\RegexAlt$ is strongly unambiguous.
\end{lemma}
\begin{proof}
  If $\LanguageOf{\Regex} = \SetOf{}$, then $\LanguageOf{\RegexAlt} = \SetOf{}$,
  by Lemma~\ref{lem:defequiv-finer-equiv}.

  For the case where $\LanguageOf{\Regex} \neq \SetOf{}$, we proceed by
  induction on the derivation of equivalence of $\Regex$ and $\RegexAlt$.
  \begin{case}[\OrIdentityRule{} left to right]
    Let the last step of the derivation be \OrIdentityRule{} left to right.
    $\Regex \DefinitionalEquiv \Regex \Or \emptyset$.

    $\emptyset$ is strongly unambiguous, as its language is empty.
    $\Regex$ is strongly unambiguous by assumption
    $\LanguageOf{\Regex} \Intersect \LanguageOf{\emptyset} =
    \LanguageOf{\Regex} \Intersect \SetOf{} = \emptyset$, so $\RegexAlt$ is
    strongly unambiguous.
  \end{case}

  \begin{case}[\OrIdentityRule{} right to left]
    Let the last step of the derivation be \OrIdentityRule{} right to left.
    $\RegexAlt \Or \emptyset \DefinitionalEquiv \RegexAlt$.

    If $\LanguageOf{\RegexAlt \Or \emptyset} = SetOf{}$ then
    $\LanguageOf{\RegexAlt} = \SetOf{}$, so $\RegexAlt$ is strongly unambiguous.

    Otherwise $\RegexAlt$ is strongly unambiguous, which is what is desired.
  \end{case}

  \begin{case}[\EmptyProjectionRightRule both directions]
    Let the last step of the derivation be \EmptyProjectionRightRule{}.
    The language of both sides is $\SetOf{}$, by
    Lemma~\ref{lem:defequiv-finer-equiv}.
  \end{case}

  \begin{case}[\EmptyProjectionLeftRule both directions]
    Let the last step of the derivation be \EmptyProjectionLeftRule{}.
    The language of both sides is $\SetOf{}$, by
    Lemma~\ref{lem:defequiv-finer-equiv}.
  \end{case}
  
  \begin{case}[\ConcatAssocRule{} left to right]
    Let the last step of the derivation be \ConcatAssocRule{} left to right.
    $\RegexConcat{(\RegexConcat{\Regex_1}{\Regex_2})}{\Regex_3}
    \DefinitionalEquiv
    \RegexConcat{\Regex_1}{(\RegexConcat{\Regex_2}{\Regex_3})}$

    Because \Regex is strongly unambiguous.
    $\Regex_1 \UnambigConcat \Regex_2$ and
    $(\Regex_1 \Concat \Regex_2) \UnambigConcat \Regex_3$

    Let $\String_2,\StringAlt_2 \in \Regex_2$, let $\String_3,\StringAlt_3
    \in \Regex_3$, and let
    $\String_2 \Concat \String_3 = \StringAlt_2 \Concat \StringAlt_3$.
    Consider $\String_1$ in $\Regex_1$ which exists as
    $\LanguageOf{\Regex} \neq \SetOf{}$.
    $(\String_1 \Concat \String_2) \Concat \String_3 =
    (\String_1 \Concat \StringAlt_2) \Concat \StringAlt_3$, so
    $\String_3 = \StringAlt_3$ and
    $\String_1 \Concat \String_2 = \String_1 \Concat \StringAlt_2$,
    so $\String_2 = \StringAlt_2$.

    Let $\String_2 \Concat \String_3 \in \Regex_2 \Concat \Regex_3$,
    $\StringAlt_2 \Concat \StringAlt_3 \in \Regex_2 \Concat \Regex_3$,
    $\String_1,\StringAlt_1 \in \Regex_1$,
    and let $\String_1 \Concat (\String_2 \Concat \String_3) = 
    \StringAlt_1 \Concat (\StringAlt_2 \Concat \StringAlt_3)$.
    This means $(\String_1 \Concat \String_2) \Concat \String_3 =
    (\StringAlt_1 \Concat \StringAlt_2) \Concat \StringAlt_3)$.
    
    So by assumption, $\String_3 = \StringAlt_3$, and
    $\String_1 \Concat \String_2 = \StringAlt_1 \Concat \StringAlt_2$.
    So by assumption, $\String_1 = \StringAlt_1$ and $\String_2 = \StringAlt_2$.
    So, $\String_2 \Concat \String_3 = \StringAlt_2 \Concat \StringAlt_3$,
    and $\String_1 = \StringAlt_1$.
  \end{case}

  \begin{case}[\ConcatAssocRule{} right to left]
    Very similarly to left to right.
  \end{case}

  \begin{case}[\OrAssociativityRule{} left to right]
    $\Regex_1 \Or (\Regex_2 \Or \Regex_3) \DefinitionalEquiv
    (\Regex_1 \Or \Regex_2) \Or \Regex_3$.

    $\LanguageOf{\Regex_1} \Intersect \LanguageOf{\Regex_2 \Or \Regex_3} =
    \SetOf{}$.
    This means that $\LanguageOf{\Regex_1} \Intersect
    (LanguageOf{\Regex_2} \Union \LanguageOf{\Regex_3}) = \SetOf{}$, so through
    distributivity, $\LanguageOf{\Regex_1} \Intersect \LanguageOf{\Regex_2}
    \Union \LanguageOf{\Regex_1} \Intersect \LanguageOf{\Regex_3} = \SetOf{}$.
    This means $\LanguageOf{\Regex_1} \Intersect \LanguageOf{\Regex_2} =
    \SetOf{}$ and
    $\LanguageOf{\Regex_1} \Intersect \LanguageOf{\Regex_3} = \SetOf{}$.

    If $\LanguageOf{\Regex_2 \Or \Regex_3} = \SetOf{}$, then the language of
    each is empty, so they are each strongly unambiguous.
    This means $\Regex_1 \Or \Regex_2$ is strongly unambiguous.

    Furthermore, $\LanguageOf{\Regex_1} \Intersect \LanguageOf{\Regex_3} \Union
    \LanguageOf{\Regex_2} \Intersect \LanguageOf{\Regex_3} = \SetOf{}$ as each
    of the intersections is empty.  So the whole thing is unambiguous.
  \end{case}

  \begin{case}[\OrAssociativityRule{} right to left]
    Done very similarly to the left to right case.
  \end{case}

  \begin{case}[\OrCommutativityRule{}]
    $\Regex_1 \Or \Regex_2 \DefinitionalEquiv \Regex_2 \Or \Regex_1$
    So if the languages are empty, then they are both empty.

    Otherwise, $\Regex_1$ is strongly unambiguous, and $\Regex_2$ is strongly
    unambiguous, and $\LanguageOf{\Regex_1} \Intersect \LanguageOf{\Regex_2} =
    \SetOf{}$.

    So $\LanguageOf{\Regex_2} \Intersect \LanguageOf{\Regex_1} = \SetOf{}$, and
    so $\Regex_2 \Or \Regex_1$ is strongly unambiguous.
  \end{case}

  \begin{case}[\DistributivityLeftRule{} left to right]
    $\Regex_1 \Concat (\Regex_2 \Or \Regex_3) \DefinitionalEquiv
    (\Regex_1 \Concat \Regex_2) \Or (\Regex_1 \Concat \Regex_3)$.

    If $\LanguageOf{\Regex_1 \Concat (\Regex_2 \Or \Regex_3)} = \SetOf{}$, then
    $(\Regex_1 \Concat \Regex_2) \Or (\Regex_1 \Concat \Regex_3) = \SetOf{}$,
    and we are done.

    If the language is nonempty, so too are the languages of each side, so
    $\Regex_1$ is nonempty, and $\Regex_2 \Or \Regex_3$ is nonempty,
    and $\Regex_1$ is strongly unambiguous, and $\Regex_2 \Or \Regex_3$ is
    strongly unambiguous.

    $\Regex_2 \Or \Regex_3$ being strongly unambiguous implies $\Regex_2$ is
    strongly unambiguous, $\Regex_3$ is strongly unambiguous, and
    $\LanguageOf{\Regex_2} \Intersect \LanguageOf{\Regex_3} = \SetOf{}$, by
    Lemma~\ref{lem:strong_unambig_or}.

    Let $\String_1,\StringAlt_1 \in \LanguageOf{\Regex_1}$,
    $\String_2,\StringAlt_2 \in \LanguageOf{\Regex_2}$,
    $\String_1\Concat\String_2 = \StringAlt_1\Concat\StringAlt_2$.
    $\String$.  Then $\StringAlt_1 \in \LanguageOf{\Regex_1 \Or \Regex_2}$, and
    $\StringAlt_2 \in \LanguageOf{\Regex_1 \Or \Regex_2}$.
    By assumption of strong unambiguity, where the languages are not empty,
    $\String_1  = \String_2$ anc $\StringAlt_1 = \StringAlt_2$.

    Similarly for $\String_1,\StringAlt_1 \in \LanguageOf{\Regex_1}$,
    $\String_3,\StringAlt_3 \in \LanguageOf{\Regex_3}$.

    Assume there exists some $\String \in \LanguageOf{\Regex_1 \Concat \Regex_2}
    \Intersect
    \LanguageOf{\Regex_1 \Concat \Regex_3}$.
    This means $\String = \String_1 \Concat \String_2$, for
    $\String_1\in\LanguageOf{\Regex_1}$ and $\String_2\in\LanguageOf{\Regex_2}$,
    uniquely.
    It means $\String = \StringAlt_1 \Concat \StringAlt_2$, for
    $\StringAlt_1\in\LanguageOf{\Regex_1}$ and
    $\StringAlt_2\in\LanguageOf{\Regex_2}$.
    From assumption, as
    $\String \in \LanguageOf{\Regex_1 \Concat (\Regex_2 \Or \Regex_3)}$,
    $\String_1 = \StringAlt_1$ and $\String_2 = \StringAlt_3$.
    Contradiction, as
    $\LanguageOf{\Regex_2} \Intersect \LanguageOf{\Regex_3} = \SetOf{}$.
    So there is no string in the intersection, or in other words
    $\LanguageOf{\Regex_1 \Concat \Regex_2}
    \Intersect
    \LanguageOf{\Regex_1 \Concat \Regex_3} = \SetOf{}$

    As such, $(\Regex_1 \Concat \Regex_2) \Or (\Regex_1 \Concat \Regex_3)$ is
    strongly unambiguous
  \end{case}

  \begin{case}[\DistributivityLeftRule{} right to left]
    $(\Regex_1 \Concat \Regex_2) \Or (\Regex_1 \Concat \Regex_3)
    \DefinitionalEquiv \Regex_1 \Concat (\Regex_2 \Or \Regex_3)$.

    If $\LanguageOf{\Regex_1} = \SetOf{}$, then the language of the entire
    $\Regex$ is empty, and we are done.  Otherwise assume
    $\LanguageOf{\Regex_1} \neq \SetOf{}$.

    From assumption $\Regex_1 \Concat \Regex_2$ is strongly unambiguous,
    $\Regex_1 \Concat \Regex_3$ is strongly unambiguous,
    and $\LanguageOf{\Regex_1 \Concat \Regex_2} \Intersect
    \LanguageOf{\Regex_1 \Concat \Regex_3} = \SetOf{}$.
    
    Assume there exists some
    $\String \in \LanguageOf{\Regex_2} \Intersect \LanguageOf{\Regex_3}$.
    Let $\String_1 \in \LanguageOf{\Regex_1}$.
    This makes
    $\String_1\Concat\String \in \LanguageOf{\Regex_1 \Concat \Regex_2}
    \Intersect \LanguageOf{\Regex_1 \Concat \Regex_3}$.  This is a
    contradiction, so
    $\LanguageOf{\Regex_2} \Intersect \LanguageOf{\Regex_3} = \SetOf{}$.

    Let $\String_1,\StringAlt_1 \in \LanguageOf{\Regex_1}$.
    Let $\String,\StringAlt \in \LanguageOf{\Regex_2 \Or \Regex_3}$.
    Let $\String_1 \Concat \String = \StringAlt_1 \Concat \StringAlt$.
    Assume $\String \in \LanguageOf{\Regex_2}$.  Then $\StringAlt \in
    \LanguageOf{\Regex_2}$, as otherwise $\Regex$ is not strongly unambiguous.
    So as $\String_1 \Concat \String \in \LanguageOf{\Regex_1 \Concat
      \Regex_2}$,
    and $\StringAlt_1 \Concat \StringAlt \in \LanguageOf{\Regex_1 \Concat
      \Regex_2}$, by assumption, $\String_1 = \StringAlt_1$, and $\String =
    \StringAlt$.
    If $\String \not\in \LanguageOf{\Regex_2}$, then $\String \in
    \LanguageOf{\Regex_3}$, and the same argument applies.
  \end{case}

  \begin{case}[\DistributivityRightRule{} both directions]
    Proceeds the same as \DistributivityLeftRule{}.
  \end{case}

  \begin{case}[\ConcatIdentityLeftRule{} left to right]
    $\EmptyString \Concat \Regex' \DefinitionalEquiv \Regex'$

    If they have empty languages, we are done.

    If nonempty, then $\Regex'$ is strongly unambiguous, and we are done.
  \end{case}

  \begin{case}[\ConcatIdentityLeftRule{} right to left]
    $\Regex' \DefinitionalEquiv \EmptyString \Concat \Regex'$

    Both $\Regex'$ and $\EmptyString$ are strongly unambiguous, by assumption
    and definition, respectively.

    Furthermore, let $\String_1,\StringAlt_1 \in \LanguageOf{\EmptyString}$, and
    $\String_2,\StringAlt_2 \in \LanguageOf{\Regex'}$, and $\String_1 \Concat
    \String_2 = \StringAlt_1 \Concat \StringAlt_2$
    $\String_1 = \StringAlt_1 = \EmptyString$, so $\String_1 = \StringAlt_2$,
    which makes $\String_2 = \StringAlt_2$.
  \end{case}

  \begin{case}[\ConcatIdentityRightRule{} both directions]
    Very similar to \ConcatIdentityLeftRule{}.
  \end{case}

  \begin{case}[\UnrollstarLeftRule{} left to right]
    $\StarOf{\Regex'} \DefinitionalEquiv \EmptyString \Or (\Regex' \Concat
    \StarOf{\Regex'})$

    Let $\String \in \LanguageOf{\EmptyString} \Intersect \LanguageOf{\Regex'
      \Concat \StarOf{\Regex'}}$.
    So $\String = \EmptyString$.
    So $\EmptyString \in \LanguageOf{\Regex'}$.
    Contradiction, as if $\EmptyString$ in $\LanguageOf{\Regex'}$, then
    if $\String_1\Concat\String_n = \StringAlt_1\Concat\StringAlt_m$, $n$ no
    longer must equal $m$, as arbitrarily many $\EmptyString$s can be input.

    $\EmptyString$ is strongly unambiguous.

    If $\LanguageOf{\Regex'} = \emptyset$, then
    $\Regex' \Concat \StarOf{\Regex'}$ also has an empty language, and is
    strongly unambiguous.

    If the language is nonempty, $\Regex'$ is strongly unambiguous.

    Let $\String_1,\String_2 \in
    \LanguageOf{\Regex'}$, $\StringAlt_1,\StringAlt_2 \in
    \LanguageOf{\StarOf{\Regex'}}$.  Let $\String_1\Concat\StringAlt_1 =
    \StringAlt_2\Concat\StringAlt_2$.
    $\StringAlt_1 = \StringAlt_{1,1}\Concat\ldots\Concat\StringAlt_{1,n}$ and
    $\StringAlt_2 = \StringAlt_{2,1}\Concat\ldots\Concat\StringAlt_{1,m}$, where
    $\StringAlt_{1,i},\StringAlt_{2,i}\in\LanguageOf{\StarOf{\Regex'}}$.
    Consider
    $\String_1\Concat\StringAlt_{1,1}\Concat\ldots\Concat\StringAlt_{1,n}$
    and
    $\String_2\Concat\StringAlt_{2,1}\Concat\ldots\Concat\StringAlt_{2,m}$.
    As $\Regex'$ is unambiguously iterable, $n+1=m+1$, and
    $\String_1 = \String_2$ and $\StringAlt_{1,i} = \StringAlt_{2,i}$.
    This means that $\StringAlt_1 = \StringAlt_2$.
    So $Regex'$ is unambiguously concatenable with $\StarOf{\Regex'}$.
  \end{case}

  \begin{case}[\UnrollstarLeftRule{} right to left]
    $\EmptyString \Or (\Regex' \Concat \StarOf{\Regex'}) \DefinitionalEquiv
    \StarOf{\Regex'}$

    If $\LanguageOf{\Regex'} = \SetOf{}$, then it is vacuously unambiguously
    concatenable, and $\Regex'$ is strongly unambiguous, so $\StarOf{\Regex'}$
    is strongly unambiguous.

    Let $\LanguageOf{\Regex'}$ not be empty.

    Let $\String_1\Concat\ldots\Concat\String_n =
    \StringAlt_1\Concat\ldots\Concat\StringAlt_m$, and
    $\String_i,\StringAlt_i\in\LanguageOf{\Regex'}$.  We want to show that $n=m$
    and $\String_i=\StringAlt_i$.
    This can be done by induction on $n$.

    If $n=0$, then $m=0$, as otherwise $m>0$, which would imply that
    $\EmptyString\in\LanguageOf{\Regex'}$, making $\Regex$ not strongly
    unambiguous.

    If $n\neq 0$, then by the unambiguous concatenability of $\Regex'$ and
    $\StarOf{\Regex'}$, $\String_1 = \StringAlt_1$, and
    $\String_2\Concat\ldots\Concat\String_n =
    \StringAlt_2\Concat\ldots\Concat\StringAlt_n$, and the IH applies.
  \end{case}

  \begin{case}[\UnrollstarRightRule{} both directions]
    Done similarly to \UnrollstarLeftRule{}.
  \end{case}

  \begin{case}[All structural cases]
    As $\DefinitionalEquiv$ is finer than $\equiv$, the subparts will have
    the same languages.  If the language of $\Regex$ is empty, then we are done,
    otherwise, each subpart will be strongly unambiguous, by the induction
    hypothesis.  As the top
    level unambiguity condition is based on the language, and the languages of
    the subparts are equal, the top level unambiguity condition will be
    satisfied.
  \end{case}

  \begin{case}[Transitivity of Equational Theory]
    If $\Regex \DefinitionalEquiv \Regex'$ and $\Regex \DefinitionalEquiv
    \RegexAlt$, then by IH,
    $\Regex'$ is strongly unambiguous, and by IH again, $\RegexAlt$ is strongly
    unambiguous.
  \end{case}
\end{proof}

\begin{definition}[Strong Unambiguity on DNF Regular Expressions]
  \leavevmode
  \begin{enumerate}
  \item $\DNFOf{\Sequence_1;\ldots;\Sequence_n}$ is \emph{strongly umambiguous}
    if $\Sequence_i$ is strongly unambiguous for all $i$, and $i\neq j
    \BooleanImplies
    \LanguageOf{\Sequence_i}\Intersect\LanguageOf{\Sequence_j}=\emptyset$.
  \item $\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\Sequence_n}$ is
    \emph{strongly unambiguous} if $\Atom_i$ is strongly unambiguous, and
    $\SequenceUnambigConcatOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}$.
  \item $\StarOf{\DNFRegex}$ is \emph{strongly unambiguous} if $\DNFRegex$ is
    strongly unambiguous, and $\UnambigItOf{\DNFRegex}$.
  \end{enumerate}
\end{definition}

\begin{lemma}[Strong Unambiguity in Lens Types]
  \label{lem:strong-unambig-lens-types}
  If $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$, then $\Regex$ is strongly
  unambiguous, and $\RegexAlt$ is strongly unambiguous.
\end{lemma}
\begin{proof}
  TODO
\end{proof}

\begin{lemma}[Strong Unambiguity in Rewriteless DNF Lens Types]
  \label{lem:strong-unambig-dnf-lens-types}
  If $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt$,
  then $\DNFRegex$ is strongly unambiguous, and $\DNFRegexAlt$ is strongly
  unambiguous.
\end{lemma}
\begin{proof}
  TODO
\end{proof}

\begin{lemma}
  \label{lem:pre-uniqueness-of-empty-in-dnf}
  If $\ToDNFRegexOf{\Regex} = \DNFOf{}$, and $\Regex \equiv \RegexAlt$, then
  $\ToDNFRegexOf{\RegexAlt} = \DNFOf{}$.
\end{lemma}
\begin{proof}
  By induction on the proof of equivalence

  \begin{case}[Structural Equality Rule]
    Then $\RegexAlt = \Regex$, so
    $\ToDNFRegexOf{\RegexAlt} = \ToDNFRegexOf{\Regex} = \DNFOf{}$.
  \end{case}

  \begin{case}[\OrIdentityRule{} left to right]
    $\Regex \equiv \RegexOr{\Regex}{\emptyset}$.
    $\ToDNFRegexOf{(\Regex \Or \emptyset)} =
    \ToDNFRegexOf{\Regex} \OrDNF \ToDNFRegexOf{\emptyset} =
    \DNFOf{} \OrDNF \DNFOf{}$.
  \end{case}

  \begin{case}[\OrIdentityRule{} right to left]
    $\RegexAlt \equiv \RegexOr{\RegexAlt}{\emptyset}$.
    $\ToDNFRegexOf{(\RegexOr{\RegexAlt}{\emptyset})} = \DNFOf{}$. So by
    definition,
    $\ToDNFRegexOf{\RegexAlt} \OrDNF \ToDNFRegexOf{\emptyset} = \DNFOf{}$.
    Again by definition,
    $\ToDNFRegexOf{\RegexAlt} \OrDNF \DNFOf{} = \DNFOf{}$.
    So by Lemma~\ref{lem:dnf-or-identity-right},
    $\ToDNFRegexOf{\RegexAlt} = \DNFOf{}$
  \end{case}

  \begin{case}[\EmptyProjectionRightRule{} left to right]
    $\RegexAlt = \emptyset$ so $\ToDNFRegexOf{\RegexAlt} = \DNFOf{}$
  \end{case}

  \begin{case}[\EmptyProjectionRightRule{} right to left]
    $\RegexAlt = \Regex \Concat \emptyset$, so $\ToDNFRegexOf{\RegexAlt} =
    \ToDNFRegexOf{\Regex} \ConcatDNF \ToDNFRegexOf{\emptyset} =
    \ToDNFRegexOf{\Regex} \ConcatDNF \DNFOf{}$, so by
    Lemma~\ref{lem:dnf-concat-projection-left},
    $\ToDNFRegexOf{\RegexAlt} = \DNFOf{}$.
  \end{case}

  \begin{case}[\EmptyProjectionLeftRule{} both directions]
    Done similarly to \EmptyProjectionRightRule{}.
  \end{case}

  \begin{case}[\ConcatAssocRule{} left to right]
    $(\Regex_1 \Concat \Regex_2) \Concat \Regex_3 \equiv
    \Regex_1 \Concat (\Regex_2 \Concat \Regex_3)$.
    Throguh definitions, and Lemma~\ref{lem:sequence-concat-assoc},
    $\DNFOf{} = \ToDNFRegexOf{((\Regex_1 \Concat \Regex_2) \Concat \Regex_3)} =
    (\ToDNFRegexOf{\Regex_1} \ConcatDNF \ToDNFRegexOf{\Regex_2}) \ConcatDNF
    \ToDNFRegexOf{\Regex_3}) =
    \ToDNFRegexOf{\Regex_1} \ConcatDNF (\ToDNFRegexOf{\Regex_2} \ConcatDNF
    \ToDNFRegexOf{\Regex_3}) =
    \ToDNFRegexOf{(\Regex_1 \Concat (\Regex_2 \Concat \Regex_3))}$
  \end{case}

  \begin{case}[\ConcatAssocRule{} right to left]
    Analogously to left to right
  \end{case}

  \begin{case}[\OrAssociativityRule{} left to right]
    $(\Regex_1 \Or \Regex_2) \Or \Regex_3 \equiv
    \Regex_1 \Or (\Regex_2 \Or \Regex_3)$.
    Through definitions, and Lemma~\ref{lem:sequence-or-assoc},
    $\DNFOf{} = \ToDNFRegexOf{((\Regex_1 \Or \Regex_2) \Or \Regex_3)} =
    (\ToDNFRegexOf{\Regex_1} \OrDNF \ToDNFRegexOf{\Regex_2}) \OrDNF
    \ToDNFRegexOf{\Regex_3}) =
    \ToDNFRegexOf{\Regex_1} \OrDNF (\ToDNFRegexOf{\Regex_2} \OrDNF
    \ToDNFRegexOf{\Regex_3}) =
    \ToDNFRegexOf{(\Regex_1 \Or (\Regex_2 \Or \Regex_3))}$
  \end{case}

  \begin{case}[\OrAssociativityRule{} right to left]
    Analogously to left to right
  \end{case}

  \begin{case}[\OrCommutativityRule{}]
    $\Regex_1 \Or \Regex_2 \equiv \Regex_1 \Or \Regex_2$.
    $\DNFOf{} = \ToDNFRegexOf{(\Regex_1 \Or \Regex_2)} =
    \ToDNFRegexOf{\Regex_1} \OrDNF \ToDNFRegexOf{\Regex_2}$.
    By the definition of $\OrDNF$, $\ToDNFRegexOf{\Regex_1} = \DNFOf{}$, and
    $\ToDNFRegexOf{\Regex_2} = \DNFOf{}$.
    $\ToDNFRegexOf{(\Regex_2 \Or \Regex_1)} =
    \ToDNFRegexOf{\Regex_2} \OrDNF \ToDNFRegexOf{\Regex_1} =
    \DNFOf{} \OrDNF \DNFOf{} = \DNFOf{}$.
  \end{case}

  \begin{case}[\DistributivityLeftRule{} left to right]
    $\RegexConcat{\Regex_1}{(\RegexOr{\Regex_2}{\Regex_3})} \equiv
    \RegexOr{(\RegexConcat{\Regex_1}{\Regex_2})}{(\RegexConcat{\Regex_1}{\Regex_3})}$

    $\ToDNFRegexOf{\Regex_1 \Concat (\Regex_2 \Or \Regex_3)} =
    \ToDNFRegexOf{\Regex_1} \ConcatDNF
    (\ToDNFRegexOf{\Regex_2} \OrDNF \ToDNFRegexOf{\Regex_3}) = \DNFOf{}$.
    By the definition of $\ConcatDNF$, this means $\ToDNFRegexOf{\Regex_1} =
    \DNFOf{}$, or $\ToDNFRegexOf{\Regex_2} \OrDNF \ToDNFRegexOf{\Regex_3} =
    \DNFOf{}$.

    If $\ToDNFRegexOf{\Regex_1} = \DNFOf{}$, then by
    Lemma~\ref{lem:dnf-concat-projection-left},
    $\ToDNFRegexOf{\Regex_1} \ConcatDNF \ToDNFRegexOf{\Regex_2} = \DNFOf{}$ and
    $\ToDNFRegexOf{\Regex_1} \ConcatDNF \ToDNFRegexOf{\Regex_3} = \DNFOf{}$,
    so $\ToDNFRegexOf{((\Regex_1 \Concat \Regex_2) \Or (\Regex_1 \Concat
      \Regex_3)} = 
    (\ToDNFRegexOf{\Regex_1} \ConcatDNF \ToDNFRegexOf{\Regex_2}) \OrDNF
    \ToDNFRegexOf{\Regex_1} \ConcatDNF \ToDNFRegexOf{\Regex_3} = \DNFOf{}$.

    If $\ToDNFRegexOf{\Regex_2} \OrDNF \ToDNFRegexOf{\Regex_3} = \DNFOf{}$,
    then by definition of $\OrDNF$, $\ToDNFRegexOf{\Regex_2} = \DNFOf{}$ and
    $\ToDNFRegexOf{\Regex_3} = \DNFOf{}$.
    By Lemma~\ref{lem:dnf-concat-projection-right},
    $\ToDNFRegexOf{\Regex_1} \ConcatDNF \ToDNFRegexOf{\Regex_2} = \DNFOf{}$ and
    $\ToDNFRegexOf{\Regex_1} \ConcatDNF \ToDNFRegexOf{\Regex_3} = \DNFOf{}$,
    so $\ToDNFRegexOf{((\Regex_1 \Concat \Regex_2) \Or (\Regex_1 \Concat
      \Regex_3)} = 
    (\ToDNFRegexOf{\Regex_1} \ConcatDNF \ToDNFRegexOf{\Regex_2}) \OrDNF
    \ToDNFRegexOf{\Regex_1} \ConcatDNF \ToDNFRegexOf{\Regex_3} = \DNFOf{}$.
  \end{case}

  \begin{case}[\DistributivityLeftRule{} right to left]
    $\RegexOr{(\RegexConcat{\Regex_1}{\Regex_2})}{(\RegexConcat{\Regex_1}{\Regex_3})} \equiv
    \RegexConcat{\Regex_1}{(\RegexOr{\Regex_2}{\Regex_3})}$

    $\ToDNFRegexOf{((\Regex_1 \Concat \Regex_2) \Or (\Regex_1 \Concat \Regex_3))} =
    (\ToDNFRegexOf{\Regex_1} \ConcatDNF \ToDNFRegexOf{\Regex_2}) \OrDNF
    (\ToDNFRegexOf{\Regex_1} \ConcatDNF \ToDNFRegexOf{\Regex_3}) = \DNFOf{}$.
    By the definition of $\OrDNF$, this means
    $\ToDNFRegexOf{\Regex_1} \ConcatDNF \ToDNFRegexOf{\Regex_2} = \DNFOf{}$,
    and
    $\ToDNFRegexOf{\Regex_1} \ConcatDNF \ToDNFRegexOf{\Regex_3} = \DNFOf{}$.

    As $\ToDNFRegexOf{\Regex_1} \ConcatDNF \ToDNFRegexOf{\Regex_2} = \DNFOf{}$.

    If $\ToDNFRegexOf{\Regex_1} = \DNFOf{}$, then by
    Lemma~\ref{lem:dnf-concat-projection-left},
    $\ToDNFRegexOf{\Regex_1} \ConcatDNF (\ToDNFRegexOf{\Regex_2} \OrDNF
    \ToDNFRegexOf{\Regex_3}) = \DNFOf{}$, so
    $\RegexConcat{\Regex_1}{(\RegexOr{\Regex_2}{\Regex_3})} = \DNFOf{}$.

    If $\ToDNFRegexOf{\Regex_1} \neq \DNFOf{}$, then
    $\ToDNFRegexOf{\Regex_2} = \DNFOf{}$ and $\ToDNFRegexOf{\Regex_3} =
    \DNFOf{}$.
    This means $\ToDNFRegexOf{\Regex_2} \OrDNF \ToDNFRegexOf{\Regex_3} =
    \DNFOf{}$.
    So, by Lemma~\ref{lem:dnf-concat-projection-left},
    $\ToDNFRegexOf{\Regex_1} \ConcatDNF (\ToDNFRegexOf{\Regex_2} \OrDNF
    \ToDNFRegexOf{\Regex_3}) = \DNFOf{}$, so
    $\ToDNFRegexOf{(\RegexConcat{\Regex_1}{(\RegexOr{\Regex_2}{\Regex_3})})}$.
  \end{case}

  \begin{case}[\DistributivityRightRule{} both directions]
    Proceeds analogously to \DistributivityLeftRule{}.
  \end{case}

  \begin{case}[\ConcatIdentityLeftRule{} left to right]
    $\RegexConcat{\EmptyString{}}{\RegexAlt} \equiv \RegexAlt$.
    By assumption, $\ToDNFRegexOf{(\RegexConcat{\EmptyString{}}{\RegexAlt})} = \DNFOf{}$
    This means $\ToDNFRegexOf{\EmptyString} \ConcatDNF \ToDNFRegexOf{\RegexAlt}
    = \DNFOf{}$.
    By Lemma~\ref{lem:dnf-concat-identity-left}, $\ToDNFRegexOf{\EmptyString}
    \ConcatDNF \ToDNFRegexOf{\RegexAlt} = \ToDNFRegexOf{\RegexAlt}$, so
    $\ToDNFRegexOf{\RegexAlt} = \DNFOf{}$.
  \end{case}

  \begin{case}[\ConcatIdentityLeftRule{} right to left]
    $\Regex \equiv \RegexConcat{\EmptyString{}}{\Regex}$.
    By assumption, $\ToDNFRegexOf{\Regex} = \DNFOf{}$.
    By Lemma~\ref{lem:dnf-concat-identity-left},
    $\ToDNFRegexOf{(\RegexConcat{\EmptyString{}}{\Regex})} =
    \ToDNFRegexOf{\Regex}$, so $\ToDNFRegexOf{\Regex} = \DNFOf{}$.
  \end{case}

  \begin{case}[\ConcatIdentityRightRule{} both dierections]
    Done analogously to \ConcatIdentityLeftRule{}.
  \end{case}

  \begin{case}[\SumstarRule{}, \ProductstarRule{}, \StarstarRule{},
    \DicyclicityRule{}, Structural \StarRegexType{} Equality]
    In all of these cases, the regular expression on the left is of the form
    $\StarOf{\Regex'}$, for some $\Regex'$.  $\EmptyString \in \StarOf{\Regex'}$
    for all $\Regex'$.  However, $\LanguageOf{\DNFOf{}} = \SetOf{}$, and by
    Theorem~\ref{thm:dnfrs}, $\LanguageOf{\ToDNFRegexOf{\Regex}} =
    \LanguageOf{\Regex}$.  This means that $\ToDNFRegexOf{\StarOf{\Regex'}} \neq
    \DNFOf{}$, for all $\Regex'$, so these rules do not apply.
  \end{case}

  \begin{case}[Structural \OrRegexType{} Equality]
    \[
      \inferrule*
      {
        \Regex_1 \equiv \RegexAlt_1\\
        \Regex_2 \equiv \RegexAlt_2
      }
      {
        \Regex_1 \Or \Regex_2 \equiv \RegexAlt_1 \Or \RegexAlt_2
      }
    \]

    $\ToDNFRegexOf{(\Regex_1 \Or \Regex_2)} =
    \ToDNFRegexOf{\Regex_1} \OrDNF \ToDNFRegexOf{\Regex_2} = \DNFOf{}$.
    By the definition of $\OrDNF$, $\ToDNFRegexOf{\Regex_1} = \DNFOf{}$ and
    $\ToDNFRegexOf{\Regex_2} = \DNFOf{}$.
    So, by induction, $\ToDNFRegexOf{\RegexAlt_1} = \DNFOf{}$ and
    $\ToDNFRegexOf{\RegexAlt_2} = \DNFOf{}$.
    So $\ToDNFRegexOf{\RegexAlt_1} \OrDNF \ToDNFRegexOf{\RegexAlt_2} =
    \ToDNFRegexOf{(\RegexAlt_1 \Or \RegexAlt_2)} = \DNFOf{}$.
  \end{case}

  \begin{case}[Structural \ConcatRegexType{} Equality]
    \[
      \inferrule*
      {
        \Regex_1 \equiv \RegexAlt_1\\
        \Regex_2 \equiv \RegexAlt_2
      }
      {
        \Regex_1 \Concat \Regex_2 \equiv \RegexAlt_1 \Concat \RegexAlt_2
      }
    \]

    $\ToDNFRegexOf{(\Regex_1 \Concat \Regex_2)} =
    \ToDNFRegexOf{\Regex_1} \ConcatDNF \ToDNFRegexOf{\Regex_2} = \DNFOf{}$.
    By the definition of $\ConcatDNF$, $\ToDNFRegexOf{\Regex_1} = \DNFOf{}$ or
    $\ToDNFRegexOf{\Regex_2} = \DNFOf{}$.
    So, by induction, $\ToDNFRegexOf{\RegexAlt_1} = \DNFOf{}$ or
    $\ToDNFRegexOf{\RegexAlt_2} = \DNFOf{}$.
    So $\ToDNFRegexOf{\RegexAlt_1} \ConcatDNF \ToDNFRegexOf{\RegexAlt_2} =
    \ToDNFRegexOf{(\RegexAlt_1 \Concat \RegexAlt_2)} = \DNFOf{}$.
  \end{case}

  \begin{case}[Transitivity of Equational Theories]
    \[
      \inferrule*
      {
        \Regex \equiv \Regex'\\
        \Regex' \equiv \RegexAlt
      }
      {
        \Regex \equiv \RegexAlt
      }
    \]
  \end{case}

  By IH, $\ToDNFRegexOf{\Regex'} = \DNFOf{}$.
  So, by IH, $\ToDNFRegexOf{\RegexAlt} = \DNFOf{}$.
\end{proof}

\begin{lemma}
  \label{lem:uniqueness-of-empty-in-dnf}
  If $\LanguageOf{\Regex} = \SetOf{}$, then $\ToDNFRegexOf{\Regex} = \DNFOf{}$
\end{lemma}
\begin{proof}
  $\LanguageOf{\emptyset} = SetOf{}$.
  We know $\LanguageOf{\Regex} = \SetOf{}$, so $\Regex \equiv \emptyset$.
  $\ToDNFRegexOf{emptyset} = DNFOf{}$.
  So, by Lemma~\ref{lem:pre-uniqueness-of-empty-in-dnf},
  $\ToDNFRegexOf{\Regex} = \DNFOf{}$.
\end{proof}

\begin{lemma}
  \label{lem:retaining-unambiguity-todnf}
  If $\Regex$ is strongly unambiguous as a regular expression, then
  $\ToDNFRegexOf{\Regex}$ is strongly unambiguous as a DNF regular expression.
\end{lemma}
\begin{proof}
  We proceed by induction.
  \begin{case}[\BaseRegexType{}]
    $\ToDNFRegexOf{\String} = \DNFOf{\SequenceOf{\String}}$, which is strongly
    unambiguous.
  \end{case}

  \begin{case}[\EmptyRegexType{}]
    $\ToDNFRegexOf{\emptyset} = \DNFOf{}$, which is strongly unambiguous.
  \end{case}

  \begin{case}[\StarRegexType{}]
    Let $\Regex = \ToDNFRegexOf{(\StarOf{\Regex'})}$ be strongly unambiguous.
    $\ToDNFRegexOf{(\StarOf{\Regex'})} =
    \AtomToDNFOf{\StarOf{(\ToDNFRegexOf{\Regex'})}}$
    By IH, $\ToDNFRegexOf{\Regex'}$ is strongly unambiguous.
    Furthermore, $\LanguageOf{\Regex'} = \LanguageOf{\ToDNFRegexOf{\Regex'}}$ is
    unambiguously iterable, so $\StarOf{(\ToDNFRegexOf{\Regex'})}$ is strongly
    unambiguous.  This means that
    $\AtomToDNFOf{\StarOf{(\ToDNFRegexOf{\Regex'})}}$ is strongly unambiguous.
  \end{case}

  \begin{case}[\ConcatRegexType{}]
    Let $\Regex = \Regex_1 \Concat \Regex_2$ be strongly unambiguous.

    If $\LanguageOf{\Regex} = \SetOf{}$, by
    Lemma~\ref{lem:uniqueness-of-empty-in-dnf}, $\ToDNFRegexOf{\Regex} =
    \DNFOf{}$, which is strongly unambiguous.

    Let $\ToDNFRegexOf{\Regex_1} = \DNFOf{\Sequence_1;\ldots;\Sequence_n}$.
    Let $\ToDNFRegexOf{\Regex_2} = \DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_m}$.
    If $\LanguageOf{\Regex} \neq \SetOf{}$, this means that
    $\LanguageOf{\ToDNFRegexOf{\Regex_1}} \neq \SetOf{}$, and
    $\LanguageOf{\ToDNFRegexOf{\Regex_2}} \neq \SetOf{}$.
    This means that $\Sequence_i$ is nonempty, and so is $\SequenceAlt_i$, for
    all $i$.
    Furthermore, as $\Regex$ is strongly unambiguous, and $\LanguageOf{\Regex}
    \neq \SetOf{}$, $\Regex_1$ and $\Regex_2$ are strongly unambiguous,
    which means so too are $\DNFOf{\Sequence_1;\ldots;\Sequence_n}$ and
    $\DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_m}$, and so too are
    $\Sequence_i$ and $\SequenceAlt_i$.

    As $\UnambigConcatOf{\ToDNFRegexOf{\Regex_1}}{\ToDNFRegexOf{\Regex_2}}$,
    $i \neq j \BooleanImplies \Sequence_i \Intersect \Sequence_j = \emptyset$, and
    $i \neq j \BooleanImplies \SequenceAlt_i \Intersect \SequenceAlt_j = \emptyset$
    I know from Lemma~\ref{lem:unambig-concat-union-equiv},
    $(i_1,j_1) \neq (i_2,j_2) \BooleanImplies \LanguageOf{\Sequence_{i_1} \ConcatDNF
    \Sequence_{j_1}} \Intersect
    \LanguageOf{\Sequence_{i_2} \ConcatDNF
    \Sequence_{j_2}} = \SetOf{}$.
    and $\LanguageOf{\Sequence_i} \UnambigConcat \LanguageOf{\SequenceAlt_j}$.

    Let $\Sequence_i =
    \SequenceOf{\String_{i,0};\Atom_{i,1};\ldots;\Atom_{i,n_i};\String_{i,n_i}}$ and
    $\SequenceAlt_i =
    \SequenceOf{\StringAlt_{i,0};\AtomAlt_{i,1};\ldots;\AtomAlt_{i,n_i};\StringAlt_{i,n_i}}$.
    $\SequenceUnambigConcatOf{\String_{i,0},\Atom_{i,1},\ldots,\Atom_{i,n_i},\String_{i,n_i}}$
    $\SequenceUnambigConcatOf{\StringAlt_{i,0},\AtomAlt_{i,1},\ldots,\AtomAlt_{i,n_i},\StringAlt_{i,n_i}}$
    Furthermore, $\Sequence_i$ and $\SequenceAlt_i$ have nonempty languages.
    By Lemma~\ref{lem:unambig-concat-equiv},
    $\SequenceUnambigConcatOf{\String_{i,0},\Atom_{i,1},\ldots,\Atom_{i,n_i},
      \String_{i,n_i}\Concat\StringAlt_{j,0},
      \AtomAlt_{j,1},\ldots,\AtomAlt_{j,n_j},\StringAlt_{j,n_j}}$
    
    As $\Sequence_i$ and $\SequenceAlt_i$ are strongly unambiguous, we know
    $\Atom_{i,j}$ and $\AtomAlt_{i,j}$ are strongly unambiguous.
    So, as $\SequenceUnambigConcatOf{\String_{i,0},\Atom_{i,1},\ldots,\Atom_{i,n_i},
      \String_{i,n_i}\Concat\StringAlt_{j,0},
      \AtomAlt_{j,1},\ldots,\AtomAlt_{j,n_j},\StringAlt_{j,n_j}}$,
    $\Sequence_i \ConcatDNF \SequenceAlt_j$ is strongly unambiguous.

    Furthermore, as 
    $\Sequence_i \ConcatDNF \SequenceAlt_j$ is strongly unambiguous and
    $(i_1,j_1) \neq (i_2,j_2) \BooleanImplies \LanguageOf{\Sequence_{i_1} \ConcatDNF
    \Sequence_{j_1}} \Intersect
    \LanguageOf{\Sequence_{i_2} \ConcatDNF
      \Sequence_{j_2}} = \SetOf{}$, then
    $\DNFOf{\Sequence_1 \ConcatDNF \SequenceAlt_1 ;\ldots;
    \Sequence_n \ConcatDNF \SequenceAlt_m}$.
  \end{case}

  \begin{case}[\OrRegexType{}]
    Let $\Regex = \Regex_1 \Or \Regex_2$ be strongly unambiguous.

    If $\LanguageOf{\Regex} = \SetOf{}$, by
    Lemma~\ref{lem:uniqueness-of-empty-in-dnf}, $\ToDNFRegexOf{\Regex} =
    \DNFOf{}$, which is strongly unambiguous.

    Otherwise, $\Regex_1$ and $\Regex_2$ are strongly unambiguous,
    and $\LanguageOf{\Regex_1} \Intersect \LanguageOf{\Regex_2} = \SetOf{}$.
    This means $\ToDNFRegexOf{\Regex_1}$ and $\ToDNFRegexOf{\Regex_2}$ are also
    strongly unambiguous, by IH.

    Let $\ToDNFRegexOf{\Regex_1} = \DNFOf{\Sequence_1;\ldots;\Sequence_n}$.
    Let $\ToDNFRegexOf{\Regex_2} =
    \DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_n}$.
    Let $\Sequence_i' = \begin{cases*}
      \Sequence_i & if $i \leq n$\\
      \SequenceAlt_{i-n} & otherwise
    \end{cases*}$.
    As $\ToDNFRegexOf{\Regex_1}$ and $\ToDNFRegexOf{\Regex_2}$ are strongly
    unambiguous, $i \neq j \BooleanImplies \LanguageOf{\Sequence_i} \Intersect
    \LanguageOf{\Sequence_j} = \SetOf{}$ and
    $i \neq j \BooleanImplies \LanguageOf{\SequenceAlt_i} \Intersect
    \LanguageOf{\SequenceAlt_j} = \SetOf{}$.
    Furthermore, as $\BigUnion_{i\in\RangeIncInc{1}{n}}\LanguageOf{\Sequence_i}
    \Intersect \BigUnion_{j\in\RangeIncInc{1}{m}}\LanguageOf{\Sequence_j}$,
    from Lemma~\ref{lem:unambig-union-equiv}, $i \neq j \BooleanImplies
    \LanguageOf{\Sequence_i'} \Intersect \LanguageOf{\Sequence_j'} = \SetOf{}$,
    and as each $\Sequence_i$ and $\SequenceAlt_i$ is strongly unambiguous,
    $\ToDNFRegexOf{\Regex_1} \OrDNF \ToDNFRegexOf{\Regex_2}$ is strongly
    unambiguous.
  \end{case}
\end{proof}

\begin{lemma}
  \label{lem:unambig-dnf}
  If $\DNFRegex = \DNFOf{\Sequence_1;\ldots;\Sequence_n}$ is strongly
  unambiguous, and for all $i$, $\ToRegexOf{\Sequence_i}$ is strongly
  unambiguous, then $\ToRegexOf{\DNFRegex}$ is strongly unambiguous.
\end{lemma}
\begin{proof}
  By induction on $n$

  \begin{case}[$n=0$]
    $\ToRegexOf{\DNFOf{}} = \emptyset$, which is strongly unambiguous.
  \end{case}

  \begin{case}[$n>0$]
    $\ToRegexOf{\Sequence_1;\ldots;\Sequence_n} =
    \ToRegexOf{\Sequence_1;\ldots;\Sequence_{n-1}} \Or \ToRegexOf{\Sequence_n}$.
    By IH, $\ToRegexOf{\Sequence_1;\ldots;\Sequence_{n-1}}$ is strongly
    unambiguous.
    Furthermore, as $\DNFRegex$ is strongly unambiguous,
    by Lemma~\ref{lem:unambig-union-equiv},
    $\LanguageOf{\ToRegexOf{\Sequence_1;\ldots;\Sequence_{n-1}}} \Intersect
    \ToRegexOf{\Sequence_n} = \emptyset$, so
    $\ToRegexOf{\Sequence_n}$ is strongly unambiguous, so the entire thing is
    strongly unambiguous.
  \end{case}
\end{proof}

\begin{lemma}
  \label{lem:unambig-seq}
  If $\Sequence = \SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}$
  is strongly unambiguous, and for all $i$, $\ToRegexOf{\Atom_i}$ is strongly
  unambiguous, then $\ToRegexOf{\Sequence}$ is strongly unambiguous.
\end{lemma}
\begin{proof}
  By induction on $n$

  \begin{case}[$n=0$]
    $\ToRegexOf{\SequenceOf{\String_0}} = \String_0$, which is strongly unambiguous.
  \end{case}

  \begin{case}[$n>0$]
    $\ToRegexOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n} =
    \ToRegexOf{\String_0;\Atom_1;\ldots;\Atom_{n-1};\String_{n-1}}
    \Concat \ToRegexOf{\Atom_n} \Concat \ToRegexOf{\String_n}$.
    From $\ToRegexOf{\Atom_n}$ and $\ToRegexOf{\String_n}$,
    we know $\UnambigConcatOf{\ToRegexOf{\Atom_n}}{\String_n}$ because
    the second part will always be $\String_n$, so the first part must be the
    same.
    By IH, $\ToRegexOf{\Sequence_1;\ldots;\Sequence_{n-1}}$ is strongly
    unambiguous.
    Furthermore, as $\Sequence$ is strongly unambiguous,
    by Lemma~\ref{lem:unambig-concat-equiv},
    $\LanguageOf{\ToRegexOf{\String_0;\Atom_1;\ldots;\Atom_{n-1};\String_{n-1}}}
    \UnambigConcat
    (\ToRegexOf{\Atom_n} \Concat \ToRegexOf{\String_n})$, so
    as each side is also is strongly unambiguous, the entire thing is
    strongly unambiguous.
  \end{case}
\end{proof}

\begin{lemma}
  \label{lem:retaining-unambiguity-toregex}
  \begin{itemize}
  \item 
    If $\DNFRegex$ is strongly unambiguous as a DNF regular expression, then
    $\ToRegexOf{\DNFRegex}$ is strongly unambiguous as a regular expression
  \item
    If $\Sequence$ is strongly unambiguous as a sequence, then
    $\ToRegexOf{\Sequence}$ is strongly unambiguous as a sequence
  \item
    If $\Atom$ is strongly unambiguous as an atom, then
    $\ToRegexOf{\Atom}$ is strongly unambiguous as an atom
  \end{itemize}
\end{lemma}
\begin{proof}
  \begin{case}[\MultiOrDNFRegexType{}]
    Let $\DNFRegex = \DNFOf{\Sequence_1;\ldots;\Sequence_n}$.
    By IH, $\ToRegexOf{\Sequence_i}$ is strongly unambiguous.
    By Lemma~\ref{lem:unambig-dnf}, $\ToRegexOf{\DNFRegex}$ is strongly
    unambiguous.
  \end{case}

  \begin{case}[\MultiConcatSequenceType{}]
    Let $\Sequence = \SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}$.
    By IH, $\ToRegexOf{\Atom_i}$ is strongly unambiguous.
    By Lemma~\ref{lem:unambig-seq}, $\ToRegexOf{\Sequence}$ is strongly
    unambiguous.
  \end{case}

  \begin{case}[StarAtomType]
    Let $\Atom = \StarOf{\DNFRegex}$.
    By IH, $\ToRegexOf{\DNFRegex}$ is strongly unambiguous.
    As $\StarOf{\DNFRegex}$ is strongly unambiguous, $\UnambigItOf{\DNFRegex}$,
    so $\UnambigItOf{\LanguageOf{\DNFRegex}}$, so
    $\UnambigItOf{(\ToRegexOf{\DNFRegex})}$.
    So $\StarOf{\DNFRegex}$ is strongly unambiguous.
  \end{case}
\end{proof}

\begin{lemma}[Expressibility of Identity on Strongly Unambiguous DNF Regex,
  Clauses, and Atoms]
  \label{lem:strongly-unambiguous-identity-expressible}
  \leavevmode
  \begin{enumerate}
  \item If $\DNFRegex$ is a strongly unambiguous DNF Regular expression, then
    there exists a DNF lens $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow
    \DNFRegex$,
    such that $\SemanticsOf{\DNFLens}=
    \SetOf{(\String,\String)\SuchThat\String\in\LanguageOf{\DNFRegex}}$, where
    \DNFLens{} typing includes no rewrite rules.
  \item If $\Sequence$ is a strongly unambiguous sequence, then
    there exists a sequence lens $\SequenceLens \OfRewritelessType \Sequence
    \Leftrightarrow \Sequence$,
    such that $\SemanticsOf{\SequenceLens}=
    \SetOf{(\String,\String)\SuchThat\String\in\LanguageOf{\DNFRegex}}$, where
    \SequenceLens{} typing includes no rewrite rules.
  \item If $\Atom$ is a strongly unambiguous atom, then
    there exists an atom lens $\AtomLens \OfRewritelessType \Atom
    \Leftrightarrow
    \Atom$, such that $\SemanticsOf{\AtomLens}=
    \SetOf{(\String,\String)\SuchThat\String\in\LanguageOf{\DNFRegex}}$, where
    \AtomLens{} typing includes no rewrite rules.
  \end{enumerate}
\end{lemma}
\begin{proof}
  By mutual induction on the structure of the DNF regular expression,
  atom, and clause.
  \begin{case}[\StarAtomType{}]
    Let $\Atom = \StarOf{\DNFRegex}$.
    As $\Atom$ is strongly unambiguous, $\DNFRegex$ is strongly unambiguous,
    and $\UnambigItOf{\DNFRegex}$.
    By IH, there exists $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow
    \DNFRegex$ such that $\SemanticsOf{\DNFLens} = \SetOf{(\String,\String)
      \SuchThat \String \in \LanguageOf{\DNFRegex}}$.
    Consider the atom lens
    \[
      \inferrule*
      {
        \DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegex\\
        \UnambigItOf{\DNFRegex}\\
        \UnambigItOf{\DNFRegex}
      }
      {
        \IterateLensOf{\DNFLens} \OfRewritelessType \StarOf{\DNFRegex}
        \Leftrightarrow \StarOf{\DNFRegex}
      }
    \] with typing as desired.

    $\SemanticsOf{\IterateLensOf{\DNFLens}} = \SetOf{(\String_1\Concat\ldots\Concat\String_n,
      \StringAlt_1\Concat\ldots\Concat\StringAlt_n) \SuchThat
      (\String_i,\StringAlt_i) \in \SemanticsOf{\DNFLens}}$.  So through
    semantics of $\DNFLens$,
    $\SemanticsOf{\IterateLensOf{\DNFLens}} = \SetOf{(\String_1\Concat\ldots\Concat\String_n,
      \String_1\Concat\ldots\Concat\String_n) \SuchThat
      \String \in \LanguageOf{\DNFRegex}}$, so through the definition of
    $\StarOf{\DNFRegex}$,
    $\SemanticsOf{\IterateLensOf{\DNFLens}} = \SetOf{(\String,\String)
      \SuchThat \String \in \LanguageOf{\StarOf{\DNFRegex}}}$
  \end{case}

  \begin{case}[\MultiConcatSequenceType{}]
    Let $\Sequence = \SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}$.
    As $\Sequence$ is strongly unambiguous, for all $i$, $\Atom_i$ is strongly
    unambiguous, and
    $\SequenceUnambigConcatOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}$.

    By IH, for all $i$, there exists $\AtomLens_i \OfRewritelessType \Atom_i
    \Leftrightarrow \Atom_i$ such that
    $\SemanticsOf{\AtomLens_i} = \SetOf{(\String,\String) \SuchThat \String \in
      \LanguageOf{\Atom_i}}$.

    Consider the typing
    \[
      \inferrule*
      {
        \AtomLens_1 \OfRewritelessType \Atom_1 \Leftrightarrow \Atom_1\\
        \ldots\\
        \AtomLens_n \OfRewritelessType \Atom_n \Leftrightarrow \Atom_n\\
        \Identity \in \PermutationSetOf{n}\\
        \SequenceUnambigConcatOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}\\
        \SequenceUnambigConcatOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}
      }
      {
        (\SequenceLensOf{(\String_0,\String_0)\SequenceLensSep\AtomLens_1\SequenceLensSep\ldots\SequenceLensSep\AtomLens_n\SequenceLensSep(\String_n,\String_n)},\Identity) \OfRewritelessType\\
        \SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}\Leftrightarrow
        \SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_n\SequenceSep\String_n}
      }
    \],
    as desired.
    
    $\SemanticsOf{(\SequenceLensOf{(\String_0,\String_0)\SequenceLensSep\AtomLens_1\SequenceLensSep\ldots\SequenceLensSep\AtomLens_n\SequenceLensSep(\String_n,\String_n)},\Identity)}
    = 
    \SetOf{(\String_0;\StringAlt_1;\ldots;\StringAlt_n;\String_n,\String_0;\StringAlt_1';\ldots;\StringAlt_n';\String_n)
      \SuchThat
      (\StringAlt_i,\StringAlt_i') \in \SemanticsOf{\AtomLens_i}}$.  So, through
    the definition of $\AtomLens_i$, 
    $\SemanticsOf{(\SequenceLensOf{(\String_0,\String_0)\SequenceLensSep\AtomLens_1\SequenceLensSep\ldots\SequenceLensSep\AtomLens_n\SequenceLensSep(\String_n,\String_n)},\Identity)}
    = 
    \SetOf{(\String_0;\StringAlt_1;\ldots;\StringAlt_n;\String_n,\String_0;\StringAlt_1;\ldots;\StringAlt_n;\String_n)
      \SuchThat
      \StringAlt_i \in \LanguageOf{\Atom_i}}$.  So, through the definition of
    $\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}$,
    $\SemanticsOf{(\SequenceLensOf{(\String_0,\String_0)\SequenceLensSep\AtomLens_1\SequenceLensSep\ldots\SequenceLensSep\AtomLens_n\SequenceLensSep(\String_n,\String_n)},\Identity)}
    = 
    \SetOf{(\String,\String)
      \SuchThat
      \String \in
      \LanguageOf{\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}}}$,
    as desired.
  \end{case}

  \begin{case}[\MultiOrDNFRegexType{}]
    Let $\DNFRegex = \DNFOf{\Sequence_1;\ldots;\Sequence_n}$.
    As $\DNFRegex$ is strongly unambiguous, for all $i$, $\Sequence_i$ is strongly
    unambiguous, and
    $i \neq j \BooleanImplies \LanguageOf{\Sequence_i} \Intersect
    \LanguageOf{\Sequence_j} = \SetOf{}$.

    By IH, for all $i$, there exists $\AtomLens_i \OfRewritelessType \Atom_i
    \Leftrightarrow \Atom_i$ such that
    $\SemanticsOf{\AtomLens_i} = \SetOf{(\String,\String) \SuchThat \String \in
      \LanguageOf{\Atom_i}}$.

    Consider the typing
    \[
      \inferrule*
      {
        \SequenceLens_1 \OfRewritelessType \Sequence_1 \Leftrightarrow \Sequence_1\\
        \ldots\\
        \SequenceLens_1 \OfRewritelessType \Sequence_1 \Leftrightarrow \Sequence_1\\
        \Identity \in \PermutationSetOf{n}\\
        i \neq j \Rightarrow \LanguageOf{\Sequence_{i}} \cap \LanguageOf{\Sequence_{j}}=\emptyset\\
        i \neq j \Rightarrow \LanguageOf{\Sequence_{i}} \cap \LanguageOf{\Sequence_{j}}=\emptyset
      }
      {
        (\DNFLensOf{\SequenceLens_1\DNFLensSep\ldots\DNFLensSep\SequenceLens_n},\Identity) \OfRewritelessType\\
        \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}
        \Leftrightarrow \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}
      }
    \]
    as desired.
    
    $\SemanticsOf{(\DNFLens{\SequenceLens_1\DNFLensSep\ldots\DNFLens_n},\Identity)}
    = 
    \SetOf{(\String,\StringAlt)
      \SuchThat
      \exists i.
      (\String,\StringAlt) \in \SemanticsOf{\SequenceLens_i}}$.
    So, through the definition of $\SequenceLens_i$, 
    $\SemanticsOf{(\DNFLens{\SequenceLens_1\DNFLensSep\ldots\DNFLens_n},\Identity)}
    = 
    \SetOf{(\String,\String)
      \SuchThat \exists i.
      \String \in \LanguageOf{\Sequence_i}}$.
    So, through the definition of
    $\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}$,
    $\SemanticsOf{(\DNFLens{\SequenceLens_1\DNFLensSep\ldots\DNFLens_n},\Identity)}
    = 
    \SetOf{(\String,\String)
      \SuchThat
      \String \in
      \LanguageOf{\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}}}$,
    as desired
  \end{case}
\end{proof}

\begin{lemma}
  \label{lem:distribute-strongly-unambiguous-iff-factor}
  If $\DNFRegex_1 \ConcatDNF (\DNFRegex_2 \OrDNF \DNFRegex_3)$ is strongly
  unambiguous, then 
  $(\DNFRegex_1 \ConcatDNF \DNFRegex_2) \OrDNF
  (\DNFRegex_1 \ConcatDNF \DNFRegex_3)$ is strongly unambiguous.
\end{lemma}
\begin{proof}
  Let $\DNFRegex_1 = \DNFOf{\Sequence_{1,1};\ldots;\Sequence_{1,n_1}}$.
  Let $\DNFRegex_2 = \DNFOf{\Sequence_{2,1};\ldots;\Sequence_{2,n_2}}$.
  Let $\DNFRegex_3 = \DNFOf{\Sequence_{3,1};\ldots;\Sequence_{3,n_3}}$.

  $\DNFRegex_2 \OrDNF \DNFRegex_3 =
  \DNFOf{\Sequence_{2,1};\ldots;\Sequence_{2,n_2};
    \Sequence_{3,1};\ldots;\Sequence_{3,n_3}}$.
  $\DNFRegex_1 \ConcatDNF (\DNFRegex_2 \OrDNF \DNFRegex_3) =
  \DNFOf{
    \Sequence_{1,1} \ConcatSequence \Sequence_{2,1}; \ldots;
    \Sequence_{1,1}\ConcatSequence\Sequence_{2,n_2};
    \Sequence_{1,1}\ConcatSequence\Sequence_{3,1}; \ldots;
    \Sequence_{1,1}\ConcatSequence\Sequence_{3,n_3}; \ldots;
    \Sequence_{1,n_1} \ConcatSequence \Sequence_{2,1}; \ldots;
    \Sequence_{1,n_1}\ConcatSequence\Sequence_{2,n_2};
    \Sequence_{1,n_1}\ConcatSequence\Sequence_{3,1}; \ldots;
    \Sequence_{1,n_1}\ConcatSequence\Sequence_{3,n_3}}$.
  As this is strongly unambiguous, $\Sequence_{1,i} \ConcatSequence
  \Sequence_{j,k}$ is strongly unambiguous for all $i,j,k$.
  Furthermore, by strong unambiguity,
  if $(i_1,j_1,k_1) \neq (i_2,j_2,k_2)$, then
  $\Sequence_{1,i_1} \ConcatSequence \Sequence_{j_1,k_1} \Intersect
  \Sequence_{1,i_2} \ConcatSequence \Sequence_{j_1,k_1}$.

  
  $(\DNFRegex_1 \ConcatDNF \DNFRegex_2) \OrDNF
  (\DNFRegex_1 \ConcatDNF \DNFRegex_3) =
  \DNFOf{
    \Sequence_{1,1}\ConcatSequence\Sequence_{2,1};\ldots
    \Sequence_{1,1}\ConcatSequence\Sequence_{2,n_2};\ldots;
    \Sequence_{1,n_1}\ConcatSequence\Sequence_{2,1};\ldots;
    \Sequence_{1,n_1}\ConcatSequence\Sequence_{2,n_2};
    \Sequence_{1,1}\ConcatSequence\Sequence_{3,1};\ldots
    \Sequence_{1,1}\ConcatSequence\Sequence_{3,n_3};
    \Sequence_{1,n_1}\ConcatSequence\Sequence_{3,1};\ldots
    \Sequence_{1,n_1}\ConcatSequence\Sequence_{3,n_3}}$
  
  From before, if $(i_1,j_1,k_1) \neq (i_2,j_2,k_2)$, then
  $\Sequence_{1,i_1} \ConcatSequence \Sequence_{j_1,k_1} \Intersect
  \Sequence_{1,i_2} \ConcatSequence \Sequence_{j_1,k_1} = \SetOf{}$.
  Furthermore, each $\Sequence_{1,i} \ConcatSequence \Sequence_{j,k}$ is still
  strongly unambiguous for all $i,j,k$, so
  $(\DNFRegex_1 \ConcatDNF \DNFRegex_2) \OrDNF
  (\DNFRegex_1 \ConcatDNF \DNFRegex_3)$ is strongly unambiguous.

  The same process can be repeated to show that assumping
  $(\DNFRegex_1 \ConcatDNF \DNFRegex_2) \OrDNF
  (\DNFRegex_1 \ConcatDNF \DNFRegex_3)$ is strongly unambiguous, we can show
  $\DNFRegex \ConcatDNF (\DNFRegex_2 \OrDNF \DNFRegex_3)$ is strongly unambiguous.
\end{proof}

\begin{lemma}
  \label{lem:id-expressible-on-distribute-left}
  If $\DNFRegex_1 \ConcatDNF (\DNFRegex_2 \OrDNF \DNFRegex_3)$ is strongly
  unambiguous, then there exists a lens
  $\DNFLens \OfRewritelessType
  \DNFRegex_1 \ConcatDNF (\DNFRegex_2 \OrDNF \DNFRegex_3)
  \Leftrightarrow
  (\DNFRegex_1 \ConcatDNF \DNFRegex_2) \OrDNF
  (\DNFRegex_1 \ConcatDNF \DNFRegex_3)$.
\end{lemma}
\begin{proof}
  If $\LanguageOf{\DNFRegex_1 \ConcatDNF (\DNFRegex_2 \OrDNF \DNFRegex_3)} = \SetOf{}$,
  then this is trivial, as
  $\DNFRegex_1 \ConcatDNF (\DNFRegex_2 \OrDNF \DNFRegex_3) =
  \SetOf{}$.
  
  Assume the language is nonempty.
  Let $\DNFRegex_1 = \DNFOf{\Sequence_{1,1};\ldots;\Sequence_{1,n_1}}$.
  Let $\DNFRegex_2 = \DNFOf{\Sequence_{2,1};\ldots;\Sequence_{2,n_2}}$.
  Let $\DNFRegex_3 = \DNFOf{\Sequence_{3,1};\ldots;\Sequence_{3,n_3}}$.

  $\DNFRegex_2 \OrDNF \DNFRegex_3 =
  \DNFOf{\Sequence_{2,1};\ldots;\Sequence_{2,n_2};
    \Sequence_{3,1};\ldots;\Sequence_{3,n_3}}$.
  $\DNFRegex_1 \ConcatDNF (\DNFRegex_2 \OrDNF \DNFRegex_3) =
  \DNFOf{
    \Sequence_{1,1} \ConcatSequence \Sequence_{2,1}; \ldots;
    \Sequence_{1,1}\ConcatSequence\Sequence_{2,n_2};
    \Sequence_{1,1}\ConcatSequence\Sequence_{3,1}; \ldots;
    \Sequence_{1,1}\ConcatSequence\Sequence_{3,n_3}; \ldots;
    \Sequence_{1,n_1} \ConcatSequence \Sequence_{2,1}; \ldots;
    \Sequence_{1,n_1}\ConcatSequence\Sequence_{2,n_2};
    \Sequence_{1,n_1}\ConcatSequence\Sequence_{3,1}; \ldots;
    \Sequence_{1,n_1}\ConcatSequence\Sequence_{3,n_3}}$.
  As this is strongly unambiguous, $\Sequence_{1,i} \ConcatSequence
  \Sequence_{j,k}$ is strongly unambiguous for all $i,j,k$.
  Furthermore, by strong unambiguity,
  if $(i_1,j_1,k_1) \neq (i_2,j_2,k_2)$, then
  $\Sequence_{1,i_1} \ConcatSequence \Sequence_{j_1,k_1} \Intersect
  \Sequence_{1,i_2} \ConcatSequence \Sequence_{j_1,k_1}$
  
  $\DNFRegex_1 \ConcatDNF \DNFRegex_2 =
  \DNFOf{\Sequence_{1,1}\ConcatSequence\Sequence_{2,1};\ldots
    \Sequence_{1,1}\ConcatSequence\Sequence_{2,n_2};\ldots;
    \Sequence_{1,n_1}\ConcatSequence\Sequence_{2,1};\ldots;
    \Sequence_{1,n_1}\ConcatSequence\Sequence_{2,n_2}}$.

  $\DNFRegex_1 \ConcatDNF \DNFRegex_3 =
  \DNFOf{\Sequence_{1,1}\ConcatSequence\Sequence_{3,1};\ldots
    \Sequence_{1,1}\ConcatSequence\Sequence_{3,n_3};
    \Sequence_{1,n_1}\ConcatSequence\Sequence_{3,1};\ldots
    \Sequence_{1,n_1}\ConcatSequence\Sequence_{3,n_3}}$.
  
  $(\DNFRegex_1 \ConcatDNF \DNFRegex_2) \OrDNF
  (\DNFRegex_1 \ConcatDNF \DNFRegex_3) =
  \DNFOf{
    \Sequence_{1,1}\ConcatSequence\Sequence_{2,1};\ldots
    \Sequence_{1,1}\ConcatSequence\Sequence_{2,n_2};\ldots;
    \Sequence_{1,n_1}\ConcatSequence\Sequence_{2,1};\ldots;
    \Sequence_{1,n_1}\ConcatSequence\Sequence_{2,n_2};
    \Sequence_{1,1}\ConcatSequence\Sequence_{3,1};\ldots
    \Sequence_{1,1}\ConcatSequence\Sequence_{3,n_3};\ldots
    \Sequence_{1,n_1}\ConcatSequence\Sequence_{3,1};\ldots
    \Sequence_{1,n_1}\ConcatSequence\Sequence_{3,n_3}}$
  From before, if $(i_1,j_1,k_1) \neq (i_2,j_2,k_2)$, then
  $\Sequence_{1,i_1} \ConcatSequence \Sequence_{j_1,k_1} \Intersect
  \Sequence_{1,i_2} \ConcatSequence \Sequence_{j_1,k_1} = \SetOf{}$.

  As $\Sequence_{1,i} \ConcatSequence \Sequence_{j,k}$ is strongly unambiguous,
  there exists
  $\SequenceLens_{i,j,k} \OfRewritelessType
  \Sequence_{1,i} \ConcatSequence \Sequence_{j,k} \Leftrightarrow
  \Sequence_{1,i} \ConcatSequence \Sequence_{j,k}$,
  from Lemma~\ref{lem:strongly-unambiguous-identity-expressible}.

  There exists a unique permutation $\sigma$ that sends
  $\Sequence_{1,i} \ConcatSequence \Sequence_{j,k}$
  in $\DNFRegex_1 \ConcatDNF (\DNFRegex_2 \OrDNF \DNFRegex_3)$
  to $\Sequence_{1,i} \ConcatSequence \Sequence_{j,k}$ in
  $(\DNFRegex_1 \ConcatDNF \DNFRegex_2) \OrDNF
  (\DNFRegex_1 \ConcatDNF \DNFRegex_3)$.  As a permutation is merely a bijective
  between a finite number of elements.
  Note, this permutation is not necessarily the identity permutation.
  In particular, the sequence at position $n_1+1$, if such a sequence exists, in
  $\DNFRegex_1 \ConcatDNF (\DNFRegex_2 \OrDNF \DNFRegex_3)$ is
  $\Sequence_{1,1} \ConcatSequence \Sequence_{3,1}$.
  However, the sequence at position $n_1+1$, if such a sequence exists, in
  $(\DNFRegex_1 \ConcatDNF \DNFRegex_2) \OrDNF
  (\DNFRegex_1 \ConcatDNF \DNFRegex_3)$, is
  $\Sequence_{1,2} \ConcatSequence \Sequence_{2,1}$.

  Consider the derivation
  \[
    \inferrule*
    {
      \SequenceLens \OfRewritelessType
      \Sequence_{1,i} \ConcatSequence \Sequence_{j,k}
      \Leftrightarrow
      \Sequence_{1,i} \ConcatSequence \Sequence_{j,k}\\
      (i_1,j_1,k_1) \neq (i_2,j_2,k_2) \BooleanImplies
      (\Sequence_{1,i_1} \ConcatSequence \Sequence_{j_1,k_1}) \Intersect
      (\Sequence_{1,i_2} \ConcatSequence \Sequence_{j_2,k_2}) = \SetOf{}
      \sigma \in \PermutationSetOf{n_1\Cross n_2\Cross n_3}
    }
    {
      (\DNFLensOf{\SequenceLens_{1,2,1};\ldots;\SequenceLens_{1,2,n_2};
        \SequenceLens_{1,3,1};\ldots;\SequenceLens_{1,3,n_3};\ldots;
        \SequenceLens_{n_1,2,1};\ldots;\SequenceLens_{n_1,2,n_2};
        \SequenceLens_{n_1,3,1};\ldots;\SequenceLens_{n_1,3,n_3}},\sigma)
    }
  \]

  Furthermore, as each $\SequenceLens$ has the identity transformation, then as
  $\sigma$ has no impact on semantics, the total DNF lens has the identity
  transformation.
\end{proof}

\begin{lemma}
  \label{lem:id-expressible-on-factor-left}
  If $(\DNFRegex_1 \ConcatDNF \DNFRegex_2) \OrDNF
  (\DNFRegex_1 \ConcatDNF \DNFRegex_3)$ is strongly
  unambiguous, then there exists a lens
  $\DNFLens \OfRewritelessType
  (\DNFRegex_1 \ConcatDNF \DNFRegex_2) \OrDNF
  (\DNFRegex_1 \ConcatDNF \DNFRegex_3)
  \Leftrightarrow
  \DNFRegex_1 \ConcatDNF (\DNFRegex_2 \OrDNF \DNFRegex_3)$.
\end{lemma}
\begin{proof}
  By Lemma~\ref{lem:distribute-strongly-unambiguous-iff-factor},
  $\DNFRegex_1 \ConcatDNF (\DNFRegex_2 \OrDNF \DNFRegex_3)$ is strongly
  unambiguous.
  So by Lemma~\ref{lem:id-expressible-on-distribute-left},
  there exists an identity lens
  $\DNFLens \OfRewritelessType
  (\DNFRegex_1 \ConcatDNF \DNFRegex_2) \OrDNF
  (\DNFRegex_1 \ConcatDNF \DNFRegex_3)
  \Leftrightarrow
  \DNFRegex_1 \ConcatDNF (\DNFRegex_2 \OrDNF \DNFRegex_3)$.
  As rewriteless DNF lenses are closed under inversion, there exists a lens
  $\InverseOf{\DNFLens} \OfRewritelessType
  \DNFRegex_1 \ConcatDNF (\DNFRegex_2 \OrDNF \DNFRegex_3)
  \Leftrightarrow
  (\DNFRegex_1 \ConcatDNF \DNFRegex_2) \OrDNF
  (\DNFRegex_1 \ConcatDNF \DNFRegex_3)$.
\end{proof}

\begin{lemma}
  \label{lem:id-expressible-on-distribute-right}
  If $(\DNFRegex_1 \OrDNF \DNFRegex_2) \ConcatDNF \DNFRegex_3$ is strongly
  unambiguous, then there exists a lens
  $\DNFLens \OfRewritelessType
  (\DNFRegex_1 \OrDNF \DNFRegex_2) \ConcatDNF \DNFRegex_3
  \Leftrightarrow
  (\DNFRegex_1 \ConcatDNF \DNFRegex_3) \OrDNF
  (\DNFRegex_2 \ConcatDNF \DNFRegex_3)$.
\end{lemma}
\begin{proof}
  By Lemma~\ref{lem:dnf-distribute-right}, $(\DNFRegex_1 \OrDNF \DNFRegex_2)
  \ConcatDNF \DNFRegex_3 = (\DNFRegex_1 \ConcatDNF \DNFRegex_3) \OrDNF
  (\DNFRegex_2 \ConcatDNF \DNFRegex_3)$, so by
  Lemma~\ref{lem:strongly-unambiguous-identity-expressible}, there is an
  identity lens between them.
\end{proof}

\begin{lemma}
  \label{lem:id-expressible-on-factor-right}
  If $(\DNFRegex_1 \OrDNF \DNFRegex_2) \ConcatDNF \DNFRegex_3$ is strongly
  unambiguous, then there exists a lens
  $\DNFLens \OfRewritelessType
  (\DNFRegex_1 \ConcatDNF \DNFRegex_3) \OrDNF
  (\DNFRegex_2 \ConcatDNF \DNFRegex_3)
  \Leftrightarrow
  (\DNFRegex_1 \OrDNF \DNFRegex_2) \ConcatDNF \DNFRegex_3$.
\end{lemma}
\begin{proof}
  By Lemma~\ref{lem:dnf-distribute-right}, $(\DNFRegex_1 \OrDNF \DNFRegex_2)
  \ConcatDNF \DNFRegex_3 = (\DNFRegex_1 \ConcatDNF \DNFRegex_3) \OrDNF
  (\DNFRegex_2 \ConcatDNF \DNFRegex_3)$, so by
  Lemma~\ref{lem:strongly-unambiguous-identity-expressible}, there is an
  identity lens between them.
\end{proof}

\begin{definition}
  Let $\rightarrow$ and $\Property$ be two binary relations on a set $\Set$.
  We say that $\rightarrow$ is confluent with respect to
  $\Property$, written
  $\IsConfluentWithPropertyOf{\rightarrow}{\Property}$, if, given $x_1,x_2\in\Set$,
  where $\Property(x_1,x_2)$, if $x_1\rightarrow x_1'$ and
  $x_2 \rightarrow x_2'$, then there exists $x_1''$ and $x_2''$ such that
  $x_1'\rightarrow x_1''$, $x_2' \rightarrow x_2''$, and
  $\Property(x_1'',x_2'')$.
\end{definition}

\begin{definition}
  Let $\rightarrow$ and $\Property$ be two binary relations on a set $\Set$.
  We say that $rightarrow$ mirrors $\Property$, written
  $\IsMirroringWithPropertyOf{\rightarrow}{\Property}$, if, given
  $x_1,x_2\in\Set$,
  where $\Property(x_1,x_2)$, if $x_1\rightarrow x_1'$ then there
  exists some $x_2$ such that $x_2\rightarrow x_2'$ where
  $\Property(x_1',x_2')$,
  and if $x_2\rightarrow x_2'$, then there exists some $x_1'$ such that
  $x_1\rightarrow x_1'$ where $\Property(x_1',x_2')$.
\end{definition}


\begin{definition}
  Let $\Property$ be a binary relation.  $\StarOf{\Property}$ is the binary
  relation defined via the inference rules
  \begin{mathpar}
    \inferrule[\ReflexivityRule]
    {
    }
    {
      \StarOf{\Property}(x,x)
    }

    \inferrule[\BaseRule]
    {
      \Property(x,y)
    }
    {
      \StarOf{\Property}(x,y)
    }

    \inferrule[\TransitivityRule]
    {
      \StarOf{\Property}(x,y)\\
      \StarOf{\Property}(y,z)
    }
    {
      \StarOf{\Property}(x,z)
    }
  \end{mathpar}
\end{definition}


\begin{lemma}[Mirroring Preserved through Star left]
  \label{lem:mirroring-star-left}
  Let $\IsMirroringWithPropertyOf{\rightarrow}{\Property}$.
  If $\Property(x,y)$ and $x\StarOf{\rightarrow} x'$ then there
  exists some $y'$ such that $y\StarOf{\rightarrow} y'$ where
  $\Property(x',y')$
\end{lemma}
\begin{proof}
  By induction on the derivation of $x \StarOf{\rightarrow} x'$.

  \begin{case}[\ReflexivityRule{}]
    \[
      \inferrule*
      {
      }
      {
        x \StarOf{\rightarrow} x
      }
    \]

    Consider the derivation
    \[
      \inferrule*
      {
      }
      {
        y \StarOf{\rightarrow} y
      }
    \]

    and by assumption $\Property(x,y)$.
  \end{case}

  \begin{case}[\BaseRule{}]
    \[
      \inferrule*
      {
        x \rightarrow x'
      }
      {
        x \StarOf{\rightarrow} x'
      }
    \]

    As $\IsMirroringWithPropertyOf{\rightarrow}{\Property}$, $y \rightarrow y'$
    where $\Property(x',y')$.
    \[
      \inferrule*
      {
        y \rightarrow y'
      }
      {
        y \StarOf{\rightarrow} y'
      }
    \]
  \end{case}

  \begin{case}[\TransitivityRule{}]
    \[
      \inferrule*
      {
        x \StarOf{\rightarrow} x''\\
        x'' \StarOf{\rightarrow} x'
      }
      {
        x \StarOf{\rightarrow} x'
      }
    \]

    By IH, $y \StarOf{\rightarrow} y''$ where $\Property(x'',y'')$.
    By IH, $y'' \StarOf{\rightarrow} y'$ where $\Property(x',y')$.
    \[
      \inferrule*
      {
        y \StarOf{\rightarrow} y''\\
        y'' \StarOf{\rightarrow} y'
      }
      {
        y \StarOf{\rightarrow} y'
      }
    \]
  \end{case}
\end{proof}

\begin{lemma}[Mirroring Preserved through Star right]
  \label{lem:mirroring-star-right}
  Let $\IsMirroringWithPropertyOf{\rightarrow}{\Property}$.
  If $\Property(x,y)$ and $x\StarOf{\rightarrow} x'$ then there
  exists some $y'$ such that $y\StarOf{\rightarrow} y'$ where
  $\Property(x',y')$
\end{lemma}
\begin{proof}
  Symmetrically to Lemma~\ref{lem:mirroring-star-left}.
\end{proof}

\begin{lemma}[Mirroring Preserved through Star]
  \label{lem:mirroring-star}
  If $\IsMirroringWithPropertyOf{\rightarrow}{\Property}$, then
  $\IsMirroringWithPropertyOf{\StarOf{\rightarrow}}{\Property}$.
\end{lemma}
\begin{proof}
  By application of Lemma~\ref{lem:mirroring-star-left} and
  Lemma~\ref{lem:mirroring-star-right}.
\end{proof}

\begin{lemma}
  \label{lem:pre-starred-confluence-propagator-like}
  If $\IsConfluentWithPropertyOf{\rightarrow}{\Property}$,
  $\IsMirroringWithPropertyOf{\rightarrow}{\Property}$,
  $\Property(x,y) \BooleanAnd \Property(y,z) \BooleanImplies
  \Property(x,z)$, and
  $\Property(x,y) \BooleanImplies \Property(x,x) \BooleanAnd \Property(y,y)$
  then if $\Property(x,y)$, $x\StarOf{\rightarrow} x_1$, $y\rightarrow
  x_1$, then there exists some $x_2$, $x_y$ such that
  $x_1\rightarrow x_2$, $y_1\StarOf{\rightarrow} y_2$, and
  $\Property(x_2,y_2)$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $x \StarOf{\rightarrow} x_1$.

  \begin{case}[\ReflexivityRule]
    \[
      \inferrule*
      {
      }
      {
        x \StarOf{\rightarrow} x
      }
    \]

    By $\IsMirroringWithPropertyOf{\rightarrow}{\Property}$, there exists
    some $x_1$ such that $x \rightarrow x_1$ and $\Property(x_1,y_1)$.
    Furthermore,
    \[
      \inferrule*
      {
      }
      {
        y_1 \StarOf{\Rewrite} y_1
      }
    \]
    so we are done.
  \end{case}

  \begin{case}[\BaseRule{}]
    \[
      \inferrule*
      {
        x \rightarrow x_1
      }
      {
        x \StarOf{\rightarrow} x_1
      }
    \]

    As $\IsConfluentWithPropertyOf{\rightarrow}{\Property}$, there exists
    $x_2$, $y_2$ such that $x_1 \rightarrow x_2$, $y_1 \rightarrow y_2$,
    and $\Property(x_2,y_2)$.
    Furthermore
    \[
      \inferrule*
      {
        y_1 \rightarrow y_2
      }
      {
        y_1 \StarOf{\rightarrow} y_2
      }
    \]
  \end{case}

  \begin{case}[\TransitivityRule{}]
    \[
      \inferrule*
      {
        x \StarOf{\rightarrow} x_1\\
        x_1 \StarOf{\rightarrow} x_2
      }
      {
        x_1 \StarOf{\rightarrow} x_2
      }
    \]

    By IH, there exists $x_3$, $y_2$ such that $x_1 \rightarrow x_3$, and
    $y_1 \StarOf{\rightarrow} y_2$, and $\Property(x_3,y_2)$.

    As $\Property(x,y)$, we have $\Property(x,x)$.  As $\Property(x,x)$, and $x
    \StarOf{\rightarrow} x_1$, then there exists $x'$ such that
    $\Property(x_1,x')$, so $\Property(x_1,x_1)$.
    So, by IH, as $\Property(x_1,x_1)$, $x_1 \StarOf{\rightarrow} x_2$, and
    $x_1 \rightarrow x_3$, there exists $x_4,x_5$ such that $x_2 \rightarrow
    x_4$, $x_3 \StarOf{\rightarrow} x_5$, and $\Property(x_4,x_5)$.

    As $\Property(x_3,y_2)$, and $x_3 \StarOf{\Rewrite} x_5$, then by
    $\IsMirroringWithPropertyOf{\rightarrow}{\Property}$ and
    Lemma~\ref{lem:mirroring-star}, there exists $y_3$ such that
    $y_2 \StarOf{\Rewrite} y_3$, and $\Property(x_5,y_3)$.
    By \TransitivityRule{}, $y_1 \StarOf{\Rewrite} y_3$.
    From before, $x_2 \rightarrow x_4$.
    Because we have $\Property(x_4,x_5)$ and $\Property(x_5,y_3)$, we have
    $\Property(x_4,y_3)$.
  \end{case}
\end{proof}

\begin{lemma}
  \label{lem:starred-confluence-propatator-like}
  If $\IsConfluentWithPropertyOf{\rightarrow}{\Property}$,
  $\IsMirroringWithPropertyOf{\rightarrow}{\Property}$, and
  $\Property(x,y) \BooleanAnd \Property(y,z) \BooleanImplies
  \Property(x,z)$, and
  $\Property(x,y) \BooleanImplies \Property(x,x) \BooleanAnd \Property(y,y)$
  then if $\Property(x,y)$, $x \StarOf{\rightarrow} x_1$,
  $y \StarOf{\rightarrow} x_1$, then there exists some $x_2$, $x_y$ such that
  $x_1 \StarOf{\rightarrow} x_2$, $y_1\StarOf{\rightarrow} y_2$, and
  $\Property(x_2,y_2)$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $y \StarOf{\rightarrow} y_1$.

  \begin{case}[\ReflexivityRule]
    \[
      \inferrule*
      {
      }
      {
        y \StarOf{\rightarrow} y
      }
    \]

    By $\IsMirroringWithPropertyOf{\rightarrow}{\Property}$,
    and Lemma~\ref{lem:mirroring-star},
    there exists
    some $y_1$ such that $y \StarOf{\rightarrow} y_1$ and $\Property(x_1,y_1)$.
    Furthermore,
    \[
      \inferrule*
      {
      }
      {
        y_1 \StarOf{\Rewrite} y_1
      }
    \]
    so we are done.
  \end{case}

  \begin{case}[\BaseRule{}]
    \[
      \inferrule*
      {
        y \rightarrow y_1
      }
      {
        y \StarOf{\rightarrow} y_1
      }
    \]

    As $\IsConfluentWithPropertyOf{\rightarrow}{\Property}$,
    $\IsMirroringWithPropertyOf{\rightarrow}{\Property}$,
    $y \rightarrow y_1$, $x \StarOf{\rightarrow} x_1$, and
    $\StarOf{\Property}(x,y)$ if, and only if $\Property(x,y)$,
    by Lemma~\ref{lem:pre-starred-confluence-propagator-like},
    there exists
    $x_2$, $y_2$ such that $x_1 \rightarrow x_2$, $y_1 \StarOf{\rightarrow} y_2$,
    and $\Property(x_2,y_2)$.
    Furthermore
    \[
      \inferrule*
      {
        x_1 \rightarrow x_2
      }
      {
        x_1 \StarOf{\rightarrow} x_2
      }
    \]
  \end{case}

  \begin{case}[\TransitivityRule{}]
    \[
      \inferrule*
      {
        y \StarOf{\rightarrow} y_1\\
        y_1 \StarOf{\rightarrow} y_2
      }
      {
        y \StarOf{\rightarrow} y_2
      }
    \]

    By IH, there exists $x_2$, $y_3$ such that $x_1 \StarOf{\rightarrow} x_2$, and
    $y_1 \StarOf{\Rewrite} y_3$, and $\Property(x_2,y_3)$.

    As $\Property(x,y)$, we have $\Property(y,y)$.  As $\Property(y,y)$, and $y
    \StarOf{\rightarrow} y_1$, then there exists $y'$ such that
    $\Property(y_1,y')$, so $\Property(y_1,y_1)$.
    So, by IH, as $\Property(y_1,y_1)$, $y_1 \StarOf{\rightarrow} y_3$, and
    $y_1 \StarOf{\rightarrow} y_2$, there exists $y_4,y_5$ such that
    $y_3 \StarOf{\rightarrow} y_4$,
    $y_2 \StarOf{\rightarrow} y_5$, and $\Property(y_4,y_5)$.

    As $\Property(x_2,y_3)$, and $y_3 \StarOf{\Rewrite} y_4$, then by
    $\IsMirroringWithPropertyOf{\rightarrow}{\Property}$ and
    Lemma~\ref{lem:mirroring-star}, there exists $x_3$ such that
    $x_2 \StarOf{\Rewrite} x_3$, and $\Property(x_3,y_4)$.
    By \TransitivityRule{}, $x_1 \StarOf{\Rewrite} x_3$.
    From before, $y_2 \rightarrow y_5$.
    As we have $\Property(x_3,y_4)$ and $\Property(y_4,y_5)$, we have
    $\Property(x_3,y_5)$.
  \end{case}
\end{proof}

\begin{definition}
  A property $\Propagator$ is a left propagator for $\Property$ with respect to
  $\rightarrow$ if
  $\IsMirroringWithPropertyOf{\rightarrow}{\Property}$,
  $\IsConfluentWithPropertyOf{\rightarrow}{\Property}$,
  $\Propagator(x,y) \BooleanAnd \Propagator(y,z) \BooleanImplies \Propagator(x,z)$,
  $\Propagator(x,y) \BooleanImplies \Propagator(x,x) \BooleanAnd
  \Propagator(y,y))$,
  $\Property(x,y) \BooleanImplies \Propagator(x,x)$, and
  $\Propagator(x,y) \BooleanAnd \Property(y,z) \BooleanImplies \Property(x,z)$.
\end{definition}

\begin{definition}
  A property $\Propagator$ is a left propagator for $\Property$ with respect to
  $\rightarrow$ if
  $\IsMirroringWithPropertyOf{\rightarrow}{\Property}$,
  $\IsConfluentWithPropertyOf{\rightarrow}{\Property}$,
  $\Propagator(x,y) \BooleanAnd \Propagator(y,z) \BooleanImplies \Propagator(x,z)$,
  $\Propagator(x,y) \BooleanImplies \Propagator(x,x) \BooleanAnd
  \Propagator(y,y))$,
  $\Property(x,y) \BooleanImplies \Propagator(y,y)$, and
  $\Property(x,y) \BooleanAnd \Propagator(y,z) \BooleanImplies \Property(x,z)$.
\end{definition}

\begin{lemma}
  \label{lem:pre-starred-confluence}
  Let $\IsConfluentWithPropertyOf{\rightarrow}{\Property}$.
  Let $\IsMirroringWithPropertyOf{\rightarrow}{\Property}$.
  Let $\Propagator_L$ be a left propagator for $\Property$ with respect to
  $\rightarrow$.
  If $\Property(x_1,x_2)$, $x_1\StarOf{\rightarrow} x_1'$, $x_2\rightarrow
  x_2'$, then there exists some $x_1''$, $x_2''$ such that
  $x_1'\rightarrow x_1''$, $x_2'\StarOf{\rightarrow} x_2''$, and
  $\Property(x_1'',x_2'')$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $x_1 \StarOf{\rightarrow} x_1'$.

  \begin{case}[\ReflexivityRule]
    \[
      \inferrule*
      {
      }
      {
        x_1 \StarOf{\rightarrow} x_1
      }
    \]

    By $\IsMirroringWithPropertyOf{\rightarrow}{\Property}$, there exists
    some $x_1'$ such that $x_1 \rightarrow x_1'$ and $\Property(x_1',x_2')$.
    Furthermore,
    \[
      \inferrule*
      {
      }
      {
        x_2' \StarOf{\Rewrite} x_2'
      }
    \]
    so we are done.
  \end{case}

  \begin{case}[\BaseRule]
    \[
      \inferrule*
      {
        x_1 \rightarrow x_1'
      }
      {
        x_1 \StarOf{\rightarrow} x_1'
      }
    \]

    As $\IsConfluentWithPropertyOf{\rightarrow}{\Property}$, there exists
    $x_2$, $y_2$ such that $x_1 \rightarrow x_2$, $y_1 \rightarrow y_2$,
    and $\Property(x_2,y_2)$.
    Furthermore
    \[
      \inferrule*
      {
        y_1 \rightarrow y_2
      }
      {
        y_1 \StarOf{\rightarrow} y_2
      }
    \]
  \end{case}

  \begin{case}[\TransitivityRule{}]
    \[
      \inferrule*
      {
        x \StarOf{\rightarrow} x_1\\
        x_1 \StarOf{\rightarrow} x_2
      }
      {
        x_1 \StarOf{\rightarrow} x_2
      }
    \]

    By IH, there exists $x_3$, $y_2$ such that $x_1 \rightarrow x_3$, and
    $y_1 \StarOf{\Rewrite} y_2$, and $\Property(x_3,y_2)$.

    As $\StarOf{\Propagator_L}(a,b)$ if, and only if $\Propagator_L(a,b)$,
    $\Propagator_L(x_1,x_1)$.

    As $\Property(x,y)$, we have $\Propagator_L(x,x)$.
    As $\Propagator_L(x,x)$ and $x \StarOf{\rightarrow} x_1$, there exists $x'$
    such that $x \StarOf{\rightarrow} x'$, and $\Propagator_L(x_1,x')$, which
    means that $\Propagator_L(x_1,x_1)$.
    As $\Propagator_L$ is a propagator with respect to $\rightarrow$,
    it fills the properties required for
    Lemma~\ref{lem:pre-starred-confluence-propagator-like}, 
    So, as $\Propagator_L(x_1,x_1)$, $x_1 \StarOf{\rightarrow} x_2$, and
    $x_1 \rightarrow x_3$, there exists $x_4,x_5$ such that $x_2 \rightarrow
    x_4$, $x_3 \StarOf{\rightarrow} x_5$, and $\Propagator_L(x_4,x_5)$.

    As $\Property(x_3,y_2)$, and $x_3 \StarOf{\Rewrite} x_5$, then by
    $\IsMirroringWithPropertyOf{\rightarrow}{\Property}$ and
    Lemma~\ref{lem:mirroring-star}, there exists $y_3$ such that
    $y_2 \StarOf{\Rewrite} y_3$, and $\Property(x_5,y_3)$.
    By \TransitivityRule{}, $y_1 \StarOf{\Rewrite} y_3$.
    From before, $x_2 \rightarrow x_4$.
    Because
    $\Propagator_L(x_4,x_5)$ and $\Property(x_5,y_3)$, and
    $\Propagator_L$ is a left propagator, $\Property(x_4,y_3)$.
  \end{case}
\end{proof}

\begin{theorem}[Confluence Preserved Through Star]
  \label{thm:starred-confluence}
  Let $\IsConfluentWithPropertyOf{\rightarrow}{\Property}$.
  Let $\IsMirroringWithPropertyOf{\rightarrow}{\Property}$.
  Let $\Propagator_L$ be a left propagator for $\Property$ with respect to
  $\rightarrow$.
  Let $\Propagator_R$ be a right propagator for $\Property$ with respect to
  $\rightarrow$.
  If $\Property(x_1,x_2)$, $x_1\StarOf{\rightarrow} x_1'$, $x_2\rightarrow
  x_2'$, then there exists some $x_1''$, $x_2''$ such that
  $x_1'\rightarrow x_1''$, $x_2'\StarOf{\rightarrow} x_2''$, and
  $\Property(x_1'',x_2'')$.
\end{theorem}
\begin{proof}
  By induction on the derivation of $y \StarOf{\rightarrow} y_1$.

  \begin{case}[\ReflexivityRule]
    \[
      \inferrule*
      {
      }
      {
        y \StarOf{\rightarrow} y
      }
    \]

    By $\IsMirroringWithPropertyOf{\rightarrow}{\Property}$,
    and Lemma~\ref{lem:mirroring-star},
    there exists
    some $y_1$ such that $y \StarOf{\rightarrow} y_1$ and $\Property(x_1,y_1)$.
    Furthermore,
    \[
      \inferrule*
      {
      }
      {
        y_1 \StarOf{\Rewrite} y_1
      }
    \]
    so we are done.
  \end{case}

  \begin{case}[\BaseRule{}]
    \[
      \inferrule*
      {
        y \rightarrow y_1
      }
      {
        y \StarOf{\rightarrow} y_1
      }
    \]

    As $\IsConfluentWithPropertyOf{\rightarrow}{\Property}$,
    $\IsMirroringWithPropertyOf{\rightarrow}{\Property}$,
    $y \rightarrow y_1$, $x \StarOf{\rightarrow} x_1$, and
    $\StarOf{\Property}(x,y)$ if, and only if $\Property(x,y)$,
    by Lemma~\ref{lem:pre-starred-confluence},
    there exists
    $x_2$, $y_2$ such that $x_1 \rightarrow x_2$, $y_1 \StarOf{\rightarrow} y_2$,
    and $\Property(x_2,y_2)$.
    Furthermore
    \[
      \inferrule*
      {
        x_1 \rightarrow x_2
      }
      {
        x_1 \StarOf{\rightarrow} x_2
      }
    \]
  \end{case}

  \begin{case}[\TransitivityRule{}]
    \[
      \inferrule*
      {
        y \StarOf{\rightarrow} y_1\\
        y_1 \StarOf{\rightarrow} y_2
      }
      {
        y \StarOf{\rightarrow} y_2
      }
    \]

    By IH, there exists $x_2$, $y_3$ such that $x_1 \StarOf{\rightarrow} x_2$, and
    $y_1 \StarOf{\Rewrite} y_3$, and $\Property(x_2,y_3)$.

    As $\Property(x,y)$, we have $\Propagator_R(y,y)$.
    As $\Propagator_R(x,x)$ and $y \StarOf{\rightarrow} y_1$, there exists $y'$
    such that $y \StarOf{\rightarrow} y'$, and $\Propagator_R(y_1,y')$, which
    means that $\Propagator_R(y_1,y_1)$.
    As $\Propagator_L$ is a propagator with respect to $\rightarrow$,
    it fills the properties required for
    Lemma~\ref{lem:starred-confluence-propagator-like}, 
    So, as $\Propagator_R(y_1,y_1)$, $y_1 \StarOf{\rightarrow} y_3$, and
    $y_1 \StarOf{\rightarrow} y_2$, there exists $y_4,y_5$ such that
    $y_3 \StarOf{\rightarrow} y_4$,
    $y_2 \StarOf{\rightarrow} y_5$, and $\Propagator_R(y_4,y_5)$.

    As $\Property(x_2,y_3)$, and $y_3 \StarOf{\Rewrite} y_4$, then by
    $\IsMirroringWithPropertyOf{\rightarrow}{\Property}$ and
    Lemma~\ref{lem:mirroring-star}, there exists $x_3$ such that
    $x_2 \StarOf{\Rewrite} x_3$, and $\Property(x_3,y_4)$.
    By \TransitivityRule{}, $x_1 \StarOf{\Rewrite} x_3$.
    From before, $y_2 \rightarrow y_5$.
    Because
    $\Property(x_3,y_4)$ and $\Propagator_R(y_4,y_5)$, and
    $\Propagator_R$ is a right propagator, $\Property(x_3,y_5)$.
  \end{case}
\end{proof}

\begin{definition}
  Let $\Property$ be a binary relation.  $\EquivalenceOf{\Property}$ is the
  binary relation defined via the inference rules
  \begin{mathpar}
    \inferrule[\BaseRule]
    {
      \Property(x,y)
    }
    {
      \EquivalenceOf{\Property}(x,y)
    }
    
    \inferrule[\ReflexivityRule]
    {
    }
    {
      \EquivalenceOf{\Property}(x,x)
    }

    \inferrule[\TransitivityRule]
    {
      \EquivalenceOf{\Property}(x,y)\\
      \EquivalenceOf{\Property}(y,z)
    }
    {
      \EquivalenceOf{\Property}(x,z)
    }

    \inferrule[\SymmetryRule]
    {
      \Property(x,y)
    }
    {
      \EquivalenceOf{\Property}(y,x)
    }
  \end{mathpar}
\end{definition}



\begin{definition}[Parallel Rewriting Without Reordering]\leavevmode
  \begin{mathpar}
    \inferrule[\AtomUnrollstarLeftRule{}]
    {
    }
    {
      \StarOf{\DNFRegex}\ParallelRewriteAtom
      \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}
      {(\ConcatDNFOf{\DNFRegex}{\DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}})}
    }
    
    \inferrule[\AtomUnrollstarRightRule{}]
    {
    }
    {
      \StarOf{\DNFRegex}\ParallelRewriteAtom
      \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}
      {(\ConcatDNFOf{\DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}}{\DNFRegex})}
    }

    \inferrule[\ParallelAtomStructuralRewriteRule{}]
    {
      \DNFRegex \ParallelRewrite \DNFRegex'
    }
    {
      \StarOf{\DNFRegex} \ParallelRewriteAtom \DNFOf{\SequenceOf{\StarOf{\DNFRegex'}}}
    }

    \inferrule[\ParallelDNFStructuralRewriteRule{}]
    {
      \DNFRegex = \DNFOf{\Sequence_1;\ldots;\Sequence_n}\\
      \forall i. \Sequence_i =
      \SequenceOf{\String_{i,0};\Atom_{i,1};\ldots;\Atom_{i,n_i};\String_{i,n_i}}\\
      \forall i,j. \Atom_{i,j} \ParallelRewriteAtom \DNFRegex_{i,j}\\
      \forall i. \DNFRegex_i = \DNFOf{\SequenceOf{\String_{i,0}}} \ConcatDNF \DNFRegex_{i,1}
      \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,n_i} \ConcatDNF
      \DNFOf{\SequenceOf{\String_{i,n_i}}}
    }
    {
      \DNFRegex \ParallelRewrite \DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n
    }

    \inferrule[\IdentityRewriteRule{}]
    {
    }
    {
      \DNFRegex \ParallelRewrite \DNFRegex
    }
  \end{mathpar}
\end{definition}

\begin{definition}[Parallel Rewriting With Reordering]\leavevmode
  \begin{mathpar}
    \inferrule[\AtomUnrollstarLeftRule{}]
    {
    }
    {
      \StarOf{\DNFRegex}\ParallelRewriteSwapAtom
      \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}
      {(\ConcatDNFOf{\DNFRegex}{\DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}})}
    }

    \inferrule[\AtomUnrollstarRightRule{n}]
    {
    }
    {
      \StarOf{\DNFRegex}\ParallelRewriteSwapAtom
      \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}
      {(\ConcatDNFOf{\DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}}{\DNFRegex})}
    }

    \inferrule[\ParallelSwapAtomStructuralRewriteRule{}]
    {
      \DNFRegex \ParallelRewriteSwap \DNFRegex'
    }
    {
      \StarOf{\DNFRegex} \ParallelRewriteSwapAtom \DNFOf{\SequenceOf{\StarOf{\DNFRegex'}}}
    }

    \inferrule[\DNFReorderRule{}]
    {
      \sigma\in\PermutationSetOf{n}
    }
    {
      \DNFOf{\Sequence_1;\ldots;\Sequence_n}
      \ParallelRewriteSwap
      \DNFOf{\Sequence_{\sigma(1)};\ldots;\Sequence_{\sigma(n)}}
    }

    \inferrule[\ParallelSwapDNFStructuralRewriteRule{}]
    {
      \DNFRegex = \DNFOf{\Sequence_1;\ldots;\Sequence_n}\\
      \forall i. \Sequence_i =
      \SequenceOf{\String_{i,0};\Atom_{i,1};\ldots;\Atom_{i,n_i};\String_{i,n_i}}\\
      \forall i,j. \Atom_{i,j} \ParallelRewriteSwapAtom \DNFRegex_{i,j}\\
      \forall i. \DNFRegex_i = \DNFOf{\SequenceOf{\String_{i,0}}} \ConcatDNF \DNFRegex_{i,1}
      \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,n_i} \ConcatDNF
      \DNFOf{\SequenceOf{\String_{i,n_i}}}
    }
    {
      \DNFRegex \ParallelRewriteSwap \DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n
    }

    \inferrule[\IdentityRewriteRule{}]
    {
    }
    {
      \DNFRegex \ParallelRewriteSwap \DNFRegex
    }
  \end{mathpar}
\end{definition}

\begin{lemma}[$\ParallelRewrite$ Maintained Under Iteration]
  \label{lem:parallel-rewrite-iteration}
  Let $\DNFRegex \ParallelRewrite \DNFRegexAlt$, then
  $\DNFOf{\SequenceOf{\StarOf{\DNFRegex}}} \ParallelRewrite
  \DNFOf{\SequenceOf{\StarOf{\DNFRegexAlt}}}$.
\end{lemma}
\begin{proof}
  Consider the derivation

  \[
    \inferrule*
    {
      \inferrule*
      {
        \DNFRegex \ParallelRewrite \DNFRegexAlt
      }
      {
        \StarOf{\DNFRegex} \ParallelRewriteAtom
        \DNFOf{\SequenceOf{\StarOf{\DNFRegexAlt}}}
      }
    }
    {
      \DNFOf{\SequenceOf{\StarOf{\DNFRegex}}} \ParallelRewrite
      \DNFOf{\SequenceOf{\StarOf{\DNFRegexAlt}}}
    }
  \]
\end{proof}

\begin{lemma}
  \label{lem:final-identity-can-be-ignored}
  If $\DNFRegex \ParallelRewrite \DNFRegex$ through an application of
  \IdentityRewriteRule{}, then $\DNFRegex \ParallelRewrite \DNFRegex$ through an
  application of \ParallelDNFStructuralRewriteRule{}.
\end{lemma}
\begin{proof}
  Let $\DNFRegex \ParallelRewrite \DNFRegex$ through an application of
  \IdentityRewriteRule{}.

  Let $\DNFRegex = \DNFOf{\Sequence_1;\ldots;\Sequence_n}$.
  Let $\Sequence_i =
  \SequenceOf{\String_{i,0};\Atom_{i,1};\ldots;\Atom_{i,n_i};\String_{i,n_i}}$.
  By Lemma~\ref{lem:identity-atom-in-parallel},
  $\Atom_{i,j} \ParallelRewriteAtom \AtomToDNFOf{\Atom_{i,j}}$.
  Define $\DNFRegex_{i,j}$ as $\AtomToDNFOf{\DNFRegex_{i,j}}$
  
  Define $\DNFRegex_i$ as
  $\DNFOf{\SequenceOf{\String_{i,0}}} \ConcatDNF \DNFRegex_{i,1}
  \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,n_i} \ConcatDNF
  \DNFOf{\SequenceOf{\String_{i,n_i}}}$,
  so as $\DNFRegex_{i,j} = \AtomToDNFOf{\Atom_{i,j}}$, through the definition
  of $\ConcatDNF$, $DNFRegex_i = \DNFOf{\Sequence_i}$.
  
  By the definition of $\OrDNF$,
  $\DNFOf{\Sequence_1} \OrDNF \ldots \OrDNF \DNFOf{\Sequence_n} =
  \DNFOf{\Sequence_1;\ldots;\Sequence_n} = \DNFRegex$.

  \[
    \inferrule*
    {
      \DNFRegex = \DNFOf{\Sequence_1;\ldots;\Sequence_n}\\
      \forall i. \Sequence_i =
      \SequenceOf{\String_{i,0};\Atom_{i,1};\ldots;\Atom_{i,n_i};\String_{i,n_i}}\\
      \forall i,j. \Atom_{i,j} \ParallelRewriteAtom \DNFRegex_{i,j}\\
      \forall i. \DNFRegex_i = \DNFOf{\SequenceOf{\String_{i,0}}} \ConcatDNF \DNFRegex_{i,1}
      \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,n_i} \ConcatDNF
      \DNFOf{\SequenceOf{\String_{i,n_i}}}
    }
    {
      \DNFRegex \ParallelRewrite \DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n
    }
  \]

  So $\DNFRegex \ParallelRewrite \DNFRegex$, with the final rule being an
  application of \IdentityRewriteRule{}.
\end{proof}

\begin{lemma}[$\ParallelRewrite$ Maintained Under $\ConcatDNF$ up to
  $\IdentityLens$]
  \label{lem:parallel-rewrite-concatenation-to-identity}
  Let $\DNFRegex$ be strongly unambiguous.  Let $\DNFRegexAlt$ be strongly
  unambiguous.
  Let $\UnambigConcatOf{\LanguageOf{\DNFRegex}}{\LanguageOf{\DNFRegexAlt}}$.
  If $\DNFRegex \StarOf{\ParallelRewrite} \DNFRegex'$,
  $\DNFRegexAlt \StarOf{\ParallelRewrite} \DNFRegexAlt'$, and
  $\DNFRegex \ConcatDNF \DNFRegexAlt \StarOf{\ParallelRewrite} \DNFRegex''$
  such that there exists a rewriteless DNF lens
  $\DNFLens \OfRewritelessType
  \DNFRegex' \ConcatDNF \DNFRegexAlt' \Leftrightarrow \DNFRegex''$, and
  $\SemanticsOf{\DNFLens} =
  \SetOf{(\String,\String) \SuchThat \String \in
    \LanguageOf{\DNFRegex \ConcatDNF \DNFRegexAlt}}$.
\end{lemma}
\begin{proof}
  Because $\UnambigConcatOf{\LanguageOf{\DNFRegex}}{\LanguageOf{\DNFRegexAlt}}$,
  $\DNFRegex \ConcatDNF \DNFRegexAlt$ is strongly unambiguous.

  By induction on the derivation of $\StarOf{\ParallelRewrite}$
  \[
    \inferrule*
    {
      \DNFRegex = \DNFOf{\Sequence_1;\ldots;\Sequence_n}\\
      \forall i. \Sequence_i =
      \SequenceOf{\String_{i,0};\Atom_{i,1};\ldots;\Atom_{i,n_i};\String_{i,n_i}}\\
      \forall i,j. \Atom_{i,j} \ParallelRewriteAtom \DNFRegex_{i,j}\\
      \forall i. \DNFRegex_i = \DNFOf{\SequenceOf{\String_{i,0}}} \ConcatDNF \DNFRegex_{i,1}
      \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,n_i} \ConcatDNF
      \DNFOf{\SequenceOf{\String_{i,n_i}}}
    }
    {
      \DNFRegex \ParallelRewrite \DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n
    }
  \]

  \[
    \inferrule*
    {
      \DNFRegexAlt = \DNFOf{\SequenceAlt_1;\ldots;\Sequence_m}\\
      \forall i. \SequenceAlt_i =
      \SequenceOf{\StringAlt_{i,0};\AtomAlt_{i,1};\ldots;\AtomAlt_{i,m_i};\StringAlt_{i,m_i}}\\
      \forall i,j. \AtomAlt_{i,j} \ParallelRewriteAtom \DNFRegexAlt_{i,j}\\
      \forall i. \DNFRegexAlt_i = \DNFOf{\SequenceOf{\StringAlt_{i,0}}} \ConcatDNF \DNFRegexAlt_{i,1}
      \ConcatDNF \ldots \ConcatDNF \DNFRegexAlt_{i,n_i} \ConcatDNF
      \DNFOf{\SequenceOf{\StringAlt_{i,n_i}}}
    }
    {
      \DNFRegexAlt \ParallelRewrite \DNFRegexAlt_1 \OrDNF \ldots \OrDNF \DNFRegexAlt_n
    }
  \]

  Define $\Atom_{i,j,k}'' =
  \begin{cases*}
    \Atom_{i,k} & if $k \leq n_i$\\
    \AtomAlt_{j,k-n_i} & if $i > n_i$
  \end{cases*}$

  Define $\String_{i,j,k}'' =
  \begin{cases*}
    \String_{i,k} & if $k < n_i$\\
    \String_{i,n_i} \Concat \StringAlt_{j,0} & if $k = n_i$\\
    \StringAlt_{j,k-n_i} & if $i > n$
  \end{cases*}$

  Define $n_{i,j} = n_i + m_j$.

  Define $\Sequence_{i,j}'' =
  \SequenceOf{\String_{i,j,0}'';\Atom_{i,j,1}'';\ldots;
    \Atom_{i,j,n_{i,j}}'';\String_{i,j,n_{i,j}}''}$.
  By inspection,
  $\Sequence_{i,j}'' = \Sequence_i \ConcatSequence \Sequence_j$.
  
  Define $\DNFRegex'' = \DNFOf{\Sequence_{1,1}'';\ldots;\Sequence_{n,m}''}$.
  By inspection, $\DNFRegex'' = \DNFRegex \ConcatDNF \DNFRegexAlt$.

  Define $\DNFRegex_{i,j,k}'' =
  \begin{cases*}
    \DNFRegex_{i,k} & if $k \leq n_i$\\
    \DNFRegexAlt_{j,k-n_i} & if $i > n_i$
  \end{cases*}$.
  By inspection $\Atom_{i,j,k}'' \ParallelRewrite \DNFRegex_{i,j,k}''$.

  Define $\DNFRegex_{i,j}''$ as
  $\DNFOf{\SequenceOf{\String_{i,j,0}''}} \ConcatDNF \DNFRegex_{i,j,1}''
  \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,j,n_{i,j}} \ConcatDNF
  \DNFOf{\SequenceOf{\String_{i,j,n_{i,j}}}}$.
  By inspection, $\DNFRegex_{i,j}'' = \DNFRegex_i \ConcatDNF \DNFRegex_j$
  This means that
  $\DNFRegex_{1,1}'' \OrDNF \ldots \OrDNF \DNFRegex_{1,m}''
  \OrDNF \ldots \OrDNF
  \DNFRegex_{n,1}'' \OrDNF \ldots \OrDNF \DNFRegex_{n,m}'' =
  (\DNFRegex_1 \ConcatDNF \DNFRegexAlt_1) \OrDNF \ldots \OrDNF
  (\DNFRegex_1 \ConcatDNF \DNFRegexAlt_m) \OrDNF \ldots \OrDNF
  (\DNFRegex_n \ConcatDNF \DNFRegexAlt_1) \OrDNF \ldots \OrDNF
  (\DNFRegex_n \ConcatDNF \DNFRegexAlt_m)$
  By repeated application of Lemma~\ref{lem:id-expressible-on-factor-left}
  and Lemma~\ref{lem:id-expressible-on-factor-right}, there
  exists a DNF lens $\DNFLens \OfRewritelessType
  \DNFRegex_{1,1}'' \OrDNF \ldots \OrDNF \DNFRegex_{n,m}'' \Leftrightarrow
  (\DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n) \ConcatDNF
  (\DNFRegexAlt_1 \OrDNF \ldots \OrDNF \DNFRegexAlt_m)$, so
  $\DNFLens \OfRewritelessType
  \DNFRegex_{1,1}'' \OrDNF \ldots \OrDNF \DNFRegex_{n,m}'' \Leftrightarrow
  DNFRegex' \ConcatDNF DNFRegexAlt'$.

  Consider the derivation 
  \[
    \inferrule*
    {
      \DNFRegex'' = \DNFOf{\Sequence_{1,1}'';\ldots;\Sequence_{n,m}''}\\
      \forall i,j. \Sequence_{i,j}'' =
      \SequenceOf{\String_{i,j,0}'';\Atom_{i,j,1}'';\ldots;\Atom_{i,j,n_{i,j}}'';\String_{i,j,n_{i,j}}''}\\
      \forall i,j. \Atom_{i,j}'' \ParallelRewriteAtom \DNFRegex_{i,j}''\\
      \forall i,j. \DNFRegex_{i,j}'' = \DNFOf{\SequenceOf{\String_{i,j,0}''}} \ConcatDNF \DNFRegex_{i,j,1}''
      \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,j,n_{i,j}}'' \ConcatDNF
      \DNFOf{\SequenceOf{\String_{i,j,n_{i,j}}''}}
    }
    {
      \DNFRegex'' \ParallelRewrite
      \DNFRegex_{1,1}'' \OrDNF \ldots \OrDNF \DNFRegex_{n,m}''
    }
  \]

  $\DNFRegex \ConcatDNF \DNFRegexAlt \ParallelRewrite
  \DNFRegex_{1,1}'' \OrDNF \ldots \OrDNF \DNFRegex_{n,m}''$,
  $\DNFRegex_{1,1}'' \OrDNF \ldots \OrDNF \DNFRegex_{n,m}''$
  
  If $\DNFRegex \ParallelRewrite \DNFRegex'$ and
  $\DNFRegexAlt \ParallelRewrite \DNFRegexAlt'$, then
  $\DNFRegex \ConcatDNF \DNFRegex \ParallelRewrite \DNFRegex''$ such that there
  exists a rewriteless DNF lens
  $\DNFLens \OfRewritelessType
  \DNFRegex \ConcatDNF \DNFRegexAlt \Leftrightarrow \DNFRegex''$, and
  $\SemanticsOf{\DNFLens} =
  \SetOf{(\String,\String) \SuchThat \String \in
    \LanguageOf{\DNFRegex \ConcatDNF \DNFRegexAlt}}$,
  as desired.
\end{proof}

\begin{lemma}[$\ParallelRewrite$ Maintained Under $\OrDNF$]
  \label{lem:parallel-rewrite-or}
  Let $\DNFRegex \ParallelRewrite \DNFRegex'$ and $\DNFRegexAlt
  \ParallelRewrite \DNFRegexAlt'$ then
  $\DNFRegex \OrDNF \DNFRegexAlt \ParallelRewrite
  \DNFRegex' \OrDNF \DNFRegexAlt'$.
\end{lemma}
\begin{proof}
  By Lemma~\ref{lem:final-identity-can-be-ignored}, a derivation with the final
  rule being an application of \IdentityRewriteRule{}, can be converted into a
  derivation with the final rule being an application of
  \ParallelDNFStructuralRewriteRule{}.  So we can assume that the final rule of
  each is an application of \ParallelDNFStructuralRewriteRule{}.

  \[
    \inferrule*
    {
      \DNFRegex = \DNFOf{\Sequence_1;\ldots;\Sequence_n}\\
      \forall i. \Sequence_i =
      \SequenceOf{\String_{i,0};\Atom_{i,1};\ldots;\Atom_{i,n_i};\String_{i,n_i}}\\
      \forall i,j. \Atom_{i,j} \ParallelRewriteAtom \DNFRegex_{i,j}\\
      \forall i. \DNFRegex_i = \DNFOf{\SequenceOf{\String_{i,0}}} \ConcatDNF \DNFRegex_{i,1}
      \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,n_i} \ConcatDNF
      \DNFOf{\SequenceOf{\String_{i,n_i}}}
    }
    {
      \DNFRegex \ParallelRewrite \DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n
    }
  \]

  \[
    \inferrule*
    {
      \DNFRegexAlt = \DNFOf{\SequenceAlt_1;\ldots;\Sequence_m}\\
      \forall i. \SequenceAlt_i =
      \SequenceOf{\StringAlt_{i,0};\AtomAlt_{i,1};\ldots;\AtomAlt_{i,m_i};\StringAlt_{i,m_i}}\\
      \forall i,j. \AtomAlt_{i,j} \ParallelRewriteAtom \DNFRegexAlt_{i,j}\\
      \forall i. \DNFRegexAlt_i = \DNFOf{\SequenceOf{\StringAlt_{i,0}}} \ConcatDNF \DNFRegexAlt_{i,1}
      \ConcatDNF \ldots \ConcatDNF \DNFRegexAlt_{i,n_i} \ConcatDNF
      \DNFOf{\SequenceOf{\StringAlt_{i,n_i}}}
    }
    {
      \DNFRegexAlt \ParallelRewrite \DNFRegexAlt_1 \OrDNF \ldots \OrDNF \DNFRegexAlt_n
    }
  \]

  Define $\Atom_{i,j}'' =
  \begin{cases*}
    \Atom_{i,j} & if $i \leq n$\\
    \AtomAlt_{i-n,j} & if $i > n$
  \end{cases*}$

  Define $\String_{i,j}'' =
  \begin{cases*}
    \String_{i,j} & if $i \leq n$\\
    \StringAlt_{i-n,j} & if $i > n$
  \end{cases*}$

  Define $n_i'' =
  \begin{cases*}
    n_i & if $i \leq n$\\
    m_{i-n} & if $i > n$
  \end{cases*}$

  Define $\Sequence_{i}'' =
  \SequenceOf{\String_{i,0}'';\Atom_{i,1}'';\ldots;
    \Atom_{i,n_i''}'';\String_{i,n_i''}''}$.
  By inspection, $\Sequence_i'' =
  \begin{cases*}
    \Sequence_i & if $i \leq n$\\
    \SequenceAlt_{i-n} & if $i > n$
  \end{cases*}$.
  
  Define $\DNFRegex'' = \DNFOf{\Sequence_1'';\ldots;\Sequence_{n+m}''}$.
  By inspection, $\DNFRegex'' = \DNFRegex \OrDNF \DNFRegexAlt$.

  Define $\DNFRegex_{i,j}'' =
  \begin{cases*}
    \DNFRegex_{i,j} & if $i \leq n$\\
    \DNFRegexAlt_{i-n,j} & if $i > n$
  \end{cases*}$.  By inspection $\Atom_{i,j}'' \ParallelRewrite \DNFRegex_{i,j}''$.

  Define $\DNFRegex_i''$ as
  $\DNFOf{\SequenceOf{\String_{i,0}''}} \ConcatDNF \DNFRegex_{i,1}''
  \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,n_i''}'' \ConcatDNF
  \DNFOf{\SequenceOf{\String_{i,n_i''}''}}$.
  By inspection, $\DNFRegex_i'' =
  \begin{cases*}
    \DNFRegex_i & if $i \leq n$\\
    \DNFRegexAlt_{i-n} & if $i > n$
  \end{cases*}$.
  This means that
  $\DNFRegex_1'' \OrDNF \ldots \OrDNF \DNFRegex_{n+m}'' =
  (\DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n \OrDNF
  \DNFRegexAlt_1 \OrDNF \ldots \OrDNF \DNFRegexAlt_m) =
  \DNFRegex' \OrDNF \DNFRegexAlt'$.

  Consider the derivation 
  \[
    \inferrule*
    {
      \DNFRegex'' = \DNFOf{\Sequence_1'';\ldots;\Sequence_{n+m}''}\\
      \forall i. \Sequence_i'' =
      \SequenceOf{\String_{i,0}'';\Atom_{i,1}'';\ldots;\Atom_{i,n_i''}'';\String_{i,n_i''}''}\\
      \forall i,j. \Atom_{i,j}'' \ParallelRewriteAtom \DNFRegex_{i,j}''\\
      \forall i. \DNFRegex_i'' = \DNFOf{\SequenceOf{\String_{i,0}''}} \ConcatDNF \DNFRegex_{i,1}''
      \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,n_i}'' \ConcatDNF
      \DNFOf{\SequenceOf{\String_{i,n_i''}''}}
    }
    {
      \DNFRegex'' \ParallelRewrite
      \DNFRegex_1'' \OrDNF \ldots \OrDNF \DNFRegex_{n+m}''
    }
  \]
\end{proof}

\begin{lemma}[$\StarOf{\ParallelRewrite}$ Maintained Under Iteration]
  \label{lem:star-parallel-rewrite-iteration}
  Let $\DNFRegex \StarOf{\ParallelRewrite} \DNFRegexAlt$, then
  $\AtomToDNFOf{\StarOf{\DNFRegex}} \StarOf{\ParallelRewrite}
  \AtomToDNFOf{\StarOf{\DNFRegexAlt}}$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\StarOf{ParallelRewrite}$.

  \begin{case}[\ReflexivityRule{}]
    \[
      \inferrule*
      {
      }
      {
        \DNFRegex \StarOf{\ParallelRewrite} \DNFRegex
      }
    \]

    By reflexivity rule

    \[
      \inferrule*
      {
      }
      {
        \AtomToDNFOf{\StarOf{\DNFRegex}} \StarOf{\ParallelRewrite}
        \AtomToDNFOf{\StarOf{\DNFRegex}}
      }
    \]
  \end{case}

  \begin{case}[\BaseRule{}]
    \[
      \inferrule*
      {
        \DNFRegex \ParallelRewrite \DNFRegexAlt
      }
      {
        \DNFRegex \StarOf{\ParallelRewrite} \DNFRegexAlt
      }
    \]

    By Lemma~\ref{lem:parallel-rewrite-iteration},
    $\AtomToDNFOf{\StarOf{\DNFRegex}} \ParallelRewrite
    \AtomToDNFOf{\StarOf{\DNFRegexAlt}}$

    Consider the derivation
    \[
      \inferrule*
      {
        \AtomToDNFOf{\StarOf{\DNFRegex}} \ParallelRewrite
        \AtomToDNFOf{\StarOf{\DNFRegexAlt}}
      }
      {
        \AtomToDNFOf{\StarOf{\DNFRegex}} \StarOf{\ParallelRewrite}
        \AtomToDNFOf{\StarOf{\DNFRegexAlt}}
      }
    \]
  \end{case}

  \begin{case}[\TransitivityRule{}]
    \[
      \inferrule*
      {
        \DNFRegex \StarOf{\ParallelRewrite} \DNFRegex'\\
        \DNFRegex' \StarOf{\ParallelRewrite} \DNFRegexAlt
      }
      {
        \DNFRegex \StarOf{\ParallelRewrite} \DNFRegexAlt
      }
    \]

    By IH, $\AtomToDNFOf{\StarOf{\DNFRegex}} \StarOf{\ParallelRewrite}
    \AtomToDNFOf{\StarOf{\DNFRegex'}}$ and
    $\AtomToDNFOf{\StarOf{\DNFRegex'}} \StarOf{\ParallelRewrite}
    \AtomToDNFOf{\StarOf{\DNFRegexAlt}}$.
  \end{case}
\end{proof}

\begin{lemma}[Equivalence of $\ToRegex \Compose \ToDNFRegex$]
  \label{lem:there-and-back-equiv}
  $(\ToRegex \Compose \ToDNFRegex) \Regex \DefinitionalEquiv \Regex$
\end{lemma}
\begin{proof}
  By induction on the structure of $\Regex$
  \begin{case}[\BaseRegexType{}]
    $(\ToRegex \Compose \ToDNFRegex)\String =
    \ToRegexOf{\DNFOf{\SequenceOf{\String}}} = \emptyset \Or \String$
    $\emptyset \Or \String \DefinitionalEquiv \String$.
  \end{case}

  \begin{case}[\EmptyRegexType{}]
    $(\ToRegex \Compose \ToDNFRegex)\emptyset =
    \ToRegexOf{\DNFOf{}} = \emptyset$
    $\emptyset \DefinitionalEquiv \emptyset$.
  \end{case}

  \begin{case}[\StarRegexType{}]
    $(\ToRegex \Compose \ToDNFRegex)\StarOf{\Regex'} =
    \ToRegexOf{\DNFOf{\SequenceOf{\EmptyString;\StarOf{(\ToDNFRegexOf{\Regex'})};\EmptyString}}}
    = \emptyset \Or (\EmptyString \Concat \StarOf{((\ToRegex \Compose \ToDNFRegex)\Regex')}
    \Concat \EmptyString)$
    Then, through application of equational theory transitivity,
    \OrIdentityRule{}, \ConcatIdentityLeftRule{}, and \ConcatIdentityRightRule{},
    We get $(\ToRegex \Compose \ToDNFRegex)\StarOf{\Regex'} \DefinitionalEquiv
    \StarOf{((\ToRegex \Compose \ToDNFRegex)\Regex')}$.
    By application of the IH, and transitivity, we get
    $(\ToRegex \Compose \ToDNFRegex)\StarOf{\Regex'} \DefinitionalEquiv
    \StarOf{\Regex'}$
  \end{case}

  \begin{case}[\ConcatRegexType{}]
    Let $(\ToRegex \Compose \ToDNFRegex)(\Regex_1 \Concat \Regex_2) =
    \ToRegexOf{(\ToDNFRegexOf{\Regex_1} \ConcatDNF \ToDNFRegexOf{\Regex_2})}$.
    Let $\ToDNFRegexOf{\Regex_1} = \DNFOf{\Sequence_1;\ldots;\Sequence_n}$ and
    $\ToDNFRegexOf{\Regex_2} = \DNFOf{\SequenceAlt_1;\ldots;\Sequence_m}$.

    $\Regex_1 \DefinitionalEquiv (\ToRegex \Compose \ToDNFRegex)(\Regex_1) =
    (\emptyset \Or (\ToRegexOf{\Sequence_1} \Or (\ldots \Or
    (\ToRegexOf{\Sequence_n})\ldots))) \DefinitionalEquiv
    \ToRegexOf{\Sequence_1} \Or \ldots \Or \ToRegexOf{\Sequence_n}$
    and
    $\Regex_2 \DefinitionalEquiv (\ToRegex \Compose \ToDNFRegex)(\Regex_2) =
    (\emptyset \Or (\ToRegexOf{\SequenceAlt_1} \Or (\ldots \Or
    (\ToRegexOf{\SequenceAlt_m})\ldots))) \DefinitionalEquiv
    \ToRegexOf{\SequenceAlt_1} \Or \ldots \Or \ToRegexOf{\SequenceAlt_m}$.

    So by structural \ConcatRegexType{} identity, and transitivity,
    $\Regex_1 \Concat \Regex_2 \DefinitionalEquiv
    (\ToRegexOf{\Sequence_1} \Or \ldots \Or \ToRegexOf{\Sequence_n})
    \Concat
    (\ToRegexOf{\SequenceAlt_1} \Or \ldots \Or \ToRegexOf{\SequenceAlt_m})$.

    Through repeated application of \DistributivityLeftRule{} and
    \DistributivityRightRule{},
    $\Regex_1 \Concat \Regex_2 \DefinitionalEquiv
    (\ToRegexOf{\Sequence_1}\Concat\ToRegexOf{\SequenceAlt_1} \Or \ldots \Or
    \ToRegexOf{\Sequence_n}\Concat\ToRegexOf{\SequenceAlt_m})$.

    Now, I want to show $\ToRegexOf{\Sequence_i} \Concat \ToRegexOf{\SequenceAlt_j}
    \DefinitionalEquiv \ToRegexOf{(\Sequence_i \ConcatDNF \SequenceAlt_j)}$.
    Let $\Sequence_i =
    \SequenceOf{\String_{i,0};\Atom_{i,1};\ldots;\Atom_{i,n_i};\String_{i,n_i}}$,
    and $\SequenceAlt_j =
    \SequenceOf{\StringAlt_{j,0};\AtomAlt_{j,1};\ldots;\Atom_{j,m_j};\String_{j,n_j}}$.
    $\ToRegexOf{(\Sequence_i \ConcatDNF \Sequence_j)} =
    \ToRegexOf{\SequenceOf{\String_{i,0};\Atom_{i,1};\ldots;
        \Atom_{i,n_i};\String_{i,n_i}\Concat\StringAlt_{j,0};\AtomAlt_{j,1};
        \ldots;\Atom_{j,m_j};\String_{j,n_j}}} =
    \String_{i,0} \Concat (\Atom_{i,1} \Concat (\ldots \Concat \String_{i,n_i}
    \Concat \StringAlt_{j,0} \Concat (\AtomAlt_{j,1} \Concat (\ldots \Concat
    (\Atom_{j,n_j} \Concat \String_{j,n_j})\ldots))\ldots))$
    So through repeated application of \ConcatAssocRule{},
    $\ToRegexOf{(\Sequence_i \ConcatDNF \Sequence_j)} \DefinitionalEquiv
    (\String_{i,0} \Concat (\Atom_{i,1} \Concat (\ldots \Concat (\Atom_{i,n_i}
    \Concat \String_{i,n_i})\ldots))) \Concat (\StringAlt_{j,0} \Concat
    (\AtomAlt_{j,1} \Concat (\ldots \Concat (\AtomAlt_{j,n_j} \Concat
    \String_{j,n_j})\ldots)))$.

    Because of this 
    $\Regex_1 \Concat \Regex_2 \DefinitionalEquiv
    \ToRegexOf{(\Sequence_1\ConcatDNF\SequenceAlt_1)} \Or \ldots \Or
    \ToRegexOf{(\Sequence_n\ConcatDNF\SequenceAlt_n)}$.
    Through repeated application of \OrAssociativityRule{}, and \OrIdentityRule{},
    $\Regex_1 \Concat \Regex_2 \DefinitionalEquiv
    \emptyset \Or (\ToRegexOf{(\Sequence_1\ConcatDNF\SequenceAlt_1)} \Or \ldots
    (\ToRegexOf{(\Sequence_n\ConcatDNF\SequenceAlt_m)})\ldots)$.
    Furthermore, $\emptyset \Or (\ToRegexOf{(\Sequence_1\ConcatDNF\SequenceAlt_1)} \Or \ldots
    (\ToRegexOf{(\Sequence_n\ConcatDNF\SequenceAlt_m)})\ldots) =
    \ToRegexOf{\DNFOf{\Sequence_1\ConcatSequence\SequenceAlt_1;\ldots;
        \Sequence_n\Concat\SequenceAlt_m}} =
    (\ToRegex \Compose \ToDNFRegex)(\Regex_1 \Concat \Regex_2)$ as desired.
  \end{case}

  \begin{case}[\OrRegexType{}]
    Let $(\ToRegex \Compose \ToDNFRegex)(\Regex_1 \Or \Regex_2) =
    \ToRegexOf{(\ToDNFRegexOf{\Regex_1} \OrDNF \ToDNFRegexOf{\Regex_2})}$.
    Let $\ToDNFRegexOf{\Regex_1} = \DNFOf{\Sequence_1;\ldots;\Sequence_n}$ and
    $\ToDNFRegexOf{\Regex_2} = \DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_m}$.
    So
    $(\ToRegex \Compose \ToDNFRegex)(\Regex_1 \Or \Regex_2) =
    \ToRegexOf{\DNFOf{\Sequence_1;\ldots;\Sequence_n;
        \SequenceAlt_1;\ldots;\SequenceAlt_m}} =
    \emptyset \Or (\ToRegexOf{\Sequence_1} \Or (
    \ldots \Or (\ToRegexOf{\SequenceAlt_m})\ldots))$.
    Through applying associativity a lot, and \OrIdentityRule{} once, I get
    $(\ToRegex \Compose \ToDNFRegex)(\Regex_1 \Or \Regex_2) =
    (\emptyset \Or (\ToRegexOf{\Sequence_1} \Or (\ldots \Or
    (\ToRegexOf{\Sequence_n})\ldots)))
    \Or
    (\emptyset \Or (\ToRegexOf{\SequenceAlt_1} \Or (\ldots \Or
    (\ToRegexOf{\SequenceAlt_m})\ldots)))$.

    $(\ToRegex \Compose \ToDNFRegex)(\Regex_1 \Or \Regex_2) =
    (\emptyset \Or (\ToRegexOf{\Sequence_1} \Or (\ldots \Or
    (\ToRegexOf{\Sequence_n})\ldots))) =
    (\ToRegex \Compose \ToDNFRegex)\Regex_1$
    and $(\emptyset \Or (\ToRegexOf{\SequenceAlt_1} \Or (\ldots \Or
    (\ToRegexOf{\SequenceAlt_m})\ldots))) =
    (\ToRegex \Compose \ToDNFRegex)\Regex_2$, so by IH
    $(\ToRegex \Compose \ToDNFRegex)(\Regex_1 \Or \Regex_2) =
    (\emptyset \Or (\ToRegexOf{\Sequence_1} \Or (\ldots \Or
    (\ToRegexOf{\Sequence_n})\ldots))) \DefinitionalEquiv
    \Regex_1$
    and $(\emptyset \Or (\ToRegexOf{\SequenceAlt_1} \Or (\ldots \Or
    (\ToRegexOf{\SequenceAlt_m})\ldots))) \DefinitionalEquiv
    \Regex_2$.

    Through an application of structural \OrRegexType{} equality,
    $(\emptyset \Or (\ToRegexOf{\Sequence_1} \Or (\ldots \Or
    (\ToRegexOf{\Sequence_n})\ldots)))
    \Or
    (\emptyset \Or (\ToRegexOf{\SequenceAlt_1} \Or (\ldots \Or
    (\ToRegexOf{\SequenceAlt_m})\ldots))) \DefinitionalEquiv
    \Regex_1 \Or \Regex_2$, as desired.
  \end{case}
\end{proof}

\begin{lemma}[Equivalence of Preimage of $\ToDNFRegex$]
  \label{lem:preimage-equiv}
  If $\ToDNFRegexOf{\Regex} = \ToDNFRegexOf{\RegexAlt}$, then $\Regex
  \DefinitionalEquiv \RegexAlt$.
\end{lemma}
\begin{proof}
  $\ToDNFRegexOf{\Regex} = \ToDNFRegexOf{\RegexAlt}$, so $(\ToRegex \Compose
  \ToDNFRegex) \Regex = (\ToRegex \Compose \ToDNFRegex) \RegexAlt$.
  By Lemma~\ref{lem:there-and-back-equiv},
  $\Regex \DefinitionalEquiv (\ToRegex \Compose \ToDNFRegex) \RegexAlt
  \DefinitionalEquiv \RegexAlt$
\end{proof}

\begin{lemma}[Equivalence of Adjacent Swapping Permutation of \OrRegexType{}]
  \label{lem:adj-swap-or}
  Let $\Regex_1 \Or \ldots \Or \Regex_n$.  Let $\sigma_i$ be an adjacent
  swapping permutation.  $\Regex_1 \Or \ldots \Or \Regex_n \DefinitionalEquiv
  \Regex_{\sigma_i(1)} \Or \ldots \Or \Regex_{\sigma_i(n)}$.
\end{lemma}
\begin{proof}
  $\Regex_1 \Or \ldots \Or \Regex_n \DefinitionalEquiv (\Regex_1 \Or \ldots \Or
  \Regex_{i-1}) \Or (\Regex_{i} \Or \Regex_{i+1}) \Or (\Regex_{i+2} \Or \ldots
  \Or \Regex_n)$ by repeated application of associativity.
  
  $\Regex_i \Or \Regex_{i+1} = \Regex_{i+1} \Or \Regex_{i}$ by \OrRegexType
  commutativity, so by \OrRegexType{} structural equality,
  $(\Regex_1 \Or \ldots \Or
  \Regex_{i-1}) \Or (\Regex_{i} \Or \Regex_{i+1}) \Or (\Regex_{i+2} \Or \ldots
  \Or \Regex_n) \DefinitionalEquiv
  (\Regex_1 \Or \ldots \Or
  \Regex_{i-1}) \Or (\Regex_{i+1} \Or \Regex_{i}) \Or (\Regex_{i+2} \Or \ldots
  \Or \Regex_n)$
  
  $(\Regex_1 \Or \ldots \Or
  \Regex_{i-1}) \Or (\Regex_{i+1} \Or \Regex_{i}) \Or (\Regex_{i+2} \Or \ldots
  \Or \Regex_n) \DefinitionalEquiv
  \Regex_{\sigma_i(1)} \Or \ldots \Or \Regex_{\sigma_i(n)}$ by repeated
  application of associativity.
  
  So, by the transitivity of equational theories,
  $\Regex_1 \Or \ldots \Or \Regex_n \DefinitionalEquiv
  \Regex_{\sigma_i(1)} \Or \ldots \Or \Regex_{\sigma_i(n)}$.
\end{proof}

\begin{lemma}[Expressibility of $\ParallelRewriteSwap$ in $\DefinitionalEquiv$
  Up To Preimage]
  \label{lem:express-swap-in-equiv}
  \leavevmode
  \begin{enumerate}
  \item If $\ToDNFRegexOf{\Regex} \ParallelRewriteSwap \ToDNFRegexOf{\RegexAlt}$, then
    $\Regex \DefinitionalEquiv \RegexAlt$.
  \item If $\ToDNFRegexOf{\Regex} = \DNFOf{\SequenceOf{\Atom}}$ and
    $\Atom \ParallelRewriteSwapAtom \ToDNFRegexOf{\RegexAlt}$ then
    $\Regex \DefinitionalEquiv \RegexAlt$.
  \end{enumerate}
\end{lemma}
\begin{proof}By mutual induction on the derivation of $\ParallelRewriteSwap$ and
  $\ParallelRewriteSwapAtom$.
  \begin{case}[\AtomUnrollstarLeftRule{}]
    Let $\ToDNFRegexOf{\Regex} = \DNFOf{\SequenceOf{\Atom}}$, and
    $\Atom \ParallelRewriteSwapAtom \ToDNFRegexOf{\RegexAlt}$ from
    \AtomUnrollstarLeftRule{}.
    This means that $\Atom = \StarOf{\DNFRegex}$ and
    $\ToDNFRegexOf{\RegexAlt} = \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}
    {(\ConcatDNFOf{\DNFRegex}{\DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}})}$.

    Let $\Regex' = \ToRegexOf{\DNFRegex}$.
    As $\ToDNFRegexOf{\StarOf{\Regex'}} =
    \DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}$, then from
    Lemma~\ref{lem:preimage-equiv}, $\StarOf{\Regex'}
    \DefinitionalEquiv \Regex$.
    Similarly, as $\ToDNFRegexOf{(\EmptyString \Or
      (\Regex'\Concat\StarOf{\Regex'}))} =
    \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}
    {(\ConcatDNFOf{\DNFRegex}{\DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}})}$,
    then from
    Lemma~\ref{lem:preimage-equiv}, $\EmptyString \Or
    (\Regex'\Concat\StarOf{\Regex'}) \DefinitionalEquiv \RegexAlt$.

    So, through an application of UnrollstarLeftRule{},
    $\Regex \DefinitionalEquiv \StarOf{\Regex'} \DefinitionalEquiv
    \EmptyString \Or
    (\Regex'\Concat\StarOf{\Regex'}) \DefinitionalEquiv \RegexAlt$, as desired.
  \end{case}

  \begin{case}[\AtomUnrollstarRightRule{}]
    Let $\ToDNFRegexOf{\Regex} = \DNFOf{\SequenceOf{\Atom}}$, and
    $\Atom \ParallelRewriteSwapAtom \ToDNFRegexOf{\RegexAlt}$ from
    \AtomUnrollstarRightRule{}.
    This means that $\Atom = \StarOf{\DNFRegex}$ and
    $\ToDNFRegexOf{\RegexAlt} = \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}
    {(\ConcatDNFOf{\DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}}{\DNFRegex})}$.

    Let $\Regex' = \ToRegexOf{\DNFRegex}$.
    As $\ToDNFRegexOf{\StarOf{\Regex'}} =
    \DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}$, then from
    Lemma~\ref{lem:preimage-equiv}, $\StarOf{\Regex'}
    \DefinitionalEquiv \Regex$.
    Similarly, as $\ToDNFRegexOf{(\EmptyString \Or
      (\StarOf{\Regex'}\Concat\Regex'))} =
    \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}
    {(\ConcatDNFOf{\DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}}{\DNFRegex})}$,
    then from
    Lemma~\ref{lem:preimage-equiv}, $\EmptyString \Or
    (\StarOf{\Regex'}\Concat\Regex') \DefinitionalEquiv \RegexAlt$.
  
    So, through an application of UnrollstarRightRule{},
    $\Regex \DefinitionalEquiv \StarOf{\Regex'} \DefinitionalEquiv
    \EmptyString \Or
    (\StarOf{\Regex'}\Concat\Regex') \DefinitionalEquiv \RegexAlt$, as desired.
  \end{case}
  
  \begin{case}[\ParallelSwapAtomStructuralRewriteRule{}]
    Let $\ToDNFRegexOf{\Regex} = \DNFOf{\SequenceOf{\Atom}}$, and
    $\Atom \ParallelRewriteSwapAtom \ToDNFRegexOf{\RegexAlt}$
    This means that $\Atom = \StarOf{\DNFRegex}$ and
    $\ToDNFRegexOf{\RegexAlt} =
    \DNFOf{\SequenceOf{\DNFRegexAlt})}$ where $\DNFRegex \ParallelRewriteSwap
    \DNFRegexAlt$.

    Let $\ToRegexOf{\DNFRegex} = \Regex'$ and
    $\ToRegexOf{\DNFRegexAlt} = \RegexAlt'$.  By induction assumption, $\Regex'
    \DefinitionalEquiv \RegexAlt'$.  By structural equivalence,
    $\StarOf{\Regex'} = \StarOf{\RegexAlt'}$.
    As $\ToDNFRegexOf{\StarOf{\Regex'}} =
    \DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}$, from
    Lemma~\ref{lem:preimage-equiv}, $\StarOf{\Regex'} \DefinitionalEquiv
    \Regex$.
    As $\ToDNFRegexOf{\StarOf{\RegexAlt'}} =
    \DNFOf{\SequenceOf{\StarOf{\DNFRegexAlt}}}$, from
    Lemma~\ref{lem:preimage-equiv}, $\StarOf{\RegexAlt'} \DefinitionalEquiv
    \RegexAlt$.

    $\Regex \DefinitionalEquiv \StarOf{\Regex'} \DefinitionalEquiv
    \StarOf{\RegexAlt'} \DefinitionalEquiv \RegexAlt$, as desired.
  \end{case}

  \begin{case}[\DNFReorderRule{}]
    Let $\ToDNFRegexOf{\Regex} \ParallelRewriteSwap \ToDNFRegexOf{\RegexAlt}$,
    and the last step of the proof is an application of $\DNFReorderRule$.
    Let $\ToDNFRegexOf{\Regex} = \DNFOf{\Sequence_1;\ldots;\Sequence_n}$.  Then,
    for some $\sigma\in\PermutationSetOf{n}$,
    $\ToDNFRegexOf{\RegexAlt} =
    \DNFOf{\Sequence_{\sigma(1)};\ldots;\Sequence_{\sigma(n)}}$.

    $\ToRegexOf{\ToDNFRegexOf{\Regex}} =
    \ToRegexOf{\Sequence_1} \Or \ldots \Or \ToRegexOf{\Sequence_n}$ and
    $\ToRegexOf{\ToDNFRegexOf{\RegexAlt}} =
    \ToRegexOf{\Sequence_{\sigma(1)}} \Or \ldots \Or
    \ToRegexOf{\Sequence_{\sigma(n)}}$.

    $\sigma$ can then be broken down into a number of adjacent swapping
    permutations, $\sigma_{i_1} \Compose \ldots \Compose \sigma_{i_m} = \sigma$

    By Lemma~\ref{lem:adj-swap-or}, each $\sigma_{i_j}$ can be applied to a
    sequence of \OrRegexType{}s.

    Consider the derivation
    \[
      \inferrule*
      {
        \inferrule*[vdots=1.5em]
        {
          \inferrule*[vdots=1.5em]
          {
            \ToRegexOf{\Sequence_1} \Or \ldots \Or \ToRegexOf{\Sequence_n}
            \DefinitionalEquiv
            \ToRegexOf{\Sequence_1} \Or \ldots \Or \ToRegexOf{\Sequence_n}
          }
          {
          }
        }
        {
          \ToRegexOf{\Sequence_{\sigma_{i_m}(1)}} \Or \ldots \Or
          \ToRegexOf{\Sequence_{\sigma_{i_m}(n)}}
          \DefinitionalEquiv
          \ToRegexOf{\Sequence_1} \Or \ldots \Or \ToRegexOf{\Sequence_n}
        }
      }
      {
        \ToRegexOf{\Sequence_{(\sigma_{i_1}\Compose\ldots\Compose\sigma_{i_m})(1)}}
        \Or \ldots \Or
        \ToRegexOf{\Sequence_{(\sigma_{i_1}\Compose\ldots\Compose\sigma_{i_m})(n)}}
        \DefinitionalEquiv
        \ToRegexOf{\Sequence_1} \Or \ldots \Or \ToRegexOf{\Sequence_n}
      }
    \]

    So, by Lemma~\ref{lem:preimage-equiv},
    $\Regex \DefinitionalEquiv \ToRegexOf{\ToDNFRegexOf{\Regex}}$ and
    $\ToRegexOf{\ToDNFRegexOf{\RegexAlt}} \DefinitionalEquiv \RegexAlt$.
    Furthermore,
    $\ToRegexOf{\ToDNFRegexOf{\Regex}} \DefinitionalEquiv
    \ToRegexOf{\ToDNFRegexOf{\RegexAlt}}$.
    So by the transitivity of an equational theory,
    $\Regex \DefinitionalEquiv \RegexAlt$.
  \end{case}

  \begin{case}[\IdentityRewriteRule{}]
    Let $\ToDNFRegexOf{\Regex} \ParallelRewriteSwap \ToDNFRegexOf{\RegexAlt}$
    by an application of \IdentityRewriteRule{}.

    That means $\ToDNFRegexOf{\Regex} = \ToDNFRegexOf{\RegexAlt}$.
    
    So, by Lemma~\ref{lem:preimage-equiv},
    That means that
    $\Regex \DefinitionalEquiv \ToRegexOf{\ToDNFRegexOf{\Regex}}
    \DefinitionalEquiv \RegexAlt$
  \end{case}

  \begin{case}[\ParallelSwapDNFStructuralRewriteRule{}]
    Let $\ToDNFRegexOf{\Regex} \ParallelRewriteSwap \ToDNFRegexOf{\RegexAlt}$
    by an application of \ParallelSwapDNFStructuralRewriteRule{}.

    \[
      \inferrule*
      {
        \ToDNFRegexOf{\Regex} = \DNFOf{\Sequence_1;\ldots;\Sequence_n}\\
        \forall i. \Sequence_i =
        \SequenceOf{\String_{i,0};\Atom_{i,1};\ldots;\Atom_{i,n_i};\String_{i,n_i}}\\
        \forall i,j. \Atom_{i,j} \ParallelRewriteSwapAtom \DNFRegex_{i,j}\\
        \forall i. \DNFRegex_i = \DNFOf{\SequenceOf{\String_{i,0}}} \ConcatDNF \DNFRegex_{i,1}
        \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,n_i} \ConcatDNF
        \DNFOf{\SequenceOf{\String_{i,n_i}}}
      }
      {
        \Regex \ParallelRewriteSwap \DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n
      }
    \]
    
    $\ToDNFRegexOf{\RegexAlt} = \DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n$.

    $\Atom_{i,j} \ParallelRewriteSwapAtom \DNFRegex_{i,j}$,
    $\ToDNFRegexOf{\ToRegexOf{\AtomToDNFOf{\Atom_{i,j}}}} =
    \AtomToDNFOf{\Atom_{i,j}}$, and
    $\ToDNFRegexOf{\ToRegexOf{\DNFRegex_{i,j}}} = \DNFRegex_{i,j}$, so by IH,
    $\ToRegexOf{\AtomToDNFOf{\Atom_{i,j}}} \DefinitionalEquiv
    \ToRegexOf{\DNFRegex_{i,j}}$.

    Consider the regular expressions
    $\Regex_i =
    \String_{i,0} \Concat \ToRegexOf{\AtomToDNFOf{\Atom_{i,1}}}
    \Concat \ldots \Concat
    \ToRegexOf{\AtomToDNFOf{\Atom_{i,n_i}}} \Concat \String_{i,n_i}$.

    Consider the regular expressions
    $\RegexAlt_i =
    \String_{i,0} \Concat \ToRegexOf{\DNFRegex_{i,j}}
    \Concat \ldots \Concat
    \ToRegexOf{\DNFRegex_{i,n_i}} \Concat \String_{i,n_i}$.

    By structural equality of $\ConcatRegexType$,
    $\Regex_i \DefinitionalEquiv \RegexAlt_i$.

    Consider the regular expression
    $\Regex' = \Regex_1 \OrDNF \ldots \OrDNF \Regex_n$ and the regular
    expression
    $\RegexAlt' = \RegexAlt_1 \Or \ldots \Or \RegexAlt_n$.

    By structural equality of $\OrRegexType$,
    $\Regex' \DefinitionalEquiv \RegexAlt'$

    $\ToDNFRegexOf{\Regex_i} =
    \DNFOf{\SequenceOf{\String_{i,0}}} \ConcatDNF \AtomToDNFOf{\Atom_{i,1}}
    \ConcatDNF \ldots \ConcatDNF
    \AtomToDNFOf{\Atom_{i,n_i}} \ConcatDNF \DNFOf{\SequenceOf{\String_{i,n_i}}}
    =
    \DNFOf{\SequenceOf{\String_{i,0};\Atom_{i,1}
        ;\ldots;\Atom_{i,n_i};\String_{i,n_i}}}
    = \DNFOf{\Sequence_i}$

    $\ToDNFRegexOf{\Regex'} =
    \ToDNFRegexOf{\Regex_1} \OrDNF \ldots \OrDNF \ToDNFRegexOf{\Regex_n} =
    \DNFOf{\Sequence_1} \OrDNF \ldots \OrDNF \DNFOf{\Sequence_n} =
    \DNFOf{\Sequence_1 ; \ldots ; \Sequence_n}$.
    This means, by Lemma~\ref{lem:preimage-equiv}, that
    $\Regex \DefinitionalEquiv \Regex'$

    $\ToDNFRegexOf{\RegexAlt_i} =
    \DNFOf{\SequenceOf{\String_{i,0}}} \ConcatDNF \DNFRegex_{i,1}
    \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,n_i} \ConcatDNF
    \DNFOf{\SequenceOf{\String_{i,n_i}}} =
    \DNFRegex_i$.

    $\ToDNFRegexOf{\RegexAlt'} =
    \ToDNFRegexOf{\RegexAlt_1} \OrDNF \ldots \OrDNF \ToDNFRegexOf{\RegexAlt_n} =
    \DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n$.
    This means, by Lemma~\ref{lem:preimage-equiv}, that
    $\RegexAlt' \DefinitionalEquiv \RegexAlt$
    
    So, $\Regex \DefinitionalEquiv \Regex' \DefinitionalEquiv \RegexAlt'
    \DefinitionalEquiv \RegexAlt$, so by transitivity of equational theories,
    $\Regex \DefinitionalEquiv \RegexAlt$.
  \end{case}
\end{proof}

\begin{lemma}[Expressibility of $\EquivalenceOf{\ParallelRewriteSwap}$ in
  $\DefinitionalEquiv$]
  \label{lem:express-equiv-swap-in-equiv}
  If $\ToDNFRegexOf{\Regex} \EquivalenceOf{\ParallelRewriteSwap}
  \ToDNFRegexOf{\RegexAlt}$, then
  $\Regex \DefinitionalEquiv \RegexAlt$.
\end{lemma}
\begin{proof}
  By induction on the typing derivation of
  $\EquivalenceOf{\ParallelRewriteSwap}$
  \begin{case}[\ReflexivityRule{}]
    Let $\ToDNFRegexOf{\Regex} \EquivalenceOf{\ParallelRewriteSwap}
    \ToDNFRegexOf{\RegexAlt}$, and the last step of the derivation is an
    application of \ReflexivityRule{}.

    This means $\ToDNFRegexOf{\Regex} = \ToDNFRegexOf{\RegexAlt}$.  That means
    $\ToRegexOf{\ToDNFRegexOf{\Regex}} = \ToRegexOf{\ToDNFRegexOf{\RegexAlt}}$.
    By Lemma~\ref{lem:preimage-equiv},
    $\Regex \DefinitionalEquiv \ToRegexOf{\ToDNFRegexOf{\Regex}}$.
    By Lemma~\ref{lem:preimage-equiv},
    $\ToRegexOf{\ToDNFRegexOf{\RegexAlt}} \DefinitionalEquiv = \RegexAlt$.
    By the transitivity of equational theories,
    $\Regex \DefinitionalEquiv \RegexAlt$.
  \end{case}

  \begin{case}[\BaseRule{}]
    Let $\ToDNFRegexOf{\Regex} \EquivalenceOf{\ParallelRewriteSwap}
    \ToDNFRegexOf{\RegexAlt}$, and the last step of the derivation is an
    application of \BaseRule{}.

    This means that $\ToDNFRegexOf{\Regex} \ParallelRewriteSwap
    \ToDNFRegexOf{\RegexAlt}$.

    By Lemma~\ref{lem:express-swap-in-equiv},
    $\Regex \DefinitionalEquiv \RegexAlt$.
  \end{case}

  \begin{case}[\SymmetryRule{}]
    Let $\ToDNFRegexOf{\Regex} \EquivalenceOf{\ParallelRewriteSwap}
    \ToDNFRegexOf{\RegexAlt}$, and the last step of the derivation is an
    application of \BaseRule{}.

    This means that $\ToDNFRegexOf{\Regex} \ParallelRewriteSwap
    \ToDNFRegexOf{\RegexAlt}$.

    By Lemma~\ref{lem:express-swap-in-equiv},
    $\Regex \DefinitionalEquiv \RegexAlt$.
  \end{case}
\end{proof}

\begin{lemma}[Propagation of $\ParallelRewriteSwap{}$ through $\OrDNF{}$ on
  the left]
  \label{lem:prop_parallel_swap_or_left}
  If $\DNFRegex \ParallelRewriteSwap \DNFRegex'$, then
  $\DNFRegex \OrDNF \DNFRegexAlt \ParallelRewriteSwap \DNFRegex'
  \OrDNF \DNFRegexAlt$
\end{lemma}
\begin{proof}
  This will be done by cases on the last step of the derivation of
  $\ParallelRewriteSwap$
  \begin{case}[\DNFReorderRule{}]
    Let $\DNFRegex \ParallelRewriteSwap \DNFRegex'$ by an application of
    \DNFReorderRule{}.
    This means, for some $\Sequence_1,\ldots,\Sequence_n$, and some $\sigma \in
    \PermutationSetOf{n}$,
    $\DNFRegex = \DNFOf{\Sequence_1;\ldots;\Sequence_n}$ and $\DNFRegex' =
    \DNFOf{\Sequence_{\sigma(1)};\ldots;\Sequence_{\sigma(n)}}$.
    The DNF regular expression
    $\DNFRegexAlt = \DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_m}$ for some
    $\SequenceAlt_1,\ldots,\SequenceAlt_m$.
    Let $\Identity_m$ be the identity permutation on $m$ elements.
    Define $\sigma' = \ConcatPermutationOf{\sigma}{\Identity_m}$.
    Define $\Sequence_i' =
    \begin{cases*}
      \Sequence_i & if $i \leq n$\\
      \SequenceAlt_{i-n} & otherwise
    \end{cases*}$.
    
    $\DNFOf{\Sequence_1';\ldots;\Sequence_{n+m}'} = \DNFRegex \OrDNF
    \DNFRegexAlt$.
    $\DNFOf{\Sequence_{\sigma'(1)}';\ldots;\Sequence_{\sigma'(n+m)}'} =
    \DNFOf{\Sequence_{sigma(1)};\ldots;\Sequence_{\sigma(n)};
      \SequenceAlt_1;\ldots;\SequenceAlt_m} =
    \DNFRegex' \OrDNF \DNFRegexAlt$.

    Consider the derivation
    \[
      \inferrule*
      {
      }
      {
        \DNFOf{\Sequence_1';\ldots;\Sequence_{n+m}'} \ParallelRewriteSwap
        \DNFOf{\Sequence_{\sigma'(1)}';\ldots;\Sequence_{\sigma'(n+m)}'}
      }
    \]
    as desired.
  \end{case}
  
  \begin{case}[\ParallelSwapAtomStructuralRewriteRule{}]
    Let $\DNFRegex \ParallelRewriteSwap \DNFRegex'$ by an application of
    \ParallelSwapAtomStructuralRewriteRule{}.
    \[
      \inferrule*
      {
        \DNFRegex = \DNFOf{\Sequence_1;\ldots;\Sequence_n}\\
        \forall i. \Sequence_i =
        \SequenceOf{\String_{i,0};\Atom_{i,1};\ldots;\Atom_{i,n_i};\String_{i,n_i}}\\
        \forall i,j. \Atom_{i,j} \ParallelRewriteSwapAtom \DNFRegex_{i,j}\\
        \forall i. \DNFRegex_i = \DNFOf{\SequenceOf{\String_{i,0}}} \ConcatDNF \DNFRegex_{i,1}
        \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,n_i} \ConcatDNF
        \DNFOf{\SequenceOf{\String_{i,n_i}}}
      }
      {
        \DNFRegex \ParallelRewriteSwap \DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n
      }
    \]

    Let $\DNFRegexAlt = \DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_m}$.
    Let $\SequenceAlt_i =
    \SequenceOf{\StringAlt_{i,0};\AtomAlt_{i,1};\ldots;\AtomAlt_{i,m_i};\StringAlt_{i,m_i}}$.
    
    Let $k_i =
    \begin{cases*}
      n_i & if $i \leq n$\\
      m_i & otherwise
    \end{cases*}$
    
    Let $\Sequence_i'' =
    \begin{cases*}
      \Sequence_i & if $i \leq n$\\
      \SequenceAlt_{i-n} & otherwise
    \end{cases*}$.
    Let $\DNFRegex'' = \DNFRegex \OrDNF \DNFRegexAlt =
    \DNFOf{\Sequence_1'';\ldots;\Sequence_{n+m}''}$.
    Let $\Atom_{i,j}'' =
    \begin{cases*}
      \Atom_{i,j} & if $i \leq n$\\
      \AtomAlt_{i-n,j} & otherwise
    \end{cases*}$
    Let $\String_{i,j}'' =
    \begin{cases*}
      \String_{i,j} & if $i \leq n$\\
      \StringAlt_{i-n,j} & otherwise
    \end{cases*}$

    Let $\DNFRegex_{i,j}'' =
    \begin{cases*}
      \DNFRegex_{i,j} & if $i \leq n$\\
      \AtomToDNFOf{\AtomAlt_{i-n,j}} & otherwise
    \end{cases*}$
    
    If $i \leq n$, by assumption $\Atom_{i,j}'' = \Atom_{i,j} \ParallelRewriteSwapAtom
    \DNFRegex_{i,j} = \DNFRegex_{i,j}''$.
    If $i > n$, by \ParallelSwapAtomStructuralRewriteRule{},
    $\Atom_{i,j}'' = \AtomAlt_{i-n,j} \ParallelRewriteSwapAtom
    \AtomToDNFOf{\AtomAlt_{i-n,j}} = \DNFRegex_{i,j}''$.
    
    Let $\DNFRegex_i'' =
    \begin{cases*}
      \DNFRegex_i & if $i \leq n$\\
      \DNFOf{\SequenceOf{\StringAlt_{i-n,0}}} \ConcatDNF \AtomAlt_{i-n,1};\ldots;
      \ConcatDNF \AtomAlt_{i-n,m_i} \ConcatDNF \StringAlt_{i-n,m_i} & otherwise
    \end{cases*}$

    For $i > n$, $\DNFRegex_i'' = \DNFOf{\SequenceOf{\StringAlt_{i-n,0}}}
    \ConcatDNF \AtomAlt_{i-n,1};\ldots;
    \ConcatDNF \AtomAlt_{i-n,k_i} \ConcatDNF \StringAlt_{i-n,k_i} =
    \DNFOf{\SequenceAlt_i}$ through application of $\ConcatDNF$ on many
    singleton DNF regular expressions.

    $\DNFRegex_{n+1}'' \OrDNF \ldots \OrDNF \DNFRegex_{n+m}'' =
    \DNFOf{\SequenceAlt_1} \OrDNF \ldots \DNFOf{\SequenceAlt_m} =
    \DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_m}$ through repeated application
    of $\OrDNF$ to singleton DNFs.

    As $\DNFRegex_1'' \OrDNF \ldots \OrDNF \DNFRegex_n''
    = \DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n
    = \DNFRegex'$,
    and $\DNFRegex_{n+1}'' \OrDNF \ldots \OrDNF \DNFRegex_{n+m}''
    = \DNFRegexAlt$, we get
    $\DNFRegex_1'' \OrDNF \ldots \OrDNF \DNFRegex_{n+m}'' = \DNFRegex' \OrDNF
    \DNFRegexAlt$

    Consider the derivation
    \[
      \inferrule*
      {
        \DNFRegex'' = \DNFOf{\Sequence_1'';\ldots;\Sequence_{n+m}''}\\
        \forall i. \Sequence_i'' =
        \SequenceOf{\String_{i,0}'';\Atom_{i,1}'';\ldots;\Atom_{i,k_i}'';\String_{i,k_i}''}\\
        \forall i,j. \Atom_{i,j}'' \ParallelRewriteSwapAtom \DNFRegex_{i,j}''\\
        \forall i. \DNFRegex_i'' = \DNFOf{\SequenceOf{\String_{i,0}''}} \ConcatDNF \DNFRegex_{i,1}''
        \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,n_i}'' \ConcatDNF
        \DNFOf{\SequenceOf{\String_{i,k_i}''}}
      }
      {
        \DNFRegex'' \ParallelRewriteSwap
        \DNFRegex_1'' \OrDNF \ldots \OrDNF \DNFRegex_{n+m}''
      }
    \]
    as desired.
  \end{case}
\end{proof}

\begin{lemma}[Propagation of $\ParallelRewriteSwap{}$ through $\OrDNF{}$ on
  the right]
  If $\DNFRegex \ParallelRewriteSwap \DNFRegex'$, then
  $\DNFRegex \ConcatDNF \DNFRegexAlt \ParallelRewriteSwap \DNFRegex'
  \ConcatDNF \DNFRegexAlt$
\end{lemma}
\begin{proof}
  Proceeds as Lemma~\ref{lem:prop_parallel_swap_or_left}, but on the right.
\end{proof}

\begin{lemma}[Propagation of $\EquivalenceOf{\ParallelRewriteSwap{}}$ through
  $\OrDNF{}$ on the left]
  \label{lem:prop-eq-swap-or-left}
  If $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex'$, then
  $\DNFRegex \OrDNF \DNFRegexAlt \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex'
  \OrDNF \DNFRegexAlt$
\end{lemma}
\begin{proof}
  By induction on the last step of the derivation of
  $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex'$.
  \begin{case}[\ReflexivityRule{}]
    If $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex'$ through an
    application of \ReflexivityRule{}, then $\DNFRegex' = \DNFRegex$.
    So, through reflexivity, $\DNFRegex \OrDNF \DNFRegexAlt
    \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex \OrDNF \DNFRegexAlt$
  \end{case}
  \begin{case}[\BaseRule{}]
    If $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex'$ through an
    application of \ReflexivityRule{}, then
    $\DNFRegex' \ParallelRewriteSwap \DNFRegex$.
    From Lemma~\ref{lem:prop_parallel_swap_left}
    $\DNFRegex \OrDNF \DNFRegexAlt
    \ParallelRewriteSwap \DNFRegex' \OrDNF \DNFRegexAlt$, so
    $\DNFRegex \OrDNF \DNFRegexAlt
    \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex' \OrDNF \DNFRegexAlt$.
  \end{case}
  \begin{case}[\TransitivityRule{}]
    If $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex'$ through an
    application of \TransitivityRule{}, then there exists a $\DNFRegex''$ such
    that
    $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex''$ and
    $\DNFRegex'' \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex'$.
    By IH, $\DNFRegex \OrDNF \DNFRegexAlt \EquivalenceOf{\ParallelRewriteSwap}
    \DNFRegex'' \OrDNF \DNFRegexAlt$ and
    $\DNFRegex'' \OrDNF \DNFRegexAlt \EquivalenceOf{\ParallelRewriteSwap}
    \DNFRegex' \OrDNF \DNFRegexAlt$.
    
    This gives us the derivation
    \[
      \inferrule*
      {
        \DNFRegex \OrDNF \DNFRegexAlt \EquivalenceOf{\ParallelRewriteSwap}
        \DNFRegex'' \OrDNF \DNFRegexAlt\\
        \DNFRegex'' \OrDNF \DNFRegexAlt \EquivalenceOf{\ParallelRewriteSwap}
        \DNFRegex' \OrDNF \DNFRegexAlt
      }
      {
        \DNFRegex \OrDNF \DNFRegexAlt \EquivalenceOf{\ParallelRewriteSwap}
        \DNFRegex' \OrDNF \DNFRegexAlt
      }
    \]
  \end{case}
\end{proof}

\begin{lemma}[Propagation of $\EquivalenceOf{\ParallelRewriteSwap{}}$ through
  $\OrDNF{}$ on the right]
  \label{lem:prop-eq-swap-or-right}
  If $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex'$, then
  $\DNFRegex \OrDNF \DNFRegexAlt \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex'
  \OrDNF \DNFRegexAlt$
\end{lemma}
\begin{proof}
  Proceeds as Lemma~\ref{lem:prop-eq-swap-or-left}, but on the right.
\end{proof}

\begin{lemma}[Propagation of $\EquivalenceOf{\ParallelRewriteSwap{}}$ through
  $\OrDNF{}$]
  \label{lem:prop-eq-swap-or}
  If $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex'$ and
  $\DNFRegexAlt \EquivalenceOf{ParallelRewriteSwap} \DNFRegexAlt'$, then
  $\DNFRegex \OrDNF \DNFRegexAlt \EquivalenceOf{\ParallelRewriteSwap}
  \DNFRegex' \OrDNF \DNFRegexAlt'$.
\end{lemma}
\begin{proof}
  By Lemma~\ref{lem:prop-eq-swap-or-left}, $\DNFRegex \OrDNF \DNFRegexAlt
  \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex' \OrDNF \DNFRegexAlt$.
  By Lemma~\ref{lem:prop-eq-swap-or-right}, $\DNFRegex' \OrDNF \DNFRegexAlt
  \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex' \OrDNF \DNFRegexAlt'$.
  Consider the derivation
  \[
    \inferrule*
    {
      \DNFRegex \OrDNF \DNFRegexAlt
      \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex' \OrDNF \DNFRegexAlt\\
      \DNFRegex' \OrDNF \DNFRegexAlt
      \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex' \OrDNF \DNFRegexAlt'
    }
    {
      \DNFRegex \OrDNF \DNFRegexAlt
      \EquivalenceOf{\ParallelRewriteSwap}
      \DNFRegex' \OrDNF \DNFRegexAlt'
    }
  \]
\end{proof}

\begin{lemma}[Propagation of $\ParallelRewriteSwap{}$ through $\ConcatDNF{}$ on
  the left]
  \label{lem:prop_parallel_swap_concat_left}
  If $\DNFRegex \ParallelRewriteSwap \DNFRegex'$, then
  $\DNFRegex \ConcatDNF \DNFRegexAlt \ParallelRewriteSwap \DNFRegex'
  \ConcatDNF \DNFRegexAlt$
\end{lemma}
\begin{proof}
  By induction on the derivation of $\ParallelRewriteSwap{}$.
  \begin{case}[\DNFReorderRule{}]
    Let $\DNFRegex \ParallelRewriteSwap \DNFRegex'$ by an application of
    \DNFReorderRule{}.
    This means, for some $\Sequence_1,\ldots,\Sequence_n$, and some $\sigma \in
    \PermutationSetOf{n}$,
    $\DNFRegex = \DNFOf{\Sequence_1;\ldots;\Sequence_n}$ and $\DNFRegex' =
    \DNFOf{\Sequence_{\sigma(1)};\ldots;\Sequence_{\sigma(n)}}$.
    The DNF regular expression
    $\DNFRegexAlt = \DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_m}$ for some
    $\SequenceAlt_1,\ldots,\SequenceAlt_m$.
    Let $\Identity_m$ be the identity permutation on $m$ elements.
    Define $\sigma' = \DistributePermutationOf{\sigma}{\Identity_m}$.
    Define $\Sequence_{i,j} = \Sequence_i \ConcatSequence \SequenceAlt_j$.

    By definition of $\ConcatDNF$,
    $\DNFOf{\Sequence_{1,1};\ldots;\Sequence_{n,m}} =
    \DNFOf{\Sequence_1 \ConcatDNF \SequenceAlt_1; \ldots;
      \Sequence_n \ConcatDNF \SequenceAlt_m} =
    \DNFRegex \ConcatDNF \DNFRegexAlt$.
    
    By the definition of $\ConcatDNF$ and $\DistributePermutation$,
    $\DNFOf{\Sequence_{\sigma'(1,1)};\ldots;\Sequence_{\sigma'(n,m)}} =
    \DNFOf{\Sequence_{(\sigma(1),1)};\ldots;\Sequence_{(\sigma(n),m)}} =
    \DNFOf{\Sequence_{\sigma(1)} \ConcatDNF \SequenceAlt_{1} ; \ldots;
      \Sequence_{\sigma(n)} \ConcatDNF \SequenceAlt_m} =
    \DNFRegex' \ConcatDNF \DNFRegexAlt$.
  \end{case}

  \begin{case}[\ParallelSwapDNFStructuralRewriteRule{}]
    Let $\DNFRegex \ParallelRewriteSwap \DNFRegex'$ by an application of
    \ParallelSwapDNFStructuralRewriteRule{}.
    \[
      \inferrule*
      {
        \DNFRegex = \DNFOf{\Sequence_1;\ldots;\Sequence_n}\\
        \forall i. \Sequence_i =
        \SequenceOf{\String_{i,0};\Atom_{i,1};\ldots;\Atom_{i,n_i};\String_{i,n_i}}\\
        \forall i,j. \Atom_{i,j} \ParallelRewriteSwapAtom \DNFRegex_{i,j}\\
        \forall i. \DNFRegex_i = \DNFOf{\SequenceOf{\String_{i,0}}} \ConcatDNF \DNFRegex_{i,1}
        \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,n_i} \ConcatDNF
        \DNFOf{\SequenceOf{\String_{i,n_i}}}
      }
      {
        \DNFRegex \ParallelRewriteSwap \DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n
      }
    \]

    Let $\DNFRegexAlt = \DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_m}$.
    Let $\SequenceAlt_i =
    \SequenceOf{\StringAlt_{i,0};\AtomAlt_{i,1};\ldots;\AtomAlt_{i,m_i};\StringAlt_{i,m_i}}$.
    Let $\Sequence_{i,j}'' = \Sequence_i \ConcatSequence \Sequence_j$
    Let $\DNFRegex'' = \DNFRegex \ConcatDNF \DNFRegexAlt =
    \DNFOf{\Sequence_{1,1}'';\ldots;\Sequence_{n,m}''}$.
    Let $\Atom_{i,j,k}'' =
    \begin{cases*}
      \Atom_{i,j,k} & if $k \leq n_i$\\
      \AtomAlt_{i,j,k-n_i} & otherwise
    \end{cases*}$
    Let $\String_{i,j,k}'' =
    \begin{cases*}
      \String_{i,k} & if $i < n_i$\\
      \String_{i,n_i} \Concat \StringAlt_{j,0} & if $i = n_i$\\
      \StringAlt_{j,k-n_i} & otherwise
    \end{cases*}$

    Let $\DNFRegex_{i,j,k}'' =
    \begin{cases*}
      \DNFRegex_{i,k} & if $i \leq n_i$\\
      \AtomToDNFOf{\AtomAlt_{i,j,k-n_i}} & otherwise
    \end{cases*}$
    
    If $k \leq n_i$, by assumption $\Atom_{i,j,k}'' = \Atom_{i,j} \ParallelRewriteSwapAtom
    \DNFRegex_{i,j,k} = \DNFRegex_{i,j,k}''$.
    If $k > n_i$, by \ParallelSwapAtomStructuralRewriteRule{},
    $\Atom_{i,j,k}'' = \AtomAlt_{j,k-n_i} \ParallelRewriteSwapAtom
    \AtomToDNFOf{\AtomAlt_{j,k-n_i}} = \DNFRegex_{i,j,k}''$.
    
    Let $\DNFRegex_{i,j}'' = \DNFRegex_i \ConcatDNF
    \DNFOf{\SequenceOf{\StringAlt_{i-n,0}}} \ConcatDNF \AtomAlt_{i-n,1};\ldots;
    \ConcatDNF \AtomAlt_{i-n,n_i} \ConcatDNF \StringAlt_{i-n,n_i}$
    
    Through repeated application of $\ConcatDNF$ on singletons,
    $\DNFRegex_{i,j}'' = \DNFRegex_i \ConcatDNF \DNFOf{\SequenceAlt_j}$.

    This means $\DNFRegex_{0,0} \OrDNF \ldots \OrDNF \DNFRegex_{n,m} =
    (\DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n) \ConcatDNF
    \DNFRegexAlt = \DNFRegex' \ConcatDNF \DNFRegexAlt$.

    Consider the derivation
    \[
      \inferrule*
      {
        \DNFRegex'' = \DNFOf{\Sequence_{1,1}'';\ldots;\Sequence_{n,m}''}\\
        \forall i,j. \Sequence_{i,j}'' =
        \SequenceOf{\String_{i,j,0}'';\Atom_{i,j,1}'';\ldots;\Atom_{i,j,n_i+m_j}'';\String_{i,j,n_i+m_j}''}\\
        \forall i,j,k. \Atom_{i,j,k}'' \ParallelRewriteSwapAtom \DNFRegex_{i,j,k}''\\
        \forall i,j. \DNFRegex_{i,j}'' = \DNFOf{\SequenceOf{\String_{i,j,0}''}} \ConcatDNF \DNFRegex_{i,j,1}''
        \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,j,n_i+m_i}'' \ConcatDNF
        \DNFOf{\SequenceOf{\String_{i,j,n_i+m_i}''}}
      }
      {
        \DNFRegex'' \ParallelRewriteSwap
        \DNFRegex_{1,1}'' \OrDNF \ldots \OrDNF \DNFRegex_{n,m}''
      }
    \]
    as desired.
  \end{case}
\end{proof}

\begin{lemma}[Propagation of $\ParallelRewriteSwap{}$ through $\ConcatDNF{}$ on
  the right]
  If $\DNFRegexAlt \ParallelRewriteSwap \DNFRegexAlt'$, then
  $\DNFRegex \ConcatDNF \DNFRegexAlt \ParallelRewriteSwap
  \DNFRegex \ConcatDNF \DNFRegexAlt'$
\end{lemma}
\begin{proof}
  Proceeds as Lemma~\ref{lem:prop_parallel_swap_or_left}, but on the right.
\end{proof}

\begin{lemma}[Propagation of $\EquivalenceOf{\ParallelRewriteSwap{}}$ through
  $\ConcatDNF{}$ on the left]
  \label{lem:prop-eq-swap-concat-left}
  If $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex'$, then
  $\DNFRegex \ConcatDNF \DNFRegexAlt \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex'
  \ConcatDNF \DNFRegexAlt$
\end{lemma}
\begin{proof}
  By induction on the last step of the derivation of
  $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex'$.
  \begin{case}[\ReflexivityRule{}]
    If $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex'$ through an
    application of \ReflexivityRule{}, then $\DNFRegex' = \DNFRegex$.
    So, through reflexivity, $\DNFRegex \ConcatDNF \DNFRegexAlt
    \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex \ConcatDNF \DNFRegexAlt$
  \end{case}
  \begin{case}[\BaseRule{}]
    If $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex'$ through an
    application of \ReflexivityRule{}, then
    $\DNFRegex' \ParallelRewriteSwap \DNFRegex$.
    From Lemma~\ref{lem:prop_parallel_swap_left}
    $\DNFRegex \ConcatDNF \DNFRegexAlt
    \ParallelRewriteSwap \DNFRegex' \ConcatDNF \DNFRegexAlt$, so
    $\DNFRegex \ConcatDNF \DNFRegexAlt
    \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex' \ConcatDNF \DNFRegexAlt$.
  \end{case}
  \begin{case}[\TransitivityRule{}]
    If $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex'$ through an
    application of \TransitivityRule{}, then there exists a $\DNFRegex''$ such
    that
    $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex''$ and
    $\DNFRegex'' \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex'$.
    By IH, $\DNFRegex \ConcatDNF \DNFRegexAlt \EquivalenceOf{\ParallelRewriteSwap}
    \DNFRegex'' \ConcatDNF \DNFRegexAlt$ and
    $\DNFRegex'' \ConcatDNF \DNFRegexAlt \EquivalenceOf{\ParallelRewriteSwap}
    \DNFRegex' \ConcatDNF \DNFRegexAlt$.
    
    This gives us the derivation
    \[
      \inferrule*
      {
        \DNFRegex \ConcatDNF \DNFRegexAlt \EquivalenceOf{\ParallelRewriteSwap}
        \DNFRegex'' \ConcatDNF \DNFRegexAlt\\
        \DNFRegex'' \ConcatDNF \DNFRegexAlt \EquivalenceOf{\ParallelRewriteSwap}
        \DNFRegex' \ConcatDNF \DNFRegexAlt
      }
      {
        \DNFRegex \ConcatDNF \DNFRegexAlt \EquivalenceOf{\ParallelRewriteSwap}
        \DNFRegex' \ConcatDNF \DNFRegexAlt
      }
    \]
  \end{case}
\end{proof}

\begin{lemma}[Propagation of $\EquivalenceOf{\ParallelRewriteSwap{}}$ through
  $\ConcatDNF{}$ on the right]
  \label{lem:prop-eq-swap-concat-right}
  If $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex'$, then
  $\DNFRegex \ConcatDNF \DNFRegexAlt \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex'
  \ConcatDNF \DNFRegexAlt$
\end{lemma}
\begin{proof}
  Proceeds as Lemma~\ref{lem:prop-eq-swap-concat-left}, but on the right.
\end{proof}

\begin{lemma}[Propagation of $\EquivalenceOf{\ParallelRewriteSwap{}}$ through
  $\ConcatDNF{}$]
  \label{lem:prop-eq-swap-concat}
  If $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex'$ and
  $\DNFRegexAlt \EquivalenceOf{ParallelRewriteSwap} \DNFRegexAlt'$, then
  $\DNFRegex \ConcatDNF \DNFRegexAlt \EquivalenceOf{\ParallelRewriteSwap}
  \DNFRegex' \ConcatDNF \DNFRegexAlt'$.
\end{lemma}
\begin{proof}
  By Lemma~\ref{lem:prop-eq-swap-concat-left}, $\DNFRegex \ConcatDNF \DNFRegexAlt
  \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex' \ConcatDNF \DNFRegexAlt$.
  By Lemma~\ref{lem:prop-eq-swap-concat-right}, $\DNFRegex' \ConcatDNF \DNFRegexAlt
  \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex' \ConcatDNF \DNFRegexAlt'$.
  Consider the derivation
  \[
    \inferrule*
    {
      \DNFRegex \OrDNF \DNFRegexAlt
      \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex' \OrDNF \DNFRegexAlt\\
      \DNFRegex' \OrDNF \DNFRegexAlt
      \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex' \OrDNF \DNFRegexAlt'
    }
    {
      \DNFRegex \OrDNF \DNFRegexAlt
      \EquivalenceOf{\ParallelRewriteSwap}
      \DNFRegex' \OrDNF \DNFRegexAlt'
    }
  \]
\end{proof}

\begin{lemma}[Propagation of $\EquivalenceOf{\ParallelRewriteSwap{}}$ through
  $\Star{}$]
  \label{lem:prop-eq-swap-star}
  If $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegexAlt$, then
  $\AtomToDNFOf{\StarOf{\DNFRegex}} \EquivalenceOf{\ParallelRewriteSwap}
  \AtomToDNFOf{\StarOf{\DNFRegexAlt}}$
\end{lemma}
\begin{proof}
  By induction on the derivation of $\EquivalenceOf{\ParallelRewriteSwap{}}$.
  \begin{case}[\ReflexivityRule{}]
    Let $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegexAlt$, with the
    last step of the derivation being \ReflexivityRule{}.  This means
    $\DNFRegexAlt = \DNFRegex$.  Consider the derivation
    \[
      \inferrule*
      {
      }
      {
        \AtomToDNFOf{\StarOf{\DNFRegex}} \EquivalenceOf{\ParallelRewriteSwap}
        \AtomToDNFOf{\StarOf{\DNFRegex}}
      }
    \]
  \end{case}

  \begin{case}[\BaseRule{}]
    Let $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegexAlt$, with the
    last step of the derivation being \BaseRule{}.  That means
    $\DNFRegex \ParallelRewriteSwap \DNFRegexAlt$.  Consider the derivation
    \[
      \inferrule*
      {
        \inferrule*
        {
          \inferrule*
          {
            \DNFRegex \ParallelRewriteSwap \DNFRegexAlt
          }
          {
            \StarOf{\DNFRegex} \ParallelRewriteSwapAtom
            \AtomToDNFOf{\StarOf{\DNFRegexAlt}}
          }
        }
        {
          \AtomToDNFOf{\StarOf{\DNFRegex}} \ParallelRewriteSwap
          \AtomToDNFOf{\StarOf{\DNFRegexAlt}}
        }
      }
      {
        \AtomToDNFOf{\StarOf{\DNFRegex}} \EquivalenceOf{\ParallelRewriteSwap}
        \AtomToDNFOf{\StarOf{\DNFRegexAlt}}
      }
    \]

    \begin{case}[\SymmetryRule{}]
      Let $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegexAlt$, with
      the last step of the derivation being \SymmetryRule{}.  That means
      $\DNFRegexAlt \ParallelRewriteSwap \DNFRegex$.  Consider the derivation
      \[
        \inferrule*
        {
          \inferrule*
          {
            \inferrule*
            {
              \DNFRegexAlt \ParallelRewriteSwap \DNFRegex
            }
            {
              \StarOf{\DNFRegexAlt} \ParallelRewriteSwapAtom
              \AtomToDNFOf{\StarOf{\DNFRegex}}
            }
          }
          {
            \AtomToDNFOf{\StarOf{\DNFRegexAlt}} \ParallelRewriteSwap
            \AtomToDNFOf{\StarOf{\DNFRegex}}
          }
        }
        {
          \AtomToDNFOf{\StarOf{\DNFRegex}} \EquivalenceOf{\ParallelRewriteSwap}
          \AtomToDNFOf{\StarOf{\DNFRegexAlt}}
        }
      \]
    \end{case}
    
    \begin{case}[\TransitivityRule{}]
      Let $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegexAlt$, with
      the last step of the derivation being \TransitivityRule{}.  That means
      that, for some $\DNFRegex'$, the last step of the derivation is
      \[
        \inferrule*
        {
          \DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex'\\
          \DNFRegex' \EquivalenceOf{\ParallelRewriteSwap} \DNFRegexAlt
        }
        {
          \DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegexAlt
        }
      \]

      By induction assumption,
      $\AtomToDNFOf{\StarOf{\DNFRegex}} \EquivalenceOf{\ParallelRewriteSwap}
      \AtomToDNFOf{\StarOf{\DNFRegex'}}$ and
      $\AtomToDNFOf{\StarOf{\DNFRegex'}} \EquivalenceOf{\ParallelRewriteSwap}
      \AtomToDNFOf{\StarOf{\DNFRegexAlt}}$.  Consider the derivation
      \[
        \inferrule*
        {
          \AtomToDNFOf{\StarOf{\DNFRegex}} \EquivalenceOf{\ParallelRewriteSwap}
          \AtomToDNFOf{\StarOf{\DNFRegex'}}\\
          \AtomToDNFOf{\StarOf{DNFRegex'}} \EquivalenceOf{\ParallelRewriteSwap}
          \AtomToDNFOf{\StarOf{\DNFRegexAlt}}
        }
        {
          \AtomToDNFOf{\StarOf{\DNFRegex}} \EquivalenceOf{\ParallelRewriteSwap}
          \AtomToDNFOf{\StarOf{\DNFRegexAlt}}
        }
      \]
    \end{case}
  \end{case}
\end{proof}

\begin{lemma}[Expressibility of $\DefinitionalEquiv$ in
  $\EquivalenceOf{\ParallelRewriteSwap}$]
  \label{lem:express-equiv-in-equiv-swap}
  If $\Regex \DefinitionalEquiv \RegexAlt$, then
  $\ToDNFRegexOf{\Regex} \EquivalenceOf{\ParallelRewriteSwap}
  \ToDNFRegexOf{\RegexAlt}$.
\end{lemma}
\begin{proof}
  Assume $\Regex \DefinitionalEquiv \RegexAlt$.
  Prove by induction on the deduction of $\DefinitionalEquiv$
  \begin{case}[Structural Equality Rule]
    Let $\Regex \DefinitionalEquiv \RegexAlt$, and the last step of the
    deduction is an application of structural equality rule.
    That means that $\RegexAlt
    = \Regex$.  Through reflexivity, $\ToDNFRegexOf{\Regex}
    \EquivalenceOf{\ParallelRewriteSwap} \ToDNFRegexOf{\Regex} =
    \ToDNFRegexOf{\RegexAlt}$.
  \end{case}

  \begin{case}[\OrIdentityRule{}]
    Let $\Regex \DefinitionalEquiv \RegexAlt$, and the last step of the
    deduction is an application of \OrIdentityRule{}.  Without loss of
    generality, from symmetry, $\RegexAlt = \Regex \Or \emptyset$.
  
    $\ToDNFRegexOf{\Regex \Or \emptyset} = \ToDNFRegexOf{\Regex} \OrDNF
    \ToDNFRegexOf{\emptyset} = \ToDNFRegexOf{\Regex} \OrDNF \DNFOf{} =
    \ToDNFRegexOf{\Regex}$.  Through reflexivity, $\ToDNFRegexOf{\Regex}
    \EquivalenceOf{\ParallelRewriteSwap} \ToDNFRegexOf{\Regex} =
    \ToDNFRegexOf{\Regex \Or \emptyset}$
  \end{case}
  
  \begin{case}[\EmptyProjectionRightRule{}]
    Let $\Regex \DefinitionalEquiv \RegexAlt$, and the last step of the
    deduction is an application of \EmptyProjectionRightRule{}.  Without
    loss of generality, from symmetry, $\Regex = \Regex' \Concat \emptyset$, and
    $\RegexAlt = \emptyset$.

    $\ToDNFRegexOf{\Regex' \Concat \emptyset} = \ToDNFRegexOf{\Regex} \ConcatDNF
    \ToDNFRegexOf{\emptyset} = \ToDNFRegexOf{\Regex} \ConcatDNF \DNFOf{} =
    \DNFOf{}$.  Through reflexivity, $\ToDNFRegexOf{\Regex} =
    \ToDNFRegexOf{\emptyset} \DefinitionalEquiv \ToDNFRegexOf{\emptyset} =
    \ToDNFRegexOf{\RegexAlt}$.
  \end{case}
  
  \begin{case}[\EmptyProjectionLeftRule{}]
    Let $\Regex \DefinitionalEquiv \RegexAlt$, and the last step of the
    deduction is an application of \EmptyProjectionRightRule{}.  Without
    loss of generality, from symmetry, $\Regex = \emptyset \Concat \Regex'$, and
    $\RegexAlt = \emptyset$.

    $\ToDNFRegexOf{\emptyset \Concat \Regex'} = \ToDNFRegexOf{\emptyset} \ConcatDNF
    \ToDNFRegexOf{\Regex} = \DNFOf{} \ConcatDNF \ToDNFRegexOf{\Regex} =
    \DNFOf{}$.  Through reflexivity, $\ToDNFRegexOf{\Regex} =
    \ToDNFRegexOf{\emptyset} \EquivalenceOf{\ParallelRewriteSwap}
    \ToDNFRegexOf{\emptyset} = \ToDNFRegexOf{\RegexAlt}$.
  \end{case}

  \begin{case}[\ConcatAssocRule{}]
    Let $\Regex \DefinitionalEquiv \RegexAlt$, and the last step of the
    deduction is an application of \ConcatAssocRule{}.  Without loss of
    generality, from symmetry,
    $\Regex = \Regex_1 \Concat (\Regex_2 \Concat \Regex_3)$, and
    $\RegexAlt = (\Regex_1 \Concat \Regex_2) \Concat \Regex_3$.

    $\ToDNFRegexOf{(\Regex_1 \Concat (\Regex_2 \Concat \Regex_3))} =
    \ToDNFRegexOf{\Regex_1} \ConcatDNF (\ToDNFRegexOf{\Regex_2} \ConcatDNF
    \ToDNFRegexOf{\Regex_3}) =
    (\ToDNFRegexOf{\Regex_1} \ConcatDNF \ToDNFRegexOf{\Regex_2}) \ConcatDNF
    \ToDNFRegexOf{\Regex_3} =
    \ToDNFRegexOf{(\Regex_1 \Concat \Regex_2) \Concat \Regex_3}$.  Through
    reflexivity, $\ToDNFRegexOf{\Regex} = \ToDNFRegexOf{\Regex_1} \ConcatDNF
    (\ToDNFRegexOf{\Regex_2} \ConcatDNF \ToDNFRegexOf{\Regex_3})
    \EquivalenceOf{\ParallelRewriteSwap} \ToDNFRegexOf{\Regex_1} \ConcatDNF
    (\ToDNFRegexOf{\Regex_2} \ConcatDNF \ToDNFRegexOf{\Regex_3}) =
    \ToDNFRegexOf{\RegexAlt}$.
  \end{case}
  
  \begin{case}[\OrAssociativityRule{}]
    Let $\Regex \DefinitionalEquiv \RegexAlt$, and the last step of the
    deduction is an application of \OrAssociativityRule{}.  Without loss of
    generality, from symmetry,
    $\Regex = \Regex_1 \Or (\Regex_2 \Or \Regex_3)$, and
    $\RegexAlt = (\Regex_1 \Or \Regex_2) \Or \Regex_3$.

    $\ToDNFRegexOf{(\Regex_1 \Or (\Regex_2 \Concat \Regex_3))} =
    \ToDNFRegexOf{\Regex_1} \OrDNF (\ToDNFRegexOf{\Regex_2} \OrDNF
    \ToDNFRegexOf{\Regex_3}) =
    (\ToDNFRegexOf{\Regex_1} \OrDNF \ToDNFRegexOf{\Regex_2}) \OrDNF
    \ToDNFRegexOf{\Regex_3} =
    \ToDNFRegexOf{(\Regex_1 \Or \Regex_2) \Or \Regex_3}$.  Through
    reflexivity, $\ToDNFRegexOf{\Regex} = \ToDNFRegexOf{\Regex_1} \OrDNF
    (\ToDNFRegexOf{\Regex_2} \OrDNF \ToDNFRegexOf{\Regex_3})
    \EquivalenceOf{\ParallelRewriteSwap} \ToDNFRegexOf{\Regex_1} \OrDNF
    (\ToDNFRegexOf{\Regex_2} \OrDNF \ToDNFRegexOf{\Regex_3}) =
    \ToDNFRegexOf{\RegexAlt}$.
  \end{case}

  \begin{case}[\OrCommutativityRule{}]
    Let $\Regex \DefinitionalEquiv \RegexAlt$, and the last step of the
    deduction is an application of \OrCommutativityRule{}.
    $\Regex = \Regex_1 \Or \Regex_2$, and
    $\RegexAlt = \Regex_2 \Or \Regex_1$.

    Let $\ToDNFRegexOf{\Regex_1} = \DNFOf{\Sequence_1;\ldots;\Sequence_n}$ and
    $\ToDNFRegexOf{\Regex_2} = \DNFOf{\SequenceAlt_1;\ldots;\Sequence_m}$.
    $\OrDNFOf
    {\DNFOf{\Sequence_1;\ldots;\Sequence_n}}
    {\DNFOf{\SequenceAlt_1;\ldots;\Sequence_m}} =
    \DNFOf{\Sequence_1;\ldots;\Sequence_n;\SequenceAlt_1;\ldots;\SequenceAlt_m}$.
    $\OrDNFOf
    {\DNFOf{\SequenceAlt_1;\ldots;\Sequence_m}}
    {\DNFOf{\Sequence_1;\ldots;\Sequence_n}} =
    \DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_n;\Sequence_1;\ldots;\Sequence_m}$.

    Let $\Sequence_i' =
    \begin{cases*}
      \Sequence_i & if $i \in \RangeIncInc{1}{n}$\\
      \SequenceAlt_{i-n} & if $i \in \RangeIncInc{n+1}{m}$
    \end{cases*}$
  
    Consider the deduction
    \[
      \inferrule*
      {
        \SwapPermutationOf{\Identity_n}{\Identity_m} \in \PermutationSetOf{n+m}
      }
      {
        \DNFOf{\Sequence_1';\ldots;\Sequence_{n+m}'}
        \ParallelRewriteSwap
        \DNFOf{\Sequence_{\SwapPermutationOf{\Identity_n}{\Identity_m}(1)}';\ldots;
        \Sequence_{\SwapPermutationOf{\Identity_n}{\Identity_m}(n+m)}'}
      }
    \]

    \[
      \begin{array}{rcl}
        \DNFOf{\Sequence_1'';\ldots;\Sequence_{n+m}''}
        & = & \DNFOf{\Sequence_1;\ldots;\Sequence_n;
              \SequenceAlt_1;\ldots;\SequenceAlt_n}\\
        & = & \ToDNFRegexOf{\Regex_1} \OrDNF \ToDNFRegexOf{\Regex_2}
      \end{array}
    \]

    \[
      \begin{array}{rcl}
        \DNFOf{\Sequence_{\SwapPermutationOf{\Identity_n}{\Identity_m}(1)}';\ldots;
        \Sequence_{\SwapPermutationOf{\Identity_n}{\Identity_m}(n+m)}'}
        & = & \DNFOf{\Sequence_{\Identity_m(1)+n}';\ldots;\Sequence_{\Identity_m(m)+n}';
              \Sequence_{\Identity_n(1)}';\ldots;\Sequence_{\Identity_n(n)}}\\
        & = & \DNFOf{\Sequence_{n+1}';\ldots;\Sequence_{n+m};
              \Sequence_1';\ldots;\Sequence_n'}\\
        & = & \DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_m;
              \Sequence_1;\ldots;\Sequence_n}\\
        & = & \ToDNFRegexOf{\Regex_2} \OrDNF \ToDNFRegexOf{\Regex_1}
      \end{array}
    \]

    So $\ToDNFRegexOf{\Regex_1} \OrDNF \ToDNFRegexOf{\Regex_2}
    \ParallelRewriteSwap
    \ToDNFRegexOf{\Regex_2} \OrDNF \ToDNFRegexOf{\Regex_1}$, which means
    $\ToDNFRegexOf{\Regex_1} \OrDNF \ToDNFRegexOf{\Regex_2}
    \EquivalenceOf{\ParallelRewriteSwap}
    \ToDNFRegexOf{\Regex_2} \OrDNF \ToDNFRegexOf{\Regex_1}$
  \end{case}

  \begin{case}[\DistributivityLeftRule{}]
    Let $\Regex \DefinitionalEquiv \RegexAlt$, and the last step of the
    deduction is an application of \DistributivityLeftRule{}.  Without loss of
    generality, from symmetry,
    $\Regex = \Regex_1 \Concat (\Regex_2 \Or \Regex_3)$, and
    $\RegexAlt = (\Regex_1 \Concat \Regex_2) \Or (\Regex_1 \Concat \Regex_3)$.

    Let $\ToDNFRegexOf{\Regex_1} =
    \DNFOf{\Sequence_{1,1};\ldots;\Sequence_{1,n_1}}$.
    Let $\ToDNFRegexOf{\Regex_2} =
    \DNFOf{\Sequence_{2,1};\ldots;\Sequence_{2,n_2}}$.
    Let $\ToDNFRegexOf{\Regex_3} =
    \DNFOf{\Sequence_{3,1};\ldots;\Sequence_{3,n_3}}$.

    \[
      \begin{array}{ccc}
        \ToDNFRegexOf{(\Regex_1 \Concat (\Regex_2 \Or \Regex_3))}
        & = & \ToDNFRegexOf{\Regex_1} \ConcatDNF (\ToDNFRegexOf{\Regex_2} \OrDNF
              \ToDNFRegexOf{\Regex_3})\\
        & = & \ToDNFRegexOf{\Regex_1} \ConcatDNF
              \DNFOf{\Sequence_{2,1};\ldots;\Sequence_{2,n_2};
              \Sequence_{3,1};\ldots;\Sequence_{3,n_3}}\\
        & = & \DNFOf{\Sequence_{1,1}\ConcatSequence\Sequence_{2,1};
              \ldots;\Sequence_{1,1}\ConcatSequence\Sequence_{3,n_3};\ldots;
              \Sequence_{1,n_1}\ConcatSequence\Sequence_{2,n_2};
              \ldots;\Sequence_{1,n_1}\ConcatSequence\Sequence_{3,n_3}}
      \end{array}
    \]

    \[
      \begin{array}{ccc}
        \ToDNFRegexOf{((\Regex_1 \Concat \Regex_2) \Or (\Regex_1 \Concat \Regex_3))}
        & = & (\ToDNFRegexOf{\Regex_1} \ConcatDNF \ToDNFRegexOf{\Regex_2})
              \OrDNF
              (\ToDNFRegexOf{\Regex_1} \ConcatDNF \ToDNFRegexOf{\Regex_3})\\
        & = & \DNFOf{\Sequence_{1,1}\ConcatSequence\Sequence_{2,1};
              \ldots;\ldots;
              \Sequence_{1,n_1}\ConcatSequence\Sequence_{2,n_2}} \OrDNF
              \DNFOf{\Sequence_{1,1}\ConcatSequence\Sequence_{3,1};
              \ldots;\ldots;
              \Sequence_{1,n_1}\ConcatSequence\Sequence_{3,n_3}}\\
        & = & \DNFOf{\Sequence_{1,1}\ConcatSequence\Sequence_{2,1};
              \ldots;\ldots;
              \Sequence_{1,n_1}\ConcatSequence\Sequence_{2,n_2};
              \Sequence_{1,1}\ConcatSequence\Sequence_{3,1};
              \ldots;\ldots;
              \Sequence_{1,n_1}\ConcatSequence\Sequence_{3,n_3}}
      \end{array}
    \]

    So $\ToDNFRegexOf{(\Regex_1 \Concat (\Regex_2 \Or \Regex_3))}$
    is different from $\ToDNFRegexOf{((\Regex_1 \Concat \Regex_2) \Or (\Regex_1
      \Concat \Regex_3))}$ only by the difference in the ordering of the
    sequences.

    Through using DNFReorderRule{},
    $\ToDNFRegexOf{(\Regex_1 \Concat (\Regex_2 \Or
      \Regex_3))} \ParallelRewriteSwap
    \ToDNFRegexOf{((\Regex_1 \Concat \Regex_2) \Or (\Regex_1
      \Concat \Regex_3))}$, so through the base rule,
    $\ToDNFRegexOf{(\Regex_1 \Concat (\Regex_2 \Or
      \Regex_3))} \EquivalenceOf{\ParallelRewriteSwap}
    \ToDNFRegexOf{((\Regex_1 \Concat \Regex_2) \Or (\Regex_1
      \Concat \Regex_3))}$.
  \end{case}

  \begin{case}[\DistributivityRightRule{}]
    Let $\Regex \DefinitionalEquiv \RegexAlt$, and the last step of the
    deduction is an application of \DistributivityRightRule{}.  Without loss of
    generality, from symmetry,
    $\Regex = (\Regex_1 \Or \Regex_2) \Concat \Regex_3$, and
    $\RegexAlt = (\Regex_1 \Concat \Regex_3) \Or (\Regex_2 \Concat \Regex_3)$.

    $\ToDNFRegexOf{(\Regex_1 \Or \Regex_2) \Concat \Regex_3} =
    (\ToDNFRegexOf{\Regex_1} \OrDNF \ToDNFRegexOf{\Regex_2}) \ConcatDNF
    \ToDNFRegexOf{\Regex_3} =
    (\ToDNFRegexOf{\Regex_1} \ConcatDNF \ToDNFRegexOf{\Regex_3}) \OrDNF
    (\ToDNFRegexOf{\Regex_2} \ConcatDNF \ToDNFRegexOf{\Regex_3}) =
    \ToDNFRegexOf{(\Regex_1 \Concat \Regex_3) \Or (\Regex_2 \Concat \Regex_3)}$.
    
    Through reflexivity, $\ToDNFRegexOf{\Regex} = \ToDNFRegexOf{((\Regex_1 \Or
      \Regex_2) \Concat \Regex_3)} \EquivalenceOf{\ParallelRewriteSwap}
    \ToDNFRegexOf{(\Regex_1 \Concat \Regex_3) \Or (\Regex_2 \Concat \Regex_3)}
    = \ToDNFRegexOf{\RegexAlt}$
  \end{case}

  \begin{case}[\ConcatIdentityLeftRule{}]
    Let $\Regex \DefinitionalEquiv \RegexAlt$, and the last step of the
    deduction is an application of \DistributivityRightRule{}.  Without loss of
    generality, from symmetry,
    $\Regex = \Regex' \Concat \EmptyString$, and
    $\RegexAlt = \Regex'$.

    $\ToDNFRegexOf{(\Regex' \Concat \EmptyString)} =
    \ToDNFRegexOf{\Regex'} \ConcatDNF \ToDNFRegexOf{\EmptyString} =
    \ToDNFRegexOf{\Regex'} \ConcatDNF \DNFOf{\SequenceOf{\EmptyString}} =
    \ToDNFRegexOf{\Regex'}$.
    
    Through reflexivity,
    $\ToDNFRegexOf{\Regex} = \ToDNFRegexOf{(\Regex' \Concat \EmptyString)}
    \EquivalenceOf{\ParallelRewriteSwap} \ToDNFRegexOf{\Regex'} =
    \ToDNFRegexOf{\RegexAlt}$
  \end{case}

  \begin{case}[\ConcatIdentityRightRule{}]
    Let $\Regex \DefinitionalEquiv \RegexAlt$, and the last step of the
    deduction is an application of \DistributivityRightRule{}.  Without loss of
    generality, from symmetry,
    $\Regex = \EmptyString \Concat \Regex'$, and
    $\RegexAlt = \Regex'$.

    $\ToDNFRegexOf{(\EmptyString \Concat \Regex')} =
    \ToDNFRegexOf{\EmptyString} \ConcatDNF \ToDNFRegexOf{\Regex'} =
    \DNFOf{\SequenceOf{\EmptyString}} \ConcatDNF \ToDNFRegexOf{\Regex'}=
    \ToDNFRegexOf{\Regex'}$
    
    Through reflexivity,
    $\ToDNFRegexOf{\Regex} = \ToDNFRegexOf{(\EmptyString \Concat \Regex')}
    \EquivalenceOf{\ParallelRewriteSwap} \ToDNFRegexOf{\Regex'} =
    \ToDNFRegexOf{\RegexAlt}$
  \end{case}

  \begin{case}[\UnrollstarLeftRule{}]
    Let $\Regex \DefinitionalEquiv \RegexAlt$, and the last step of the
    deduction is an application of \UnrollstarLeftRule{}.  Without loss of
    generality, from symmetry,
    $\Regex = \StarOf{\Regex'}$, and
    $\RegexAlt = \EmptyString \Or (\Regex' \Concat \StarOf{\Regex'})$.

    $\ToDNFRegexOf{\StarOf{\Regex'}} =
    \AtomToDNFOf{\StarOf{(\ToDNFRegexOf{\Regex'})}}$.
    $\ToDNFRegexOf{(\EmptyString \Or (\Regex' \Concat \StarOf{\Regex'}))} =
    \DNFOf{\SequenceOf{\EmptyString}} \OrDNF (\ToDNFRegexOf{\Regex'} \ConcatDNF
    \AtomToDNFOf{\StarOf{(\ToDNFRegexOf{\Regex'})}})$.
    
    Through \AtomUnrollstarLeftRule{},
    $\ToDNFRegexOf{\Regex} =
    \ToDNFRegexOf{\StarOf{\Regex'}} \ParallelRewriteSwap
    \ToDNFRegexOf{(\EmptyString \Or (\Regex' \Concat \StarOf{\Regex'}))} =
    \ToDNFRegexOf{\RegexAlt}$.
  \end{case}

  \begin{case}[\UnrollstarRightRule{}]
    Let $\Regex \DefinitionalEquiv \RegexAlt$, and the last step of the
    deduction is an application of \UnrollstarRightRule{}.  Without loss of
    generality, from symmetry,
    $\Regex = \StarOf{\Regex'}$, and
    $\RegexAlt = \EmptyString \Or (\StarOf{\Regex'} \Concat \Regex')$.

    $\ToDNFRegexOf{\StarOf{\Regex'}} =
    \AtomToDNFOf{\StarOf{(\ToDNFRegexOf{\Regex'})}}$.
    $\ToDNFRegexOf{(\EmptyString \Or (\StarOf{\Regex'} \Concat \Regex'))} =
    \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
    (\AtomToDNFOf{\StarOf{(\ToDNFRegexOf{\Regex'})}} \ConcatDNF
    \ToDNFRegexOf{\Regex'})$.
    
    Through \AtomUnrollstarRightRule{},
    $\ToDNFRegexOf{\Regex} =
    \ToDNFRegexOf{\StarOf{\Regex'}} \ParallelRewriteSwap
    \ToDNFRegexOf{(\EmptyString \Or (\StarOf{\Regex'} \Concat \Regex'))} =
    \ToDNFRegexOf{\RegexAlt}$.
  \end{case}

  \begin{case}[Structural \OrRegexType{} Equality]
    Let $\Regex \DefinitionalEquiv \RegexAlt$, through structural equality of
    \OrRegexType{}.
    $\Regex = \Regex_1 \Or \Regex_2$, and
    $\RegexAlt = \RegexAlt_1 \Or \RegexAlt_2$,
    $\Regex_1 \DefinitionalEquiv \RegexAlt_1$, and
    $\Regex_2 \DefinitionalEquiv \RegexAlt_2$.

    By induction assumption,
    $\ToDNFRegexOf{\Regex_1} \EquivalenceOf{\ParallelRewriteSwap}
    \ToDNFRegexOf{\RegexAlt_1}$ and
    $\ToDNFRegexOf{\Regex_2} \EquivalenceOf{\ParallelRewriteSwap}
    \ToDNFRegexOf{\RegexAlt_2}$.

    By Lemma~\ref{lem:prop-eq-swap-or},
    $\ToDNFRegexOf{\Regex_1} \OrDNF \ToDNFRegexOf{\Regex_2}
    \EquivalenceOf{\ParallelRewriteSwap}
    \ToDNFRegexOf{\RegexAlt_1} \OrDNF \ToDNFRegexOf{\RegexAlt_2}$.
    By the definition of $\ToDNFRegex{}$,
    $\ToDNFRegexOf{(\Regex_1 \Or \Regex_2)}
    \EquivalenceOf{\ParallelRewriteSwap}
    \ToDNFRegexOf{(\RegexAlt_1 \Or \RegexAlt_2)}$, as desired.
  \end{case}

  \begin{case}[Structural \ConcatRegexType{} Equality]
    Let $\Regex \DefinitionalEquiv \RegexAlt$, through structural equality of
    \ConcatRegexType{}.
    $\Regex = \Regex_1 \Concat \Regex_2$, and
    $\RegexAlt = \RegexAlt_1 \Concat \RegexAlt_2$,
    $\Regex_1 \DefinitionalEquiv \RegexAlt_1$, and
    $\Regex_2 \DefinitionalEquiv \RegexAlt_2$.

    By induction assumption,
    $\ToDNFRegexOf{\Regex_1} \EquivalenceOf{\ParallelRewriteSwap}
    \ToDNFRegexOf{\RegexAlt_1}$ and
    $\ToDNFRegexOf{\Regex_2} \EquivalenceOf{\ParallelRewriteSwap}
    \ToDNFRegexOf{\RegexAlt_2}$.

    By Lemma~\ref{lem:prop-eq-swap-concat},
    $\ToDNFRegexOf{\Regex_1} \ConcatDNF \ToDNFRegexOf{\Regex_2}
    \EquivalenceOf{\ParallelRewriteSwap}
    \ToDNFRegexOf{\RegexAlt_1} \ConcatDNF \ToDNFRegexOf{\RegexAlt_2}$.
    By the definition of $\ToDNFRegex{}$,
    $\ToDNFRegexOf{(\Regex_1 \Concat \Regex_2)}
    \EquivalenceOf{\ParallelRewriteSwap}
    \ToDNFRegexOf{(\RegexAlt_1 \Concat \RegexAlt_2)}$, as desired.
  \end{case}

  \begin{case}[Structural \StarRegexType{} Equality]
    Let $\Regex \DefinitionalEquiv \RegexAlt$, through structural equality of
    \StarRegexType{}.
    $\Regex = \StarOf{\Regex'}$,
    $\RegexAlt = \StarOf{\RegexAlt'}$, and
    $\Regex' \DefinitionalEquiv \RegexAlt'$.

    By induction assumption,
    $\ToDNFRegexOf{\Regex'} \EquivalenceOf{\ParallelRewriteSwap}
    \ToDNFRegexOf{\RegexAlt'}$.

    By Lemma~\ref{lem:prop-eq-swap-star},
    $\AtomToDNFOf{\StarOf{\ToDNFRegexOf{\Regex'}}}
    \EquivalenceOf{\ParallelRewriteSwap}
    \AtomToDNFOf{\StarOf{\ToDNFRegexOf{\Regex'}}}$.
    By the definition of $\ToDNFRegex{}$,
    $\ToDNFRegexOf{\StarOf{\Regex'}}
    \EquivalenceOf{\ParallelRewriteSwap}
    \ToDNFRegexOf{\StarOf{\RegexAlt'}}$, as desired.
  \end{case}

  \begin{case}[Transitivity of Equational Theory]
    Let $\Regex \DefinitionalEquiv \RegexAlt$ through the transitivity of an
    equational theory.  This means there exists a $\Regex'$ such that $\Regex
    \DefinitionalEquiv \Regex'$ and $\Regex' \DefinitionalEquiv \RegexAlt$.
    
    By induction assumption,
    $\ToDNFRegexOf{\Regex} \EquivalenceOf{\ParallelRewriteSwap}
    \ToDNFRegexOf{\Regex'}$ and
    $\ToDNFRegexOf{\Regex'} \EquivalenceOf{\ParallelRewriteSwap}
    \ToDNFRegexOf{\RegexAlt}$.
    
    Consider the derivation
    \[
      \inferrule*
      {
        \ToDNFRegexOf{\Regex} \EquivalenceOf{\ParallelRewriteSwap}
        \ToDNFRegexOf{\Regex'}\\
        \ToDNFRegexOf{\Regex'} \EquivalenceOf{\ParallelRewriteSwap}
        \ToDNFRegexOf{\RegexAlt}
      }
      {
        \ToDNFRegexOf{\Regex} \EquivalenceOf{\ParallelRewriteSwap}
        \ToDNFRegexOf{\RegexAlt}
      }
    \]
  \end{case}
\end{proof}

\begin{theorem}[Equivalence of $\EquivalenceOf{\ParallelRewriteSwap}$ and
  $\DefinitionalEquiv$]
  \label{thm:defequiv-equiv-parallelswapequiv}
  $\Regex \DefinitionalEquiv \RegexAlt$ if, and only if $\ToDNFRegexOf{\Regex}
  \EquivalenceOf{\ParallelRewriteSwap} \ToDNFRegexOf{\RegexAlt}$
\end{theorem}
\begin{proof}
  The forward direction is proven by Lemma~\ref{lem:express-equiv-in-equiv-swap}.
  The reverse direction is proven by Lemma~\ref{lem:express-equiv-swap-in-equiv}
\end{proof}

\begin{lemma}[Swap's Unimportance For Identity]
  \label{lem:swap-unimportance-identity}
  \leavevmode
  \begin{enumerate}
  \item If $\DNFRegex$ is strongly unambiguous and
    $\DNFRegex \ParallelRewriteSwap \DNFRegex_1$ then there exists a
    $\DNFRegex_2$ such that $\DNFRegex \ParallelRewrite \DNFRegex_2$
    and there exists a lens
    $\Lens \OfRewritelessType \DNFRegex_1 \Leftrightarrow \DNFRegex_2$
    such that
    $\SemanticsOf{\Lens} = \SetOf{(\String,\String)
      \SuchThat \String \in \LanguageOf{\DNFRegex}}$
  \item If $\Atom$ is strongly unambiguous and
    $\Atom \ParallelRewriteSwapAtom \DNFRegex_1$ then there exists a
    $\DNFRegex_2$ such that $\Atom \ParallelRewriteAtom \DNFRegex_2$
    and there exists a lens
    $\Lens \OfRewritelessType \DNFRegex_1 \Leftrightarrow \DNFRegex_2$
    such that
    $\SemanticsOf{\Lens} = \SetOf{(\String,\String)
      \SuchThat \String \in \LanguageOf{\Atom}}$
  \end{enumerate}
\end{lemma}
\begin{proof}
  By mutual induction on the derivation of $\ParallelRewriteSwap$.
  \begin{case}[\AtomUnrollstarLeftRule{}]
    Let $\Atom \ParallelRewriteSwapAtom \DNFRegex_1$, and the last step of the
    derivation is an application of \AtomUnrollstarRightRule{}.
    That means $\Atom = \StarOf{\DNFRegex}$ and
    $\DNFRegex_1 = \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
    (\DNFRegex \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegex}})$.
    
    Consider an application of $\ParallelRewriteAtom$'s
    \AtomUnrollstarRightRule{}.
    $\Atom \ParallelRewrite \DNFRegex_1$.
    By Lemma~\ref{lem:strongly-unambiguous-identity-expressible}, there exists
    a DNF lens
    $\DNFLens \OfRewritelessType \DNFRegex_1 \Leftrightarrow \DNFRegex_1$ and
    $\SemanticsOf{\DNFLens} = \SetOf{(\String,\String) \SuchThat \String \in
      \LanguageOf{\Atom}}$.
  \end{case}
  
  \begin{case}[AtomUnrollstarRightRule{}]
    Let $\Atom \ParallelRewriteSwapAtom \DNFRegex_1$, and the last step of the
    derivation is an application of \AtomUnrollstarLeftRule{}.
    That means $\Atom = \StarOf{\DNFRegex}$ and
    $\DNFRegex_1 = \AtomToDNFOf{\DNFRegex_1'}$, where 
    
    Consider an application of $\ParallelRewriteAtom$'s
    \AtomUnrollstarRightRule{}.
    $\Atom \ParallelRewrite \DNFRegex_1$.
    By Lemma~\ref{lem:strongly-unambiguous-identity-expressible}, there exists
    a DNF lens
    $\DNFLens \OfRewritelessType \DNFRegex_1 \Leftrightarrow \DNFRegex_1$ and
    $\SemanticsOf{\DNFLens} = \SetOf{(\String,\String) \SuchThat \String \in
      \LanguageOf{\Atom}}$.
  \end{case}

  \begin{case}[\ParallelSwapAtomStructuralRewriteRule{}]
    Let $\Atom \ParallelRewriteSwapAtom \DNFRegex_1$, and the last step of the
    derivation is an application of \ParallelSwapAtomStructuralRewriteRule{}.
    That means $\Atom = \StarOf{\DNFRegex}$ and
    $\DNFRegex_1 = \AtomToDNFOf{\StarOf{\DNFRegex_1'}}$, and
    $\DNFRegex \ParallelRewriteSwapAtom \DNFRegex_1'$.

    By IH, there exists $\DNFRegex_2'$ such that
    $\DNFRegex \ParallelRewrite \DNFRegex_2'$, and there exists a
    rewriteless DNF lens
    $\DNFLens \OfRewritelessType \DNFRegex_1' \Leftrightarrow \DNFRegex_2'$.

    By \ParallelSwapAtomStructuralRewriteRule{},
    $\Atom \ParallelRewriteAtom \AtomToDNFOf{\StarOf{\DNFRegex_2'}}$.
    By Lemma~\ref{lem:typ_sem_it},
    $\AtomToDNFLensOf{\IterateLensOf{\DNFLens}} \OfRewritelessType
    \AtomToDNFOf{\StarOf{\DNFRegex_1}} \Leftrightarrow
    \AtomToDNFOf{\StarOf{\DNFRegex_2}}$, with
    $\SemanticsOf{\AtomToDNFLensOf{\IterateLensOf{\DNFLens}}}
    = \SetOf{(\String_1\ldots\String_n,\StringAlt_1\ldots\StringAlt_n)
      \SuchThat (\String_i,\StringAlt_i) \in \SemanticsOf{\DNFLens}}
    = \SetOf{(\String_1\ldots\String_n,\String_1\ldots\String_n)
      \SuchThat (\String_i,\String_i) \in \LanguageOf{\DNFRegex}}
    = \SetOf{(\String,\String) \SuchThat \String \in \LanguageOf{\Atom})}$
  \end{case}

  \begin{case}[\ParallelSwapDNFStructuralRewriteRule{}]
    Let $\DNFRegex \ParallelRewriteSwap \DNFRegex'$, and the last step of the
    derivation is an application of \ParallelSwapDNFStructuralRewriteRule{}.

    \[
      {
        \DNFRegex = \DNFOf{\Sequence_1;\ldots;\Sequence_n}\\
        \forall i. \Sequence_i =
        \SequenceOf{\String_{i,0};\Atom_{i,1};\ldots;\Atom_{i,n_i};\String_{i,n_i}}\\
        \forall i,j. \Atom_{i,j} \ParallelRewriteSwapAtom \DNFRegex_{i,j}\\
        \forall i. \DNFRegex_i = \DNFOf{\SequenceOf{\String_{i,0}}} \ConcatDNF \DNFRegex_{i,1}
        \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,n_i} \ConcatDNF
        \DNFOf{\SequenceOf{\String_{i,n_i}}}
      }
      {
        \DNFRegex \ParallelRewriteSwap \DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n
      }
    \]
    and $\DNFRegex' = \DNFRegex_1 \OrDNF \OrDNF \ldots \OrDNF \DNFRegex_n$.

    There exists lenses
    By IH, there exist $\DNFRegexAlt_{i,j}$ and $\DNFLens_{i,j}$, such that
    $\Atom_{i,j} \ParallelRewrite \DNFRegexAlt_{i,j}$,
    $\DNFLens_{i,j} \OfRewritelessType
    \DNFRegex_{i,j} \Leftrightarrow \DNFRegexAlt_{i,j}$,
    and $\SemanticsOf{\DNFLens_{i,j}} =
    \SetOf{(\String,\String) \SuchThat \String \in \LanguageOf{\Atom_{i,j}}}$.

    Define $\DNFRegexAlt_i =
    \DNFOf{\SequenceOf{\String_{i,0}}} \ConcatDNF \DNFRegexAlt_{i,1}
    \ConcatDNF \ldots \ConcatDNF
    \DNFRegexAlt_{i,n_i} \ConcatDNF \DNFOf{\SequenceOf{\String_{i,n_i}}}$.

    Define $\DNFRegexAlt = \DNFRegexAlt_0 \OrDNF \ldots \OrDNF \DNFRegexAlt_n$
    
    By repeated application of Lemma~\ref{lem:typ_sem_concat}, there exists a
    lens
    $\DNFLens_i =
    (\DNFLensOf{(\SequenceLensOf{(\String_{i,0},\String_{i,0})},\Identity)},\Identity)
    \ConcatDNFLens \DNFLens_{i,1}
    \ConcatDNFLens \ldots \ConcatDNFLens
    \DNFLens_{i,n_i} \ConcatDNFLens
    (\DNFLensOf{(\SequenceLensOf{(\String_{i,n_i},\String_{i,n_i})},\Identity)},\Identity)
    \OfRewritelessType
    \DNFOf{\SequenceOf{\String_{i,0}}} \ConcatDNF
    \DNFRegex_{i,1} \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,n_i}
    \ConcatDNF \DNFOf{\SequenceOf{\String_{i,n_i}}} \Leftrightarrow
    \DNFOf{\SequenceOf{\String_{i,0}}} \ConcatDNF
    \DNFRegexAlt_{i,1} \ConcatDNF \ldots \ConcatDNF \DNFRegexAlt_{i,n_i}
    \ConcatDNF \DNFOf{\SequenceOf{\String_{i,n_i}}}$
    
    By pushing around the definitions of $\ConcatDNF$, this becomes
    $\DNFLens_i \OfRewritelessType
    \DNFRegex_i
    \Leftrightarrow
    \DNFRegexAlt_i$ and
    $\SemanticsOf{\DNFLens_i} = \SetOf{(\String,\String) \SuchThat
      \String \in \LanguageOf{\Sequence_i}}$.

    By repeated applications of Lemma~\ref{lem:typ_sem_or}, there exists a lens
    $\DNFLens =
    \DNFLens_0 \OrDNFLens \ldots \OrDNFLens \DNFLens_n 
    \OfRewritelessType
    \DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n
    \Leftrightarrow
    \DNFRegexAlt_1 \OrDNF \ldots \OrDNF \DNFRegexAlt_n$.
    
    By pushing around the definitions of $\OrDNF$, this becomes
    $\DNFLens \OfRewritelessType
    \DNFRegex' \Leftrightarrow \DNFRegexAlt$, and
    $\SemanticsOf{\DNFLens} =
    \SetOf{(\String,\String) \SuchThat \String\in\LanguageOf{\DNFRegex}}$

    Furthermore,
    \[
      {
        \DNFRegex = \DNFOf{\Sequence_1;\ldots;\Sequence_n}\\
        \forall i. \Sequence_i =
        \SequenceOf{\String_{i,0};\Atom_{i,1};\ldots;\Atom_{i,n_i};\String_{i,n_i}}\\
        \forall i,j. \Atom_{i,j} \ParallelRewrite \DNFRegexAlt_{i,j}\\
        \forall i. \DNFRegexAlt_i = \DNFOf{\SequenceOf{\String_{i,0}}}
        \ConcatDNF \DNFRegexAlt_{i,1}
        \ConcatDNF \ldots \ConcatDNF \DNFRegexAlt_{i,n_i} \ConcatDNF
        \DNFOf{\SequenceOf{\String_{i,n_i}}}
      }
      {
        \DNFRegex \ParallelRewrite \DNFRegexAlt_1 \OrDNF \ldots \OrDNF \DNFRegexAlt_n
      }
    \]
  \end{case}
  
  \begin{case}[\IdentityRewriteRule{}]
    Let $\DNFRegex \ParallelRewriteSwap \DNFRegex_1$, and the last step of the
    derivation is an application of \IdentityRewriteRule{}.

    This means $\DNFRegex \ParallelRewriteSwap \DNFRegex$

    Consider the application of $\ParallelRewrite{}$'s $\IdentityRewriteRule$,
    $\DNFRegex \ParallelRewrite \DNFRegex$.

    By Lemma~\ref{lem:strongly-unambiguous-identity-expressible}, there exists
    a DNF lens
    $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegex$ and
    $\SemanticsOf{\DNFLens} = \SetOf{(\String,\String) \SuchThat \String \in
      \LanguageOf{\DNFRegex}}$.
  \end{case}

  \begin{case}[\DNFReorderRule{}]
    Let $\DNFRegex \ParallelRewriteSwap \DNFRegex_1$, and the last step of the
    derivation is an application of \DNFReorderRule{}.

    Let $\DNFRegex = \DNFOf{\Sequence_1;\ldots;\Sequence_n}$.
    This means that there exists a $\sigma$ such that
    $\DNFRegex_1 = \DNFOf{\Sequence_{\sigma(1)};\ldots;\Sequence_{\sigma(n)}}$.

    Consider $\DNFRegex \ParallelRewrite \DNFRegex$.
    By Lemma~\ref{lem:strongly-unambiguous-identity-expressible}, there exists
    sequence lenses $\SequenceLens_i$ such that $\SequenceLens_i
    \OfRewritelessType \Sequence_i \Leftrightarrow \Sequence_i$ and
    $\SemanticsOf{\SequenceLens_i} = \SetOf{(\String,\String) \SuchThat \String
      \in \LanguageOf{\Sequence_i}}$

    Consider $(\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n},\sigma)
    \OfRewritelessType \DNFOf{\Sequence_1;\ldots;\Sequence_n}
    \Leftrightarrow \DNFOf{\Sequence_{\sigma(1)};\ldots;\Sequence_{\sigma(n)}}$,
    which is typed as desired.
    $\SemanticsOf{(\DNFLensOf{\SequenceLens_1;\ldots;\SequenceLens_n},\sigma)} =
    \SetOf{(\String,\StringAlt) \SuchThat \exists i. (\String,\StringAlt) \in
      \SemanticsOf{\SequenceLens_i}} =
    \SetOf{(\String,\String) \SuchThat \exists i. \String \in
      \LanguageOf{\Sequence_i}} =
    \SetOf{(\String,\String) \SuchThat \String \in \LanguageOf{\DNFRegex}}$
  \end{case}
\end{proof}

\begin{definition}
  Let $\Lens$ be a lens.
  Define the binary relation, $\DNFLensHasSemanticsOf{\Lens}\subseteq \DNFRegexType
  \Cross\DNFRegexType$, as
  $\SatisfiesDNFLensHasSemanticsOf{\Lens}{\DNFRegex}{\DNFRegexAlt}$ if, and
  only if there exists a DNF Lens $\DNFLens$ such that $\DNFLens
  \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt$, and
  $\SemanticsOf{\DNFLens}=\SemanticsOf{\Lens}$.
  $\SatisfiesIdentitySemantics{\DNFRegex}{\DNFRegexAlt}$ is
  shorthand for
  $\SatisfiesDNFLensHasSemanticsOf{\IdentityLensOf{\DNFRegex}}{\DNFRegex}{\DNFRegexAlt}$.
\end{definition}

\begin{lemma}
  \label{lem:copyable_expansions_left_swapless}\leavevmode
  \begin{enumerate}
  \item Let $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow
    \DNFRegexAlt$ and $\DNFRegex \ParallelRewrite \DNFRegex'$.  There exists some
    $\DNFRegexAlt'$, $\DNFLens'$ such that $\DNFRegexAlt \ParallelRewrite
    \DNFRegexAlt'$,
    $\DNFLens' \OfRewritelessType
    \DNFRegex' \Leftrightarrow \DNFRegexAlt'$, and $\SemanticsOf{\DNFLens} =
    \SemanticsOf{\DNFLens'}$.
  \item Let $\AtomLens \OfRewritelessType \Atom \Leftrightarrow \AtomAlt$ and
    $\Atom \ParallelRewriteAtom \DNFRegex$.  There exists some $\DNFRegexAlt$,
    $\DNFLens$, such that $\AtomAlt \ParallelRewriteAtom \DNFRegexAlt$,
    $\DNFLens' \OfRewritelessType \DNFRegex
    \Leftrightarrow \DNFRegexAlt$, and $\SemanticsOf{\DNFLens} =
    \SemanticsOf{\AtomLens}$.
  \end{enumerate}
\end{lemma}
\begin{proof}
  By mutual induction on the derivation of $\ParallelRewrite$ and
  $\ParallelRewriteAtom$
  \begin{case}[\AtomUnrollstarLeftRule{}]
    Let $\AtomLens \OfRewritelessType \Atom \Leftrightarrow \AtomAlt$, and
    $\Atom\ParallelRewriteAtom\DNFRegex$ through an application of
    \AtomUnrollstarLeftRule{}.  By inversion, there exists a derivation of
    \[
      \inferrule*
      {
        \DNFLens \OfRewritelessType \DNFRegex' \Leftrightarrow \DNFRegexAlt'\\
        \UnambigItOf{\DNFRegex'}\\
        \UnambigItOf{\DNFRegexAlt'}
      }
      {
        \IterateLensOf{\DNFLens} \OfRewritelessType \StarOf{\DNFRegex'} \Leftrightarrow
        \StarOf{\DNFRegexAlt'}
      }
    \]

    Where $\IterateLensOf{\DNFLens} = \AtomLens$, $\StarOf{\DNFRegex'} = \Atom$,
    and $\StarOf{\DNFRegexAlt'} = \AtomAlt$.

    As \AtomUnrollstarLeftRule{} was applied,
    $\DNFRegex =
    \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}
    {(\ConcatDNFOf{\DNFRegex'}{\DNFOf{\SequenceOf{\StarOf{\DNFRegex'}}}})}$.

    Consider applying \AtomUnrollstarLeftRule{} to $\StarOf{\DNFRegexAlt'}$.
    $\StarOf{\DNFRegexAlt'}\ParallelRewriteAtom
    \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}
    {(\ConcatDNFOf{\DNFRegexAlt'}{\DNFOf{\SequenceOf{\StarOf{\DNFRegexAlt'}}}})}$

    Consider the lenses

    \[
      \inferrule*
      {
        \inferrule*
        {
        }
        {
          \SequenceLensOf{(\EmptyString,\EmptyString)}
        }
      }
      {
        \DNFLensOf{\SequenceLensOf{(\EmptyString,\EmptyString)}}
      }
    \]

    \[
      \inferrule*
      {
        \inferrule*
        {
          \IterateLensOf{\DNFLens} \OfRewritelessType \StarOf{\DNFRegex} \Leftrightarrow
          \StarOf{\DNFRegexAlt}
        }
        {
          \SequenceLensOf{\IterateLensOf{\DNFLens}} \OfRewritelessType
          \SequenceOf{\StarOf{\DNFRegex}} \Leftrightarrow
          \SequenceOf{\StarOf{\DNFRegexAlt}}
        }
      }
      {
        \DNFLensOf{\SequenceLensOf{\IterateLensOf{\DNFLens}}} \OfRewritelessType
        \DNFOf{\SequenceOf{\StarOf{\DNFRegex}}} \Leftrightarrow
        \DNFOf{\SequenceOf{\StarOf{\DNFRegexAlt}}}
      }
    \]

    As $\UnambigItOf{\DNFRegex}$, $\LanguageOf{\DNFRegex} \UnambigConcat
    \LanguageOf{\DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}}$.
    As $\UnambigItOf{\DNFRegex}$, $\EmptyString\not\in\LanguageOf{\DNFRegex}$.
    This means $\EmptyString\not\in\LanguageOf{\DNFRegex \ConcatDNF
      \DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}}$, so
    $\LanguageOf{\DNFOf{\SequenceOf{\EmptyString}}} \Intersect
    \LanguageOf{\DNFRegex \ConcatDNF \DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}} =
    \emptyset$

    Because of this, by Lemma~\ref{lem:typ_sem_concat} and
    Lemma~\ref{lem:typ_sem_or}, there exists the typing
    for the lens
    $\DNFLensOf{\SequenceLensOf{(\EmptyString,\EmptyString)}} \OrDNFLens
    (\DNFLens \ConcatDNFLens \DNFLensOf{\SequenceLensOf{\IterateLensOf{\DNFLens}}})
    \OfRewritelessType
    \DNFOf{\SequenceOf{\EmptyString}} \OrDNF (\DNFRegex \ConcatDNFLens
    \DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}) \Leftrightarrow
    \DNFOf{\SequenceOf{\EmptyString}} \OrDNF (\DNFRegexAlt \ConcatDNFLens
    \DNFOf{\SequenceOf{\StarOf{\DNFRegexAlt}}})$, which is the desired typing.

    \[
      \begin{array}{rcl}
        \SemanticsOf{\DNFLensOf{\SequenceLensOf{(\EmptyString,\EmptyString)}}
        \OrDNFLens
        (\DNFLens \ConcatDNFLens
        \DNFLensOf{\SequenceLensOf{\IterateLensOf{\DNFLens}}})}
        & = & \SetOf{(\String,\StringAlt)\SuchThat
              (\String,\StringAlt)\in\SemanticsOf{\DNFLensOf{\SequenceLensOf{
              (\EmptyString,\EmptyString)}}} \BooleanOr (\String,\StringAlt)
              \in \SemanticsOf{\DNFLens \ConcatDNFLens
              \DNFLensOf{\SequenceLensOf{\IterateLensOf{\DNFLens}}}}}\\
        & = & \SetOf{(\EmptyString,\EmptyString)} \Union
              \SetOf{(\String,\StringAlt) \SuchThat (\String,\StringAlt) \in
              \SemanticsOf{\DNFLens \ConcatDNFLens
              \DNFLensOf{\SequenceLensOf{\IterateLensOf{\DNFLens}}}}}\\
        & = & \SetOf{(\EmptyString,\EmptyString)} \Union
              \SetOf{(\String_1\Concat\String_2,\StringAlt_1\Concat\StringAlt_2)
              \SuchThat (\String_1,\StringAlt_1) \in
              \SemanticsOf{\DNFLens} \BooleanAnd
              (\String_2,\StringAlt_2) \in
              \SemanticsOf{\DNFLensOf{\SequenceLensOf{\IterateLensOf{\DNFLens}}}}}\\
        & = & \SetOf{(\EmptyString,\EmptyString)} \Union
              \SetOf{(\String_1\Concat
              (\String_{2,1}\Concat\ldots\Concat\String_{2,n}),
              \StringAlt_1\Concat
              (\StringAlt_{2,1}\Concat\ldots\Concat\String_{2,n}))\\
        & & \hspace*{5em}
            \SuchThat (\String_1,\StringAlt_1) \in
            \SemanticsOf{\DNFLens} \BooleanAnd n\geq 0 \BooleanAnd
            \forall i\in\RangeIncInc{1}{n}.(\String_{2,i},\StringAlt_{2,i}) \in
            \SemanticsOf{\DNFLens}}\\
        & = & \SetOf{(\EmptyString,\EmptyString)} \Union
              \SetOf{(\String_1\Concat\ldots\Concat\String_n,
              \StringAlt_1\Concat\ldots\Concat\StringAlt_n) \SuchThat
              n \geq 1 \BooleanAnd \forall i\in\RangeIncInc{1}{n}.
              (\String_i,\StringAlt_i)\in\SemanticsOf{\DNFLens}}\\
        & = & \SetOf{(\String_1\Concat\ldots\Concat\String_n,
              \StringAlt_1\Concat\ldots\Concat\StringAlt_n) \SuchThat
              n \geq 0 \BooleanAnd \forall i\in\RangeIncInc{1}{n}.
              (\String_i,\StringAlt_i)\in\SemanticsOf{\DNFLens}}\\
        & = & \SemanticsOf{\IterateLensOf{\DNFLens}}
      \end{array}
    \]
  \end{case}

  \begin{case}[\AtomUnrollstarRightRule{}]
    Let $\AtomLens \OfRewritelessType \Atom \Leftrightarrow \AtomAlt$, and
    $\Atom\ParallelRewriteAtom\DNFRegex$ through an application of
    \AtomUnrollstarRightRule{}.
  \end{case}

  \begin{case}[\ParallelAtomStructuralRewriteRule{}]
    Let $\AtomLens \OfRewritelessType \Atom \Leftrightarrow \AtomAlt$, and
    $\Atom\ParallelRewriteAtom\DNFRegex$ through an application of
    \ParallelAtomStructuralRewriteRule{}.  By inversion, there exists a derivation of
  
    \[
      \inferrule*
      {
        \DNFLens \OfRewritelessType \DNFRegex' \Leftrightarrow \DNFRegexAlt'\\
        \UnambigItOf{\DNFRegex'}\\
        \UnambigItOf{\DNFRegexAlt'}
      }
      {
        \IterateLensOf{\DNFLens} \OfRewritelessType \StarOf{\DNFRegex'} \Leftrightarrow
        \StarOf{\DNFRegexAlt'}
      }
    \]

    Where $\IterateLensOf{\DNFLens} = \AtomLens$, $\StarOf{\DNFRegex'} = \Atom$,
    and $\StarOf{\DNFRegexAlt'} = \AtomAlt$.

    As \ParallelAtomStructuralRewriteRule{} was applied,
    $\DNFRegex' \ParallelRewrite \DNFRegex''$, and
    $\DNFRegex = \DNFOf{\SequenceOf{\StarOf{\DNFRegex''}}}$.

    By induction hypothesis, there exists some $\DNFLens'$, $\DNFRegexAlt''$,
    such that $\DNFLens' \OfRewritelessType \DNFRegex' \Leftrightarrow
    \DNFRegex''$, and $\SemanticsOf{\DNFLens'} = \SemanticsOf{\DNFLens}$.
    Because $\LanguageOf{\DNFRegex''} = \LanguageOf{\DNFRegex'}$ and
    $\LanguageOf{\DNFRegexAlt''} = \LanguageOf{\DNFRegexAlt'}$,
    $\UnambigItOf{\DNFRegex''}$ and $\UnambigItOf{\DNFRegexAlt''}$.

    Consider the typing
    \[
      \inferrule*
      {
        \inferrule*
        {
          \inferrule*
          {
            \DNFLens' \OfRewritelessType \DNFRegex'' \Leftrightarrow
            \DNFRegexAlt''\\
            \UnambigItOf{\DNFRegex''}\\
            \UnambigItOf{\DNFRegexAlt''}
          }
          {
            \IterateLensOf{\DNFLens'} \OfRewritelessType \StarOf{\DNFRegex''}
            \Leftrightarrow \StarOf{\DNFRegexAlt''}
          }
        }
        {
          \SequenceLensOf{\IterateLensOf{\DNFLens'}} \OfRewritelessType
          \SequenceOf{\StarOf{\DNFRegex''}} \Leftrightarrow
          \SequenceOf{\StarOf{\DNFRegexAlt''}}
        }
      }
      {
        \DNFLensOf{\SequenceLensOf{\IterateLensOf{\DNFLens'}}}
        \OfRewritelessType
        \DNFOf{\SequenceOf{\StarOf{\DNFRegex''}}} \Leftrightarrow
        \DNFOf{\SequenceOf{\StarOf{\DNFRegexAlt''}}}
      }
    \]

    This is the desired typing.  The semantics are as desired as well.

    \[
      \begin{array}{rcl}
        \SemanticsOf{\DNFLensOf{\SequenceLensOf{\IterateLensOf{\DNFLens'}}}}
        & = & \SetOf{(\String_1\Concat\ldots\Concat\String_n,
              \StringAlt_1\Concat\ldots\Concat\StringAlt_n) \SuchThat
              n \geq 0 \BooleanAnd \forall i\in\RangeIncInc{1}{n}
              (\String_i,\StringAlt_i)\in\SemanticsOf{\DNFLens'}}\\
        & = & \SetOf{(\String_1\Concat\ldots\Concat\String_n,
              \StringAlt_1\Concat\ldots\Concat\StringAlt_n) \SuchThat
              n \geq 0 \BooleanAnd \forall i\in\RangeIncInc{1}{n}
              (\String_i,\StringAlt_i)\in\SemanticsOf{\DNFLens}}\\
        & = & \SemanticsOf{\AtomLens}
      \end{array}
    \]
  \end{case}

  
  \begin{case}[\DNFReorderRule{}]
    Let $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt$, and
    $\DNFRegex\ParallelRewrite\DNFRegex'$ through an application of
    \DNFReorderRule{}.
  \end{case}

  \begin{case}[\ParallelDNFStructuralRewriteRule{}]
    Let $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt$, and
    $\DNFRegex\ParallelRewrite\DNFRegex'$ through an application of
    \ParallelDNFStructuralRewriteRule{}.
  \end{case}

  \begin{case}[\IdentityRewriteRule{}]
    Let $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt$, and
    $\DNFRegex\ParallelRewrite\DNFRegex'$ through an application of
    \IdentityRewriteRule{}.
  \end{case}
\end{proof}

\begin{lemma}
  \label{lem:copyable_expansions_left_swapless_star}\leavevmode
  Let $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow
  \DNFRegexAlt$ and $\DNFRegex \StarOf{\ParallelRewrite} \DNFRegex'$.  There
  exists some
  $\DNFRegexAlt'$, $\DNFLens'$ such that $\DNFRegexAlt
  \StarOf{\ParallelRewrite} \DNFRegexAlt'$,
  $\DNFLens' \OfRewritelessType
  \DNFRegex' \Leftrightarrow \DNFRegexAlt'$, and $\SemanticsOf{\DNFLens} =
  \SemanticsOf{\DNFLens'}$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\StarOf{\ParallelRewrite}$.
  \begin{case}[\ReflexivityRule{}]
    Let $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt$, and
    $\DNFRegex\StarOf{\ParallelRewrite}\DNFRegex'$ through an application of
    \DNFReorderRule{}.
  \end{case}

  \begin{case}[\BaseRule{}]
    Let $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt$, and
    $\DNFRegex\StarOf{\ParallelRewrite}\DNFRegex'$ through an application of
    \DNFReorderRule{}.
  \end{case}

  \begin{case}[\TransitivityRule{}]
    Let $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt$, and
    $\DNFRegex\StarOf{\ParallelRewrite}\DNFRegex'$ through an application of
    \DNFReorderRule{}.
  \end{case}
\end{proof}

\begin{lemma}
  \label{lem:copyable_expansions_right_swapless}\leavevmode
  \begin{enumerate}
  \item Let $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow
    \DNFRegexAlt$ and $\DNFRegexAlt \ParallelRewrite \DNFRegexAlt'$.  There exists some
    $\DNFRegex'$, $\DNFLens'$ such that $\DNFRegex \ParallelRewrite
    \DNFRegex'$,
    $\DNFLens' \OfRewritelessType
    \DNFRegex' \Leftrightarrow \DNFRegexAlt'$, and $\SemanticsOf{\DNFLens} =
    \SemanticsOf{\DNFLens'}$.
  \item Let $\AtomLens \OfRewritelessType \Atom \Leftrightarrow \AtomAlt$ and
    $\AtomAlt \ParallelRewriteAtom \DNFRegexAlt$.  There exists some $\DNFRegex$,
    $\DNFLens$, such that $\Atom \ParallelRewriteAtom \DNFRegex$,
    $\DNFLens' \OfRewritelessType \DNFRegex
    \Leftrightarrow \DNFRegexAlt$, and $\SemanticsOf{\DNFLens} =
    \SemanticsOf{\AtomLens}$.
  \end{enumerate}
\end{lemma}
\begin{proof}
  This can be proven symmetrically to Lemma~\ref{lem:copyable_expansions_left_swapless}.
\end{proof}

\begin{lemma}
  \label{lem:mirroring-property-parallel-swapless}
  For all lenses $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$,
  $\IsMirroringWithPropertyOf{\ParallelRewrite}{\DNFLensHasSemanticsOf{\Lens}}$,
  over the set of strongly unambiguous DNF regular expressions.
\end{lemma}
\begin{proof}
  Let $\DNFRegex,\DNFRegexAlt$ be strongly unambiguous DNF regular expressions,
  with $\DNFRegex \DNFLensHasSemanticsOf{\Lens} \DNFRegexAlt$.
  So there exists a rewriteless DNF lens
  $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt$ where
  $\SemanticsOf{\DNFLens} = \SemanticsOf{\Lens}$.

  Let $\DNFRegex \ParallelRewrite \DNFRegex'$.  By
  Lemma~\ref{lem:copyable_expansions_left_swapless}, there exists $\DNFLens'$,
  $\DNFRegexAlt'$ such that $\DNFRegexAlt \ParallelRewrite \DNFRegexAlt'$,
  $\DNFLens' \OfRewritelessType \DNFRegex' \Leftrightarrow \DNFRegexAlt'$,
  and $\SemanticsOf{\DNFLens'} = \SemanticsOf{\DNFLens} = \SemanticsOf{\Lens}$,
  so $\DNFRegex' \DNFLensHasSemanticsOf{\Lens} \DNFRegexAlt'$.

  Let $\DNFRegexAlt \ParallelRewrite \DNFRegexAlt'$.  By
  Lemma~\ref{lem:copyable_expansions_right_swapless}, there exists $\DNFLens'$,
  $\DNFRegex'$ such that $\DNFRegex \ParallelRewrite \DNFRegex'$,
  $\DNFLens' \OfRewritelessType \DNFRegex' \Leftrightarrow \DNFRegexAlt'$,
  and $\SemanticsOf{\DNFLens'} = \SemanticsOf{\DNFLens} = \SemanticsOf{\Lens}$,
  so $\DNFRegex' \DNFLensHasSemanticsOf{\Lens} \DNFRegexAlt'$.
\end{proof}

\begin{lemma}
  \label{lem:copyable_expansions_right_swapless_star}
  Let $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow
  \DNFRegexAlt$ and $\DNFRegexAlt \StarOf{\ParallelRewrite} \DNFRegexAlt'$.
  There exists some
  $\DNFRegex'$, $\DNFLens'$ such that $\DNFRegex
  \StarOf{\ParallelRewrite} \DNFRegex'$,
  $\DNFLens' \OfRewritelessType
  \DNFRegex' \Leftrightarrow \DNFRegexAlt'$, and $\SemanticsOf{\DNFLens} =
  \SemanticsOf{\DNFLens'}$.
\end{lemma}
\begin{proof}
  This can be proven symmetrically to
  Lemma~\ref{lem:copyable_expansions_left_swapless_star}.
\end{proof}

\begin{lemma}[$\ParallelRewrite$ Maintained Under $\ConcatDNF$ up to
  $\IdentityLens$ on the left]
  \label{lem:star-parallel-rewrite-concatenation-to-identity-left}
  Let $\DNFRegex$ be strongly unambiguous.  Let $\DNFRegexAlt$ be strongly
  unambiguous.
  Let $\UnambigConcatOf{\LanguageOf{\DNFRegex}}{\LanguageOf{\DNFRegexAlt}}$.
  If $\DNFRegex \StarOf{\ParallelRewrite} \DNFRegex'$, then
  $\DNFRegex \ConcatDNF \DNFRegexAlt \StarOf{\ParallelRewrite} \DNFRegex''$ such that there
  exists a rewriteless DNF lens
  $\DNFLens \OfRewritelessType
  \DNFRegex' \ConcatDNF \DNFRegexAlt \Leftrightarrow \DNFRegex''$, and
  $\SemanticsOf{\DNFLens} =
  \SetOf{(\String,\String) \SuchThat \String \in
    \LanguageOf{\DNFRegex \ConcatDNF \DNFRegexAlt}}$.
\end{lemma}
\begin{proof}
  As $\UnambigConcatOf{\LanguageOf{\DNFRegex}}{\LanguageOf{\DNFRegexAlt}}$,
  $\DNFRegex \ConcatDNF \DNFRegexAlt$ is strongly unambiguous.

  We proceed by induction on the derivation of $\StarOf{\ParallelRewrite}$.
  
  \begin{case}[\ReflexivityRule{}]
    \[
      \inferrule*
      {
      }
      {
        $\DNFRegex \StarOf{\ParallelRewrite} \DNFRegex$
      }
    \]

    By reflexivity

    \[
      \inferrule*
      {
      }
      {
        \DNFRegex \ConcatDNF \DNFRegexAlt \StarOf{\ParallelRewrite}
        \DNFRegex \ConcatDNF \DNFRegexAlt
      }
    \]

    Furthermore, as $\DNFRegex \ConcatDNF \DNFRegexAlt$ is strongly unambiguous,
    there exists a lens
    $\DNFLens \OfRewritelessType
    \DNFRegex \ConcatDNF \DNFRegexAlt \Leftrightarrow
    \DNFRegex \ConcatDNF \DNFRegexAlt$.
  \end{case}

  \begin{case}[\BaseRule{}]
    \[
      \inferrule*
      {
        \DNFRegex \ParallelRewrite \DNFRegex'
      }
      {
        \DNFRegex \StarOf{\ParallelRewrite} \DNFRegex'
      }
    \]

    So $\DNFRegex \ParallelRewrite \DNFRegex'$, and by \IdentityRewriteRule{},
    $\DNFRegexAlt \ParallelRewrite \DNFRegexAlt$.

    So Lemma~\ref{lem:parallel-rewrite-concatenation-to-identity} says that
    there exists $\DNFRegex''$ such that
    \[
      \inferrule*
      {
        \DNFRegex \ConcatDNF \DNFRegexAlt \ParallelRewrite \DNFRegex''
      }
      {
        \DNFRegex \ConcatDNF \DNFRegexAlt \StarOf{\ParallelRewrite} \DNFRegex''
      }
    \]
    where there exists a DNF lens
    $\DNFLens \OfRewritelessType \DNFRegex' \ConcatDNF \DNFRegexAlt
    \Leftrightarrow \DNFRegex''$ such that
    $\SemanticsOf{\DNFLens} = \SetOf{(\String,\String) \SuchThat \String \in
      \LanguageOf{\DNFRegex \ConcatDNF \DNFRegexAlt}}$.
  \end{case}

  \begin{case}[\TransitivityRule{}]
    \[
      \inferrule*
      {
        \DNFRegex \StarOf{\ParallelRewrite} \DNFRegex_1\\
        \DNFRegex_1 \StarOf{\ParallelRewrite} \DNFRegex'
      }
      {
        \DNFRegex \StarOf{\ParallelRewrite} \DNFRegex'
      }
    \]

    By IH, there exists $\DNFRegex_1''$ such that
    $\DNFRegex \ConcatDNF \DNFRegexAlt \StarOf{\ParallelRewrite} \DNFRegex_1''$,
    and there exists a DNF lens
    $\DNFLens_1 \OfRewritelessType \DNFRegex_1 \ConcatDNF \DNFRegexAlt
    \Leftrightarrow \DNFRegex_1''$, and
    $\SemanticsOf{\DNFLens_1} =
    \SetOf{(\String,\String) \SuchThat \String \in
      \LanguageOf{\DNFRegex \ConcatDNF \DNFRegexAlt}}$.

    By IH, there exists $\DNFRegex''$ such that
    $\DNFRegex_1 \ConcatDNF \DNFRegexAlt \StarOf{\ParallelRewrite} \DNFRegex''$,
    and there exists a DNF lens
    $\DNFLens \OfRewritelessType \DNFRegex' \ConcatDNF \DNFRegexAlt
    \Leftrightarrow \DNFRegex''$, and
    $\SemanticsOf{\DNFLens} =
    \SetOf{(\String,\String) \SuchThat \String \in
      \LanguageOf{\DNFRegex \ConcatDNF \DNFRegexAlt}}$.

    By Lemma~\ref{lem:copyable_expansions_left_swapless_star}, as
    $\DNFRegex_1 \ConcatDNF \DNFRegexAlt \StarOf{\ParallelRewrite} \DNFRegex''$,
    then there exists $\DNFRegex_1'$, $\DNFLens_1'$ such that
    $\DNFRegex_1'' \StarOf{\ParallelRewrite} \DNFRegex_1'$, and
    $\DNFLens_1' \OfRewritelessType
    \DNFRegex'' \Leftrightarrow \DNFRegex'' \Leftrightarrow \DNFRegex_1'$, with
    the same semantics as $\DNFLens_1$.

    So $\DNFLens \OfRewritelessType \DNFRegex' \ConcatDNF \DNFRegexAlt
    \Leftrightarrow \DNFRegex''$, and
    $\DNFLens_1' \OfRewritelessType
    \DNFRegex'' \Leftrightarrow \DNFRegex'' \Leftrightarrow \DNFRegex_1'$.
    By Lemma~\ref{lem:composition-completeness}, there exists a DNF lens,
    $\DNFLens' \OfRewritelessType \DNFRegex' \ConcatDNF \DNFRegexAlt
    \Leftrightarrow \DNFRegex_1'$.  As both the lenses in the composition are
    the identity lens, this lens is the identity lens, so
    $\SemanticsOf{\DNFLens'} = \SetOf{(\String,\String) \SuchThat
    \String \in \LanguageOf{\DNFRegex \ConcatDNF \DNFRegexAlt}}$

    Furthermore
    \[
      \inferrule*
      {
        \DNFRegex \ConcatDNF \DNFRegexAlt \StarOf{\ParallelRewrite} \DNFRegex_1''\\
        \DNFRegex_1'' \StarOf{\ParallelRewrite} \DNFRegex_1'
      }
      {
        \DNFRegex \ConcatDNF \DNFRegexAlt \StarOf{\ParallelRewrite} \DNFRegex_1'
      }
    \]
  \end{case}
\end{proof}


\begin{lemma}[$\ParallelRewrite$ Maintained Under $\ConcatDNF$ up to
  $\IdentityLens$ on the right]
  \label{lem:star-parallel-rewrite-concatenation-to-identity-right}
  Let $\DNFRegex$ be strongly unambiguous.  Let $\DNFRegexAlt$ be strongly
  unambiguous.
  Let $\UnambigConcatOf{\LanguageOf{\DNFRegexAlt}}{\LanguageOf{\DNFRegex}}$.
  If $\DNFRegex \StarOf{\ParallelRewrite} \DNFRegex'$, then
  $\DNFRegexAlt \ConcatDNF \DNFRegex \StarOf{\ParallelRewrite} \DNFRegex''$ such that there
  exists a rewriteless DNF lens
  $\DNFLens \OfRewritelessType
  \DNFRegexAlt \ConcatDNF \DNFRegex' \Leftrightarrow \DNFRegex''$, and
  $\SemanticsOf{\DNFLens} =
  \SetOf{(\String,\String) \SuchThat \String \in
    \LanguageOf{\DNFRegex \ConcatDNF \DNFRegexAlt}}$.
\end{lemma}
\begin{proof}
  This is done symmetrically to
  Lemma~\ref{lem:star-parallel-rewrite-concatenation-to-identity-left}.
\end{proof}


\begin{lemma}[$\ParallelRewrite$ Maintained Under $\ConcatDNF$ up to
  $\IdentityLens$]
  \label{lem:star-parallel-rewrite-concatenation-to-identity}
  Let $\DNFRegex$ be strongly unambiguous.  Let $\DNFRegexAlt$ be strongly
  unambiguous.
  Let $\UnambigConcatOf{\LanguageOf{\DNFRegexAlt}}{\LanguageOf{\DNFRegex}}$.
  Let $\DNFRegex \StarOf{\ParallelRewrite} \DNFRegex'$.
  Let $\DNFRegexAlt \StarOf{\ParallelRewrite} \DNFRegexAlt'$.
  Then $\DNFRegex \ConcatDNF \DNFRegexAlt \StarOf{\ParallelRewrite} \DNFRegex''$ such
  that
  there exists a rewriteless DNF lens
  $\DNFLens \OfRewritelessType
  \DNFRegex' \ConcatDNF \DNFRegexAlt' \Leftrightarrow \DNFRegex''$, and
  $\SemanticsOf{\DNFLens} =
  \SetOf{(\String,\String) \SuchThat \String \in
    \LanguageOf{\DNFRegex \ConcatDNF \DNFRegexAlt}}$.
\end{lemma}
\begin{proof}
  By Lemma~\ref{lem:star-parallel-rewrite-concatenation-to-identity-right},
  there exists a DNF lens
  $\DNFLens_1 \OfRewritelessType \DNFRegex \ConcatDNF \DNFRegexAlt'
  \Leftrightarrow \DNFRegex_1$, such that
  $\DNFRegex \ConcatDNF \DNFRegexAlt \StarOf{\ParallelRewrite} \DNFRegex_1$ and
  $\SemanticsOf{\DNFLens_1} =
  \SetOf{(\String,\String) \SuchThat \String \in
    \LanguageOf{\DNFRegex \ConcatDNF \DNFRegexAlt}}$.
  
  By Lemma~\ref{lem:star-parallel-rewrite-concatenation-to-identity-left},
  there exists a DNF lens
  $\DNFLens_2 \OfRewritelessType \DNFRegex' \ConcatDNF \DNFRegexAlt'
  \Leftrightarrow \DNFRegex_2$, such that
  $\DNFRegex \ConcatDNF \DNFRegexAlt' \StarOf{\ParallelRewrite} \DNFRegex_2$ and
  $\SemanticsOf{\DNFLens_2} =
  \SetOf{(\String,\String) \SuchThat \String \in
    \LanguageOf{\DNFRegex \ConcatDNF \DNFRegexAlt}}$.
  
  By Lemma~\ref{lem:copyable_expansions_left_swapless_star},
  as $\DNFRegex \ConcatDNF \DNFRegexAlt' \StarOf{\ParallelRewrite} \DNFRegex_2$,
  there exists a DNF lens
  $\DNFLens_1' \OfRewritelessType \DNFRegex_2 \Leftrightarrow \DNFRegex_1'$
  with $\SemanticsOf{\DNFLens_2} = \SetOf{(\String,\String) \SuchThat
    \String \in \LanguageOf{\DNFRegex \ConcatDNF \DNFRegexAlt}}$ and
  $\DNFRegex_1 \StarOf{\ParallelRewrite} \DNFRegex_1'$

  So $\DNFLens_2 \OfRewritelessType \DNFRegex' \ConcatDNF \DNFRegexAlt'
  \Leftrightarrow \DNFRegex_2$, and
  $\DNFLens_1' \OfRewritelessType
  \DNFRegex_2 \Leftrightarrow \DNFRegex_1'$.
  By Lemma~\ref{lem:composition-completeness}, there exists a DNF lens,
  $\DNFLens' \OfRewritelessType \DNFRegex' \ConcatDNF \DNFRegexAlt'
  \Leftrightarrow \DNFRegex_1'$.  As both the lenses in the composition are
  the identity lens, this lens is the identity lens, so
  $\SemanticsOf{\DNFLens'} = \SetOf{(\String,\String) \SuchThat
    \String \in \LanguageOf{\DNFRegex \ConcatDNF \DNFRegexAlt}}$
  
  Furthermore
  \[
    \inferrule*
    {
      \DNFRegex \ConcatDNF \DNFRegexAlt \StarOf{\ParallelRewrite} \DNFRegex_1\\
      \DNFRegex_1 \StarOf{\ParallelRewrite} \DNFRegex_1'
    }
    {
      \DNFRegex \ConcatDNF \DNFRegexAlt \StarOf{\ParallelRewrite} \DNFRegex_1'
    }
  \]
\end{proof}


\begin{lemma}[Pre-Confluence of Parallel Rewriting Without Reordering]
  \label{lem:pre-confluence}
  \begin{itemize}\leavevmode
  \item If $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt$,
    $\DNFRegex \ParallelRewrite \DNFRegex'$, and $\DNFRegexAlt \ParallelRewrite
    \DNFRegexAlt'$, then
    \begin{enumerate}
      \item There exists a $\DNFRegex''$ such that $\DNFRegex' \ParallelRewrite
        \DNFRegex''$
      \item There exists a $\DNFRegexAlt''$ such that
        $\DNFRegexAlt' \ParallelRewrite \DNFRegexAlt''$
      \item There exists a $\DNFLens' \OfRewritelessType \DNFRegex''
        \Leftrightarrow \DNFRegex''$ such that $\SemanticsOf{\DNFLens'} =
        \SemanticsOf{\DNFLens}$.
    \end{enumerate}
  \item If $\AtomLens \OfRewritelessType \Atom \Leftrightarrow \AtomAlt$, $\Atom
    \ParallelRewriteAtom \DNFRegex$, and $\AtomAlt \ParallelRewriteAtom
    \DNFRegexAlt$, then
    \begin{enumerate}
    \item There exists a $\DNFRegex'$ such that $\DNFRegex \ParallelRewrite
      \DNFRegex'$
    \item There exists a $\DNFRegexAlt'$ such that
      $\DNFRegexAlt \ParallelRewrite \DNFRegexAlt'$
    \item There exists a $\DNFLens \OfRewritelessType \DNFRegex' \Leftrightarrow
      \DNFRegexAlt'$ such that $\SemanticsOf{\DNFLens} = \SemanticsOf{\AtomLens}$
    \end{enumerate}
  \end{itemize}
\end{lemma}
\begin{proof}
  By mutual induction on the derivation of $\ParallelRewrite$ and
  $\ParallelRewriteAtom$.  We will split into cases by the last step taken in
  each derivation.
  \begin{case}[\AtomUnrollstarLeftRule{},\AtomUnrollstarLeftRule{}]
    Let $\AtomLens \OfType \Atom \Leftrightarrow \AtomAlt$.
    Let $\Atom = \StarOf{\DNFRegex'}$ and $\StarOf{\DNFRegexAlt'}
    \ParallelRewriteAtom
    \DNFOf{\SequenceOf{\EmptyString}} \OrDNF (\DNFRegex'
    \ConcatDNF \DNFOf{\SequenceOf{\StarOf{\DNFRegex'}}})$
    through an application of
    \AtomUnrollstarLeftRule{}.
    Let $\AtomAlt = \StarOf{\DNFRegexAlt}$ and $\StarOf{\DNFRegexAlt}
    \ParallelRewriteAtom \DNFOf{\SequenceOf{\EmptyString}} \OrDNF (\DNFRegexAlt
    \ConcatDNF \DNFOf{\SequenceOf{\StarOf{\DNFRegexAlt}}})$ through an application of
    \AtomUnrollstarLeftRule{}.
    
    \begin{enumerate}
    \item Consider using \IdentityRewriteRule{}
      \[
        \inferrule*
        {
        }
        {
          \DNFOf{\SequenceOf{\EmptyString}} \OrDNF (\DNFRegex
          \ConcatDNF \DNFOf{\SequenceOf{\StarOf{\DNFRegex}}})
          \ParallelRewrite
          \DNFOf{\SequenceOf{\EmptyString}} \OrDNF (\DNFRegex
          \ConcatDNF \DNFOf{\SequenceOf{\StarOf{\DNFRegex}}})
        }
      \]
    \item Consider using \IdentityRewriteRule{}
      \[
        \inferrule*
        {
        }
        {
          \DNFOf{\SequenceOf{\EmptyString}} \OrDNF (\DNFRegexAlt
          \ConcatDNF \DNFOf{\SequenceOf{\StarOf{\DNFRegexAlt}}})
          \ParallelRewrite
          \DNFOf{\SequenceOf{\EmptyString}} \OrDNF (\DNFRegexAlt
          \ConcatDNF \DNFOf{\SequenceOf{\StarOf{\DNFRegexAlt}}})
        }
      \]
    \item 
      By inversion, $\AtomLens = \StarOf{\DNFLens}$, and $\DNFLens
      \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt$.
      
      By Lemma~\ref{lem:typ_sem_concat}, Lemma~\ref{lem:typ_sem_or}, and
      Lemma~\ref{lem:typ_sem_it}
      $\DNFLensOf{\SequenceLensOf{(\EmptyString,\EmptyString)}} \OrDNFLens
      (\DNFLens' \ConcatDNFLens \AtomToDNFLensOf{\IterateLensOf{\DNFLens'}})
      \OfRewritelessType \DNFOf{\SequenceOf{\EmptyString}} \OrDNF (\DNFRegex'
      \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegex'}}) \Leftrightarrow
      \DNFOf{\SequenceOf{\EmptyString}} \OrDNF (\DNFRegexAlt'
      \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegexAlt'}})$, which is the desired
      typing.

      By Lemma~\ref{lem:iterate-lens-unroll-left},
      $\SemanticsOf{\DNFLensOf{\SequenceLensOf{(\EmptyString,\EmptyString)}}
        \OrDNFLens
        (\DNFLens' \ConcatDNFLens \AtomToDNFLensOf{\IterateLensOf{\DNFLens'}})}
      = \SemanticsOf{\AtomLens}$, which is the desired semantics.
      
    \end{enumerate}
  \end{case}
  \begin{case}[\AtomUnrollstarLeftRule{},\AtomUnrollstarRightRule{}]
    Let $\AtomLens \OfType \Atom \Leftrightarrow \AtomAlt$.
    Let $\Atom = \StarOf{\DNFRegex'}$ and $\StarOf{\DNFRegexAlt'}
    \ParallelRewriteAtom
    \DNFOf{\SequenceOf{\EmptyString}} \OrDNF (\DNFRegex'
    \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegex'}})$
    through an application of
    \AtomUnrollstarLeftRule{}.
    Let $\AtomAlt = \StarOf{\DNFRegexAlt}$ and $\StarOf{\DNFRegexAlt}
    \ParallelRewriteAtom \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
    (\AtomToDNFOf{\StarOf{\DNFRegexAlt}} \ConcatDNF \DNFRegexAlt)$
    through an application of \AtomUnrollstarRightRule{}.

    \begin{enumerate}
    \item
      \[
        \inferrule*
        {
          \StarOf{\DNFRegex'} \ParallelRewriteAtom
          \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
          (\AtomToDNFOf{\StarOf{\DNFRegex'}}
          \ConcatDNF \DNFRegex')
        }
        {
          \AtomToDNFOf{\StarOf{\DNFRegex'}} \ParallelRewrite
          \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
          (\AtomToDNFOf{\StarOf{\DNFRegex'}}
          \ConcatDNF \DNFRegex')
        }
      \]

      \[
        \inferrule*
        {
        }
        {
          \DNFRegex' \ParallelRewrite \DNFRegex'
        }
      \]

      By Lemma~\ref{TODO} there exists a $\DNFRegex_1$ such that
      $\DNFRegex' \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegex'}} \ParallelRewrite \DNFRegex_1$,
      and there exists $\DNFLens_1 \OfRewritelessType 
      \DNFRegex_1 \Leftrightarrow
      \DNFRegex' \ConcatDNF (\DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      (\AtomToDNFOf{\StarOf{\DNFRegex'}}
      \ConcatDNF \DNFRegex'))$
      where $\DNFLens_1$ has identity semantics.

      \[
        \inferrule*
        {
        }
        {
          \DNFOf{\SequenceOf{\EmptyString}} \ParallelRewrite
          \DNFOf{\SequenceOf{\EmptyString}}
        }
      \]

      So by Lemma~\ref{TODO},
      $\DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      (\DNFRegex' \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegex'}}) \ParallelRewrite
      \DNFOf{\SequenceOf{\EmptyString}} \OrDNF \DNFRegex_1$.
      
      Furthermore, as $\DNFLensOf{\SequenceLensOf{(\EmptyString,\EmptyString)}}
      \OfRewritelessType \DNFOf{\SequenceOf{\EmptyString}} \Leftrightarrow
      \DNFOf{\SequenceOf{\EmptyString}}$ has identity semantics, through
      Lemma~\ref{TODO},
      $\DNFLensOf{\SequenceLensOf{(\EmptyString,\EmptyString)}} \OrDNFLens
      \DNFLens_1 \OfRewritelessType \DNFOf{\SequenceOf{\EmptyString}}
      \OrDNF \DNFRegex_1 \Leftrightarrow
      \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      (\DNFRegex' \ConcatDNF (\DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      (\AtomToDNFOf{\StarOf{\DNFRegex'}}
      \ConcatDNF \DNFRegex')))$, which has the identity semantics.
      
    \item
      \[
        \inferrule*
        {
          \StarOf{\DNFRegexAlt'} \ParallelRewriteAtom
          \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
          (\DNFRegexAlt'
          \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegexAlt'}})
        }
        {
          \AtomToDNFOf{\StarOf{\DNFRegexAlt'}} \ParallelRewrite
          \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
          (\DNFRegexAlt'
          \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegexAlt'}})
        }
      \]

      \[
        \inferrule*
        {
        }
        {
          \DNFRegexAlt' \ParallelRewrite \DNFRegexAlt'
        }
      \]

      By Lemma~\ref{TODO} there exists a $\DNFRegexAlt_2$ such that
      $\DNFRegexAlt' \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegexAlt'}}
      \ParallelRewrite \DNFRegexAlt_2$,
      and there exists $\DNFLens_2 \OfRewritelessType 
      (\DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      (\DNFRegexAlt'
      \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegexAlt'}})) \ConcatDNF
      \DNFRegexAlt' \Leftrightarrow \DNFRegexAlt_2$
      where $\DNFLens_2$ has identity semantics.

      \[
        \inferrule*
        {
        }
        {
          \DNFOf{\SequenceOf{\EmptyString}} \ParallelRewrite
          \DNFOf{\SequenceOf{\EmptyString}}
        }
      \]

      So by Lemma~\ref{TODO},
      $\DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      (\AtomToDNFOf{\StarOf{\DNFRegexAlt'}} \ConcatDNF \DNFRegexAlt') \ParallelRewrite
      \DNFOf{\SequenceOf{\EmptyString}} \OrDNF \DNFRegexAlt_2$.

      Furthermore, as $\DNFLensOf{\SequenceLensOf{(\EmptyString,\EmptyString)}}
      \OfRewritelessType \DNFOf{\SequenceOf{\EmptyString}} \Leftrightarrow
      \DNFOf{\SequenceOf{\EmptyString}}$ has identity semantics, through
      Lemma~\ref{TODO},
      $\DNFLensOf{\SequenceLensOf{(\EmptyString,\EmptyString)}} \OrDNFLens
      \DNFLens_2 \OfRewritelessType \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      ((\DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      (\DNFRegexAlt'
      \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegexAlt'}})) \ConcatDNF
      \DNFRegexAlt') \Leftrightarrow
      \DNFOf{\SequenceOf{\EmptyString}}
      \OrDNF \DNFRegexAlt_2$, which has the identity semantics.
    \item
      As $\AtomLens \OfRewritelessType \StarOf{\DNFRegex'} \Leftrightarrow
      \StarOf{\DNFRegexAlt'}$, by inversion,
      $\AtomLens = \IterateLensOf{\DNFLens}$, and
      $\DNFLens \OfRewritelessType \DNFRegex' \Leftrightarrow \DNFRegexAlt'$.
      
      Let $\DNFLens' = \DNFLensOf{\SequenceLensOf{(\EmptyString,\EmptyString)}}
      \OrDNFLens (\DNFLens \ConcatDNFLens \AtomToDNFLensOf{\IterateLensOf{\DNFLens}})$
      By Lemma~\ref{lem:iterate-lens-unroll-right},
      $\SemanticsOf{\DNFLens'} = \SemanticsOf{\AtomLens}$.
      By application of Lemma~\ref{TODO} and Lemma~\ref{TODO},
      $\DNFLens' \OfRewritelessType \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      (\DNFRegex' \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegex}}) \Leftrightarrow
      \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      (\DNFRegexAlt' \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegexAlt}})$.
      
      Let $\DNFLens'' = \DNFLensOf{\SequenceLensOf{(\EmptyString,\EmptyString)}}
      \OrDNFLens (\AtomToDNFLensOf{\IterateLensOf{\DNFLens}}
      \ConcatDNFLens \DNFLens)$
      By Lemma~\ref{lem:iterate-lens-unroll-right-dnf},
      $\SemanticsOf{\DNFLens''} =
      \SemanticsOf{\AtomToDNFLensOf{\AtomLens}}$,
      By application of Lemma~\ref{TODO} and Lemma~\ref{TODO},
      $\DNFLens'' \OfRewritelessType \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      (\AtomToDNFOf{\StarOf{\DNFRegex}} \ConcatDNF \DNFRegex') \Leftrightarrow
      \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      (\AtomToDNFOf{\StarOf{\DNFRegexAlt}} \ConcatDNF \DNFRegexAlt')$.

      Consider the DNF lens
      $\DNFLens''' = \DNFLensOf{\SequenceLensOf{(\EmptyString,\EmptyString)}}
      \OrDNFLens (\DNFLens \ConcatDNFLens \DNFLens'')$.
      $\DNFLens''' \OfRewritelessType
      \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      (\DNFRegex' \ConcatDNF (\DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      (\AtomToDNFOf{\StarOf{\DNFRegex}} \ConcatDNF \DNFRegex'))) \Leftrightarrow
      \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      (\DNFRegexAlt' \ConcatDNF (\DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      (\AtomToDNFOf{\StarOf{\DNFRegexAlt}} \ConcatDNF \DNFRegexAlt')))$,
      where $\DNFLens'''$ has the same semantics as $\DNFLens'$, as
      $\DNFLens''$ has the same semantics as $\AtomToDNFLensOf{\AtomLens}$.

      By Lemma~\ref{TODO}, there exists
      $\DNFLens_3 \OfRewritelessType \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      (\DNFRegexAlt' \ConcatDNF (\DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      (\AtomToDNFOf{\StarOf{\DNFRegexAlt}} \ConcatDNF \DNFRegexAlt')))
      \Leftrightarrow
      \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      (\DNFRegexAlt' \ConcatDNF \DNFOf{\SequenceOf{\EmptyString}}) \OrDNF
      (\DNFRegexAlt' \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegexAlt}}
      \ConcatDNF \DNFRegexAlt')$.

      By Lemma~\ref{TODO}, there exists
      $\DNFLens_4 \OfRewritelessType \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      (\DNFOf{\SequenceOf{\EmptyString}} \ConcatDNF \DNFRegexAlt') \OrDNF
      (\DNFRegexAlt' \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegexAlt}}
      \ConcatDNF \DNFRegexAlt')
      \Leftrightarrow
      \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      ((\DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      \DNFRegexAlt' \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegexAlt}})
      \ConcatDNF \DNFRegexAlt')$.

      Consider the composition of
      $\DNFLensOf{\SequenceLensOf{(\EmptyString,\EmptyString)}} \OrDNFLens \DNFLens_1$,
      $\DNFLens'''$, $\DNFLens_3$, $\DNFLens_4$, and
      $\DNFLensOf{\SequenceLensOf{(\EmptyString,\EmptyString)}} \OrDNFLens
      \DNFLens_2$

      Because of Lemma~\ref{lem:composition-completeness}, there exists a lens
      $\DNFLens_5 \OfRewritelessType \DNFOf{\SequenceOf{\EmptyString}}
      \OrDNF \DNFRegex_1 \Leftrightarrow \DNFOf{\SequenceOf{\EmptyString}}
      \OrDNF \DNFRegexAlt_2$.  Furthermore, as all lenses except
      $\DNFLens'''$ are the identity lens, $\SemanticsOf{\DNFLens_5} =
      \SemanticsOf{\DNFLens'''} = \SemanticsOf{\AtomLens}$.
    \end{enumerate}
  \end{case}
  \begin{case}[\AtomUnrollstarLeftRule{},\ParallelAtomStructuralRewriteRule{}]
    Let $\AtomLens \OfType \Atom \Leftrightarrow \AtomAlt$.
    Let $\Atom = \StarOf{\DNFRegex}$ and $\StarOf{\DNFRegexAlt}
    \ParallelRewriteAtom
    \DNFOf{\SequenceOf{\EmptyString}} \OrDNF (\DNFRegex'
    \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegex'}})$
    through an application of
    \AtomUnrollstarLeftRule{}.
    Let $\AtomAlt = \StarOf{\DNFRegexAlt}$ and
    \[
      \inferrule*
      {
        \DNFRegexAlt \ParallelRewrite \DNFRegexAlt'
      }
      {
        \StarOf{\DNFRegexAlt} \ParallelRewriteAtom \AtomToDNFOf{\DNFRegexAlt'}
      }
    \]
    through an application of \ParallelAtomStructuralRewriteRule{}.

    From inversion, $\AtomLens = \IterateLensOf{\DNFLens}$,
    and $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt$.

    From Lemma~\ref{lem:copyable_expansions_right_swapless}, there exists
    $DNFRegex'$ such that $\DNFRegex \ParallelRewrite \DNFRegex'$, such that
    there exists a lens $\DNFLens' \OfRewritelessType \DNFRegex'
    \Leftrightarrow \DNFRegexAlt'$, and
    $\SemanticsOf{\DNFLens'} = \SemanticsOf{\DNFLens}$

    \begin{enumerate}
    \item
      \[
        \inferrule*
        {
          \StarOf{\DNFRegex'} \ParallelRewriteAtom
          \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
          (\DNFRegex' \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegex'}})
        }
        {
          \AtomToDNFOf{\StarOf{\DNFRegex'}} \ParallelRewrite
          \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
          (\DNFRegex' \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegex'}})
        }
      \]
      
    \item
      \[
        \inferrule*
        {
          \inferrule*
          {
            \DNFRegexAlt \ParallelRewrite \DNFRegexAlt'
          }
          {
            \StarOf{\DNFRegexAlt} \ParallelRewriteAtom
            \AtomToDNFOf{\StarOf{\DNFRegexAlt'}}
          }
        }
        {
          \AtomToDNFOf{\StarOf{\DNFRegex}} \ParallelRewrite
          \AtomToDNFOf{\StarOf{\DNFRegex'}}
        }
      \]

      By Lemma~\ref{TODO} there exists a $\DNFRegexAlt_1$ such that
      $\DNFRegexAlt \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegexAlt}}
      \ParallelRewrite \DNFRegexAlt_1$,
      and there exists $\DNFLens_1 \OfRewritelessType 
      \DNFRegexAlt' \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegexAlt'}}
      \Leftrightarrow
      \DNFRegexAlt_1$
      where $\DNFLens_1$ has identity semantics.
      
      \[
        \inferrule*
        {
        }
        {
          \DNFOf{\SequenceOf{\EmptyString}} \ParallelRewrite
          \DNFOf{\SequenceOf{\EmptyString}}
        }
      \]

      So by Lemma~\ref{TODO},
      $\DNFOf{\SequenceOf{\EmptyString}}
      \OrDNF
      (\DNFRegexAlt \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegexAlt}})
      \ParallelRewrite
      \DNFOf{\SequenceOf{\EmptyString}} \OrDNF \DNFRegexAlt_1$.
      
      Furthermore, as $\DNFLensOf{\SequenceLensOf{(\EmptyString,\EmptyString)}}
      \OfRewritelessType \DNFOf{\SequenceOf{\EmptyString}} \Leftrightarrow
      \DNFOf{\SequenceOf{\EmptyString}}$ has identity semantics, through
      Lemma~\ref{TODO},
      $\DNFLensOf{\SequenceLensOf{(\EmptyString,\EmptyString)}} \OrDNFLens
      \DNFLens_1 \OfRewritelessType
      \DNFOf{\SequenceOf{\EmptyString}}
      \OrDNF (\DNFRegexAlt' \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegexAlt'}})
      \Leftrightarrow
      \DNFOf{\SequenceOf{\EmptyString}}
      \OrDNF \DNFRegexAlt_1$, which has the identity semantics.

    \item
      Let $\DNFLens'' = \DNFLensOf{\SequenceLensOf{(\EmptyString,\EmptyString)}}
      \OrDNFLens (\DNFLens' \ConcatDNFLens \AtomToDNFLensOf{\IterateLensOf{\DNFLens'}})$
      By Lemma~\ref{lem:iterate-lens-unroll-right},
      $\SemanticsOf{\DNFLens''} = \SemanticsOf{\IterateLensOf{\DNFLens'}} =
      \SemanticsOf{\AtomLens}$.
      By application of Lemma~\ref{TODO} and Lemma~\ref{TODO},
      $\DNFLens'' \OfRewritelessType \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      (\DNFRegex' \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegex'}}) \Leftrightarrow
      \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      (\DNFRegexAlt' \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegexAlt'}})$.
      
      By Lemma~\ref{lem:composition-completeness}, we can compose lenses, so
      consider $\DNFLens'''$, the composition of the lenses
      $\DNFLens''$ and $\DNFLensOf{\SequenceLensOf{(\EmptyString,\EmptyString)}} \OrDNFLens
      \DNFLens_1$.
      $\DNFLens''' \OfRewritelessType \DNFOf{\SequenceOf{\EmptyString}} \OrDNF
      (\DNFRegex' \ConcatDNF \AtomToDNFOf{\StarOf{\DNFRegex'}}) \Leftrightarrow
      \DNFOf{\SequenceOf{\EmptyString}} \OrDNF \DNFRegexAlt_1$.
      Furthermore, as all lenses in the composition except $\DNFLens'''$ are the
      identity, $\SemanticsOf{\DNFLens'''} = \SemanticsOf{\DNFLens} =
      \SemanticsOf{\AtomLens}$.
    \end{enumerate}
  \end{case}

  \begin{case}[\AtomUnrollstarRightRule{},\AtomUnrollstarLeftRule{}]
    This is easily transformed into the case of
    (\AtomUnrollstarLeftRule{},\AtomUnrollstarRightRule{}), and the solution to
    that case transformed to a solution of this case, through two applications
    of Lemma~\ref{lem:closure-inversion}
  \end{case}

  \begin{case}[\AtomUnrollstarRightRule{},\AtomUnrollstarRightRule{}]
    This proceeds in the same way as
    (\AtomUnrollstarLeftRule{},\AtomUnrollstarLeftRule{}).
  \end{case}

  \begin{case}[\AtomUnrollstarRightRule{},\ParallelAtomStructuralRewriteRule{}]
    This proceeds in the same way as
    (\AtomUnrollstarLeftRule{},\ParallelAtomStructuralRewriteRule{})
  \end{case}

  \begin{case}[\ParallelAtomStructuralRewriteRule{},\AtomUnrollstarLeftRule{}]
    This is easily transformed into the case of
    (\AtomUnrollstarLeftRule{},\ParallelAtomStructuralRewriteRule{}), and the
    solution to
    that case transformed to a solution of this case, through two applications
    of Lemma~\ref{lem:closure-inversion}
  \end{case}

  \begin{case}[\ParallelAtomStructuralRewriteRule{},\AtomUnrollstarRightRule{}]
    This is easily transformed into the case of
    (\AtomUnrollstarRightRule{},\ParallelAtomStructuralRewriteRule{}), and the
    solution to
    that case transformed to a solution of this case, through two applications
    of Lemma~\ref{lem:closure-inversion}
  \end{case}

  \begin{case}[\ParallelAtomStructuralRewriteRule{},\ParallelAtomStructuralRewriteRule{}]
    Let $\AtomLens \OfType \Atom \Leftrightarrow \AtomAlt$.
    Let $\Atom = \StarOf{\DNFRegex}$ and
    \[
      \inferrule*
      {
        \DNFRegex \ParallelRewrite \DNFRegex'
      }
      {
        \StarOf{\DNFRegex} \ParallelRewrite \AtomToDNFOf{\DNFRegex'}
      }
    \]
    through an application of
    \AtomUnrollstarLeftRule{}.
    Let $\AtomAlt = \StarOf{\DNFRegexAlt}$ and
    \[
      \inferrule*
      {
        \DNFRegexAlt \ParallelRewrite \DNFRegexAlt'
      }
      {
        \StarOf{\DNFRegexAlt} \ParallelRewriteAtom \AtomToDNFOf{\DNFRegexAlt'}
      }
    \]
    through an application of \ParallelAtomStructuralRewriteRule{}.

    From inversion, $\AtomLens = \IterateLensOf{\DNFLens}$,
    and $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt$.

    By IH, there exists $\DNFRegex''$, $\DNFRegexAlt''$, and $\DNFLens''$ such that
    $\DNFRegex' \ParallelRewrite \DNFRegex''$, $\DNFRegexAlt' \ParallelRewrite
    \DNFRegexAlt''$, and $\DNFLens'' \OfRewritelessType \DNFRegex''
    \Leftrightarrow \DNFRegexAlt''$ with $\SemanticsOf{\DNFLens''} =
    \SemanticsOf{\DNFLens}$.

    \begin{enumerate}
    \item
      \[
        \inferrule*
        {
          \inferrule*
          {
            \DNFRegex' \ParallelRewrite \DNFRegex''
          }
          {
            \StarOf{\DNFRegex'} \ParallelRewriteAtom
            \AtomToDNFOf{\StarOf{\DNFRegex''}}
          }
        }
        {
          \AtomToDNFOf{\StarOf{\DNFRegex'}} \ParallelRewrite
          \AtomToDNFOf{\StarOf{\DNFRegex''}}
        }
      \]
      
    \item
      \[
        \inferrule*
        {
          \inferrule*
          {
            \DNFRegexAlt' \ParallelRewrite \DNFRegexAlt''
          }
          {
            \StarOf{\DNFRegexAlt'} \ParallelRewriteAtom
            \AtomToDNFOf{\StarOf{\DNFRegexAlt''}}
          }
        }
        {
          \AtomToDNFOf{\StarOf{\DNFRegexAlt'}} \ParallelRewrite
          \AtomToDNFOf{\StarOf{\DNFRegexAlt''}}
        }
      \]

    \item
      As $\SemanticsOf{\DNFLens} = \SemanticsOf{\DNFLens''}$,
      $\SemanticsOf{\AtomLens} = \SemanticsOf{\IterateLensOf{\DNFLens}} =
      \SemanticsOf{\IterateLensOf{DNFLens''}}$.
      Furthermore, as $\LanguageOf{\DNFRegex''} = \LanguageOf{\DNFRegex}$ and
      $\LanguageOf{\DNFRegexAlt''} = \LanguageOf{\DNFRegex''}$,
      $\UnambigItOf{\DNFRegexAlt''}$ and $\UnambigItOf{\DNFRegex''}$.
      This means $\IterateLensOf{\DNFLens''} \OfRewritelessType
      \StarOf{\DNFRegex''} \Leftrightarrow \StarOf{\DNFRegexAlt''}$
      From Lemma~\ref{lem:typ_sem_todnflens},
      $\SemanticsOf{\IterateLensOf{\DNFLens''}} =
      \SemanticsOf{\AtomToDNFLensOf{\IterateLensOf{\DNFLens''}}}$, and
      $\AtomToDNFLensOf{\IterateLensOf{\IterateLensOf{\DNFLens''}}}
      \OfRewritelessType \AtomToDNFOf{\StarOf{\DNFRegex''}} \Leftrightarrow
      \AtomToDNFOf{\StarOf{\DNFRegexAlt''}}$.
    \end{enumerate}
  \end{case}

  \begin{case}[\IdentityRewriteRule{},\IdentityRewriteRule{}]
    Let $\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$.
    Let $\DNFRegex \ParallelRewrite \DNFRegex$ through an application of
    \AtomUnrollstarLeftRule{}.
    Let $\DNFRegexAlt \ParallelRewrite \DNFRegexAlt$ through an application of
    \AtomUnrollstarLeftRule{}.
    \begin{enumerate}
    \item
      \[
        \inferrule*
        {
        }
        {
          \DNFRegex \ParallelRewrite \DNFRegex
        }
      \]
    \item
      \[
        \inferrule*
        {
        }
        {
          \DNFRegexAlt \ParallelRewrite \DNFRegexAlt
        }
      \]
    \item
      $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt$,
      and $\SemanticsOf{\DNFLens} = \SemanticsOf{\DNFLens}$.
    \end{enumerate}
  \end{case}
  
  \begin{case}[\IdentityRewriteRule{},\ParallelDNFStructuralRewriteRule{}]
    Let $\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$.
    Let $\DNFRegex \ParallelRewrite \DNFRegex$ through an application of
    \AtomUnrollstarLeftRule{}.
    Let $\DNFRegexAlt \ParallelRewrite \DNFRegexAlt'$ through an application of
    \ParallelDNFStructuralRewriteRule{}.

    By Lemma~\ref{lem:mirroring-property-parallel-swapless}, there exists
    $\DNFLens'$, $\DNFRegex'$ such that $\DNFRegex \ParallelRewrite \DNFRegex'$,
    $\DNFLens' \OfRewritelessType \DNFRegex' \Leftrightarrow \DNFRegexAlt'$,
    $\SemanticsOf{\DNFLens} = \SemanticsOf{\DNFLens'}$

    \begin{enumerate}
    \item $\DNFRegex \ParallelRewrite \DNFRegex'$
    \item
      \[
        \inferrule*
        {
        }
        {
          \DNFRegex' \ParallelRewrite \DNFRegex'
        }
      \]
    \item
      $\DNFLens' \OfRewritelessType \DNFRegex' \Leftrightarrow \DNFRegexAlt'$
      and
      $\SemanticsOf{\DNFLens} = \SemanticsOf{\DNFLens'}$
    \end{enumerate}
  \end{case}

  \begin{case}[\ParallelDNFStructuralRewriteRule{},\IdentityRewriteRule{}]
    This is easily transformed into the case of
    (\IdentityRewriteRule{},\ParallelDNFStructuralRewriteRule{}), and the
    solution to
    that case transformed to a solution of this case, through two applications
    of Lemma~\ref{lem:closure-inversion}
  \end{case}

  \begin{case}[\ParallelDNFStructuralRewriteRule{},\ParallelDNFStructuralRewriteRule{}]
    Let $\DNFLens \OfType \DNFRegex \Leftrightarrow \DNFRegexAlt$.
    Let $\DNFRegex \ParallelRewrite \DNFRegex$ through an application of
    \AtomUnrollstarLeftRule{}.
    Let $\DNFRegexAlt \ParallelRewrite \DNFRegexAlt'$ through an application of
    \ParallelDNFStructuralRewriteRule{}.

    By inversion,
    \[
      \inferrule*
      {
        \SequenceLens_1 \OfRewritelessType \Sequence_1 \Leftrightarrow \SequenceAlt_1\\
        \ldots\\
        \SequenceLens_n \OfRewritelessType \Sequence_n \Leftrightarrow \SequenceAlt_n\\\\
        \sigma \in \PermutationSetOf{n}\\
        i \neq j \Rightarrow \LanguageOf{\Sequence_{i}} \cap \LanguageOf{\Sequence_{j}}=\emptyset\\
        i \neq j \Rightarrow \LanguageOf{\SequenceAlt_{i}} \cap \LanguageOf{\SequenceAlt_{j}}=\emptyset\\
      }
      {
        (\DNFLensOf{\SequenceLens_1\DNFLensSep\ldots\DNFLensSep\SequenceLens_n},\sigma) \OfRewritelessType\\
        \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}
        \Leftrightarrow \DNFOf{\SequenceAlt_{\sigma(1)}\DNFSep\ldots\DNFSep\SequenceAlt_{\sigma(n)}}
      }
    \]

    Also by inversion
    \[
      \inferrule*
      {
        \AtomLens_{i,1} \OfRewritelessType \Atom_1 \Leftrightarrow \AtomAlt_{i,1}\\
        \ldots\\
        \AtomLens_{i,n_i} \OfRewritelessType \Atom_n \Leftrightarrow \AtomAlt_{i,n_i}\\
        \sigma_i \in \PermutationSetOf{n_i}\\
        \UnambigConcat\SequenceOf{\String_{i,0}\SequenceSep\Atom_{i,1}\SequenceSep\ldots\SequenceSep\Atom_{i,n_i}\SequenceSep\String_{i,n_i}}\\
        \UnambigConcat\SequenceOf{\StringAlt_{i,0}\SequenceSep\AtomAlt_{i,\sigma_i(1)}\SequenceSep\ldots\SequenceSep\AtomAlt_{i,\sigma_i(n_i)}\SequenceSep\StringAlt_{i,n_i}}
      }
      {
        (\SequenceLensOf{(\String_{i,0},\StringAlt_{i,0})\SequenceLensSep\AtomLens_{i,1}\SequenceLensSep\ldots\SequenceLensSep\AtomLens_{i,n_i}\SequenceLensSep(\String_{i,n_i},\StringAlt_{i,n_i})},\sigma_i) \OfRewritelessType
        \SequenceOf{\String_{i,0}\SequenceSep\Atom_{i,1}\SequenceSep\ldots\SequenceSep\Atom_{i,n_i}\SequenceSep\String_{i,n_i}}\Leftrightarrow
        \SequenceOf{\StringAlt_{i,0}\SequenceSep\AtomAlt_{i,\sigma_i(1)}\SequenceSep\ldots\SequenceSep\AtomAlt_{i,\sigma_i(n_i)}\SequenceSep\StringAlt_{i,n_i}}
      }
    \]

    where $\DNFLens =
    \DNFLensOf{\SequenceLens_1\DNFLensSep\ldots\DNFLensSep\SequenceLens_n},\sigma)$,
    $\SequenceLens_i =
    (\SequenceLensOf{(\String_{i,0},\StringAlt_{i,0})\SequenceLensSep\AtomLens_{i,1}\SequenceLensSep\ldots\SequenceLensSep\AtomLens_{i,n_i}\SequenceLensSep(\String_{i,n_i},\StringAlt_{i,n_i})},\sigma_i)$,
    $\DNFRegex = \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_n}$,
    $\DNFRegexAlt =
    \DNFOf{\SequenceAlt_{\sigma(1)}\DNFSep\ldots\DNFSep\SequenceAlt_{\sigma(n)}}$,
    $\Sequence_i =
    \SequenceOf{\String_{i,0}\SequenceSep\Atom_{i,1}\SequenceSep\ldots\SequenceSep\Atom_{i,n_i}\SequenceSep\String_{i,n_i}}$, and
    $\SequenceAlt_i =
    \SequenceOf{\StringAlt_{i,0}\SequenceSep\AtomAlt_{i,\sigma_i(1)}\SequenceSep\ldots\SequenceSep\AtomAlt_{i,\sigma_i(n_i)}\SequenceSep\StringAlt_{i,n_i}}$

    \[
      \inferrule*
      {
        \DNFRegex = \DNFOf{\Sequence_1;\ldots;\Sequence_n}\\
        \forall i. \Sequence_i =
        \SequenceOf{\String_{i,0};\Atom_{i,1};\ldots;\Atom_{i,n_i};\String_{i,n_i}}\\
        \forall i,j. \Atom_{i,j} \ParallelRewriteAtom \DNFRegex_{i,j}\\
        \forall i. \DNFRegex_i = \DNFOf{\SequenceOf{\String_{i,0}}} \ConcatDNF \DNFRegex_{i,1}
        \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,n_i} \ConcatDNF
        \DNFOf{\SequenceOf{\String_{i,n_i}}}
      }
      {
        \DNFRegex \ParallelRewrite \DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n
      }
    \]

    \[
      \inferrule*
      {
        \DNFRegexAlt = \DNFOf{\SequenceAlt_{\sigma(1)};\ldots;\SequenceAlt_{\sigma(n)}}\\
        \forall i. \SequenceAlt_{\sigma(i)} =
        \SequenceOf{\StringAlt_{\sigma(i),0};\AtomAlt_{\sigma(i),\sigma_i(1)};\ldots;\AtomAlt_{\sigma(i),\sigma_i(n_i)};\StringAlt_{\sigma(i),n_i}}\\
        \forall i,j. \AtomAlt_{\sigma(i),\sigma_i(j)} \ParallelRewriteAtom \DNFRegexAlt_{\sigma(i),\sigma_i(j)}\\
        \forall i. \DNFRegexAlt_{\sigma(i)} = \DNFOf{\SequenceOf{\String_{\sigma(i),0}}} \ConcatDNF \DNFRegex_{\sigma(i),\sigma_i(1)}
        \ConcatDNF \ldots \ConcatDNF \DNFRegex_{\sigma(i),\sigma_i(n_i)} \ConcatDNF
        \DNFOf{\SequenceOf{\String_{\sigma(i),n_i}}}
      }
      {
        \DNFRegexAlt \ParallelRewrite \DNFRegexAlt_{\sigma(1)} \OrDNF \ldots \OrDNF \DNFRegexAlt_{\sigma(n)}
      }
    \]

    By IH, as $\Atom_{i,j} \ParallelRewrite \DNFRegex_{i,j}$,
    $\AtomAlt_{i,j} \ParallelRewrite \DNFRegexAlt_{i,j}$, and
    $\AtomLens_{i,j} \OfRewritelessType
    \Atom_{i,j} \Leftrightarrow \AtomAlt_{i,j}$, then there exists
    $\DNFRegex_{i,j}'$, $\DNFRegexAlt_{i,j}'$, and $\DNFLens_{i,j}$ such that
    $\DNFRegex_{i,j} \ParallelRewrite \DNFRegex_{i,j}'$,
    $\DNFRegexAlt_{i,j} \ParallelRewrite \DNFRegexAlt_{i,j}'$, and
    $\DNFLens_{i,j} \OfRewritelessType \DNFRegex_{i,j} \Leftrightarrow
    \DNFRegexAlt_{i,j}$, where $\SemanticsOf{\DNFLens_{i,j}} =
    \SemanticsOf{\AtomLens_{i,j}}$.
    \begin{enumerate}
    \item
      $\DNFRegex_{i,j} \ParallelRewrite \DNFRegex_{i,j}'$, for all $i,j$.
      \[
        \inferrule*
        {
        }
        {
          \DNFOf{\SequenceOf{\String_{i,j}}} \ParallelRewrite
          \DNFOf{\SequenceOf{\String_{i,j}}}
        }
      \]

      Define $\DNFRegex_i' =
      \DNFOf{\SequenceOf{\String_{i,0}}} \ConcatDNF \DNFRegex_{i,1}'
      \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,n_i}' \ConcatDNF
      \DNFOf{\SequenceOf{\String_{i,n_i}}}$.

      By repeated application of Lemma~\ref{TODO}, there exists $\DNFRegex_i''$
      such that $\DNFRegex_i =
      \DNFOf{\SequenceOf{\String_{i,0}}} \ConcatDNF \DNFRegex_{i,1}
      \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,n_i} \ConcatDNF
      \DNFOf{\SequenceOf{\String_{i,n_i}}} \ParallelRewrite \DNFRegex_i''$,
      and there exists $\DNFLens_i$ such that
      $\DNFLens_i \OfRewritelessType \DNFRegex_i'' \Leftrightarrow
      \DNFRegex_i'$, and $\DNFLens_i$ has the identity
      semantics on $\LanguageOf{\DNFRegex_i}$.

      By repeated application of Lemma~\ref{TODO},
      $\DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n \ParallelRewrite
      \DNFRegex_1' \OrDNF \ldots \OrDNF \DNFRegex_n'$.
      Furthermore, through application of Lemma~\ref{lem:typ_sem_or},
      $\DNFLens_1 \OrDNFLens \ldots \OrDNFLens \DNFLens_n \OfRewritelessType
      \DNFRegex_1'' \OrDNF \ldots \OrDNF \DNFRegex_n'' \Leftrightarrow \DNFRegex_1'
      \OrDNF \ldots \OrDNF \DNFRegex_n'$.
      
    \item
      $\DNFRegexAlt_{\sigma(i),\sigma_i(j)} \ParallelRewrite
      \DNFRegexAlt_{\sigma(i),\sigma_i(j)}'$, for all $i,j$.
      \[
        \inferrule*
        {
        }
        {
          \DNFOf{\SequenceOf{\String_{\sigma(i),j}}} \ParallelRewrite
          \DNFOf{\SequenceOf{\String_{\sigma(i),j}}}
        }
      \]

      Define $\DNFRegexAlt_{\sigma(i)}' =
      \DNFOf{\SequenceOf{\String_{\sigma(i),0}}} \ConcatDNF
      \DNFRegex_{\sigma(i),\sigma_i(1)}'
      \ConcatDNF \ldots \ConcatDNF \DNFRegex_{\sigma(i),\sigma_i(n_i)}' \ConcatDNF
      \DNFOf{\SequenceOf{\String_{\sigma(i),\sigma_i(n_i)}}}$.
      
      By repeated application of Lemma~\ref{TODO}, there exists
      $\DNFRegexAlt_{\sigma(i)}''$ such that $\DNFRegexAlt_{\sigma(i)} =
      \DNFOf{\SequenceOf{\StringAlt_{\sigma(i),0}}} \ConcatDNF \DNFRegexAlt_{\sigma(i),\sigma_i(1)}
      \ConcatDNF \ldots \ConcatDNF \DNFRegexAlt_{\sigma(i),\sigma_i(n_i)} \ConcatDNF
      \DNFOf{\SequenceOf{\StringAlt_{\sigma(i),n_i}}} \ParallelRewrite \DNFRegexAlt_i''$,
      and there exists $\DNFLens_{\sigma(i)}'$ such that
      $\DNFLens_{\sigma(i)}' \OfRewritelessType
      \DNFRegexAlt_{\sigma(i)}' \Leftrightarrow
      \DNFRegexAlt_{\sigma(i)}''$, and $\DNFLens_{\sigma(i)}'$ has the identity
      semantics on $\LanguageOf{\DNFRegexAlt_{\sigma(i)}}$.
      
      By repeated application of Lemma~\ref{TODO},
      $\DNFRegexAlt_{\sigma(1)} \OrDNF \ldots \OrDNF \DNFRegexAlt_{\sigma(n)}
      \ParallelRewrite
      \DNFRegexAlt_{\sigma(1)}'' \OrDNF \ldots \OrDNF \DNFRegexAlt_{\sigma(n)}''$.
      Furthermore, through application of Lemma~\ref{lem:typ_sem_or},
      $\DNFLens_{\sigma(1)}' \OrDNFLens \ldots \OrDNFLens \DNFLens_{\sigma(n)}'
      \OfRewritelessType
      \DNFRegexAlt_{\sigma(1)}' \OrDNF \ldots \OrDNF \DNFRegexAlt_{\sigma(n)}'
      \Leftrightarrow
      \DNFRegexAlt_{\sigma(1)}'' \OrDNF \ldots \OrDNF
      \DNFRegexAlt_{\sigma(1)}''$.

    \item
      Consider the permutation $\overline{\sigma_i}$, the permutation on
      $2*n_i+1$ elements, defined as
      $\overline{\sigma_i}(j) =
      \begin{cases*}
        j & if $j$ is odd\\
        2*(\sigma_i(j/2)) & if $j$ is even
      \end{cases*}$.

      As $\LanguageOf{\Atom_{i,j}} = \LanguageOf{\DNFRegex_{i,j}'}$, and
      $\LanguageOf{\AtomAlt_{i,j}} = \LanguageOf{\DNFRegexAlt_{i,j}'}$, then
      $\SequenceUnambigConcatOf{\DNFOf{\SequenceOf{\String_{i,0}}},
        \DNFRegex_{i,1}',\ldots,\DNFRegex_{i,n_i}',\DNFOf{\SequenceOf{\String_{i,n_i}}}}$.
      and
      
      $\SequenceUnambigConcatOf{\DNFOf{\SequenceOf{\StringAlt_{i,0}}},
        \DNFRegexAlt_{i,\sigma_i(1)}',\ldots,\DNFRegexAlt_{i,\sigma_i(n_i)}',
        \DNFOf{\SequenceOf{\StringAlt_{i,n_i}}}}$.
      Then by Lemma~\ref{}, with the permutation $\overline{\sigma_i}$,
      there exists a DNF lens
      $\overline{\DNFLens_i} \OfRewritelessType \DNFRegex_i' \Leftrightarrow
      \DNFRegexAlt_i'$,
      with $\SemanticsOf{\overline{\DNFLens_i}} =
      \SetOf{(\String_{i,0}\String_{i,1}'\ldots\String_{i,n_i}'\String_{i,n_i},
        \StringAlt_{i,0}\StringAlt_{i,\sigma_i(1)}'\ldots\StringAlt_{i,\sigma_i(n_i)}'\StringAlt_{i,n_i})
        \SuchThat
        (\String_{i,j}',\StringAlt_{i,j}') \in \SemanticsOf{\DNFLens_{i,j}}} =
      \SemanticsOf{\DNFLens} =
      \SetOf{(\String_{i,0}\String_{i,1}'\ldots\String_{i,n_i}'\String_{i,n_i},
        \StringAlt_{i,0}\StringAlt_{i,\sigma_i(1)}'\ldots\StringAlt_{i,\sigma_i(n_i)}'\StringAlt_{i,n_i})
        \SuchThat
        (\String_{i,j}',\StringAlt_{i,j}') \in \SemanticsOf{\AtomLens_{i,j}}} =
      \SemanticsOf{\SequenceLens_i}$.

      As $\LanguageOf{\DNFRegex_i'} = \LanguageOf{\Sequence_i}$,
      $i \neq j \BooleanImplies \LanguageOf{\DNFRegex_i} \Intersect
      \LanguageOf{\DNFRegex_j} = \SetOf{}$.
      By Lemma~\ref{}, with the permutation $\sigma$, there exists a DNF lens
      $\overline{\DNFLens} = \OfRewritelessType
      \DNFRegex_1' \OrDNF \ldots \OrDNF \DNFRegex_n'
      \Leftrightarrow
      \DNFRegexAlt_{\sigma(1)}' \OrDNF \ldots \OrDNF \DNFRegexAlt_{\sigma(n)}'$,
      with $\SemanticsOf{\overline{\DNFLens}} =
      \SetOf{(\String,\StringAlt) \SuchThat \Exists i. (\String,\StringAlt) \in
        \SemanticsOf{\overline{\DNFLens_i}}} =
      \SetOf{(\String,\StringAlt) \SuchThat \Exists i. (\String,\StringAlt) \in
        \SemanticsOf{\SequenceLens_i}} =
      \SemanticsOf{\DNFLens}$.

      Consider the $\DNFLens'$, the composition of
      $\DNFLens_1 \OrDNF \ldots \OrDNF \DNFLens_n$, $\overline{\DNFLens}$, and
      $\DNFLens_1' \OrDNF \ldots \OrDNF \DNFLens_n$,
      $\DNFLens' \OfRewritelessType \DNFRegex_1'' \OrDNF \ldots \OrDNF
      \DNFRegex_n'' \Leftrightarrow
      \DNFRegexAlt_1'' \OrDNF \ldots \OrDNF \DNFRegex_n''$.
      Furthermore, all but $\overline{\DNFLens}$ are identity,
      $\SemanticsOf{\DNFLens'''} = \SemanticsOf{\overline{\DNFLens}} =
      \SemanticsOf{\DNFLens}$.
    \end{enumerate}
  \end{case}
\end{proof}

\begin{theorem}[Confluence of Parallel Rewriting Without Reordering]
  \label{thm:parallel_confluence_noswap}
  For all lenses $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$,
  $\IsConfluentWithPropertyOf{\ParallelRewrite}{\DNFLensHasSemanticsOf{\Lens}}$.
\end{theorem}
\begin{proof}
  Let $\DNFRegex \DNFLensHasSemanticsOf{\Lens} \DNFRegexAlt$.
  This means there exists some $\DNFLens \OfRewritelessType \DNFRegex
  \Leftrightarrow \DNFRegexAlt$ such that $\SemanticsOf{\DNFLens} =
  \SemanticsOf{\Lens}$.
  Let $\DNFRegex \ParallelRewrite \DNFRegex'$ and $\DNFRegexAlt \ParallelRewrite
  \DNFRegexAlt'$.  From Lemma~\ref{lem:pre-confluence}, there exists a
  $\DNFRegex''$, $\DNFRegexAlt''$, $\DNFLens'$ such that $\DNFRegex'
  \ParallelRewrite
  \DNFRegex''$, $\DNFRegexAlt' \ParallelRewrite \DNFRegexAlt''$, $\DNFLens'
  \OfType
  \DNFRegex'' \Leftrightarrow \DNFRegexAlt''$, and $\SemanticsOf{\DNFLens'} =
  \SemanticsOf{\DNFLens}$.  Because $\SemanticsOf{\DNFLens'} =
  \SemanticsOf{\DNFLens} = \SemanticsOf{\Lens}$, $\DNFRegex''
  \DNFLensHasSemanticsOf{\Lens} \DNFRegexAlt''$.
\end{proof}

\begin{lemma}[Identity is a left propagator]
  \label{lem:id-left-prop}
  If $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ is a lens,
  then $\DNFLensHasSemanticsOf{\IdentityLensOf{\Regex}}$ is a left propagator
  for $\DNFLensHasSemanticsOf{\Lens}$ with respect to $\ParallelRewrite$.
\end{lemma}
\begin{proof}
  If $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ is a lens,
  by Lemma~\ref{lem:strong-unambig-lens-types},
  $\Regex$ is strongly unambiguous.
  By Lemma~\ref{lem:retaining-unambiguity-todnf}, $\ToDNFRegexOf{\Regex}$ is
  strongly unambiguous.
  As such, $\IdentityLensOf{\Regex} \OfType \Regex \Leftrightarrow \Regex$.
  Consider $\DNFLensHasSemanticsOf{\IdentityLensOf{\Regex}}$.
  
  By Lemma~\ref{lem:mirroring-property-parallel-swapless},
  $\IsMirroringWithPropertyOf{\ParallelRewrite}{\DNFLensHasSemanticsOf{\IdentityLensOf{\Regex}}}$.
  
  By Lemma~\ref{lem:thm:parallel_confluence_noswap},
  $\IsConfluentWithPropertyOf{\ParallelRewrite}{\DNFLensHasSemanticsOf{\IdentityLensOf{\Regex}}}$.
  
  Let $\DNFRegex_1 \DNFLensHasSemanticsOf{\IdentityLensOf{\Regex}} \DNFRegex_2$,
  and $\DNFRegex_2 \DNFLensHasSemanticsOf{\IdentityLensOf{\Regex}} \DNFRegex_3$.
  So there exists $\DNFLens_1$, $\DNFLens_2$ such that
  $\DNFLens_1 \OfRewritelessType \DNFRegex_1 \Leftrightarrow \DNFRegex_2$ and
  $\DNFLens_2 \OfRewritelessType \DNFRegex_2 \Leftrightarrow \DNFRegex_3$,
  where $\SemanticsOf{\DNFLens_1} = \SemanticsOf{\IdentityLensOf{\Regex}} =
  \SemanticsOf{\DNFLens_2}$.
  By Lemma~\ref{lem:composition-completeness}, there exists
  $\DNFLens_3 \OfRewritelessType \DNFRegex_1 \Leftrightarrow \DNFRegex_3$, with
  semantics $\SemanticsOf{\DNFLens_3} = \SemanticsOf{\IdentityLensOf{\Regex}}$,
  as the semantics of each side of the composition was the identity relation
  on $\LanguageOf{\Regex}$.  This means
  $\DNFRegex_1 \DNFLensHasSemanticsOf{\IdentityLensOf{\Regex}} \DNFRegex_3$.

  Let $\DNFRegex \DNFLensHasSemanticsOf{\IdentityLensOf{\Regex}} \DNFRegexAlt$.
  So there exists $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow
  \DNFRegexAlt$.  By Lemma~\ref{lem:lens-bij},
  $\SemanticsOf{\Lens}$ is a bijection between $\LanguageOf{\Regex}$ and
  $\LanguageOf{\RegexAlt}$.
  As $\SemanticsOf{\DNFLens} = \SemanticsOf{\Lens}$,
  $\SemanticsOf{\DNFLens}$ is a bijection between $\LanguageOf{\Regex}$ and
  $\LanguageOf{\RegexAlt}$.  $\SemanticsOf{\DNFLens}$ is a bijection between
  $\LanguageOf{\DNFRegex}$ and $\LanguageOf{\DNFRegexAlt}$, by Lemma~\ref{lem:rw-dnf-lens-bij}, so
  $\LanguageOf{\DNFRegex} = \LanguageOf{\Regex}$ and
  $\LanguageOf{\DNFRegexAlt} = \LanguageOf{\RegexAlt}$.
  As $\DNFRegex$ is strongly unambiguous, there exists an identity lens
  by Lemma~\ref{lem:strongly-unambiguous-identity-expressible}
  $\IdentityLens_L \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegex$,
  such that $\SemanticsOf{\IdentityLens_L} = \SetOf{(\String,\String) \SuchThat
    \String \in \LanguageOf{\DNFRegex}} = \SetOf{(\String,\String) \SuchThat
    \String \in \LanguageOf{\Regex}} = \SemanticsOf{\IdentityLensOf{\Regex}}$.
  This means $\DNFRegex \DNFLensHasSemanticsOf{\IdentityLensOf{\Regex}} \DNFRegex$.
  As $\DNFRegexAlt$ is strongly unambiguous, there exists an identity lens
  $\IdentityLens_R \OfRewritelessType \DNFRegexAlt \Leftrightarrow \DNFRegexAlt$,
  such that $\SemanticsOf{\IdentityLens_R} = \SetOf{(\String,\String) \SuchThat
    \String \in \LanguageOf{\DNFRegexAlt}} = \SetOf{(\String,\String) \SuchThat
    \String \in \LanguageOf{\RegexAlt}} = \SemanticsOf{\IdentityLensOf{\RegexAlt}}$.
  This means $\DNFRegexAlt \DNFLensHasSemanticsOf{\IdentityLensOf{\Regex}} \DNFRegexAlt$.

  Let $\DNFRegex \DNFLensHasSemanticsOf{\Lens} \DNFRegexAlt$.
  This means there exists $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow
  \DNFRegexAlt$.
  This means that $\DNFRegex$ is strongly unambiguous, so there exists a DNF
  lens
  $\DNFLens' \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegex$,
  with $\SemanticsOf{\DNFLens'} = \SetOf{(\String,\String) \SuchThat \String \in
    \LanguageOf{\DNFRegex}}$.  By the same logic as above,
  $\LanguageOf{\DNFRegex} = \LanguageOf{\Regex}$, so $\SemanticsOf{\DNFLens'} =
  \SetOf{(\String,\String) \SuchThat \String \in \LanguageOf{\Regex}} =
  \SemanticsOf{\IdentityLensOf{\Regex}}$.
\end{proof}

\begin{lemma}[Identity is a right propagator]
  \label{lem:id-right-prop}
  If $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ is a lens,
  then $\DNFLensHasSemanticsOf{\IdentityLensOf{\RegexAlt}}$ is a right propagator
  for $\DNFLensHasSemanticsOf{\Lens}$ with respect to $\ParallelRewrite$.
\end{lemma}
\begin{proof}
  By a symmetric argument to Lemma~\ref{lem:id-left-prop}.
\end{proof}

\begin{lemma}[Confluence of Starred Parallel Rewriting Without Reordering]
  \label{thm:star_parallel_confluence}
  For all lenses $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$,
  $\IsConfluentWithPropertyOf{\StarOf{\ParallelRewrite}}{\DNFLensHasSemanticsOf{\Lens}}$.
\end{lemma}
\begin{proof}
  By Lemma~\ref{lem:mirroring-property-parallel-swapless}
  For all lenses $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$,
  $\IsMirroringWithPropertyOf{\ParallelRewrite}{\DNFLensHasSemanticsOf{\Lens}}$.
  For all lenses $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$,
  $\IsConfluentWithPropertyOf{\ParallelRewrite}{\DNFLensHasSemanticsOf{\Lens}}$.
  By Lemma~\ref{lem:id-left-prop},
  $\DNFLensHasSemanticsOf{\IdentityLensOf{\Regex}}$ is a left propagator for
  $\DNFLensHasSemanticsOf{\Lens}$.
  By Lemma~\ref{lem:id-right-prop},
  $\DNFLensHasSemanticsOf{\IdentityLensOf{\Regex}}$ is a right propagator for
  $\DNFLensHasSemanticsOf{\Lens}$.
  By Theorem~\ref{thm:starred-confluence},
  $\IsConfluentWithPropertyOf{\StarOf{\ParallelRewrite}}{\DNFLensHasSemanticsOf{\Lens}}$.
\end{proof}

\begin{lemma}
  \label{lem:identity-atom-in-parallel}
  $\Atom \ParallelRewriteAtom \AtomToDNFOf{\Atom}$.
\end{lemma}
\begin{proof}
  $\Atom = \StarOf{\DNFRegex}$ for some DNF regular expression.
  Consider the derivation
  \[
    \inferrule*
    {
      \DNFRegex \ParallelRewrite \DNFRegex
    }
    {
      \StarOf{\DNFRegex} \ParallelRewrite \AtomToDNFOf{\StarOf{\DNFRegex}}
    }
  \] as desired.
\end{proof}

\begin{lemma}
  \label{lem:serial-expressible-in-parallel}
  \leavevmode
  \begin{itemize}
  \item If $\Atom \Rewrite \DNFRegexAlt$, then
    $\Atom \ParallelRewrite \DNFRegexAlt$.
  \item If $\DNFRegex \Rewrite \DNFRegexAlt$, then
    $\DNFRegex \ParallelRewrite \DNFRegexAlt$.
  \end{itemize}
\end{lemma}
\begin{proof}
  By mutual induction on the derivation of $\Rewrite$ and $\RewriteAtom$

  \begin{case}[\AtomUnrollstarLeftRule{}]
    \[
      \inferrule*
      {
      }
      {
        \StarOf{\DNFRegex}\RewriteAtom
        \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}{(\ConcatDNFOf{\DNFRegex}{\AtomToDNFOf{\StarOf{\DNFRegex}}})}
      }
    \]

    Consider the derivation
    
    \[
      \inferrule*
      {
      }
      {
        \StarOf{\DNFRegex}\ParallelRewriteAtom
        \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}{(\ConcatDNFOf{\DNFRegex}{\AtomToDNFOf{\StarOf{\DNFRegex}}})}
      }
    \]
  \end{case}

  \begin{case}[\AtomUnrollstarRightRule{}]
    \[
      \inferrule*
      {
      }
      {
        \StarOf{\DNFRegex}\RewriteAtom
        \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}{(\ConcatDNFOf{\AtomToDNFOf{\StarOf{\DNFRegex}}}{\DNFRegex})}
      }
    \]

    Consider the derivation
    
    \[
      \inferrule*
      {
      }
      {
        \StarOf{\DNFRegex}\ParallelRewriteAtom
        \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}{(\ConcatDNFOf{\AtomToDNFOf{\StarOf{\DNFRegex}}}{\DNFRegex})}
      }
    \]
  \end{case}

  \begin{case}[\AtomStructuralRewriteRule{}]
    \[
      \inferrule*
      {
        \DNFRegex \Rewrite \DNFRegexAlt'
      }
      {
        \StarOf{\DNFRegex} \Rewrite \AtomToDNFOf{\StarOf{\DNFRegexAlt'}}
      }
    \]
    
    By IH, $\DNFRegex \ParallelRewrite \DNFRegexAlt'$, so consider the
    derivation
    \[
      \inferrule*
      {
        \DNFRegex \ParallelRewrite \DNFRegexAlt'
      }
      {
        \StarOf{\DNFRegex} \ParallelRewrite \AtomToDNFOf{\StarOf{\DNFRegexAlt'}}
      }
    \]
  \end{case}

  \begin{case}[\DNFStructuralRewriteRule{}]
    \[
      \inferrule*
      {
        \Atom_j \RewriteAtom \DNFRegex
      }
      {
        \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
        \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}
        \ConcatDNF \AtomToDNFOf{\Atom_j} \ConcatDNF
        \DNFOf{\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m}}
        \OrDNF \DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n}\Rewrite\\
        \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
        \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}\ConcatDNF\DNFRegex\ConcatDNF\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m} \OrDNF
        \DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n}
      }
    \]

    Define $\Sequence_i$ as
    $\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m}$.
    Through the definition of $\OrDNF$ and $\ConcatDNF$,
    $\DNFRegex = \DNFOf{\Sequence_1;\ldots;\Sequence_n}$.
    Define $\Sequence_k =
    \SequenceOf{\String_{k,0};\Atom_{k,1};\ldots;\Atom_{k,n_k};\String_{k,n_k}}$.
    So, in particular, $\Atom_{i,j} = \Atom_j$, and $n_i = m$.
    Define $\DNFRegex_{k,l} =
    \begin{cases*}
      \DNFRegex & if $(k,l) = (i,j)$\\
      \AtomToDNFOf{\Atom_{k,l}} & otherwise
    \end{cases*}$
    So, for all $k,l$, $\Atom_{k,l} \ParallelRewriteAtom \DNFRegex_{k,l}$, as if
    $(k,l) = (i,j)$, then by assumption
    $\Atom_{i,j} \ParallelRewriteAtom \DNFRegex$, and otherwise,
    from Lemma~\ref{lem:identity-atom-in-parallel},
    $\Atom_{k,l} \ParallelRewriteAtom
    \AtomToDNFOf{\Atom_{k,l}}$.
    
    Define $\DNFRegex_k$ as $\DNFOf{\SequenceOf{\String_{k,0}}} \ConcatDNF \DNFRegex_{k,1}
    \ConcatDNF \ldots \ConcatDNF \DNFRegex_{k,n_k} \ConcatDNF
    \DNFOf{\SequenceOf{\String_{k,n_k}}}$.
    
    \[
      \inferrule*
      {
        \DNFRegex = \DNFOf{\Sequence_1;\ldots;\Sequence_n}\\
        \forall i. \Sequence_i =
        \SequenceOf{\String_{i,0};\Atom_{i,1};\ldots;\Atom_{i,n_i};\String_{i,n_i}}\\
        \forall i,j. \Atom_{i,j} \ParallelRewriteAtom \DNFRegex_{i,j}\\
        \forall i. \DNFRegex_i = \DNFOf{\SequenceOf{\String_{i,0}}} \ConcatDNF \DNFRegex_{i,1}
        \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,n_i} \ConcatDNF
        \DNFOf{\SequenceOf{\String_{i,n_i}}}
      }
      {
        \DNFRegex \ParallelRewrite \DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n
      }
    \]

    So $\DNFRegex_k$, for $k \neq i =
    \DNFOf{\SequenceOf{\String_{k,0}}} \ConcatDNF \AtomToDNFOf{\Atom_{k,1}}
    \ConcatDNF \ldots \ConcatDNF \AtomToDNFOf{\Atom_{k,n_k}} \ConcatDNF
    \DNFOf{\SequenceOf{\String_{k,n_k}}} = \Sequence_k$

    $\DNFRegex_i =
    \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}
    \ConcatDNF \AtomToDNFOf{\Atom_j} \ConcatDNF
    \DNFOf{\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m}}$,

    so, through the definition of $\OrDNF$,
    $\DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n =
    \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
    \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}\ConcatDNF\DNFRegex\ConcatDNF\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m} \OrDNF
    \DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n}$,
    so we get $\DNFRegex \ParallelRewrite \DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n =
    \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
    \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}\ConcatDNF\DNFRegex\ConcatDNF\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m} \OrDNF
    \DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n}$.
  \end{case}
\end{proof}

\begin{lemma}
  \label{lem:star-serial-expressible-in-star-parallel}
  If $\DNFRegex \StarOf{\Rewrite} \DNFRegexAlt$, then
  $\DNFRegex \StarOf{\ParallelRewrite} \DNFRegexAlt$
\end{lemma}
\begin{proof}
  By induction on the derivation of $\StarOf{\Rewrite}$

  \begin{case}[\ReflexivityRule{}]
    \[
      \inferrule*
      {
      }
      {
        \DNFRegex \StarOf{\Rewrite} \DNFRegex
      }
    \]

    Consider the following derivation

    \[
      \inferrule*
      {
      }
      {
        \DNFRegex \StarOf{\ParallelRewrite} \DNFRegex
      }
    \]
  \end{case}

  \begin{case}[\BaseRule{}]
    \[
      \inferrule*
      {
        \DNFRegex \Rewrite \DNFRegexAlt
      }
      {
        \DNFRegex \StarOf{\Rewrite} \DNFRegexAlt
      }
    \]

    By Lemma~\ref{lem:parallel-expressible-in-star-serial},
    $\DNFRegex \StarOf{\ParallelRewrite} \DNFRegexAlt$.
  \end{case}

  \begin{case}[\TransitivityRule{}]
    \[
      \inferrule*
      {
        \DNFRegex \StarOf{\Rewrite} \DNFRegex'\\
        \DNFRegex' \StarOf{\Rewrite} \DNFRegexAlt
      }
      {
        \DNFRegex \StarOf{\Rewrite} \DNFRegexAlt
      }
    \]

    By IH, $\DNFRegex \StarOf{\ParallelRewrite} \DNFRegex'$ and
    $\DNFRegex' \StarOf{\ParallelRewrite} \DNFRegexAlt$.

    Consider the following derivation
    \[
      \inferrule*
      {
        \DNFRegex \StarOf{\ParallelRewrite} \DNFRegex'\\
        \DNFRegex' \StarOf{\ParallelRewrite} \DNFRegexAlt
      }
      {
        \DNFRegex \StarOf{\ParallelRewrite} \DNFRegexAlt
      }
    \]
  \end{case}
\end{proof}

\begin{lemma}
  \label{lem:propagation-of-rewrites-through-atom-structure}
  If $\DNFRegex \StarOf{\Rewrite} \DNFRegexAlt$, then
  $\AtomToDNFOf{\StarOf{\DNFRegex}} \StarOf{\Rewrite}
  \AtomToDNFOf{\StarOf{\DNFRegexAlt}}$.
\end{lemma}
\begin{proof}
  By induction on the derivation of $\StarOf{\Rewrite}$

  \begin{case}[\ReflexivityRule{}]
    \[
      \inferrule*
      {
      }
      {
        \DNFRegex \StarOf{\Rewrite} \DNFRegex
      }
    \]

    Consider the derivation
    
    \[
      \inferrule*
      {
      }
      {
        \AtomToDNFOf{\DNFRegex} \StarOf{\Rewrite} \AtomToDNFOf{\DNFRegex}
      }
    \]
  \end{case}

  \begin{case}[\BaseRule{}]
    \[
      \inferrule*
      {
        \DNFRegex \Rewrite \DNFRegexAlt
      }
      {
        \DNFRegex \StarOf{\Rewrite} \DNFRegexAlt
      }
    \]

    Consider the derivation
    \[
      \inferrule*
      {
        \inferrule*
        {
          \inferrule*
          {
            \DNFRegex \Rewrite \DNFRegexAlt
          }
          {
            \StarOf{\DNFRegex} \RewriteAtom \AtomToDNFOf{\StarOf{\DNFRegexAlt}}
          }
        }
        {
          \AtomToDNFOf{\StarOf{\DNFRegex}} \Rewrite
          \AtomToDNFOf{\StarOf{\DNFRegexAlt}}
        }
      }
      {
        \AtomToDNFOf{\StarOf{\DNFRegex}} \StarOf{\Rewrite}
        \AtomToDNFOf{\StarOf{\DNFRegexAlt}}
      }
    \]
  \end{case}

  \begin{case}[\TransitivityRule{}]
    \[
      \inferrule*
      {
        \DNFRegex \StarOf{\Rewrite} \DNFRegex'\\
        \DNFRegex' \StarOf{\Rewrite} \DNFRegexAlt
      }
      {
        \DNFRegex \StarOf{\Rewrite} \DNFRegexAlt
      }
    \]

    By IH, there exists derivations of
    $\AtomToDNFOf{\StarOf{\DNFRegex}} \StarOf{\Rewrite}
    \AtomToDNFOf{\StarOf{\DNFRegex'}}$ and
    $\AtomToDNFOf{\StarOf{\DNFRegex'}} \StarOf{\Rewrite}
    \AtomToDNFOf{\StarOf{\DNFRegexAlt}}$.

    Consider the derivation
    \[
      \inferrule*
      {
        \AtomToDNFOf{\StarOf{\DNFRegex}} \StarOf{\Rewrite}
        \AtomToDNFOf{\StarOf{\DNFRegex'}}\\
        \AtomToDNFOf{\StarOf{\DNFRegex'}} \StarOf{\Rewrite}
        \AtomToDNFOf{\StarOf{\DNFRegexAlt}}
      }
      {
        \AtomToDNFOf{\StarOf{\DNFRegex}} \StarOf{\Rewrite}
        \AtomToDNFOf{\StarOf{\DNFRegexAlt}}
      }
    \]
  \end{case}
\end{proof}

\begin{lemma}
  \label{lem:propagation-of-star-rewrites-through-or-left}
  If $\DNFRegex_1 \StarOf{\Rewrite} \DNFRegex_2$, then for all $\DNFRegexAlt$,
  $\DNFRegex_1 \OrDNF \DNFRegexAlt \StarOf{\Rewrite}
  \DNFRegex_2 \OrDNF \DNFRegexAlt$
\end{lemma}
\begin{proof}
  By induction on the derivation of \StarOf{\Rewrite}

  \begin{case}[\ReflexivityRule{}]
    \[
      \inferrule*
      {
      }
      {
        \DNFRegex_1 \StarOf{\Rewrite} \DNFRegex_1
      }
    \]

    so, by \ReflexivityRule{}
    
    \[
      \inferrule*
      {
      }
      {
        \DNFRegex_1 \OrDNF \DNFRegexAlt
        \StarOf{\Rewrite}
        \DNFRegex_1 \OrDNF \DNFRegexAlt
      }
    \]
  \end{case}

  \begin{case}[\BaseRule{}]
    \[
      \inferrule*
      {
        \DNFRegex_1 \Rewrite \DNFRegex_2
      }
      {
        \DNFRegex_1 \StarOf{\Rewrite} \DNFRegex_2
      }
    \]

    The only way to get a derivation of \Rewrite{} is with an application of
    \DNFStructuralRewriteRule{}, so by inversion,

    \[
      \inferrule*
      {
        \Atom_j \Rewrite \DNFRegex
      }
      {
        \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
        \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}
        \ConcatDNF \AtomToDNFOf{\Atom_j} \ConcatDNF
        \DNFOf{\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m}}
        \OrDNF \DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n}\Rewrite\\
        \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
        \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}\ConcatDNF\DNFRegex\ConcatDNF\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m} \OrDNF
        \DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n}
      }
    \]

    where
    $\DNFRegex_1 = \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
    \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}
    \ConcatDNF \AtomToDNFOf{\Atom_j} \ConcatDNF
    \DNFOf{\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m}}
    \OrDNF \DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n}$
    and where
    $\DNFRegex_2 = \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
    \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}\ConcatDNF\DNFRegex\ConcatDNF\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m} \OrDNF
    \DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n}$.

    So, let $\DNFRegexAlt = \DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_{n'}}$.

    Consider the derivation
    \[
      \inferrule*
      {
        \Atom_j \Rewrite \DNFRegex
      }
      {
        \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
        \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}
        \ConcatDNF \AtomToDNFOf{\Atom_j} \ConcatDNF
        \DNFOf{\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m}}
        \OrDNF \DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n\DNFSep\SequenceAlt_1;\ldots;\SequenceAlt_{n'}}\Rewrite\\
        \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
        \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}\ConcatDNF\DNFRegex\ConcatDNF\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m} \OrDNF
        \DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n\DNFSep\SequenceAlt_1;\ldots;\SequenceAlt_{n'}}
      }
    \]
    
    $\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
    \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}
    \ConcatDNF \AtomToDNFOf{\Atom_j} \ConcatDNF
    \DNFOf{\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m}}
    \OrDNF \DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n\DNFSep\SequenceAlt_1;\ldots;\SequenceAlt_{n'}}
    =\\
    \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
    \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}
    \ConcatDNF \AtomToDNFOf{\Atom_j} \ConcatDNF
    \DNFOf{\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m}}
    \OrDNF (\DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n} \OrDNF
    \DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_{n'}})$.
    So through associativity of $\OrDNF$, $\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
    \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}
    \ConcatDNF \AtomToDNFOf{\Atom_j} \ConcatDNF
    \DNFOf{\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m}}
    \OrDNF
    \DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n\DNFSep\SequenceAlt_1;\ldots;\SequenceAlt_{n'}}
    = \DNFRegex_1 \OrDNF \DNFRegexAlt$.

    $\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
    \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}
    \ConcatDNF \DNFRegex \ConcatDNF
    \DNFOf{\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m}}
    \OrDNF \DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n\DNFSep\SequenceAlt_1;\ldots;\SequenceAlt_{n'}}
    =\\
    \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
    \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}
    \ConcatDNF \DNFRegex \ConcatDNF
    \DNFOf{\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m}}
    \OrDNF (\DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n} \OrDNF
    \DNFOf{\SequenceAlt_1;\ldots;\SequenceAlt_{n'}})$.
    So through associativity of $\OrDNF$, $\DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
    \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}
    \ConcatDNF \DNFRegex \ConcatDNF
    \DNFOf{\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m}}
    \OrDNF
    \DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n\DNFSep\SequenceAlt_1;\ldots;\SequenceAlt_{n'}}
    = \DNFRegex_2 \OrDNF \DNFRegexAlt$.
  \end{case}

  \begin{case}[\TransitivityRule{}]
    \[
      \inferrule*
      {
        \DNFRegex_1 \StarOf{\Rewrite} \DNFRegex_3\\
        \DNFRegex_3 \StarOf{\Rewrite} \DNFRegex_2
      }
      {
        \DNFRegex_1 \StarOf{\Rewrite} \DNFRegex_2
      }
    \]

    By IH, $\DNFRegex_1 \OrDNF \DNFRegexAlt \StarOf{\Rewrite}
    \DNFRegex_3 \OrDNF \DNFRegexAlt$.
    By IH, $\DNFRegex_3 \OrDNF \DNFRegexAlt \StarOf{\Rewrite}
    \DNFRegex_2 \OrDNF \DNFRegexAlt$.

    Consider the derivation
    \[
      \inferrule*
      {
        \DNFRegex_1 \OrDNF \DNFRegexAlt \StarOf{\Rewrite}
        \DNFRegex_3 \OrDNF \DNFRegexAlt\\
        \DNFRegex_3 \OrDNF \DNFRegexAlt \StarOf{\Rewrite}
        \DNFRegex_2 \OrDNF \DNFRegexAlt
      }
      {
        \DNFRegex_1 \OrDNF \DNFRegexAlt \StarOf{\Rewrite}
        \DNFRegex_2 \OrDNF \DNFRegexAlt
      }
    \]
  \end{case}
\end{proof}

\begin{lemma}
  \label{lem:propagation-of-star-rewrites-through-or-right}
  If $\DNFRegex_1 \StarOf{\Rewrite} \DNFRegex_2$, then for all $\DNFRegexAlt$,
  $\DNFRegexAlt \OrDNF \DNFRegex_1 \StarOf{\Rewrite}
  \DNFRegexAlt \OrDNF \DNFRegex_2$
\end{lemma}
\begin{proof}
  Proven symmetrically to Lemma~\ref{lem:propagation-of-star-rewrites-through-or-left}.
\end{proof}

\begin{lemma}
  \label{lem:propagation-of-star-rewrites-through-or}
  If $\DNFRegex_1 \StarOf{\Rewrite} \DNFRegex_2$, and
  $\DNFRegexAlt_1 \StarOf{\Rewrite} \DNFRegexAlt_2$, then
  $\DNFRegex_1 \OrDNF \DNFRegexAlt_1 \StarOf{\Rewrite}
  \DNFRegex_2 \OrDNF \DNFRegexAlt_2$
\end{lemma}
\begin{proof}
  By Lemma~\ref{lem:propagation-of-star-rewrites-through-or-left},
  $\DNFRegex_1 \OrDNF \DNFRegex_2 \StarOf{\Rewrite}
  \DNFRegexAlt_1 \OrDNF \DNFRegex_2$.
  By Lemma~\ref{lem:propagation-of-star-rewrites-through-or-right},
  $\DNFRegexAlt_1 \OrDNF \DNFRegex_2 \StarOf{\Rewrite}
  \DNFRegexAlt_1 \OrDNF \DNFRegexAlt_2$.

  Consider the derivation
  \[
    \inferrule*
    {
      \DNFRegex_1 \OrDNF \DNFRegex_2 \StarOf{\Rewrite}
      \DNFRegexAlt_1 \OrDNF \DNFRegex_2\\
      \DNFRegexAlt_1 \OrDNF \DNFRegex_2 \StarOf{\Rewrite}
      \DNFRegexAlt_1 \OrDNF \DNFRegexAlt_2
    }
    {
      \DNFRegex_1 \OrDNF \DNFRegex_2 \StarOf{\Rewrite}
      \DNFRegexAlt_1 \OrDNF \DNFRegexAlt_2
    }
  \]
\end{proof}

\begin{lemma}
  \label{lem:propagation-of-star-rewrites-through-singleton-concat-left}
  If $\DNFRegex_1 \StarOf{\Rewrite} \DNFRegex_2$, then for all $\Sequence$,
  $\DNFRegex_1 \ConcatDNF \DNFOf{\Sequence} \StarOf{\Rewrite}
  \DNFRegex_2 \ConcatDNF \DNFOf{\Sequence}$
\end{lemma}
\begin{proof}
  By induction on the derivation of $\StarOf{\Rewrite}$

  \begin{case}[\ReflexivityRule{}]
    \[
      \inferrule*
      {
      }
      {
        \DNFRegex_1 \StarOf{\Rewrite} \DNFRegex_1
      }
    \]

    so, by \ReflexivityRule{}
    
    \[
      \inferrule*
      {
      }
      {
        \DNFRegex_1 \ConcatDNF \DNFOf{\Sequence}
        \StarOf{\Rewrite}
        \DNFRegex_1 \ConcatDNF \DNFOf{\Sequence}
      }
    \]
  \end{case}

  \begin{case}[\BaseRule{}]
    \[
      \inferrule*
      {
        \DNFRegex_1 \Rewrite \DNFRegex_2
      }
      {
        \DNFRegex_1 \StarOf{\Rewrite} \DNFRegex_2
      }
    \]

    The only way to get a derivation of \Rewrite{} is with an application of
    \DNFStructuralRewriteRule{}, so by inversion,

    \[
      \inferrule*
      {
        \Atom_j \Rewrite \DNFRegex
      }
      {
        \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
        \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}
        \ConcatDNF \AtomToDNFOf{\Atom_j} \ConcatDNF
        \DNFOf{\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m}}
        \OrDNF \DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n}\Rewrite\\
        \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
        \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}\ConcatDNF\DNFRegex\ConcatDNF\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m} \OrDNF
        \DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n}
      }
    \]

    Consider the derivation
    \[
      \inferrule*
      {
        \Atom_j \Rewrite \DNFRegex
      }
      {
        \DNFOf{\Sequence_1\ConcatSequence\Sequence\DNFSep\ldots\DNFSep\Sequence_{i-1}\ConcatSequence\Sequence} \OrDNF
        \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}
        \ConcatDNF \AtomToDNFOf{\Atom_j} \ConcatDNF
        \DNFOf{\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m}\ConcatSequence\Sequence}
        \OrDNF \DNFOf{\Sequence_{i+1}\ConcatSequence\Sequence\DNFSep\ldots\DNFSep\Sequence_n\ConcatSequence\Sequence}\Rewrite\\
        \DNFOf{\Sequence_1\ConcatSequence\Sequence\DNFSep\ldots\DNFSep\Sequence_{i-1}\ConcatSequence\Sequence} \OrDNF
        \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}\ConcatDNF\DNFRegex\ConcatDNF\DNFOf{\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m}\ConcatSequence\Sequence} \OrDNF
        \DNFOf{\Sequence_{i+1}\ConcatSequence\Sequence\DNFSep\ldots\DNFSep\Sequence_n\ConcatSequence\Sequence}
      }
    \]

    By the definition of $\ConcatDNF$, using
    Lemma~\ref{lem:dnf-distribute-singleton-left} this is equal to
    $\DNFRegex_1 \ConcatDNF \DNFOf{\Sequence} \Rewrite
    \DNFRegex_2 \ConcatDNF \DNFOf{\Sequence}$, so, consider the derivation

    \[
      \inferrule*
      {
        \inferrule*
        {
          \Atom_j \Rewrite \DNFRegex
        }
        {
          \DNFRegex_1 \ConcatDNF \DNFOf{\Sequence} \Rewrite
          \DNFRegex_2 \ConcatDNF \DNFOf{\Sequence}
        }
      }
      {
        \DNFRegex_1 \ConcatDNF \DNFOf{\Sequence} \StarOf{\Rewrite}
        \DNFRegex_2 \ConcatDNF \DNFOf{\Sequence}
      }
    \]
  \end{case}

  \begin{case}[\TransitivityRule{}]
    \[
      \inferrule*
      {
        \DNFRegex_1 \StarOf{\Rewrite} \DNFRegex_3
        \DNFRegex_3 \StarOf{\Rewrite} \DNFRegex_2
      }
      {
        \DNFRegex_1 \StarOf{\Rewrite} \DNFRegex_2
      }
    \]

    By IH, $\DNFRegex_1 \ConcatDNF \DNFOf{\Sequence} \StarOf{\Rewrite}
    \DNFRegex_3 \ConcatDNF \DNFOf{\Sequence}$.
    By IH, $\DNFOf{\Sequence} \ConcatDNF \DNFRegex_3 \StarOf{\Rewrite}
    \DNFOf{\Sequence} \ConcatDNF \DNFRegex_2$.

    Consider the derivation
    \[
      \inferrule*
      {
        \DNFOf{\Sequence} \ConcatDNF \DNFRegex_1 \StarOf{\Rewrite}
        \DNFOf{\Sequence} \ConcatDNF \DNFRegex_3\\
        \DNFOf{\Sequence} \ConcatDNF \DNFRegex_3 \StarOf{\Rewrite}
        \DNFOf{\Sequence} \ConcatDNF \DNFRegex_2
      }
      {
        \DNFOf{\Sequence} \ConcatDNF \DNFRegex_1 \StarOf{\Rewrite}
        \DNFOf{\Sequence} \ConcatDNF \DNFRegex_2
      }
    \]
  \end{case}
\end{proof}

\begin{lemma}
  \label{lem:propagation-of-star-rewrites-through-concat-right}
  If $\DNFRegex_1 \StarOf{\Rewrite} \DNFRegex_2$, then for all $\DNFRegexAlt$,
  $\DNFRegexAlt \ConcatDNF \DNFRegex_1 \StarOf{\Rewrite}
  \DNFRegexAlt \ConcatDNF \DNFRegex_2$
\end{lemma}
\begin{proof}
  By induction on the derivation of $\StarOf{\Rewrite}$

  \begin{case}[\ReflexivityRule{}]
    \[
      \inferrule*
      {
      }
      {
        \DNFRegex_1 \StarOf{\Rewrite} \DNFRegex_1
      }
    \]

    so, by \ReflexivityRule{}
    
    \[
      \inferrule*
      {
      }
      {
        \DNFRegexAlt \ConcatDNF \DNFRegex_1
        \StarOf{\Rewrite}
        \DNFRegexAlt \ConcatDNF \DNFRegex_1
      }
    \]
  \end{case}

  \begin{case}[\BaseRule{}]
    \[
      \inferrule*
      {
        \DNFRegex_1 \Rewrite \DNFRegex_2
      }
      {
        \DNFRegex_1 \StarOf{\Rewrite} \DNFRegex_2
      }
    \]

    The only way to get a derivation of \Rewrite{} is with an application of
    \DNFStructuralRewriteRule{}, so by inversion,

    \[
      \inferrule*
      {
        \Atom_j \Rewrite \DNFRegex
      }
      {
        \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
        \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}
        \ConcatDNF \AtomToDNFOf{\Atom_j} \ConcatDNF
        \DNFOf{\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m}}
        \OrDNF \DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n}\Rewrite\\
        \DNFOf{\Sequence_1\DNFSep\ldots\DNFSep\Sequence_{i-1}} \OrDNF
        \DNFOf{\SequenceOf{\String_0\SequenceSep\Atom_1\SequenceSep\ldots\SequenceSep\String_{j-1}}}\ConcatDNF\DNFRegex\ConcatDNF\SequenceOf{\String_j\SequenceSep\ldots\SequenceSep\Atom_m\SequenceSep\String_m} \OrDNF
        \DNFOf{\Sequence_{i+1}\DNFSep\ldots\DNFSep\Sequence_n}
      }
    \]

    Let $\DNFRegexAlt = \DNFOf{\Sequence_1';\ldots;\Sequence_{n'}'}$.

    By
    Lemma~\ref{lem:propagation-of-star-rewrites-through-singleton-concat-right},
    $\DNFOf{\Sequence_k'} \ConcatDNF \DNFRegex_1 \ParallelRewrite
    \DNFOf{\Sequence_k'} \ConcatDNF \DNFRegex_2$.
    So, through repeated application of
    Lemma~\ref{lem:propagation-of-star-rewrites-through-or},
    $(\DNFOf{\Sequence_1'} \ConcatDNF \DNFRegex_1) \OrDNF \ldots \OrDNF
    (\DNFOf{\Sequence_{n'}'} \ConcatDNF \DNFRegex_1) \ParallelRewrite
    (\DNFOf{\Sequence_1'} \ConcatDNF \DNFRegex_2) \OrDNF \ldots \OrDNF
    (\DNFOf{\Sequence_{n'}'} \ConcatDNF \DNFRegex_2)$

    From Lemma~\ref{lem:dnf-distribute-right},
    $(\DNFOf{\Sequence_1'} \ConcatDNF \DNFRegex_1) \OrDNF \ldots \OrDNF
    (\DNFOf{\Sequence_{n'}'} \ConcatDNF \DNFRegex_1) =
    (\DNFOf{\Sequence_1'} \OrDNF \ldots \OrDNF \DNFOf{\Sequence_{n'}'})
    \ConcatDNF \DNFRegex_1 = \DNFRegexAlt \ConcatDNF \DNFRegex_1$ and
    $(\DNFOf{\Sequence_1'} \ConcatDNF \DNFRegex_2) \OrDNF \ldots \OrDNF
    (\DNFOf{\Sequence_{n'}'} \ConcatDNF \DNFRegex_2) =
    (\DNFOf{\Sequence_1'} \OrDNF
    \ldots \OrDNF \DNFOf{\Sequence_{n'}'}) \ConcatDNF \DNFRegex_2 =
    \DNFRegexAlt \ConcatDNF \DNFRegex_2$.

    So we have
    $\DNFRegexAlt \ConcatDNF \DNFRegex_1 \StarOf{\Rewrite}
    \DNFRegexAlt \ConcatDNF \DNFRegex_2$.
  \end{case}

  \begin{case}[\TransitivityRule{}]
    \[
      \inferrule*
      {
        \DNFRegex_1 \StarOf{\Rewrite} \DNFRegex_3
        \DNFRegex_3 \StarOf{\Rewrite} \DNFRegex_2
      }
      {
        \DNFRegex_1 \StarOf{\Rewrite} \DNFRegex_2
      }
    \]

    By IH, $\DNFRegex_1 \ConcatDNF \DNFRegexAlt \StarOf{\Rewrite}
    \DNFRegex_3 \ConcatDNF \DNFRegexAlt$.
    By IH, $\DNFRegex_3 \ConcatDNF \DNFRegexAlt \StarOf{\Rewrite}
    \DNFRegex_2 \ConcatDNF \DNFRegexAlt$.

    Consider the derivation
    \[
      \inferrule*
      {
        \DNFRegex_1 \ConcatDNF \DNFRegexAlt \StarOf{\Rewrite}
        \DNFRegex_3 \ConcatDNF \DNFRegexAlt\\
        \DNFRegex_3 \ConcatDNF \DNFRegexAlt \StarOf{\Rewrite}
        \DNFRegex_2 \ConcatDNF \DNFRegexAlt
      }
      {
        \DNFRegex_1 \ConcatDNF \DNFRegexAlt \StarOf{\Rewrite}
        \DNFRegex_2 \ConcatDNF \DNFRegexAlt
      }
    \]
  \end{case}
\end{proof}

\begin{lemma}
  \label{lem:propagation-of-star-rewrites-through-sequence}
  Let $\AtomToDNFOf{\Atom_i} \StarOf{\Rewrite} \DNFRegex_i$.
  $\DNFOf{\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}}
  \StarOf{\Rewrite}
  \DNFOf{\SequenceOf{\String_0}} \ConcatDNF \DNFRegex_1 \ConcatDNF \ldots
  \ConcatDNF \DNFRegex_n \ConcatDNF \DNFOf{\SequenceOf{\String_n}}$
\end{lemma}
\begin{proof}
  By induction on $n$.
  \begin{case}[$n=0$]
    Through use of \ReflexivityRule{}
    \[
      \inferrule*
      {
      }
      {
        $\DNFOf{\SequenceOf{\String_0}} \StarOf{\Rewrite}
        \DNFOf{\SequenceOf{\String_0}}$
      }
    \]
  \end{case}

  \begin{case}[$n>0$]
    $\DNFOf{\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}} =
    \DNFOf{\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_{n-1};\String_{n-1}}}
    \ConcatDNF
    \DNFOf{\SequenceOf{\EmptyString;\Atom_n;\String_n}}$ by the definition of
    $\ConcatDNF$.
    
    From IH,
    $\DNFOf{\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_{n-1};\String_{n-1}}}
    \StarOf{\Rewrite}
    \DNFOf{\SequenceOf{\String_0}} \ConcatDNF \DNFRegex_1 \ConcatDNF \ldots
    \ConcatDNF \DNFRegex_{n-1} \ConcatDNF \DNFOf{\SequenceOf{\String_{n-1}}}$
    From
    Lemma~\ref{lem:propagation-of-star-rewrites-through-singleton-concat-left},
    $\DNFOf{\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_{n-1};\String_{n-1}}}
    \ConcatDNF
    \DNFOf{\SequenceOf{\EmptyString;\Atom_n;\String_n}}
    \StarOf{\Rewrite}
    \DNFOf{\SequenceOf{\String_0}} \ConcatDNF \DNFRegex_1 \ConcatDNF \ldots
    \ConcatDNF \DNFRegex_{n-1} \ConcatDNF
    \DNFOf{\SequenceOf{\EmptyString;\Atom_n;\String_n}}$.

    $\DNFOf{\SequenceOf{\EmptyString;\Atom_n;\String_n}} =
    \AtomToDNFOf{\Atom_n} \ConcatDNF \DNFOf{\SequenceOf{\String_n}}$
    From
    Lemma~\ref{lem:propagation-of-star-rewrites-through-singleton-concat-left},
    as $\AtomToDNFOf{\Atom_n} \StarOf{\Rewrite} \DNFRegex_n$
    $\DNFOf{\SequenceOf{\EmptyString;\Atom_n;\String_n}} \StarOf{\Rewrite}
    \DNFRegex_n \ConcatDNF \DNFOf{\SequenceOf{\String_n}}$.

    As $\DNFOf{\SequenceOf{\EmptyString;\Atom_n;\String_n}} \StarOf{\Rewrite}
    \DNFRegex_n \ConcatDNF \DNFOf{\SequenceOf{\String_n}}$, from
    Lemma~\ref{lem:propagation-of-star-rewrites-through-concat-right},
    $\DNFOf{\SequenceOf{\String_0}} \ConcatDNF \DNFRegex_1 \ConcatDNF \ldots
    \ConcatDNF \DNFRegex_{n-1} \ConcatDNF
    \DNFOf{\SequenceOf{\EmptyString;\Atom_n;\String_n}} \StarOf{\Rewrite}
    \DNFOf{\SequenceOf{\String_0}} \ConcatDNF \DNFRegex_1 \ConcatDNF \ldots
    \ConcatDNF \DNFRegex_{n-1} \ConcatDNF \DNFRegex_n \ConcatDNF
    \DNFOf{\SequenceOf{\String_n}}$.

    Consider the derivation
    \[
      \inferrule*
      {
        \DNFOf{\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_{n-1};\String_{n-1}}}
        \ConcatDNF
        \DNFOf{\SequenceOf{\EmptyString;\Atom_n;\String_n}}
        \StarOf{\Rewrite}
        \DNFOf{\SequenceOf{\String_0}} \ConcatDNF \DNFRegex_1 \ConcatDNF \ldots
        \ConcatDNF \DNFRegex_{n-1} \ConcatDNF
        \DNFOf{\SequenceOf{\EmptyString;\Atom_n;\String_n}}\\
        \DNFOf{\SequenceOf{\String_0}} \ConcatDNF \DNFRegex_1 \ConcatDNF \ldots
        \ConcatDNF \DNFRegex_{n-1} \ConcatDNF
        \DNFOf{\SequenceOf{\EmptyString;\Atom_n;\String_n}} \StarOf{\Rewrite}
        \DNFOf{\SequenceOf{\String_0}} \ConcatDNF \DNFRegex_1 \ConcatDNF \ldots
        \ConcatDNF \DNFRegex_{n-1} \ConcatDNF \DNFRegex_n \ConcatDNF
        \DNFOf{\SequenceOf{\String_n}}
      }
      {
        \DNFOf{\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}} =
        \DNFOf{\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_{n-1};\String_{n-1}}}
        \ConcatDNF
        \DNFOf{\SequenceOf{\EmptyString;\Atom_n;\String_n}} \StarOf{\Rewrite}
        \DNFOf{\SequenceOf{\String_0}} \ConcatDNF \DNFRegex_1 \ConcatDNF \ldots
        \ConcatDNF \DNFRegex_{n-1} \ConcatDNF \DNFRegex_n \ConcatDNF
        \DNFOf{\SequenceOf{\String_n}}
      }
    \]

    So, $\DNFOf{\SequenceOf{\String_0;\Atom_1;\ldots;\Atom_n;\String_n}}
    \StarOf{\Rewrite}
    \DNFOf{\SequenceOf{\String_0}} \ConcatDNF \DNFRegex_1 \ConcatDNF \ldots
    \ConcatDNF \DNFRegex_n \ConcatDNF \DNFOf{\SequenceOf{\String_n}}$,
    as desired.
  \end{case}
\end{proof}

\begin{lemma}
  \label{lem:parallel-expressible-in-star-serial}
  \leavevmode
  \begin{itemize}
  \item If $\Atom \ParallelRewriteAtom \DNFRegexAlt$, then
    $\AtomToDNFOf{\DNFRegex} \StarOf{\Rewrite} \DNFRegexAlt$.
  \item If $\DNFRegex \ParallelRewrite \DNFRegexAlt$, then
    $\AtomToDNFOf{\DNFRegex} \StarOf{\Rewrite} \DNFRegexAlt$.
  \end{itemize}
\end{lemma}
\begin{proof}
  By mutual induction on the derivation of $\ParallelRewriteAtom$
  \begin{case}[\AtomUnrollstarLeftRule{}]
    \[
      \inferrule*
      {
      }
      {
        \StarOf{\DNFRegex}\ParallelRewriteAtom
        \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}{(\ConcatDNFOf{\DNFRegex}{\AtomToDNFOf{\StarOf{\DNFRegex}}})}
      }
    \]

    Consider the derivation
    
    \[
      \inferrule*
      {
        \inferrule*
        {
          \inferrule*
          {
          }
          {
            \StarOf{\DNFRegex}\RewriteAtom
            \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}{(\ConcatDNFOf{\DNFRegex}{\AtomToDNFOf{\StarOf{\DNFRegex}}})}
          }
        }
        {
          \AtomToDNFOf{\StarOf{\DNFRegex}} \Rewrite
          \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}{(\ConcatDNFOf{\DNFRegex}{\AtomToDNFOf{\StarOf{\DNFRegex}}})}
        }
      }
      {
        \AtomToDNFOf{\StarOf{\DNFRegex}} \StarOf{\Rewrite}
        \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}{(\ConcatDNFOf{\DNFRegex}{\AtomToDNFOf{\StarOf{\DNFRegex}}})}
      }
    \]
  \end{case}

  \begin{case}[\AtomUnrollstarRightRule{}]
    \[
      \inferrule*
      {
      }
      {
        \StarOf{\DNFRegex}\ParallelRewriteAtom
        \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}{(\ConcatDNFOf{\AtomToDNFOf{\StarOf{\DNFRegex}}}{\DNFRegex})}
      }
    \]

    Consider the derivation
    
    \[
      \inferrule*
      {
        \inferrule*
        {
          \inferrule*
          {
          }
          {
            \StarOf{\DNFRegex}\RewriteAtom
            \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}{(\ConcatDNFOf{\AtomToDNFOf{\StarOf{\DNFRegex}}}{\DNFRegex})}
          }
        }
        {
          \AtomToDNFOf{\StarOf{\DNFRegex}} \Rewrite
          \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}{(\ConcatDNFOf{\DNFRegex}{\AtomToDNFOf{\StarOf{\DNFRegex}}})}
        }
      }
      {
        \AtomToDNFOf{\StarOf{\DNFRegex}} \StarOf{\Rewrite}
        \OrDNFOf{\DNFOf{\SequenceOf{\EmptyString}}}{(\ConcatDNFOf{\DNFRegex}{\AtomToDNFOf{\StarOf{\DNFRegex}}})}
      }
    \]
  \end{case}

  \begin{case}[\ParallelAtomStructuralRewriteRule{}]
    \[
      \inferrule*
      {
        \DNFRegex \ParallelRewrite \DNFRegexAlt'
      }
      {
        \StarOf{\DNFRegex} \ParallelRewrite \AtomToDNFOf{\StarOf{\DNFRegexAlt'}}
      }
    \]
    
    By IH, $\DNFRegex \StarOf{\Rewrite} \DNFRegexAlt'$, so
    by Lemma~\ref{lem:propagation-of-rewrites-through-atom-structure},
    $\AtomToDNFOf{\StarOf{\DNFRegex}} \StarOf{\Rewrite}
    \AtomToDNFOf{\StarOf{\DNFRegexAlt'}}$.
  \end{case}

  \begin{case}[ParallelDNFStructuralRewriteRule{}]
    \[
      \inferrule*
      {
        \DNFRegex = \DNFOf{\Sequence_1;\ldots;\Sequence_n}\\
        \forall i. \Sequence_i =
        \SequenceOf{\String_{i,0};\Atom_{i,1};\ldots;\Atom_{i,n_i};\String_{i,n_i}}\\
        \forall i,j. \Atom_{i,j} \ParallelRewriteAtom \DNFRegex_{i,j}\\
        \forall i. \DNFRegex_i = \DNFOf{\SequenceOf{\String_{i,0}}} \ConcatDNF \DNFRegex_{i,1}
        \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,n_i} \ConcatDNF
        \DNFOf{\SequenceOf{\String_{i,n_i}}}
      }
      {
        \DNFRegex \ParallelRewrite \DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n
      }
    \]

    From the definition of $\OrDNF$,
    $\DNFRegex = \DNFOf{\Sequence_1} \OrDNF \ldots \OrDNF \DNFOf{\Sequence_n}$.
    From IH, $\AtomToDNFOf{\Atom_{i,1}} \StarOf{\Rewrite} \DNFRegex_{i,j}$.
    From Lemma~\ref{lem:propagation-of-star-rewrites-through-sequence},
    $\DNFOf{\Sequence_i} =
    \DNFOf{\SequenceOf{\String_{i,0};\Atom_{i,1};\ldots;\Atom_{i,n_i};\String_{i,n_i}}}
    \StarOf{\Rewrite}
    \DNFOf{\SequenceOf{\String_{i,0}}} \ConcatDNF \DNFRegex_{i,1}
    \ConcatDNF \ldots \ConcatDNF \DNFRegex_{i,n_i} \ConcatDNF
    \DNFOf{\SequenceOf{\String_{i,n_i}}} = \DNFRegex_i$,
    so $\DNFOf{\Sequence_i} \StarOf{\Rewrite} \DNFRegex_i$.

    From Lemma~\ref{lem:propagation-of-star-rewrites-through-or},
    $\DNFRegex = \DNFOf{\Sequence_i} \OrDNF \ldots \OrDNF \DNFOf{\Sequence_n}
    \StarOf{\Rewrite}
    \DNFRegex_1 \OrDNF \ldots \OrDNF \DNFRegex_n$.
  \end{case}

  \begin{case}[\IdentityRewriteRule]
    \[
      \inferrule*
      {
      }
      {
        \DNFRegex \ParallelRewrite \DNFRegex
      }
    \]

    Through application of \ReflexivityRule{}
    \[
      \inferrule*
      {
      }
      {
        \DNFRegex \StarOf{\Rewrite} \DNFRegex
      }
    \]
  \end{case}
\end{proof}

\begin{lemma}
  \label{lem:star-parallel-expressible-in-star-serial}
  If $\DNFRegex \StarOf{\ParallelRewrite} \DNFRegexAlt$, then
  $\DNFRegex \StarOf{\Rewrite} \DNFRegexAlt$
\end{lemma}
\begin{proof}
  By induction on the derivation of $\StarOf{\ParallelRewrite}$

  \begin{case}[\ReflexivityRule{}]
    \[
      \inferrule*
      {
      }
      {
        \DNFRegex \StarOf{\ParallelRewrite} \DNFRegex
      }
    \]

    Consider the following derivation

    \[
      \inferrule*
      {
      }
      {
        \DNFRegex \StarOf{\Rewrite} \DNFRegex
      }
    \]
  \end{case}

  \begin{case}[\BaseRule{}]
    \[
      \inferrule*
      {
        \DNFRegex \ParallelRewrite \DNFRegexAlt
      }
      {
        \DNFRegex \StarOf{\ParallelRewrite} \DNFRegexAlt
      }
    \]

    By Lemma~\ref{lem:parallel-expressible-in-star-serial},
    $\DNFRegex \StarOf{\Rewrite} \DNFRegexAlt$.
  \end{case}

  \begin{case}[\TransitivityRule{}]
    \[
      \inferrule*
      {
        \DNFRegex \StarOf{\ParallelRewrite} \DNFRegex'\\
        \DNFRegex' \StarOf{\ParallelRewrite} \DNFRegexAlt
      }
      {
        \DNFRegex \StarOf{\ParallelRewrite} \DNFRegexAlt
      }
    \]

    By IH, $\DNFRegex \StarOf{\Rewrite} \DNFRegex'$ and
    $\DNFRegex' \StarOf{\Rewrite} \DNFRegexAlt$.

    Consider the following derivation
    \[
      \inferrule*
      {
        \DNFRegex \StarOf{\Rewrite} \DNFRegex'\\
        \DNFRegex' \StarOf{\Rewrite} \DNFRegexAlt
      }
      {
        \DNFRegex \StarOf{\Rewrite} \DNFRegexAlt
      }
    \]
  \end{case}
\end{proof}

\begin{theorem}
  \label{thm:parallel-star-equivalence}
  $\DNFRegex \StarOf{\ParallelRewrite} \DNFRegex'$, if, and only if $\DNFRegex
  \StarOf{\Rewrite} \DNFRegex'$
\end{theorem}
\begin{proof}
  Forward direction is proven by
  Lemma~\ref{lem:star-serial-expressible-in-star-parallel}.
  Reverse direction is proven by
  Lemma~\ref{lem:star-parallel-expressible-in-star-serial}.
\end{proof}

\begin{corollary}[$\StarOf{\Rewrite}$ Maintained Under Iteration]
  \label{cor:rewrite-maintained-iteration}
  If $\DNFRegex \StarOf{\Rewrite} \DNFRegexAlt$, then
  $\DNFOf{\SequenceOf{\StarOf{\DNFRegex}}} \StarOf{\Rewrite}
  \DNFOf{\SequenceOf{\StarOf{\DNFRegexAlt}}}$.
\end{corollary}
\begin{proof}
  From Theorem~\ref{thm:parallel-star-equivalence} applied to
  Lemma~\ref{lem:star-parallel-rewrite-iteration}.
\end{proof}

\begin{corollary}[$\StarOf{\Rewrite}$ Maintained Under $\ConcatDNF$]
  \label{cor:star-rewrite-maintained-concat-to-identity}
  Let $\DNFRegex$ be strongly unambiguous.  Let $\DNFRegexAlt$ be strongly
  unambiguous.
  Let $\UnambigConcatOf{\LanguageOf{\DNFRegexAlt}}{\LanguageOf{\DNFRegex}}$.
  Let $\DNFRegex \StarOf{\Rewrite} \DNFRegex'$.
  Let $\DNFRegexAlt \StarOf{\Rewrite} \DNFRegexAlt'$.
  Then $\DNFRegex \ConcatDNF \DNFRegexAlt \StarOf{\Rewrite} \DNFRegex''$ such
  that
  there exists a rewriteless DNF lens
  $\DNFLens \OfRewritelessType
  \DNFRegex' \ConcatDNF \DNFRegexAlt' \Leftrightarrow \DNFRegex''$, and
  $\SemanticsOf{\DNFLens} =
  \SetOf{(\String,\String) \SuchThat \String \in
    \LanguageOf{\DNFRegex \ConcatDNF \DNFRegexAlt}}$.
\end{corollary}
\begin{proof}
  From Theorem~\ref{thm:parallel-star-equivalence} applied to
  Lemma~\ref{lem:star-parallel-rewrite-concatenation-to-identity}.
\end{proof}

\begin{corollary}
  \label{cor:copyable_expansions_left_serialized_star}
  Let $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow
  \DNFRegexAlt$ and $\DNFRegex \StarOf{\Rewrite} \DNFRegex'$.  There
  exists some
  $\DNFRegexAlt'$, $\DNFLens'$ such that $\DNFRegexAlt
  \StarOf{\Rewrite} \DNFRegexAlt'$,
  $\DNFLens' \OfRewritelessType
  \DNFRegex' \Leftrightarrow \DNFRegexAlt'$, and $\SemanticsOf{\DNFLens} =
  \SemanticsOf{\DNFLens'}$.
\end{corollary}
\begin{proof}
  From Theorem~\ref{thm:parallel-star-equivalence} applied to
  Lemma~\ref{lem:copyable_expansions_left_swapless_star}.
\end{proof}

\begin{corollary}
  \label{cor:copyable_expansions_right_serialized_star}
  Let $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow
  \DNFRegexAlt$ and $\DNFRegexAlt \StarOf{\Rewrite} \DNFRegexAlt'$.  There
  exists some
  $\DNFRegex'$, $\DNFLens'$ such that $\DNFRegex
  \StarOf{\Rewrite} \DNFRegex'$,
  $\DNFLens' \OfRewritelessType
  \DNFRegex' \Leftrightarrow \DNFRegexAlt'$, and $\SemanticsOf{\DNFLens} =
  \SemanticsOf{\DNFLens'}$.
\end{corollary}
\begin{proof}
  From Theorem~\ref{thm:parallel-star-equivalence} applied to
  Lemma~\ref{lem:copyable_expansions_right_swapless_star}.
\end{proof}

\begin{corollary}
  \label{cor:rewrite-confluence}
  For all lenses $\Lens$,
  $\IsConfluentWithPropertyOf{\StarOf{\Rewrite}}{\DNFLensHasSemanticsOf{\Lens}}$
\end{corollary}
\begin{proof}
  By Theorem~\ref{thm:parallel_confluence_noswap}, and
  Theorem~\ref{thm:starred-confluence},
  for all lenses $\Lens$,
  $\IsConfluentWithPropertyOf
  {\StarOf{\ParallelRewrite}}{\DNFLensHasSemanticsOf{\Lens}}$.
  By Theorem~\ref{thm:parallel-star-equivalence},
  for all lenses $\Lens$,
  $\IsConfluentWithPropertyOf
  {\StarOf{\Rewrite}}{\DNFLensHasSemanticsOf{\Lens}}$.
\end{proof}

\begin{lemma}
  \label{lem:parallelswapequiv-has-identity-lens}
  Let $\DNFRegex$ be strongly unambiguous, and
  let $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegexAlt$.
  There exists $\DNFLens$, $\DNFRegex'$, $\DNFRegexAlt'$ such that
  $\DNFRegex \StarOf{\Rewrite} \DNFRegex'$,
  $\DNFRegexAlt' \StarOf{\Rewrite} \DNFRegexAlt'$,
  $\DNFLens \OfRewritelessType \DNFRegex' \Leftrightarrow \DNFRegexAlt'$,
  and $\SemanticsOf{\DNFLens} =
  \SetOf{(\String,\String) \SuchThat \String \in \LanguageOf{\DNFRegex}}$.
\end{lemma}
\begin{proof}
  Proof by induction on the typing of $\EquivalenceOf{\ParallelRewriteSwap}$
  \begin{case}[\ReflexivityRule]
    Let $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegexAlt$ through an
    application of \ReflexivityRule{}.
    That means $\DNFRegexAlt = \DNFRegex$.

    Consider $\DNFRegex \StarOf{\Rewrite} \DNFRegex$, and
    $\DNFRegexAlt \StarOf{\Rewrite} \DNFRegex$ through applications
    of \ReflexivityRule{}.

    Then, by Lemma~\ref{lem:strongly-unambiguous-identity-expressible}, there
    exists a lens $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow
    \DNFRegex$ such that $\SemanticsOf{\DNFLens} = \SetOf{(\String,\String)
      \SuchThat \String \in \LanguageOf{\DNFRegex}}$
  \end{case}

  \begin{case}[\BaseRule]
    Let $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegexAlt$ through an
    application of \BaseRule{}.
    That means $\DNFRegex \ParallelRewriteSwap \DNFRegexAlt$.

    $\DNFRegexAlt \StarOf{\Rewrite} \DNFRegexAlt$ through an application
    of \ReflexivityRule{}.
    
    By Lemma~\ref{lem:swap-unimportance-identity}, there exists a DNF regular
    expression, $\DNFRegex'$, and a DNF lens $\DNFLens$,
    such that $\DNFRegex \Rewrite \DNFRegex'$,
    $\DNFLens \OfRewritelessType \DNFRegex' \Leftrightarrow \DNFRegexAlt$,
    and $\SemanticsOf{\DNFLens} =
    \SetOf{(\String,\String) \SuchThat \String \in \LanguageOf{\DNFRegex}}$.
    Through an application of \BaseRule{},
    $\DNFRegex \StarOf{\ParallelRewrite} \DNFRegex'$.
    From Theorem~\ref{thm:parallel-star-equivalence},
    $\DNFRegex \StarOf{\Rewrite} \DNFRegex'$, as desired.
  \end{case}

  \begin{case}[\SymmetryRule]
    Let $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegexAlt$ through an
    application of \SymmetryRule{}.
    That means $\DNFRegexAlt \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex$.

    By IH, there exists DNF regular expressions $\DNFRegexAlt'$, $\DNFRegex'$,
    and a DNF lens $\DNFLens$ such that
    $\DNFRegexAlt \StarOf{\Rewrite} \DNFRegexAlt'$,
    $\DNFRegex \StarOf{\Rewrite} \DNFRegex'$,
    $\DNFLens \OfRewritelessType \DNFRegexAlt' \Leftrightarrow \DNFRegex'$,
    and $\SemanticsOf{\DNFRegexAlt'} = \SetOf{(\String,\String) \SuchThat
      \String \in \LanguageOf{\DNFRegexAlt}}$.

    Because $\EquivalenceOf{\ParallelRewriteSwap}$ is equivalent to
    $\DefinitionalEquiv$, $\LanguageOf{\DNFRegex} = \LanguageOf{\DNFRegexAlt}$

    By Lemma~\ref{lem:closure-inversion}, there exists
    $\DNFLens' \OfRewritelessType \DNFRegex' \Leftrightarrow \DNFRegexAlt'$,
    and $\SemanticsOf{\DNFLens'} = \SetOf{(\String,\String) \SuchThat
      \String \in \LanguageOf{\DNFRegex}}$, as desired.
  \end{case}

  \begin{case}[\TransitivityRule{}]
    Let $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegexAlt$ through an
    application of \TransitivityRule{}.
    That means there exists $\DNFRegex'$ such that
    $\DNFRegex \EquivalenceOf{\ParallelRewriteSwap} \DNFRegex'$ and
    $\DNFRegex' \EquivalenceOf{\ParallelRewriteSwap} \DNFRegexAlt$.

    By IH, there exists DNF regular expressions $\DNFRegex_1$, $\DNFRegex_2$,
    and a DNF lens $\DNFLens_1$ such that
    $\DNFRegex \StarOf{\Rewrite} \DNFRegex_1$,
    $\DNFRegex' \StarOf{\Rewrite} \DNFRegex_2$,
    and $\DNFLens_1 \OfRewritelessType \DNFRegex_1 \Leftrightarrow \DNFRegex_2$.

    By IH, there exists DNF regular expressions $\DNFRegex_3$, $\DNFRegex_4$,
    and a DNF lens $\DNFLens_2$ such that
    $\DNFRegex' \StarOf{\Rewrite} \DNFRegex_3$,
    $\DNFRegexAlt \StarOf{\Rewrite} \DNFRegex_4$,
    and $\DNFLens_2 \OfRewritelessType \DNFRegex_3 \Leftrightarrow \DNFRegex_4$.

    By Lemma~\ref{lem:strongly-unambiguous-identity-expressible}, there exists a
    lens $\DNFLens_{\Identity_1} \OfRewritelessType
    \DNFRegex' \Leftrightarrow \DNFRegex'$, where
    $\SemanticsOf{\DNFLens_{\Identity_1}} = \SetOf{(\String,\String) \SuchThat
      \String \in \LanguageOf{\DNFRegex'}}$.
    
    Because $\SatisfiesIdentitySemantics{\DNFRegex'}{\DNFRegex'}$, and
    by Corollary~\ref{cor:rewrite-confluence}, there exists $\DNFRegex_5$ and
    $\DNFRegex_6$, such that
    $\DNFRegex_2 \StarOf{\Rewrite} \DNFRegex_5$,
    $\DNFRegex_3 \StarOf{\Rewrite} \DNFRegex_6$, and
    $\SatisfiesIdentitySemantics{\DNFRegex_5}{\DNFRegex_6}$.
    That means there exists
    $\DNFLens_{\Identity_2} \OfRewritelessType
    \DNFRegex_5 \Leftrightarrow \DNFRegex_6$, where
    $\SemanticsOf{\DNFLens_{\Identity_2}} = \SetOf{(\String,\String) \SuchThat
      \String \in \LanguageOf{\DNFRegex'}}$.

    By Corollary~\ref{cor:copyable_expansions_right_serialized_star},
    as $\DNFRegex_2 \StarOf{\Rewrite} \DNFRegex_5$, and
    $\DNFLens_1 \OfRewritelessType \DNFRegex_1 \Leftrightarrow \DNFRegex_2$.
    Because $\DNFRegex_2 \StarOf{\Rewrite} \DNFRegex_5$, there exists a
    DNF lens $\DNFLens_3$, and DNF regular expression $\DNFRegex_7$ such that
    $\DNFRegex_1 \StarOf{\Rewrite} \DNFRegex_7$, $\DNFLens_3 \OfRewritelessType
    \DNFRegex_7 \Leftrightarrow \DNFRegex_5$, and
    $\SemanticsOf{\DNFLens_3} =
    \SetOf{(\String,\String) \SuchThat \String \in \LanguageOf{\DNFRegex}}$.

    By Corollary~\ref{cor:copyable_expansions_left_serialized_star},
    as $\DNFRegex_3 \StarOf{\Rewrite} \DNFRegex_6$, and
    $\DNFLens_2 \OfRewritelessType \DNFRegex_3 \Leftrightarrow \DNFRegex_4$.
    Because $\DNFRegex_3 \StarOf{\Rewrite} \DNFRegex_6$, there exists a
    DNF lens $\DNFLens_4$, and DNF regular expression $\DNFRegex_8$ such that
    $\DNFRegex_4 \StarOf{\Rewrite} \DNFRegex_8$, $\DNFLens_4 \OfRewritelessType
    \DNFRegex_6 \Leftrightarrow \DNFRegex_8$, and
    $\SemanticsOf{\DNFLens_3} =
    \SetOf{(\String,\String) \SuchThat \String \in \LanguageOf{\DNFRegex'}}$.

    So there are lenses
    $\DNFLens_3 \OfRewritelessType \DNFRegex_7 \Leftrightarrow \DNFRegex_5$,
    $\DNFLens_{\Identity_2} \OfRewritelessType \DNFRegex_5 \Leftrightarrow \DNFRegex_6$, and
    $\DNFLens_4 \OfRewritelessType \DNFRegex_6 \Leftrightarrow \DNFRegex_8$, so
    by Lemma~\ref{lem:composition-completeness}, there exists a lens
    $\DNFLens_5 \OfRewritelessType \DNFRegex_7 \Leftrightarrow \DNFRegex_8$.
    Because all of these have the semantics of the identity lens on DNF regular
    expressions with the same language,
    $\SemanticsOf{\DNFLens_5} =
    \SetOf{(\String,\String) \SuchThat \String \in \LanguageOf{\DNFRegex}}$.

    Furthermore, $\DNFRegex \StarOf{\Rewrite} \DNFRegex_1$ and
    $\DNFRegex_1 \StarOf{\Rewrite} \DNFRegex_7$, so
    $\DNFRegex \StarOf{\Rewrite} \DNFRegex_7$.
    $\DNFRegexAlt \StarOf{\Rewrite} \DNFRegex_4$ and
    $\DNFRegex_4 \StarOf{\Rewrite} \DNFRegex_8$, so
    $\DNFRegexAlt \StarOf{\Rewrite} \DNFRegex_8$, as desired.
  \end{case}
\end{proof}

\begin{lemma}
  \label{lem:identity-definitional-equivalence}
  Let $\Regex \DefinitionalEquiv \RegexAlt$, and let $\Regex$ be strongly
  unambiguous.  There exists $\DNFLens$, $\DNFRegex$, $\DNFRegexAlt$ such that
  $\DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt$,
  $\ToDNFRegexOf{\Regex} \StarOf{\Rewrite} \DNFRegex$,
  $\ToDNFRegexOf{\RegexAlt} \StarOf{\Rewrite} \DNFRegexAlt$, and
  $\SemanticsOf{\DNFLens} =
  \SetOf{(\String,\String) \SuchThat \String\in\LanguageOf{\Regex}}$
\end{lemma}
\begin{proof}
  From Lemma~\ref{thm:defequiv-equiv-parallelswapequiv}, as 
  $\Regex \DefinitionalEquiv \RegexAlt$,
  $\ToDNFRegexOf{\Regex} \EquivalenceOf{\ParallelRewriteSwap}
  \ToDNFRegexOf{\RegexAlt}$.
  Because $\Regex$ is strongly unambiguous, by
  Lemma~\ref{lem:retaining-unambiguity}, $\ToDNFRegexOf{\Regex}$ is strongly
  unambiguous.
  Because of this, from Lemma~\ref{lem:parallelswapequiv-has-identity-lens},
  there exists $\DNFRegex$, $\DNFRegexAlt$, and $\DNFLens$ such that
  $\ToDNFRegexOf{\Regex} \StarOf{\Rewrite} \DNFRegex$,
  $\ToDNFRegexOf{\RegexAlt} \StarOf{\Rewrite} \DNFRegexAlt$, and
  $\SemanticsOf{\DNFLens} =
  \SetOf{(\String,\String) \SuchThat
    \String\in\LanguageOf{ToDNFRegexOf{\Regex}}}$.
  From Theorem~\ref{thm:dnfrs}, $\LanguageOf{\ToDNFRegexOf{\Regex}} =
  \LanguageOf{\Regex}$, as desired.
\end{proof}

\begin{lemma}
  \label{lem:pre-completeness}
  If $\Lens \OfType \Regex \Leftrightarrow \RegexAlt$ then there exists
  $\DNFLens$, $\DNFRegex$, $\DNFRegexAlt$ such that $\DNFLens \OfRewritelessType
  \DNFRegex \Leftrightarrow \DNFRegexAlt$, $\ToDNFRegexOf{\Regex}
  \StarOf{\Rewrite} \DNFRegex$, $\ToDNFRegexOf{\RegexAlt} \StarOf{\Rewrite}
  \DNFRegexAlt$, and $\SemanticsOf{\DNFLens} = \SemanticsOf{\Lens}$
\end{lemma}
\begin{proof}
  By induction of the typing derivation of $\Lens \OfType \Regex \Leftrightarrow
  \RegexAlt$.

  Let the last typing rule be an instance of \IterateLensRule{}.
  \[
    \inferrule*
    {
      \Lens \OfType \Regex \Leftrightarrow \RegexAlt
    }
    {
      \IterateLensOf{\Lens} \OfType \StarOf{\Regex} \Leftrightarrow
      \StarOf{\RegexAlt}
    }
  \]

  By IH, there exists $\DNFLens$, $\DNFRegex$, $\DNFRegexAlt$
  such that
  \begin{gather*}
    \DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt\\
    \ToDNFRegex{\Regex}\StarOf{\Rewrite}\DNFRegex\\
    \ToDNFRegex{\RegexAlt}\StarOf{\Rewrite}\DNFRegexAlt\\
    \SemanticsOf{\DNFLens} = \SemanticsOf{\Lens}
  \end{gather*}

  By Lemma~\ref{lem:typ_sem_it},
  $\DNFLensOf{\SequenceLensOf{\IterateLensOf{\DNFLens}}}
  \OfRewritelessType \DNFOf{\SequenceOf{\StarOf{\DNFRegex}}} \Leftrightarrow
  \DNFOf{\SequenceOf{\StarOf{\DNFRegexAlt}}}$.  By
  Corollary~\ref{cor:rewrite-maintained-iteration},
  $\DNFOf{\SequenceOf{\StarOf{\ToDNFRegexOf{\Regex}}}} \StarOf{\Rewrite}
  \DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}$ and
  $\DNFOf{\SequenceOf{\StarOf{\ToDNFRegexOf{\RegexAlt}}}} \StarOf{\Rewrite}
  \DNFOf{\SequenceOf{\StarOf{\DNFRegexAlt}}}$.  From this, we get

  \[
    \inferrule*
    {
      \DNFLensOf{\SequenceLensOf{\IterateLensOf{\DNFLens}}}
      \OfRewritelessType \DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}
      \Leftrightarrow \DNFOf{\SequenceOf{\StarOf{\DNFRegexAlt}}}\\
      \DNFOf{\SequenceOf{\StarOf{\ToDNFRegexOf{\Regex}}}} \StarOf{\Rewrite}
      \DNFOf{\SequenceOf{\StarOf{\DNFRegex}}}\\
      \DNFOf{\SequenceOf{\StarOf{\ToDNFRegexOf{\RegexAlt}}}} \StarOf{\Rewrite}
      \DNFOf{\SequenceOf{\StarOf{\DNFRegexAlt}}}
    }
    {
      \DNFLensOf{\SequenceLensOf{\IterateLensOf{\DNFLens}}} \OfType
      \ToDNFRegexOf{\StarOf{\Regex}} \Leftrightarrow
      \ToDNFRegexOf{\StarOf{\RegexAlt}}
    }
  \]

  By Lemma~\ref{lem:typ_sem_it},
  $\SemanticsOf{\DNFLensOf{\SequenceLensOf{\IterateLensOf{\DNFLens}}}} =
  \SetOf{(\String_1\Concat\ldots\Concat\String_n,\StringAlt_1\Concat\ldots\Concat\StringAlt_n)
    \SuchThat (\String_i,\StringAlt_i)\in\SemanticsOf{\DNFLens}} =
  \SetOf{(\String_1\Concat\ldots\Concat\String_n,\StringAlt_1\Concat\ldots\Concat\StringAlt_n)
    \SuchThat (\String_i,\StringAlt_i)\in\SemanticsOf{\Lens}} =
  \SemanticsOf{\IterateLensOf{\Lens}}$
  \\
  \\
  
  Let the last typing rule be an instance of \ConstantLensRule{}.

  \[
    \inferrule*
    {
    }
    {
      \ConstLensOf{\String_1}{\String_2}
    }
  \]

  Consider DNF Lens Derivation

  \[
    \inferrule*
    {
      \inferrule*
      {
        \SequenceLensOf{(\String_1,\String_2)} \OfRewritelessType
        \SequenceOf{\String_1} \Leftrightarrow
        \SequenceOf{\String_2}
      }
      {
        \DNFLensOf{\SequenceLensOf{(\String_1,\String_2)}} \OfRewritelessType
        \DNFOf{\SequenceOf{\String_1}} \Leftrightarrow
        \DNFOf{\SequenceOf{\String_2}}
      }\\
      \DNFOf{\SequenceOf{\String_1}} \StarOf{\Rewrite} \DNFOf{\SequenceOf{\String_1}}\\
      \DNFOf{\SequenceOf{\String_2}} \StarOf{\Rewrite} \DNFOf{\SequenceOf{\String_2}}
    }
    {
      \DNFLensOf{\SequenceLensOf{(\String_1,\String_2)}} \OfType
      \DNFOf{\SequenceOf{\String_1}} \Leftrightarrow \DNFOf{\SequenceOf{\String_2}}
    }
  \]

  $\SemanticsOf{\DNFLensOf{\SequenceLensOf{(\String_1,\String_2)}}} =
  \SetOf{(\String_1,\String_2)} =
  \SemanticsOf{\ConstLensOf{\String_1}{\String_2}}$
  \\
  \\

  Let the last typing rule be an instance of \ConcatLensRule{}.
  \[
    \inferrule*
    {
      \Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1\\
      \Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2
    }
    {
      \ConcatLensOf{\Lens_1}{\Lens_2} \OfType \RegexConcat{\Regex_1}{\Regex_2}
      \Leftrightarrow \RegexConcat{\RegexAlt_1}{\RegexAlt_2}
    }
  \]

  By IH, there exists $\DNFLens_1$, $\DNFRegex_1$,
  $\DNFRegexAlt_1$, $\DNFLens_2$, $\DNFRegex_2$, and $\DNFRegexAlt_2$ such that
  \begin{gather*}
    \DNFLens_1 \OfRewritelessType \DNFRegex_1 \Leftrightarrow \DNFRegexAlt_1 \\
    \ToDNFRegex{\Regex_1 }\StarOf {\Rewrite}\DNFRegex_1 \\
    \ToDNFRegex{\RegexAlt_1} \StarOf {\Rewrite}\DNFRegexAlt_1 \\
    \SemanticsOf{\DNFLens_1} = \SemanticsOf{\Lens_1} \\
    \DNFLens_2 \OfRewritelessType \DNFRegex_2 \Leftrightarrow \DNFRegexAlt_2 \\
    \ToDNFRegex{\Regex_2} \StarOf{\Rewrite} \DNFRegex_2 \\
    \ToDNFRegex{\RegexAlt_2} \StarOf{\Rewrite} \DNFRegexAlt_2 \\
    \SemanticsOf{\DNFLens_2} = \SemanticsOf{\Lens_2}
  \end{gather*}

  From Lemma~\ref{lem:typ_sem_concat}, $\ConcatDNFLensOf{\DNFLens_1}{\DNFLens_2}
  \OfRewritelessType
  \ConcatDNFOf{\DNFRegex_1}{\DNFRegex_2} \Leftrightarrow
  \ConcatDNFOf{\DNFRegexAlt_1}{\DNFRegexAlt_2}$.
  
  By Corollary~\ref{cor:star-rewrite-maintained-concat-to-identity}, and
  Lemma~\ref{lem:dnf-lens-inversion},
  there exists a DNF regular expression, $\DNFRegex_L$, and a DNF lens,
  $\DNFLens_L$, such that $\DNFLens_L \OfRewritelessType \DNFRegex_L
  \Leftrightarrow \ConcatDNFOf{\DNFRegex_1}{\DNFRegex_2}$, where
  $\SemanticsOf{\DNFLens_L} = \SetOf{(\String,\String) \SuchThat
    \String \in
    \LanguageOf{\ToDNFRegexOf{(\ConcatDNFOf{\DNFRegex_1}{\DNFRegex_2})}}}$.
  Furthermore, $\ToDNFRegexOf{(\ConcatDNFOf{\DNFRegex_1}{\DNFRegex_2})}
  \StarOf{\Rewrite} \DNFRegex_L$.
  
  By Corollary~\ref{cor:star-rewrite-maintained-concat-to-identity},
  there exists a DNF regular expression, $\DNFRegex_R$, and a DNF lens,
  $\DNFLens_R$, such that
  $\DNFLens_R \OfRewritelessType \ConcatDNFOf{\DNFRegexAlt_1}{\DNFRegexAlt_2}
  \Leftrightarrow \DNFRegex_R$, where
  $\SemanticsOf{\DNFLens_R} = \SetOf{(\String,\String) \SuchThat
    \String \in
    \LanguageOf{\ToDNFRegexOf{(\ConcatDNFOf{\DNFRegexAlt_1}{\DNFRegexAlt_2})}}}$
  Furthermore, $\ToDNFRegexOf{(\ConcatDNFOf{\DNFRegexAlt_1}{\DNFRegexAlt_2})}
  \StarOf{\Rewrite} \DNFRegex_R$.

  By Lemma~\ref{lem:composition-completeness}, as
  $\DNFLens_L \OfRewritelessType \DNFRegex_L
  \Leftrightarrow \ConcatDNFOf{\DNFRegex_1}{\DNFRegex_2}$,
  $\ConcatDNFLensOf{\DNFLens_1}{\DNFLens_2}
  \OfRewritelessType
  \ConcatDNFOf{\DNFRegex_1}{\DNFRegex_2} \Leftrightarrow
  \ConcatDNFOf{\DNFRegexAlt_1}{\DNFRegexAlt_2}$, and
  $\DNFLens_R \OfRewritelessType \ConcatDNFOf{\DNFRegexAlt_1}{\DNFRegexAlt_2}
  \Leftrightarrow \DNFRegex_R$
  there exists a DNF Lens
  $\DNFLens \OfRewritelessType \DNFRegex_L \Leftrightarrow \DNFRegex_R$, with
  semantics of the composition of the three lenses.  Because the left and right
  lenses are the identity lenses, $\SemanticsOf{\DNFLens} =
  \SemanticsOf{\ConcatDNFLensOf{\DNFLens_1}{\DNFLens_2}}$.
  
  \[
    \inferrule*
    {
      \DNFLens \OfRewritelessType \DNFRegex_L \Leftrightarrow \DNFRegex_R\\
      \ToDNFRegexOf{(\RegexConcat{\Regex_1}{\Regex_2})} \StarOf{\Rewrite}
      \DNFRegex_L\\
      \ToDNFRegexOf{(\RegexConcat{\RegexAlt_1}{\RegexAlt_2})} \StarOf{\Rewrite}
      \DNFRegex_R
    }
    {
      \DNFLens \OfType
      \ToDNFRegexOf{(\RegexConcat{\Regex_1}{\Regex_2})} \Leftrightarrow
      \ToDNFRegexOf{(\RegexConcat{\RegexAlt_1}{\RegexAlt_2})}
    }
  \]

  By Lemma~\ref{lem:typ_sem_concat},
  $\SemanticsOf{\DNFLens} = \SemanticsOf{\ConcatDNFLensOf{\DNFLens_1}{\DNFLens_2}} =
  \SetOf{(\String_1\Concat\String_2,\StringAlt_1\Concat\StringAlt_2) \SuchThat
    (\String_1,\StringAlt_1)\in\SemanticsOf{\DNFLens_1} \BooleanAnd
    (\String_2,\StringAlt_2)\in\SemanticsOf{\DNFLens_2}} =
  \SetOf{(\String_1\Concat\String_2,\StringAlt_1\Concat\StringAlt_2) \SuchThat
    (\String_1,\StringAlt_1)\in\SemanticsOf{\Lens_1} \BooleanAnd
    (\String_2,\StringAlt_2)\in\SemanticsOf{\Lens_2}} =
  \SemanticsOf{\ConcatLensOf{\Lens_1}{\Lens_2}}$.
  \\
  \\
  Let the last typing rule be an instance of \OrLensRule{}.
  \[
    \inferrule*
    {
      \Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1\\
      \Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2\\
    }
    {
      \OrLensOf{\Lens_1}{\Lens_2} \OfType \RegexOr{\Regex_1}{\Regex_2}
      \Leftrightarrow \RegexOr{\RegexAlt_1}{\RegexAlt_2}
    }
  \]

  By induction assumption, there exists $\DNFLens_1$, $\DNFRegex_1$,
  $\DNFRegexAlt_1$, $\DNFLens_2$, $\DNFRegex_2$, and $\DNFRegexAlt_2$ such that.

  \[
    \inferrule*
    {
      \DNFLens_1 \OfRewritelessType \DNFRegex_1 \Leftrightarrow \DNFRegexAlt_1\\
      \ToDNFRegex{\Regex_1}\StarOf{\Rewrite}\DNFRegex_1\\
      \ToDNFRegex{\RegexAlt_1}\StarOf{\Rewrite}\DNFRegexAlt_1
    }
    {
      \DNFLens_1 \OfType \ToDNFRegexOf{\Regex_1} \Leftrightarrow
      \ToDNFRegexOf{\RegexAlt_1}
    }
  \]

  and

  \[
    \inferrule*
    {
      \DNFLens_2 \OfRewritelessType \DNFRegex_2 \Leftrightarrow \DNFRegexAlt_2\\
      \ToDNFRegex{\Regex_2}\StarOf{\Rewrite}\DNFRegex_2\\
      \ToDNFRegex{\RegexAlt_2}\StarOf{\Rewrite}\DNFRegexAlt_2
    }
    {
      \DNFLens_2 \OfType \ToDNFRegexOf{\Regex_2} \Leftrightarrow
      \ToDNFRegexOf{\RegexAlt_2}
    }
  \]

  From Lemma~\ref{lem:typ_sem_or}, $\OrDNFLensOf{\DNFLens_1}{\DNFLens_2}
  \OfRewritelessType
  \OrDNFOf{\DNFRegex_1}{\DNFRegex_2} \Leftrightarrow
  \OrDNFOf{\DNFRegexAlt_1}{\DNFRegexAlt_2}$.
  By Lemma~\ref{lem:propagation-of-star-rewrites-through-or},
  $\ToDNFRegexOf{\RegexOr{\Regex_1}{\Regex_2}} \StarOf{\Rewrite}
  \OrDNFOf{\DNFRegex_1}{\DNFRegex_2}$ and
  $\ToDNFRegexOf{\RegexOr{\RegexAlt_1}{\RegexAlt_2}} \StarOf{\Rewrite}
  \OrDNFOf{\DNFRegexAlt_1}{\DNFRegexAlt_2}$.  From this, we get
  
  \[
    \inferrule*
    {
      \OrDNFLensOf{\DNFLens_1}{\DNFLens_2} \OfRewritelessType
      \OrDNFOf{\DNFRegex_1}{\DNFRegex_2} \Leftrightarrow
      \OrDNFOf{\DNFRegexAlt_1}{\DNFRegexAlt_2}\\
      $\ToDNFRegexOf{\RegexOr{\Regex_1}{\Regex_2}} \StarOf{\Rewrite}
      \OrDNFOf{\DNFRegex_1}{\DNFRegex_2}$\\
      $\ToDNFRegexOf{\RegexOr{\RegexAlt_1}{\RegexAlt_2}} \StarOf{\Rewrite}
      \OrDNFOf{\DNFRegexAlt_1}{\DNFRegexAlt_2}$
    }
    {
      \OrDNFLensOf{\DNFLens_1}{\DNFLens_2} \OfType
      \ToDNFRegexOf{\RegexOr{\Regex_1}{\Regex_2}} \Leftrightarrow
      \ToDNFRegexOf{\RegexOr{\RegexAlt_1}{\RegexAlt_2}}
    }
  \]

  By Lemma~\ref{lem:typ_sem_or},
  $\SemanticsOf{\OrDNFLensOf{\DNFLens_1}{\DNFLens_2}} =
  \SetOf{(\String,\StringAlt) \SuchThat
    (\String,\StringAlt)\in\SemanticsOf{\DNFLens_1} \BooleanOr
    (\String,\StringAlt)\in\SemanticsOf{\DNFLens_2}} =
  \SetOf{(\String,\StringAlt) \SuchThat
    (\String,\StringAlt)\in\SemanticsOf{\Lens_1} \BooleanOr
    (\String,\StringAlt)\in\SemanticsOf{\Lens_2}} =
  \SemanticsOf{\OrLensOf{\Lens_1}{\Lens_2}}$.
  \\
  \\
  Let the last typing rule be an instance of \SwapLensRule{}.
  \[
    \inferrule*
    {
      \Lens_1 \OfType \Regex_1 \Leftrightarrow \RegexAlt_1\\
      \Lens_2 \OfType \Regex_2 \Leftrightarrow \RegexAlt_2\\
    }
    {
      \SwapLensOf{\Lens_1}{\Lens_2} \OfType \RegexConcat{\Regex_1}{\Regex_2}
      \Leftrightarrow \RegexConcat{\RegexAlt_2}{\RegexAlt_1}
    }
  \]

  By induction assumption, there exists $\DNFLens_1$, $\DNFRegex_1$,
  $\DNFRegexAlt_1$, $\DNFLens_2$, $\DNFRegex_2$, and $\DNFRegexAlt_2$ such that.

  \[
    \inferrule*
    {
      \DNFLens_1 \OfRewritelessType \DNFRegex_1 \Leftrightarrow \DNFRegexAlt_1\\
      \ToDNFRegex{\Regex_1}\StarOf{\Rewrite}\DNFRegex_1\\
      \ToDNFRegex{\RegexAlt_1}\StarOf{\Rewrite}\DNFRegexAlt_1
    }
    {
      \DNFLens_1 \OfType \ToDNFRegexOf{\Regex_1} \Leftrightarrow
      \ToDNFRegexOf{\RegexAlt_1}
    }
  \]

  and

  \[
    \inferrule*
    {
      \DNFLens_2 \OfRewritelessType \DNFRegex_2 \Leftrightarrow \DNFRegexAlt_2\\
      \ToDNFRegex{\Regex_2}\StarOf{\Rewrite}\DNFRegex_2\\
      \ToDNFRegex{\RegexAlt_2}\StarOf{\Rewrite}\DNFRegexAlt_2
    }
    {
      \DNFLens_2 \OfType \ToDNFRegexOf{\Regex_2} \Leftrightarrow
      \ToDNFRegexOf{\RegexAlt_2}
    }
  \]

  From Lemma~\ref{lem:typ_sem_swap}, $\SwapDNFLensOf{\DNFLens_1}{\DNFLens_2}
  \OfRewritelessType
  \ConcatDNFOf{\DNFRegex_1}{\DNFRegex_2} \Leftrightarrow
  \ConcatDNFOf{\DNFRegexAlt_2}{\DNFRegexAlt_1}$.
  
  By Corollary~\ref{cor:star-rewrite-maintained-concat-to-identity}, and
  Lemma~\ref{lem:dnf-lens-inversion},
  there exists a DNF regular expression, $\DNFRegex_L$, and a DNF lens,
  $\DNFLens_L$, such that $\DNFLens_L \OfRewritelessType \DNFRegex_L
  \Leftrightarrow \ConcatDNFOf{\DNFRegex_1}{\DNFRegex_2}$, where
  $\SemanticsOf{\DNFLens_L} = \SetOf{(\String,\String) \SuchThat
    \String \in
    \LanguageOf{\ToDNFRegexOf{(\ConcatDNFOf{\DNFRegex_1}{\DNFRegex_2})}}}$.
  Furthermore, $\ToDNFRegexOf{(\ConcatDNFOf{\DNFRegex_1}{\DNFRegex_2})}
  \StarOf{\Rewrite} \DNFRegex_L$.
  
  By Corollary~\ref{cor:star-rewrite-maintained-concat-to-identity},
  there exists a DNF regular expression, $\DNFRegex_R$, and a DNF lens,
  $\DNFLens_R$, such that
  $\DNFLens_R \OfRewritelessType \ConcatDNFOf{\DNFRegexAlt_2}{\DNFRegexAlt_1}
  \Leftrightarrow \DNFRegex_R$, where
  $\SemanticsOf{\DNFLens_R} = \SetOf{(\String,\String) \SuchThat
    \String \in
    \LanguageOf{\ToDNFRegexOf{(\ConcatDNFOf{\DNFRegexAlt_2}{\DNFRegexAlt_1})}}}$
  Furthermore, $\ToDNFRegexOf{(\ConcatDNFOf{\DNFRegexAlt_2}{\DNFRegexAlt_1})}
  \StarOf{\Rewrite} \DNFRegex_R$.

  By Lemma~\ref{lem:composition-completeness}, as
  $\DNFLens_L \OfRewritelessType \DNFRegex_L
  \Leftrightarrow \ConcatDNFOf{\DNFRegex_1}{\DNFRegex_2}$,
  $\SwapDNFLensOf{\DNFLens_1}{\DNFLens_2}
  \OfRewritelessType
  \ConcatDNFOf{\DNFRegex_1}{\DNFRegex_2} \Leftrightarrow
  \ConcatDNFOf{\DNFRegexAlt_2}{\DNFRegexAlt_1}$, and
  $\DNFLens_R \OfRewritelessType \ConcatDNFOf{\DNFRegexAlt_2}{\DNFRegexAlt_1}
  \Leftrightarrow \DNFRegex_R$
  there exists a DNF Lens
  $\DNFLens \OfRewritelessType \DNFRegex_L \Leftrightarrow \DNFRegex_R$, with
  semantics of the composition of the three lenses.  Because the left and right
  lenses are the identity lenses, $\SemanticsOf{\DNFLens} =
  \SemanticsOf{\SwapDNFLensOf{\DNFLens_1}{\DNFLens_2}}$.

  \[
    \inferrule*
    {
      \DNFLens \OfRewritelessType
      \DNFRegex_L \Leftrightarrow \DNFRegex_R\\
      \ToDNFRegexOf{(\RegexConcat{\Regex_1}{\Regex_2})} \StarOf{\Rewrite}
      \DNFRegex_L\\
      \ToDNFRegexOf{(\RegexConcat{\RegexAlt_2}{\RegexAlt_1})} \StarOf{\Rewrite}
      \DNFRegex_R
    }
    {
      \DNFLens \OfType
      \ToDNFRegexOf{(\RegexConcat{\Regex_1}{\Regex_2})} \Leftrightarrow
      \ToDNFRegexOf{(\RegexConcat{\RegexAlt_2}{\RegexAlt_1})}
    }
  \]
  
  By Lemma~\ref{lem:typ_sem_swap},
  $\SemanticsOf{\DNFLens} = \SemanticsOf{\SwapDNFLensOf{\DNFLens_1}{\DNFLens_2}} =
  \SetOf{(\String_1\Concat\String_2,\StringAlt_2\Concat\StringAlt_1) \SuchThat
    (\String_1,\StringAlt_1)\in\SemanticsOf{\DNFLens_1} \BooleanAnd
    (\String_2,\StringAlt_2)\in\SemanticsOf{\DNFLens_2}} =
  \SetOf{(\String_1\Concat\String_2,\StringAlt_2\Concat\StringAlt_1) \SuchThat
    (\String_1,\StringAlt_1)\in\SemanticsOf{\Lens_1} \BooleanAnd
    (\String_2,\StringAlt_2)\in\SemanticsOf{\Lens_2}} =
  \SemanticsOf{\SwapLensOf{\Lens_1}{\Lens_2}}$.
  \\
  \\

  Let the last rule be an instance of \ComposeLensRule{}.
  \[
    \inferrule*
    {
      \Lens_1 \OfType \Regex_1 \Leftrightarrow \Regex_2\\
      \Lens_2 \OfType \Regex_2 \Leftrightarrow \Regex_3\\
    }
    {
      \ComposeLensOf{\Lens_2}{\Lens_1} \OfType \Regex_1 \Leftrightarrow \Regex_3
    }
  \]

  By induction assumption, there exists $\DNFLens_1$, $\DNFRegex_1$,
  $\DNFRegex_2$, $\DNFLens_2$, $\DNFRegexAlt_2$, and $\DNFRegex_3$ such that

  \[
    \inferrule*
    {
      \DNFLens_1 \OfRewritelessType \DNFRegex_1 \Leftrightarrow \DNFRegex_2\\
      \ToDNFRegex{\Regex_1}\StarOf{\Rewrite}\DNFRegex_1\\
      \ToDNFRegex{\Regex_2}\StarOf{\Rewrite}\DNFRegex_2
    }
    {
      \DNFLens_1 \OfType \ToDNFRegexOf{\Regex_1} \Leftrightarrow
      \ToDNFRegexOf{\RegexAlt_1}
    }
  \]

  and

  \[
    \inferrule*
    {
      \DNFLens_2 \OfRewritelessType \DNFRegexAlt_2 \Leftrightarrow \DNFRegex_3\\
      \ToDNFRegex{\Regex_2}\StarOf{\Rewrite}\DNFRegexAlt_2\\
      \ToDNFRegex{\Regex_3}\StarOf{\Rewrite}\DNFRegex_3
    }
    {
      \DNFLens_2 \OfType \ToDNFRegexOf{\Regex_2} \Leftrightarrow
      \ToDNFRegexOf{\RegexAlt_2}
    }
  \]

  From Lemma~\ref{lem:strongly-unambiguous-identity-expressible}, there exists
  a rewriteless dnf lens
  $\DNFLens_{\IdentityLens} \OfRewritelessType \ToDNFRegex{\Regex_2} \Leftrightarrow
  \ToDNFRegex{\Regex_2}$ where $\SemanticsOf{\DNFLens_{\IdentityLens}} =
  \SetOf{(\String,\String)\SuchThat \String\in\LanguageOf{\Regex_2}}$.
  From Corollary~\ref{cor:rewrite-confluence}, we know that, as
  $\ToDNFRegex{\Regex_2}\StarOf{\Rewrite}\DNFRegex_2$ and as
  $\ToDNFRegex{\Regex_2}\StarOf{\Rewrite}\DNFRegexAlt_2$, there must exist some
  $\DNFRegex_2'$, $\DNFRegexAlt_2'$ such that
  $\DNFRegex_2\StarOf{\Rewrite}\DNFRegex_2'$ and
  $\DNFRegexAlt_2\StarOf{\Rewrite}\DNFRegexAlt_2'$ and there exists a rewriteless dnf
  lens $\DNFLens_{\IdentityLens}' \OfRewritelessType \DNFRegex_2' \Leftrightarrow
  \DNFRegexAlt_2'$ where $\SemanticsOf{\DNFLens_{\IdentityLens}'} =
  \SetOf{(\String,\String)\SuchThat \String\in\LanguageOf{\Regex_2}}$.
  From Corollary~\ref{cor:copyable_expansions_left_serialized_star} and
  Corollary~\ref{cor:copyable_expansions_right_serialized_star}, there exists
  $\DNFRegex_1'$, $\DNFRegex_3'$, $\DNFLens_1'$, and $\DNFLens_2'$ such that
  $\DNFRegex_1\StarOf{\Rewrite}\DNFRegex_1'$, $\DNFRegex_3\StarOf{\Rewrite}\DNFRegex_3'$,
  $\DNFLens_1' \OfRewritelessType \DNFRegex_1' \Leftrightarrow \DNFRegex_2'$,
  $\DNFLens_2' \OfRewritelessType \DNFRegexAlt_2' \Leftrightarrow \DNFRegex_3'$,
  $\SemanticsOf{\DNFLens_1} = \SemanticsOf{\DNFLens_1'}$ and
  $\SemanticsOf{\DNFLens_2} = \SemanticsOf{\DNFLens_2'}$.  From
  Lemma~\ref{lem:composition-completeness}
  rewriteless DNF lenses are closed under composition, so there exists a
  rewriteless DNF lens $\DNFLens' \OfRewritelessType \DNFRegex_1' \Leftrightarrow
  \DNFRegex_2'$ where $\SemanticsOf{\DNFLens'} = \SemanticsOf{\DNFLens_2'}
  \Compose \SemanticsOf{\DNFLens_{\IdentityLens}'} \Compose
  \SemanticsOf{\DNFLens_1'} = \SemanticsOf{\DNFLens_2'} \Compose
  \SemanticsOf{\DNFLens_1'} = \SemanticsOf{\Lens_2} \Compose
  \SemanticsOf{\Lens_1} = \SemanticsOf{\Lens_2\Compose\Lens_1}$.  Furthermore,
  $\ToDNFRegexOf{\Regex_1} \StarOf{\Rewrite} \DNFRegex \StarOf{\Rewrite} \DNFRegex_1'$ so
  $\ToDNFRegex{\Regex_1} \StarOf{\Rewrite} \DNFRegex_1$. $\ToDNFRegex{\Regex_3}
  \StarOf{\Rewrite} \DNFRegex_3 \StarOf{\Rewrite} \DNFRegex_3'$ so $\ToDNFRegex{\Regex_3}
  \StarOf{\Rewrite} \DNFRegex_3'$.  So we get the typing derivation

  \[
    \inferrule*
    {
      \DNFLens' \OfRewritelessType \DNFRegex_1' \Leftrightarrow \DNFRegex_3'\\
      \ToDNFRegex{\Regex_1}\StarOf{\Rewrite}\DNFRegex_1'\\
      \ToDNFRegex{\Regex_3}\StarOf{\Rewrite}\DNFRegex_3'
    }
    {
      \DNFLens' \OfType \ToDNFRegexOf{\Regex_1} \Leftrightarrow
      \ToDNFRegexOf{\Regex_3}
    }
  \]
  \\
  \\

  Let the last rule be an instance of \RewriteRegexLensRule{}.
  \[
    \inferrule*
    {
      \Lens \OfType \Regex \Leftrightarrow \RegexAlt\\
      \Regex \equiv \Regex'\\
      \RegexAlt \equiv \RegexAlt'
    }
    {
      \Lens \OfType \Regex' \Leftrightarrow \RegexAlt'
    }
  \]
  
  By induction assumption, there exists $\DNFLens$, $\DNFRegex$,
  $\DNFRegexAlt$ such that

  \[
    \inferrule*
    {
      \DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt\\
      \ToDNFRegex{\Regex} \StarOf{\Rewrite} \DNFRegex\\
      \ToDNFRegex{\RegexAlt} \StarOf{\Rewrite} \DNFRegexAlt
    }
    {
      \DNFLens \OfType \ToDNFRegexOf{\Regex} \Leftrightarrow
      \ToDNFRegexOf{\RegexAlt}
    }
  \]

  As $\Regex' \DefinitionalEquiv \Regex$, and $\Regex$ is strongly unambiguous,
  from Lemma~\ref{lem:identity-definitional-equivalence} there exists a
  rewriteless DNF lens $\DNFLens_{\Regex',\Regex}
  \OfRewritelessType \overline{\DNFRegex'} \Leftrightarrow
  \overline{\DNFRegex}$ such that
  $\ToDNFRegexOf{\Regex} \StarOf{\Rewrite} \overline{\DNFRegex}$,
  $\ToDNFRegexOf{\Regex'} \StarOf{\Rewrite} \overline{\DNFRegex'}$, and
  $\SemanticsOf{\DNFLens_{\Regex',\Regex}} = \SetOf{(\String,\String)
    \SuchThat \String \in \LanguageOf{\ToDNFRegexOf{\Regex}}}$.
  
  As $\RegexAlt \DefinitionalEquiv \RegexAlt'$, and $\RegexAlt$ is strongly unambiguous,
  from Lemma~\ref{lem:identity-definitional-equivalence} there exists a
  rewriteless DNF lens $\DNFLens_{\RegexAlt,\RegexAlt'}
  \OfRewritelessType \overline{\DNFRegexAlt} \Leftrightarrow
  \overline{\DNFRegexAlt'}$ such that
  $\ToDNFRegexOf{\RegexAlt} \StarOf{\Rewrite} \overline{\DNFRegexAlt}$,
  $\ToDNFRegexOf{\RegexAlt'} \StarOf{\Rewrite} \overline{\DNFRegexAlt'}$, and
  $\SemanticsOf{\DNFLens_{\RegexAlt,\RegexAlt'}} = \SetOf{(\String,\String)
    \SuchThat \String \in \LanguageOf{\ToDNFRegexOf{\RegexAlt}}}$.

  From Lemma~\ref{lem:strongly-unambiguous-identity-expressible}, there exists a
  lens $\DNFLens_{\ToDNFRegexOf{\Regex}} \OfRewritelessType
  \ToDNFRegexOf{\Regex} \Leftrightarrow \ToDNFRegexOf{\Regex}$.  As
  $\ToDNFRegexOf{\Regex} \StarOf{\Rewrite} \overline{\DNFRegex}$ and
  $\ToDNFRegexOf{\Regex} \StarOf{\Rewrite} \DNFRegex$, by
  Corollary~\ref{cor:rewrite-confluence}, there exists some
  $\tilde{\DNFLens_{\ToDNFRegexOf{\Regex}}} \OfRewritelessType
  \tilde{\overline{\DNFRegex}} \Leftrightarrow \tilde{\DNFRegex}$,
  such that
  $\overline{\DNFRegex} \StarOf{\Rewrite} \tilde{\overline{\DNFRegex}}$,
  $\DNFRegex \StarOf{\Rewrite} \tilde{\DNFRegex}$, and
  $\SemanticsOf{\tilde{\DNFLens_{\ToDNFRegexOf{\Regex}}}} =
  \SemanticsOf{\DNFLens_{\ToDNFRegexOf{\Regex}}}$.
  From Corollary~\ref{cor:copyable_expansions_right_serialized_star}, there
  exists a $\tilde{\DNFLens_{\Regex',\Regex}} \OfRewritelessType
  \tilde{\overline{\DNFRegex'}} \Leftrightarrow \tilde{\overline{\DNFRegex}}$
  such that $\overline{\DNFRegex'} \StarOf{\Rewrite}
  \tilde{\overline{\DNFRegex'}}$ and
  $\SemanticsOf{\tilde{\DNFLens_{\Regex',\Regex}}} =
  \SemanticsOf{\DNFLens_{\Regex',\Regex}}$

  From Lemma~\ref{lem:strongly-unambiguous-identity-expressible}, there exists a
  lens $\DNFLens_{\ToDNFRegexOf{\RegexAlt}} \OfRewritelessType
  \ToDNFRegexOf{\RegexAlt} \Leftrightarrow \ToDNFRegexOf{\RegexAlt}$.  As
  $\ToDNFRegexOf{\RegexAlt} \StarOf{\Rewrite} \DNFRegexAlt$ and
  $\ToDNFRegexOf{\RegexAlt} \StarOf{\Rewrite} \overline{\DNFRegexAlt}$, by
  Corollary~\ref{cor:rewrite-confluence}, there exists some
  $\tilde{\DNFLens_{\ToDNFRegexOf{\RegexAlt}}} \OfRewritelessType
  \tilde{\DNFRegexAlt} \Leftrightarrow \tilde{\overline{\DNFRegexAlt}}$,
  such that
  $\DNFRegexAlt \StarOf{\Rewrite} \tilde{\DNFRegexAlt}$,
  $\overline{\DNFRegexAlt} \StarOf{\Rewrite} \tilde{\overline{\DNFRegexAlt}}$, and
  $\SemanticsOf{\tilde{\DNFLens_{\ToDNFRegexOf{\RegexAlt}}}} =
  \SemanticsOf{\DNFLens_{\ToDNFRegexOf{\RegexAlt}}}$.
  From Corollary~\ref{cor:copyable_expansions_left_serialized_star}, there
  exists a $\tilde{\DNFLens_{\RegexAlt,\RegexAlt'}} \OfRewritelessType
  \tilde{\overline{\DNFRegexAlt}} \Leftrightarrow \tilde{\overline{\DNFRegexAlt'}}$
  such that $\overline{\DNFRegexAlt'} \StarOf{\Rewrite}
  \tilde{\overline{\DNFRegexAlt'}}$ and
  $\SemanticsOf{\tilde{\DNFLens_{\RegexAlt',\RegexAlt}}} =
  \SemanticsOf{\DNFLens_{\RegexAlt',\RegexAlt}}$.

  As $\DNFRegex \StarOf{\Rewrite} \tilde{\DNFRegex}$ and
  $\DNFRegexAlt \StarOf{\Rewrite} \tilde{\DNFRegexAlt}$,
  by Corollary~\ref{cor:rewrite-confluence} there exists a lens
  $\underline{\DNFLens} \OfRewritelessType \underline{\DNFRegex} \Leftrightarrow
  \underline{\DNFRegexAlt}$ such that
  $\tilde{\DNFRegex} \StarOf{\Rewrite} \underline{\DNFRegex}$,
  $\tilde{\DNFRegexAlt} \StarOf{\Rewrite} \underline{\DNFRegexAlt}$, and
  $\SemanticsOf{\underline{\DNFLens}} = \SemanticsOf{\DNFLens}$.
  
  From Corollary~\ref{cor:copyable_expansions_right_serialized_star}, there
  exists $\underline{\tilde{\DNFLens_{\ToDNFRegexOf{\Regex}}}}
  \OfRewritelessType \underline{\tilde{\overline{\DNFRegex}}}
  \Leftrightarrow \underline{\DNFRegex}$ such that $\tilde{\overline{\DNFRegex}}
  \StarOf{\Rewrite} \underline{\tilde{\overline{\DNFRegex}}}$ and
  $\SemanticsOf{\underline{\tilde{\DNFLens_{\ToDNFRegexOf{\Regex}}}}} =
  \SemanticsOf{\tilde{\DNFLens_{\ToDNFRegexOf{\Regex}}}}$.
  From Corollary~\ref{cor:copyable_expansions_right_serialized_star}, there
  exists $\underline{\tilde{\DNFLens_{\Regex',\Regex}}}
  \OfRewritelessType \underline{\tilde{\overline{\DNFRegex'}}}
  \Leftrightarrow \underline{\tilde{\overline{\DNFRegex}}}$
  such that $\tilde{\overline{\DNFRegex'}}
  \StarOf{\Rewrite} \underline{\tilde{\overline{\DNFRegex'}}}$ and
  $\SemanticsOf{\underline{\tilde{\DNFLens_{\Regex',\Regex}}}} =
  \SemanticsOf{\tilde{\DNFLens_{\Regex',\Regex}}}$.
  
  From Corollary~\ref{cor:copyable_expansions_left_serialized_star}, there
  exists $\underline{\tilde{\DNFLens_{\ToDNFRegexOf{\RegexAlt}}}}
  \OfRewritelessType \underline{\DNFRegexAlt}
  \Leftrightarrow \underline{\tilde{\overline{\DNFRegexAlt}}}$ such that
  $\tilde{\overline{\DNFRegexAlt}}
  \StarOf{\Rewrite} \underline{\tilde{\overline{\DNFRegexAlt}}}$ and
  $\SemanticsOf{\underline{\tilde{\DNFLens_{\ToDNFRegexOf{\RegexAlt}}}}} =
  \SemanticsOf{\tilde{\DNFLens_{\ToDNFRegexOf{\RegexAlt}}}}$.
  From Corollary~\ref{cor:copyable_expansions_left_serialized_star}, there
  exists $\underline{\tilde{\DNFLens_{\RegexAlt,\RegexAlt'}}}
  \OfRewritelessType \underline{\tilde{\overline{\DNFRegexAlt}}}
  \Leftrightarrow \underline{\tilde{\overline{\DNFRegexAlt'}}}$
  such that $\tilde{\overline{\DNFRegexAlt'}}
  \StarOf{\Rewrite} \underline{\tilde{\overline{\DNFRegexAlt'}}}$ and
  $\SemanticsOf{\underline{\tilde{\DNFLens_{\RegexAlt,\RegexAlt'}}}} =
  \SemanticsOf{\tilde{\DNFLens_{\RegexAlt,\RegexAlt'}}}$.

  From Lemma~\ref{lem:composition-completeness}, there exists a lens
  $\boldsymbol{\DNFLens} \OfRewritelessType
  \underline{\tilde{\overline{\DNFRegex'}}} \Leftrightarrow
  \underline{\tilde{\overline{\DNFRegexAlt'}}}$.  Because the semantics of all
  lenses in the composition for $\boldsymbol{\DNFLens}$ were all the identity
  relation, $\SemanticsOf{\boldsymbol{\DNFLens}} = \SemanticsOf{\DNFLens}$.
  Furthermore,
  $\ToDNFRegexOf{\Regex'} \StarOf{\Rewrite}
  \underline{\tilde{\overline{\DNFRegex'}}}$
  and
  $\ToDNFRegexOf{\RegexAlt'} \StarOf{\Rewrite}
  \underline{\tilde{\overline{\DNFRegexAlt'}}}$, so we have the derivation
  
  \[
    \inferrule*
    {
      \boldsymbol{\DNFLens} \OfRewritelessType
      \underline{\tilde{\overline{\DNFRegex'}}} \Leftrightarrow
      \underline{\tilde{\overline{\DNFRegexAlt'}}}\\
      \ToDNFRegexOf{\Regex'} \StarOf{\Rewrite}
      \underline{\tilde{\overline{\DNFRegex'}}}\\
      \ToDNFRegexOf{\RegexAlt'} \StarOf{\Rewrite}
      \underline{\tilde{\overline{\DNFRegexAlt'}}}
    }
    {
      \boldsymbol{\DNFLens} \OfType \ToDNFRegexOf{\Regex'} \Leftrightarrow
      \ToDNFRegexOf{\RegexAlt'}
    }
  \]

  with $\SemanticsOf{\boldsymbol{\DNFLens}} = \SemanticsOf{\Lens}$
\end{proof}

\dnflc*
\begin{proof}
  By Lemma~\ref{lem:pre-completeness}, there exists $\DNFLens$, $\DNFRegex$,
  $\DNFRegexAlt$ such that $\DNFLens \OfRewritelessType \DNFRegex
  \Leftrightarrow \DNFRegexAlt$, $\ToDNFRegexOf{\Regex} \StarOf{\Rewrite}
  \DNFRegex$, $\ToDNFRegexOf{\RegexAlt} \StarOf{\Rewrite} \DNFRegexAlt$, and
  $\SemanticsOf{\DNFLens} = \SemanticsOf{\Lens}$.  Because of that, we have the
  derivation

  \[
    \inferrule*
    {
      \DNFLens \OfRewritelessType \DNFRegex \Leftrightarrow \DNFRegexAlt\\
      \ToDNFRegexOf{\Regex} \StarOf{\Rewrite} \DNFRegex\\
      \ToDNFRegexOf{\RegexAlt} \StarOf{\Rewrite} \DNFRegexAlt
    }
    {
      \DNFLens \OfType \ToDNFRegexOf{\Regex} \Leftrightarrow
      \ToDNFRegexOf{\RegexAlt}
    }
  \]
\end{proof}

% proof-dnflc end
% end proofs
% \appendixtrue
\fi

\end{document}



%%% Local Variables:
%%% TeX-master: "main"
%%% End:
