
Lenses are two functions, that satisfy the get-put laws.
But it is annoying to prove, automatically or through provided proofs,
that two functions satisfy the get-put laws.

We can take a language based approach, where the language only allows for
the writing of functions
that satisfy the get-put laws.
This has been explored in previous work like Boomerang\cite{boomerang}.
A close inspection of the laws behind the lenses shows that the typing of the
lenses corresponds tightly with the actual lenses.
For example, consider the concatenation rule

\begin{mathpar}
\inferrule*
{
\Lens_1 : \Regex_1 \Leftrightarrow \RegexAlt_1\\
\Lens_2 : \Regex_2 \Leftrightarrow \RegexAlt_2\\\\
\UnambigConcat{\Language(\Regex_1)}{\Language(\Regex_2)}\\
\UnambigConcat{\Language(\Regex_2)}{\Language(\RegexAlt_2)}\\
}
{
\ConcatLens{\Lens_1}{\Lens_2} :
\RegexConcat{\Regex_1}{\Regex_2} \Leftrightarrow
\RegexConcat{\RegexAlt_1}{\RegexAlt_2}
}
\end{mathpar}

Concatenation lenses come alongside a regular expression concatenation.
Perhaps, instead of writing out lenses explicitly, we can merely
write its type, and the lenses can be inferred from the types.
Utilizing types for synthesis is not a new idea, and has been explored
in systems like Myth \cite{tds-pldi}.
However, we have found that type directed synthesis is well suited
for domain specific languages like the language of lenses.
The constraints the type systems of these languages make the search space
tighter, and allow us to synthesize very complicated
programs very quickly.

\input{fig_regex-syntax}
\input{fig_regex-semantics}
However, if we are to use the types to direct, and the types are
regular expressions, we would like to allow for users to easily engineer
regular expressions.
For this we have created a language of regular expressions with a context,
with syntax defined in Figure~\ref{fig:regex-syntax}, and semantics defined
in Figure~\ref{fig:regex-semantics}.  In this, we only allow the context to
have finite size.
We show that adding in a context doesn't increase expressibility.
\begin{restatable}[Completeness of the Regular Expressions Without Variables]{theorem}{ecrc}
\label{thm:empty-context-regex-completeness}
For all contexts \RegexContext{} and regular expressions \Regex{}, there exists a regular expression \Regex{}',
such that \LanguageOf{\RegexContext{}}{\Regex{}}=\LanguageOf{\emptyset}{\Regex{}'}.
\end{restatable}
\begin{proof}
By induction on the size of the context and the regular expression
\end{proof}

\input{fig_lens-syntax}
\input{fig_lens-alternate-alternate-semantics}

We choose to work on a restricted class of lenses,
bijective lenses.
While normal lenses allow for loss of data in going from
the source to the target, bijective lenses do not allow for any loss of data.
With this further restriction, we arrive at the lenses shown in Figure~\ref{fig:lens-syntax}.
These lenses have a type system, shown in Figure~\ref{fig:lens-alternate-alternate-semantics},
even more suited to synthesis than the normal language of lenses.
In these, the typing $\FullContext \DerivesLens \Lens \OfType \MapsBetweenTypeOf{\Regex}{\RegexAlt} \HasSemantics \PutLeft,\PutRight$ means
under the regular expression context \RegexContext{} and the lens context \LensContext{},
there is a bijective lens \Lens{}, with two underlying functions,
\PutRight{} and \PutLeft{}, where $\PutRight \OfType \ArrowTypeOf{\LanguageOf{\RegexContext}{\Regex}}{\LanguageOf{\RegexContext}{\RegexAlt}}$
and $\PutLeft \OfType \ArrowTypeOf{\LanguageOf{\RegexContext}{\RegexAlt}}{\LanguageOf{\RegexContext}{\Regex}}$.
We can prove that the system only expresses bijective
functions, but does not express all bijective functions.
\begin{restatable}[Soundness of the Language of Bijective Lenses]{theorem}{bls}
\label{thm:bij-lens-soundness}
If $\FullContext \vdash \Lens : \Regex \Leftrightarrow \RegexAlt \HasSemantics \PutRight,\PutLeft$,
then \PutRight{} is a bijective function from \LanguageOf{\Delta{}}{\Regex{}} to \LanguageOf{\Delta{}}{\RegexAlt{}}, with inverse $\PutLeft{}$.
\end{restatable}
\begin{proof}
Through induction on typing derivations.
\end{proof}
\begin{restatable}[Incompleteness of the Language of Bijective Lenses]{theorem}{blic}
\label{thm:bij-lens-incompleteness}
There exists regular expressions $\Regex$, $\RegexAlt$,
a regular expression context $\RegexContext$, a lens context $\LensContext$, and a bijective function $f:\LanguageOf{\Delta}{\Regex}\rightarrow\LanguageOf{\Delta}{\RegexAlt}$
such that for all lenses \Lens{}, there does not exist a derivation for
$\FullContext \vdash \Lens : \Regex \Leftrightarrow \RegexAlt \HasSemantics f,\InverseOf{f}$.
\end{restatable}
\begin{proof}
Through a specific bijection between $\LanguageOf{\emptyset}{\Star{a}}$ and $\LanguageOf{\emptyset}{\Star{a}}$.
\end{proof}
or
\begin{proof}
Through a counting argument of the possible number of bijections between $\LanguageOf{\emptyset}{\Star{a}}$ and $\LanguageOf{\emptyset}{\Star{a}}$.
\end{proof}

Interestingly, the use of lens contexts and regular expression contexts
is not needed.
This can be formalized in the following theorem.
\begin{restatable}[Completeness of Bijective Lenses Without Variables]{theorem}{eclc}
\label{thm:empty-context-lens-completeness}
If $\FullContext \vdash \Lens : \Regex \Leftrightarrow \RegexAlt \HasSemantics \PutRight,\PutLeft$,
then there exists a $\Lens'$, $\Regex'$, $\RegexAlt'$, such that
\LanguageOf{\RegexContext}{\Regex}=\LanguageOf{\emptyset}{\Regex'},
\LanguageOf{\RegexContext}{\RegexAlt}=\LanguageOf{\emptyset}{\RegexAlt'}, and
$\emptyset,\emptyset \DerivesLens \Lens' \OfType \MapsBetweenTypeOf{\Regex'}{\RegexAlt'} \HasSemantics \PutRight,\PutLeft$.
\end{restatable}
\begin{proof}
Through induction on typing derivations.
\end{proof}
However, despite the fact these variables are not needed, they are useful for nice
separation of concerns.
Lenses in the context are likely to be used, much like when programming, one
doesn't import libraries for no reason.

In this, all of the rules except Retype Lens have a clear synthesis algorithm.
For example, given the type $\RegexConcat{\Regex_1}{\Regex_2}\Leftrightarrow\RegexConcat{\RegexAlt_1}{\RegexAlt_2}$.
We know that it can be created from a Concat Lens rule,
which would create the subproblems of $\Regex_1\Leftrightarrow\RegexAlt_1$ and $\Regex_2\Leftrightarrow\RegexAlt_2$;
it can be created from a Swap Lens rule, which would create the subproblems of $\Regex_1\Leftrightarrow\RegexAlt_2$ and $\Regex_2\Leftrightarrow\RegexAlt_1$;
and it can be created from Retype Lens, for which the subproblems are not clear.

However, the Retype Lens rule is a very important rule.
Without the Retype Lens rule, it would not be possible to have a lens of the type
$a\Concat (b\Concat (c\Concat d))\Leftrightarrow(a\Concat b)\Concat(c\Concat d)$,
despite the fact that we expect this lens to be inhabited by the lens \IdentityLens{}.


\input{fig_dnf-regex-syntax}
\input{fig_dnf-regex-semantics}
\input{fig_dnf-regex-functions}
\input{fig_dnf-regex-rewrites}
Because of this, to synthesize lenses, we instead create a new, equivalent language,
who handles many of the equivalences of regular expressions through exploiting a normal form.
We define this normal form of regular expression DNF Regular expression, with syntax
defined as in Figure~\ref{fig:dnf-regex-syntax}, and with semantics defined as
in Figure~\ref{fig:dnf-regex-semantics}.  These semantics rely on some functions
defined in Figure~\ref{fig:dnf-regex-functions},
and some rewrite rules defined in Figure~\ref{fig:dnf-regex-rewrites}.
This normal form is called a DNF regular expression, as it is similar to the
sentences in logical disjunctive normal form.
These DNF regular expression expresses exactly the same amount as standard regular
expressions.
\begin{restatable}[Completeness of DNF Regexs]{theorem}{dnfrc}
\label{thm:completeness-dnf-lenses}
There exists a function $\ToDNFRegex\OfType\ArrowTypeOf{\mathit{Regex}}{\mathit{DNF Regex}}$,
such that, for all $\RegexContext$, $\LanguageOf{\RegexContext}{\Regex}=\LanguageOf{\RegexContext}{\ToDNFRegex(\Regex)}$.
\end{restatable}

\begin{restatable}[Soundness of DNF Regexs]{theorem}{dnfrs}
\label{thm:soundness-dnf-lenses}
The function \ToDNFRegex{} has a right inverse \FromDNFRegex{}.
\end{restatable}


\input{fig_dnf-lens-syntax}
\input{fig_dnf-lens-alternate-alternate-semantics}
We have created a language which can handle many of the equivalences of regular
expressions through operation on dnf regular expressions,
and adds additional structure to the search
space, constraining it and minimizing the traversal through equivalent elements.
We call this language, the language of DNF lenses, due to the fact the lenses
operate on DNF regular expressions.
The syntax for these lenses is provided in Figure~\ref{fig:dnf-lens-syntax}.
The typing and semantics for these lenses is provided in Figure~\ref{fig:dnf-lens-alternate-alternate-semantics}.
DNF Lenses express exactly the same amount as standard lenses.
\begin{restatable}[Completeness of DNF Lenses]{theorem}{dnflc}
\label{thm:completeness-dnf-lenses}
If there exists a derivation of $\FullContext \DerivesLens \Lens \OfType \MapsBetweenTypeOf{\Regex}{\RegexAlt} \HasSemantics \PutRight,\PutLeft$,
then there exists a derivation of $\FullContext \DerivesDNFLens \DNFLens \OfType \MapsBetweenTypeOf{\DNFRegex}{\DNFRegexAlt} \HasSemantics \PutRight,\PutLeft$ such that
$\LanguageOf{\RegexContext}{\DNFRegex}=\LanguageOf{\RegexContext}{\Regex}$, and
$\LanguageOf{\RegexContext}{\DNFRegexAlt}=\LanguageOf{\RegexContext}{\RegexAlt}$.
\end{restatable}

\begin{restatable}[Soundness of DNF Lenses]{theorem}{dnfls}
\label{thm:soundness-dnf-lenses}
If there exists a derivation of $\FullContext \DerivesDNFLens \DNFLens \OfType \MapsBetweenTypeOf{\DNFRegex}{\DNFRegexAlt} \HasSemantics \PutRight,\PutLeft$,
then there exists a derivation of $\FullContext \DerivesLens \Lens \OfType \MapsBetweenTypeOf{\Regex}{\RegexAlt} \HasSemantics \PutRight,\PutLeft$ such that
$\LanguageOf{\RegexContext}{\Regex}=\LanguageOf{\RegexContext}{\DNFRegex}$, and
$\LanguageOf{\RegexContext}{\RegexAlt}=\LanguageOf{\RegexContext}{\DNFRegexAlt}$.
\end{restatable}

DNF lenses handle the equivalences of concatenation associativity,
or associativity, or commutativity, and and-or distributivity.
Furthermore, they do not require composition to be complete,
though we do allow for concatenation of lenses in the lens context.
While these are not needed for full expressibility because of Theorem~\ref{thm:empty-context-regex-completeness}
and Theorem~\ref{thm:completeness-dnf-lenses},
we choose to use these contextual lenses and regular expression.
This is under the assumption that if lenses are present
in the context, they are likely to be used.
However, this does add in additional choices for synthesis, but we've found
that in practice, it simplifies the algorithm (TODO: this analysis).
Because of this, the choices needed to be done by the synthesis algorithm
are fairly minimal.  There are only
a few types of equivalences related to stars and use of regular expressions
in the context that need to be explored for completeness.
Furthermore, there is the difficulty of determining which permutations create
well typed regular expressions, but our implentation reduces the problem of
finding a valid permutation to ordering the terms under a specific order.

\input{fig_regex-equivalence-rules}
Two regular expressions are said to be equivalent if they are equivalent through
any of the rules specified in Figure~\ref{fig:regex-equivalence-rules}.
Indeed, after ordering we have put our regular expressions in a very normal form.
If we normalize two regular expressions, and those two regular expressions are
equivalent through any number of applications of equivalences 1 through 8, then
their ordered DNF regular expressions will be equivalent.
What's more, we can use the ordering on ordered DNF regular expressions to create another
equivalence class.  The ordering on DNF regular expressions says two ordered
dnf regular expressions are equal if, and only if, there exists a lens between
then, where the lens typing doesn't include the DNF Rewrite Lens rule.  The purpose
of the DNF Rewrite rule is to handle the other types of equivalences.




