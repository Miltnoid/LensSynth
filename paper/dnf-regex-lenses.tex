\section{DNF Regular Expressions and Lenses}
We can push the boundaries of what is expressible through syntactic lenses
through finding a language, equivalent to regular expressions, with fewer
equivalences.

A language which removes some of those equivalences is the language of regular
expressions in disjunctive normal form.  This language removes the
equivalences corresponding to distributivity, associativity, and concatenation identity.
Figure~\ref{fig:dnf-regex-definition} defines this, with semantics as in
~\ref{fig:dnf-regex-semantics}
The full DNF Regex is a list of Clauses.  This corresponds to a chain of $+$s
in the normal language of regular expressions.
A Clause is a list of Atoms, with strings in between.
This corresponds to a chain of composition.  These strings
correspond to regular expression base types, and their requirement to
exist between every atom removes the $\epsilon$ equivalences.
Atoms correspond to pieces that either cannot be broken up uniquely, or we feel should not be broken up.
These are the star regular expressions, and the user defined regular expressions.
The star regular expressions can be broken up in an infinite number of ways.
We feel that a user grouping together aspects of their regular expression together
signifies that it will likely stay together in the transformation.

As we have dnf regular expressions, it also makes sense to have dnf lenses,
whose types are dnf regular expressions.  We define dnf lenses in Figure~\ref{fig:dnf-lens-syntax}.
These dnf lenses have the comparable underlying relations to the underlyingrelations 
of normal lenses, and are given in Figure~\ref{fig:dnf-lens-semantics}.
There is also a similar theorem to Theorem~\ref{thm:lens-bij-fcn}.
\begin{theorem}
\label{thm:dnf-lens-bij-fcn}
If $\Delta \vdash \DNFLens : \DNFRegex_1 \Leftrightarrow \DNFRegex_2$,
then for all $x \in \LanguageOf{\Delta}{\DNFRegex_1}$, there exists a unique $y \in \LanguageOf{\Delta}{\DNFRegex_2}$ such that $\denot{\DNFLens}(x,y)$.
This defines a bijective function called $\DNFLens.putr : \LanguageOf{\Delta}{\DNFRegex_1} \rightarrow \LanguageOf{\Delta}{\DNFRegex_2}$,
whose inverse is called $\DNFLens.putl$.
\end{theorem}
TODO: make a nice diagram of how clause lenses work.
They can be typed according to the rules given in Figure~\ref{fig:dnf-lens-typing}

One thing to note about these lenses is that they are slightly more expressive
than the syntactic lenses given previously.
Not all permutations are possible through only using swap.
Furthermore, before we did not allow for permutations on union clauses,
which previously were dealt with through the type change rule of pure lenses.
Now, these permutations are possible.  So, for example, there are no syntactic lenses
between $a+b*$ and $z*+y$.  However, with allowing for permutations, the new
language can synthesize these types of lenses.

Just as we used the parse trees of strings within a regular expression,
to help guide the synthesis for syntactic lenses, we can do the same
for dnf lenses.
