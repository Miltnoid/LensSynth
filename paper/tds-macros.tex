\newif\ifdraft\draftfalse
\newif\ifappendix\appendixfalse

\usepackage{mathpartir}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{xparse}
\usepackage{stmaryrd}
\usepackage{xcolor}

\newcommand{\comment}[1]{}

\definecolor{pennred}{RGB}{149,0,26}
\definecolor{cornellred}{RGB}{196,18,48}
\definecolor{princetonorange}{RGB}{255,143,0}
\definecolor{grinnellscarlet}{RGB}{255,36,0}
\definecolor{tmlblue}{RGB}{0,58,120}  % tml == Toronto Maple Leafs
\definecolor{brownbrown}{RGB}{121,37,0}

\newcommand{\finish}[1]{\ifdraft#1\else\fi}
\newcommand{\dpw}[1]{\finish{\textcolor{tmlblue}{[#1 --DPW]}}}
\newcommand{\saz}[1]{\finish{\textcolor{pennred}{[#1 --SAZ]}}}
\newcommand{\jef}[1]{\finish{\textcolor{princetonorange}{[#1 --JEF]}}}
\newcommand{\pmo}[1]{\finish{\textcolor{grinnellscarlet}{[#1 --PM]}}}

\newcommand{\IncludeInAppendix}[1]{\ifappendix#1\else\fi}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                         %%
%%     MACROS                                              %%
%%                                                         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}{Definition}



% CONTEXTS
\newcommand{\CtorCtx} {\ensuremath{\Sigma}}      % Constructor context
\newcommand{\TypeCtx} {\ensuremath{\Gamma}}      % Type context
\newcommand{\TypeCtxA} {\ensuremath{\langle\Gamma\rangle}}      % Type context
\newcommand{\TypeCtxAi}[1]{\ensuremath{\langle\Gamma_{#1}\rangle}}      % Type context
\newcommand{\TypeCtxAlt} {\ensuremath{\Delta}}   % Type context alternate variable (Dave)
\newcommand{\ValCtx}  {\ensuremath{\Delta}}      % Value context
\newcommand{\ExamCtx} {\ensuremath{\mathcal{E}}} % Example context
\newcommand{\RefinementCtx}{\ensuremath{\Delta}}     % Refinement type context
\newcommand{\FocusCtx}{\ensuremath{\mathcal{F}}} % Focusing context
\newcommand{\AuxCtx}  {\ensuremath{\mathcal{A}}} % Auxiliary definition context
\newcommand{\GoalCtx} {\ensuremath{\mathcal{G}}} % Goal context
\newcommand{\ExtCtx} {\ensuremath{\Psi}}        % External context
\newcommand{\WorldOne}{\ensuremath{w}}           % A single world
\newcommand{\WorldCtx}{\ensuremath{\mathcal{W}}} % World symbol
\newcommand{\Exam}{\ensuremath{\epsilon}}        % Examples
\newcommand{\Refinement}{\ensuremath{r}}         % Refinements
\newcommand{\NRefinement}{\ensuremath{u}}        % Negated Refinements
\newcommand{\Base}{\ensuremath{b}}               % Base refinements
\newcommand{\RefinementN}{\ensuremath{\tilde{r}}}% Refinements with negation
\newcommand{\Sefinement}{\ensuremath{t}}         % Refinements
\newcommand{\Nefinement}{\ensuremath{n}}         % Refinements
\newcommand{\SefinementN}{\ensuremath{\tilde{s}}}% Refinements with negation
\newcommand{\Partial}{\ensuremath{pf}}           % Partial functions
\newcommand{\Elim}{\ensuremath{E}}               % Elimination form
\newcommand{\Intro}{\ensuremath{I}}              % Introduction form

% WELL-FORMEDNESS
\newcommand{\Wf}[1]{\ensuremath{\vdash {#1}~~wf}} % Well formed

% METAVARIABLES
\newcommand{\DType}{\ensuremath{\tau}}           % Default type symbol
\newcommand{\DVar} {\ensuremath{x}}              % Default variable symbol
\newcommand{\DFVar} {\ensuremath{f}}             % Default function variable symbol
\newcommand{\DExp} {\ensuremath{e}}              % Default expression symbol
\newcommand{\DVal} {\ensuremath{v}}              % Default value symbol
\newcommand{\DValf}{\ensuremath{\hat{v}}}        % Default first-order value symbol
\newcommand{\DValEq}{\ensuremath{\dot{\DVal}}}   % Default equality value symbol
\newcommand{\DExam}{\ensuremath{\Exam}}          % Default example symbol
\newcommand{\DCtor}{\ensuremath{C}}              % Default constructor symbol
\newcommand{\DFun} {\ensuremath{f}}              % Default function symbol

% GRAMMAR OPERATORS
\newcommand{\GBar}{\ensuremath{~|~}}
\newcommand{\GIndent}{\hspace{.5in}}
\newcommand{\GEq}{\ensuremath{::=~}}
\newcommand{\GEmp}{\ensuremath{\cdot}}

% USEFUL COMBINATORS
\DeclareDocumentCommand{\Range}{                % Range
    O{\DVal} O{n} O{,}
  }{\ensuremath{{#1}_1{#3}~... {#3}~{#1}_{#2}}}
\newcommand{\CtorType}[1]                       % Constructor type
   {{#1} \rightarrow \TBase}
\newcommand{\Overbar}[2]                        % Overbar
  {\ensuremath{\overline{{#2}}^{#1}}}
\newcommand{\SynthProp}[4]                      % A synthesis proposition
   {\ensuremath{{#2} \vdash {#3} \overset{#1}{\leadsto} {#4}}}
\newcommand{\IntSynthProp}[3]                   % An intersection synthesis proposition
   {\ensuremath{{#2} \overset{#1}{\leadsto} {#3}}}

% RELATIONSHIPS
\DeclareDocumentCommand{\HasType}{               % Has Type...
    O{\DExp} O{\DType}
  }{\ensuremath{{#1} : {#2}}}
\DeclareDocumentCommand{\HasTypeCtx}{               % Has Type...
    O{\TypeCtx} O{\DExp} O{\DType}
  }{\ensuremath{{#1} \vdash {#2} : {#3}}}
\DeclareDocumentCommand{\HasTypeVal}{               % Has Type...
    O{\DExp} O{\DType} O{\DVal}
  }{\ensuremath{{#1} : {#2} = {#3}}}
\DeclareDocumentCommand{\InType}{                % In Type...
    O{\DExp} O{\DType}
  }{\ensuremath{{#1} \in {#2}}}
\DeclareDocumentCommand{\Subtype}{               % Is a subtype of...
    O{\DType_1} O{\DType_2}
  }{\ensuremath{{#1} <: {#2}}}
\DeclareDocumentCommand{\Refines}{               % Refines...
    O{\DVar} O{\DExam}
  }{\ensuremath{{#1} \triangleright {#2}}}
\DeclareDocumentCommand{\SubRefines}{            % Refines at a subtype
    O{\Refinement_1} O{\Refinement_2} O{\DType}
  }{\ensuremath{\Refines[\Subtype[{#1}][{#2}]][{#3}]}}


% TYPES
\newcommand{\TPoly}[1]{\ensuremath{#1}}
\newcommand{\DPoly}{\TPoly{\alpha}}
\newcommand{\DPolyVar}{\ensuremath{\alpha_n}}
\newcommand{\TSumTop}[1]{\ensuremath{\mathsf{#1}^\top}}
\newcommand{\TBase}{\ensuremath{\mathcal{B}}}   % Base type
\newcommand{\TBTop}{\ensuremath{\TBase^\top}}   % Base top
\newcommand{\TBBot}{\ensuremath{\TBase^\bot}}   % Base bottom
\newcommand{\TBool}{\ensuremath{\mathsf{Bool}}}   % Bool type
\newcommand{\TTrue}{\ensuremath{\mathsf{true}}}   % true refinement type
\newcommand{\TFalse}{\ensuremath{\mathsf{false}}} % false refinement type
\DeclareDocumentCommand{\TComp}{                % Complement type
    O{\TBase} O{\DVal}
  }{\ensuremath{{#1}^{\setminus {#2}}}}
\DeclareDocumentCommand{\TAnd}{                 % Intersection type
    O{\DType_1} O{\DType_2}
  }{\ensuremath{{#1} \land {#2}}}
\DeclareDocumentCommand{\TAndRange}{            % Intersection range
    O{\DType} O{m}
  }{\Range[#1][#2][~\land]}
\DeclareDocumentCommand{\TAnds}{                % Intersection type
    O{\DType_1}
  }{\ensuremath{\land({#1})}}
\DeclareDocumentCommand{\TAndsRange}{           % Intersection range
    O{\DType} O{m}
  }{\TAnds[{#1}_1, ..., {#1}_{#2}]}
\DeclareDocumentCommand{\TOr}{                 % Union type
    O{\DType_1} O{\DType_2}
  }{\ensuremath{{#1} \lor {#2}}}
\DeclareDocumentCommand{\TOrRange}{            % Union range
    O{\DType} O{m}
  }{\Range[#1][#2][~\lor]}
\DeclareDocumentCommand{\TOrs}{                % Union type
    O{\DType_1}
  }{\ensuremath{\lor({#1})}}
\DeclareDocumentCommand{\TOrsRange}{           % Union range
    O{\DType} O{m}
  }{\TOrs[{#1}_1, ..., {#1}_{#2}]}
\newcommand{\TStar}{\ensuremath{\times}}             % Tuple star operator
\DeclareDocumentCommand{\TPair}{                 % Intersection type
    O{\DType_1} O{\DType_2}
  }{\ensuremath{{#1} \TStar {#2}}}
\newcommand{\TTuple}[1]{\ensuremath{#1}}        % Tuple type
\DeclareDocumentCommand{\TTupleRange}{          % Tuple type range
    O{\DType} O{m}
  }{\Range[#1][#2][~\TStar]}
\newcommand{\TFunc}[2]                          % Arrow type
   {\ensuremath{{#1} \rightarrow {#2}}}
\newcommand{\TFuncE}[2]                         % Existential arrow type
   {\ensuremath{{#1} \Rightarrow {#2}}}
\newcommand{\DTFunc}{\TFunc{\DType_1}{\DType_2}}
\newcommand{\TUnit                              % Unit type
  }{\ensuremath{\mathsf{unit}}}
\newcommand{\TUTop}{\ensuremath{\mathsf{unit}^\top}}
\newcommand{\TUBot}{\ensuremath{\mathsf{unit}^\bot}}
\DeclareDocumentCommand{\TVal}{                 % Refinement type
    O{\DValEq}
  }{\ensuremath{\langle {#1} \rangle}}
\newcommand{\TBot}{\ensuremath{\bot}}           % Bottom type
\newcommand{\TNot}[1]{\ensuremath{\textsf{not}({#1})}} % Not refinement
\newcommand{\TNotN}{\ensuremath{\textsf{not}}} % Not refinement

% SYNTHESIS JUDGMENTS FOR ORIGINAL VERSION
\DeclareDocumentCommand{\RefineCtxO             % Refinement context
  }{O{\CtorCtx} O{\TypeCtx} O{\WorldCtx}
  }{\ensuremath{{#1}~|~{#2}~|~{#3}}}
\DeclareDocumentCommand{\EGuessCtxO             % EGuess context
  }{O{\CtorCtx} O{\TypeCtx}
  }{\ensuremath{{#1}~|~{#2}}}
\DeclareDocumentCommand{\EGuessO                % EGuess judgment
  }{O{\CtorCtx} O{\TypeCtx} O{\DType} O{\Intro}
  }{\SynthProp{\Elim}{\EGuessCtxO[#1][#2]}{#3}{#4}}
\DeclareDocumentCommand{\RefineO                % IRefine judgment
  }{O{\CtorCtx} O{\TypeCtx} O{\WorldCtx} O{\DType} O{\Intro}
  }{\SynthProp{\Intro}{\RefineCtxO[#1][#2][#3]}{#4}{#5}}

% SYNTHESIS JUDGMENTS FOR ORIGINAL VERSION WITHOUT CONSTRUCTORS
\DeclareDocumentCommand{\RefineCtxOM             % Refinement context
  }{O{\TypeCtx} O{\WorldCtx}
  }{\ensuremath{{#1}~|~{#2}}}
\DeclareDocumentCommand{\EGuessCtxOM             % EGuess context
  }{O{\TypeCtx}
  }{\ensuremath{{#1}}}
\DeclareDocumentCommand{\EGuessOM                % EGuess judgment
  }{O{\TypeCtx} O{\DType} O{\Intro}
  }{\SynthProp{\Elim}{\EGuessCtxOM[#1]}{#2}{#3}}
\DeclareDocumentCommand{\RefineOM                % IRefine judgment
  }{O{\TypeCtx} O{\WorldCtx} O{\DType} O{\Intro}
  }{\SynthProp{\Intro}{\RefineCtxOM[#1][#2]}{#3}{#4}}
\DeclareDocumentCommand{\ERefineOM               % ERefine judgment
  }{O{\TypeCtx} O{\WorldCtx} O{\DType} O{\Intro}
  }{\SynthProp{\Elim}{\RefineCtxOM[#1][#2]}{#3}{#4}}
\DeclareDocumentCommand{\SequentOM               % Sequent judgment
  }{O{\TypeCtx} O{\WorldCtx} O{\DType} O{\DExp}
  }{\SynthProp{}{\RefineCtxOM[#1][#2]}{#3}{#4}}

% SYNTHESIS JUDGMENTS FOR SEQUENT VERSION WITHOUT CONSTRUCTORS
\DeclareDocumentCommand{\RefineCtxSeq             % Refinement context
  }{O{\TypeCtx} O{\WorldCtx}
  }{\ensuremath{{#1}~|~{#2}}}
\DeclareDocumentCommand{\EGuessCtxOM             % EGuess context
  }{O{\TypeCtx}
  }{\ensuremath{{#1}}}
\DeclareDocumentCommand{\EGuessOM                % EGuess judgment
  }{O{\TypeCtx} O{\DType} O{\Intro}
  }{\SynthProp{\Elim}{\EGuessCtxOM[#1]}{#2}{#3}}
\DeclareDocumentCommand{\RefineOM                % IRefine judgment
  }{O{\TypeCtx} O{\WorldCtx} O{\DType} O{\Intro}
  }{\SynthProp{\Intro}{\RefineCtxOM[#1][#2]}{#3}{#4}}
\DeclareDocumentCommand{\ERefineOM               % ERefine judgment
  }{O{\TypeCtx} O{\WorldCtx} O{\DType} O{\Intro}
  }{\SynthProp{\Elim}{\RefineCtxOM[#1][#2]}{#3}{#4}}
\DeclareDocumentCommand{\SequentOM               % Sequent judgment
  }{O{\TypeCtx} O{\WorldCtx} O{\DType} O{\DExp}
  }{\SynthProp{}{\RefineCtxOM[#1][#2]}{#3}{#4}}

% SYNTHESIS JUDGMENTS FOR PRODUCT VERSION
\DeclareDocumentCommand{\World                  % An example world pair
  }{O{\ExamCtx} O{\Exam}
  }{\ensuremath{\langle{#1}; {#2}\rangle}}
\DeclareDocumentCommand{\WorldN                 % An example world pair
  }{O{\ExamCtx} O{\Exam}
  }{\Overbar{n}{\ensuremath{\langle{#1}; {#2}\rangle}}}
\DeclareDocumentCommand{\RefineCtx              % Refinement context
  }{O{\CtorCtx} O{\TypeCtx} O{\WorldCtx} O{\AuxCtx} O{\FocusCtx}
  }{\ensuremath{{#1}~|~{#2}; {#3}; {#4}~|~{#5}}}
\DeclareDocumentCommand{\EGuessCtx              % EGuess context
  }{O{\CtorCtx} O{\TypeCtx} O{\AuxCtx} O{\FocusCtx}
  }{\ensuremath{{#1}~|~{#2}; {#3}; {#4}}}
\DeclareDocumentCommand{\EGuess                 % EGuess judgment
  }{O{\CtorCtx} O{\TypeCtx} O{\AuxCtx} O{\FocusCtx} O{\DType} O{\Intro}
  }{\SynthProp{\Elim}{\EGuessCtx[#1][#2][#3][#4]}{#5}{#6}}
\DeclareDocumentCommand{\Refine                 % IRefine judgment
  }{O{\CtorCtx} O{\TypeCtx} O{\AuxCtx} O{\FocusCtx} O{\WorldCtx} O{\DType} O{\Intro}
  }{\SynthProp{\Intro}{\RefineCtx[#1][#2][#3][#4][#5]}{#6}{#7}}

\DeclareDocumentCommand{\RefineCtxM             % Refinement context without ctor ctx
  }{O{\TypeCtx} O{\WorldCtx} O{\AuxCtx} O{\FocusCtx}
  }{{#1}; {#2}; {#3}~|~{#4}}
\DeclareDocumentCommand{\RefineM                % IRefine judgment without ctor ctx
  }{O{\TypeCtx} O{\AuxCtx} O{\FocusCtx} O{\WorldCtx} O{\DType} O{\Intro}
  }{\SynthProp{\Intro}{\RefineCtx[#1][#2][#3][#4]}{#5}{#6}}
\DeclareDocumentCommand{\EGuessCtxM             % EGuess context
  }{O{\TypeCtx} O{\AuxCtx} O{\FocusCtx}
  }{\ensuremath{#1}; {#2}; {#3}}
\DeclareDocumentCommand{\EGuessM                % EGuess judgment
  }{O{\TypeCtx} O{\AuxCtx} O{\FocusCtx} O{\DType} O{\Elim}
  }{\SynthProp{\Elim}{\EGuessCtxM[#1][#2][#3]}{#4}{#5}}
\DeclareDocumentCommand{\RefineM                % IRefine judgment
  }{O{\TypeCtx} O{\AuxCtx} O{\FocusCtx} O{\WorldCtx} O{\DType} O{\Intro}
  }{\SynthProp{\Intro}{\RefineCtxM[#1][#2][#3][#4]}{#5}{#6}}
\DeclareDocumentCommand{\EGuessN                % EGuess judgment2
  }{O{\TypeCtx} O{\AuxCtx} O{\FocusCtx} O{\DType} O{\Elim}
  }{\SynthProp{\Elim'}{\EGuessCtxM[#1][#2][#3]}{#4}{#5}}
\DeclareDocumentCommand{\RefineN                % IRefine judgment2
  }{O{\TypeCtx} O{\AuxCtx} O{\FocusCtx} O{\WorldCtx} O{\DType} O{\Intro}
  }{\SynthProp{\Intro'}{\RefineCtxM[#1][#2][#3][#4]}{#5}{#6}}

% FOCUSING JUDGMENTS FOR PRODUCT VERSION
\newcommand{\FocusStarArrow                    % Focus transitive closure operator
  }{\Longrightarrow^*}
\DeclareDocumentCommand{\IFocus                % Focus judgment
  }{O{\RefineCtx} O{\RefineCtx}
  }{\ensuremath{{#1} \Longrightarrow {#2}}}
\DeclareDocumentCommand{\IFocusStar            % Focus transitive closure judgment
  }{O{\RefineCtx} O{\RefineCtx}
  }{\ensuremath{{#1} \FocusStarArrow {#2}}}

% SYNTHESIS JUDGMENTS FOR INTERSECTION VERSION
\newcommand{\FocusCtxR                         % Right focusing context
  }{\ensuremath{\FocusCtx^R}}
\newcommand{\FocusCtxL                         % Left focusing context
  }{\ensuremath{\FocusCtx^L}}
\newcommand{\AuxCtxL                           % Left auxiliary context
  }{\ensuremath{\AuxCtx^L}}
\DeclareDocumentCommand{\IntCtx                % Synthesis context
  }{O{\CtorCtx} O{\TypeCtx} O{\AuxCtxL} O{\FocusCtxL} O{\FocusCtxR} O{\GoalCtx}
  }{\ensuremath{{#1}~|~{#2}; {#3}; {#4}~|~{#5}; {#6}}}
\DeclareDocumentCommand{\IntProp               % Synthesis proposition
  }{O{\Intro} O{\Intro} O{\GoalCtx} O{\FocusCtxL} O{\FocusCtxR} O{\CtorCtx} O{\TypeCtx} O{\AuxCtxL}
  }{\IntSynthProp{#1}{\IntCtx[#6][#7][#8][#4][#5][#3]}{#2}}
\DeclareDocumentCommand{\IntPropMany           % Many Synthesis propositions
  }{O{\Intro} O{\Intro} O{n} O{\GoalCtx_i} O{\FocusCtxL_i} O{\FocusCtxR_i} O{\CtorCtx_i} O{\TypeCtx_i} O{\AuxCtxL_i}
  }{\IntSynthProp{#1}{\Overbar{i \in #3}{\IntCtx[#7][#8][#9][#5][#6][#4]}}{#2}}
\DeclareDocumentCommand{\IntCtxI               % Synthesis context with index
  }{O{i}
  }{\IntCtx[\CtorCtx_{#1}][\TypeCtx_{#1}][\AuxCtxL_{#1}][\FocusCtxL_{#1}][\FocusCtxR_{#1}][\GoalCtx_{#1}]}  
\DeclareDocumentCommand{\SynthCtx              % Shorthand for the synthesis context
  }{O{i}}{\ensuremath{\Psi_{#1}}}    

% SYNTHESIS JUDGMENTS FOR MINIMAL INTERSECTION VERSION
\DeclareDocumentCommand{\IntMinCtx             % Synthesis context
  }{O{\ValCtx} O{\TypeCtx} O{\DType}
  }{\ensuremath{{#1}~|~{#2}~|~{#3}}}
\DeclareDocumentCommand{\IntMinProp            % Synthesis proposition
  }{O{\Intro} O{\Intro} O{\DType} O{\TypeCtx} O{\ValCtx}
  }{\IntSynthProp{#1}{\IntMinCtx[#5][#4][#3]}{#2}}
\DeclareDocumentCommand{\IntMinPropMany        % Many Synthesis propositions
  }{O{\Intro} O{\Intro} O{n} O{\DType_i} O{\TypeCtx_i} O{\ValCtx_i}
  }{\IntSynthProp{#1}{\Overbar{i \in #3}{\IntMinCtx[#6][#5][#4]}}{#2}}
\DeclareDocumentCommand{\IntMinCtxI            % Synthesis context with index
  }{O{i}
  }{\IntMinCtx[\ValCtx_{#1}][\TypeCtx_{#1}][\DType_{#1}]}
\newcommand{\TNat}{\ensuremath{\textsf{nat}}}
\newcommand{\DNat}{\ensuremath{n}}
\DeclareDocumentCommand{\TSum}{O{\DType_1} O{\DType_2}
  }{\ensuremath{{#1} + {#2}}}
\DeclareDocumentCommand{\EInl}{O{\DExp}}{\ensuremath{\mathsf{inl}~{#1}}}
\DeclareDocumentCommand{\EInr}{O{\DExp}}{\ensuremath{\mathsf{inr}~{#1}}}
\DeclareDocumentCommand{\EMatchS}{O{\DExp} O{\DExp} O{\DExp}
  }{\ensuremath{\mathsf{match}~{#1}~\mathsf{with}~\EInl[\DVar] \rightarrow {#2}~|~
                                                  \EInr[\DVar] \rightarrow {#3}}}

% Judgements for simple Dave version

\newcommand{\Stepstostar}{\ensuremath{\longrightarrow^{*}}}
\newcommand{\Stepsto}{\ensuremath{\longrightarrow}}
\newcommand{\EConstant}{\ensuremath{c}}
\newcommand{\NDCtx}{\ensuremath{\Delta}}
\DeclareDocumentCommand{\DaLam
  }{O{x} O{\DExp}
  }{\ensuremath{\lambda{#1}.{#2}}}
\DeclareDocumentCommand{\DaFix
  }{O{f} O{x} O{\DExp}
  }{\ensuremath{\mathsf{fix}~{#1}~{#2}.{#3}}}
\newcommand{\Interp}{\ensuremath{{\cal I}}}
\DeclareDocumentCommand{\DaWorld                  % world pair
  }{O{\TypeCtx} O{\Refinement}
  }{\ensuremath{\langle{#1} \vdash {#2}\rangle}}
\DeclareDocumentCommand{\DaWorldN                 % n world pairs
  }{O{\TypeCtx} O{\Refinement}
  }{\Overbar{n}{\ensuremath{\langle{#1} \vdash {#2}\rangle}}}
\DeclareDocumentCommand{\Synch                   % Simple sequent judgment
  }{O{\WorldCtx} O{\DExp}
  }{#1 \leadsto #2\ \mathsf{sync}}
\DeclareDocumentCommand{\USynch                   % Unsyncronized sequent judgment with projections
  }{O{\WorldCtx} O{\DExp}
  }{#1 \leadsto #2 \ \mathsf{unsyncp}}
\DeclareDocumentCommand{\USynchL                % Unsynchronized sequent judgement with left rules, no projections
  }{O{\WorldCtx} O{\DExp}
  }{#1 \leadsto #2 \ \mathsf{unsync}}
\DeclareDocumentCommand{\SynchA                % anonymous Unsynchronized sequent judgement
  }{O{\WorldCtx} O{\DExp}
  }{#1 \leadsto #2}
\DeclareDocumentCommand{\Sqnt
  }{O{\DaWorld} O{\DExp}
  }{\ensuremath{#1 \leadsto #2}}
\DeclareDocumentCommand{\ISND                    % Intro S ND judgment
  }{O{\WorldCtx} O{\DExp} O{\Refinement}
  }{#1 \vdash #2 : #3 \ \mathsf{norm}}
\DeclareDocumentCommand{\ESND                    % Elim S ND judgment
  }{O{\WorldCtx} O{\DVar} O{\Refinement}
  }{#1 \vdash #2 : #3 \ \mathsf{sub}}
\DeclareDocumentCommand{\GPrj                   % Projection from Gamma
  }{O{\TypeCtx} O{\DVar} O{\Refinement}
  }{#1 \vdash #2 : #3 \ \mathsf{prj}}
\DeclareDocumentCommand{\GSplit                 % Split from Gamma
  }{O{\TypeCtx} O{\DVar} O{\Refinement} O{\Refinement}
  }{#1 \vdash #2 : #3, #4 \ \mathsf{sp}}
\DeclareDocumentCommand{\FromCtx                % Hypothesis appears in the context context
  }{O{\TypeCtx} O{\DVar} O{\Refinement}
  }{\HasType[#2][#3] \in #1}
\DeclareDocumentCommand{\DaSub                   % Simple subtype judgement
  }{O{\Refinement_1} O{\Refinement_2}
  }{#1 \leq #2}
\DeclareDocumentCommand{\DaPrj                   % Projection
  }{O{\Refinement_1} O{\Refinement_2}
  }{#1 \rhd #2}
\DeclareDocumentCommand{\Split                   % Splitting
  }{O{\Refinement_1} O{\Refinement_2} O{\Refinement_3}
  }{#1 \rhd #2,#3}
\DeclareDocumentCommand{\DaWF                    % Well-formed context
  }{O{\langle\TypeCtx_1\rangle \cdots \langle\TypeCtx_n\rangle}
  }{\vdash #1 \ \mathsf{wf}}
%\DeclareDocumentCommand{\DaWFE                   % Well-formed elimination expression
%  }{O{\TypeCtx} 0{\DExp} 0{\Refinement}
%  }{#1 \vdash #2 : #3 \ \ensuremath{\mathsf{elim}}}
\DeclareDocumentCommand{\ND                    % Natural deduction
  }{O{\TypeCtx} O{\DExp} O{\Refinement}
  }{\ensuremath{{#1} \vdash {#2} : {#3}\ \mathsf{nd}}}
\DeclareDocumentCommand{\NDE                   % Natural deduction
  }{O{\TypeCtx} O{\DExp} O{\Refinement}
  }{\ensuremath{{#1} \vdash {#2} : {#3}\ \mathsf{nde}}}
\DeclareDocumentCommand{\DaV                   % Value denotation of refinements
  }{O{\Refinement_1}
  }{\ensuremath{{\cal V}\llbracket #1 \rrbracket}}
\DeclareDocumentCommand{\DaB                   % Value denotation of refinements
  }{O{\Refinement_1}
  }{\ensuremath{{\cal B}\llbracket #1 \rrbracket}}
\DeclareDocumentCommand{\DaE                   % Expression denotation of refinements
  }{O{\Refinement_1}
  }{\ensuremath{{\cal E}\llbracket #1 \rrbracket}}
\DeclareDocumentCommand{\DaC                   % Constant denotation of refinements
  }{O{\Refinement_1}
  }{\ensuremath{{\cal C}\llbracket #1 \rrbracket}}
\newcommand{\ContextsOf}{\ensuremath{\mathsf{Contexts}}}
\newcommand{\Dom}{\ensuremath{\mathsf{Dom}}}

% EXPRESSIONS

\newcommand{\SNorm}{\ensuremath{s}}   % sequent normal form
\newcommand{\ETrue}{\ensuremath{\mathsf{true}}}   % true refinement type
\newcommand{\EFalse}{\ensuremath{\mathsf{false}}} % false refinement type
\DeclareDocumentCommand{\EFix                  % Fixpoint
  }{O{f} O{x} O{\DType_1} O{\DType_2} O{\DExp}
  }{\ensuremath{\mathsf{fix}~{#1} \HasType[(\HasType[{#2}][{#3}])][{#4}] = {#5}}}
\DeclareDocumentCommand{\ELam
  }{O{x} O{\DType_1} O{\DExp}
  }{\ensuremath{\lambda{#1}{:}{#2}.{#3}}}
\DeclareDocumentCommand{\EULam
  }{O{x} O{\DExp}
  }{\ensuremath{\lambda{#1}.{#2}}}
\DeclareDocumentCommand{\EITE
  }{O{\DExp_0} O{\DExp_1} O{\DExp_2}
  }{\ensuremath{\mathsf{if}\,{#1}\,\mathsf{then}\,{#2}\,\mathsf{else}\,{#3}}}
\DeclareDocumentCommand{\ELet
  }{O{x} O{\DExp_1} O{\DExp_2}
  }{\ensuremath{\mathsf{let}\,{#1}\,=\,{#2}\,\mathsf{in}\,{#3}}}
\DeclareDocumentCommand{\ECtor                 % Constructor
  }{O{\DCtor} O{\DExp}
  }{{\ensuremath{#1}}~{\ensuremath{#2}}}
\DeclareDocumentCommand{\EApp                  % Application
  }{O{\DExp_1} O{\DExp_2}
  }{\ensuremath{{#1}~{#2}}}
\DeclareDocumentCommand{\EMatch                % Match
  }{O{\DExp} O{\Overbar{i \in m}{\DCtor_i~\DVar \rightarrow e_i}}
  }{\ensuremath{\mathsf{match}~{#1}~\mathsf{with}~{#2}}}
\DeclareDocumentCommand{\ETuple                % Tuple
  }{O{\DExp_1, ..., \DExp_m}
  }{\ensuremath{\langle {#1} \rangle}}
\DeclareDocumentCommand{\EPair                % Tuple
  }{O{\DExp_1} O{\DExp_2}
  }{\ensuremath{\langle {#1}, {#2} \rangle}}

\DeclareDocumentCommand{\EProj                 % Projection
  }{O{k} O{\DExp}
  }{\ensuremath{\pi_{#1}~{#2}}}
\DeclareDocumentCommand{\EProjI                % Projection for intersections
  }{O{k} O{\DExp}
  }{\ensuremath{\rho_{#1}~{#2}}}
\newcommand{\EUnit                             % Unit
  }{\ensuremath{()}}
\newcommand{\ETupleRange}[1]                   % Tuple range
  {\ETuple[\Range[#1][m]]}

% Evaluation rules
\DeclareDocumentCommand{\RefCon
  }{O{\TypeCtx} O{\DVal} O{\DType} O{\Refinement}
  }{\ensuremath{\mathsf{RefCon}({#1}; {#2}; {#3}) = {#4}}}

\DeclareDocumentCommand{\Univ
  }{O{\Refinement} O{\DType} O{\Refinement'}
  }{\ensuremath{\mathsf{Univ}(\Refines[{#1}][{#2}]) = {#3}}}

\newcommand{\Sss}{\ensuremath{\rightarrow}}
\newcommand{\SssStar}{\ensuremath{\rightarrow^*}}
\DeclareDocumentCommand{\EtaEq}{O{\DExp} O{\DType}
    }{\ensuremath{\left[{#1}\right]_{\eta}^{#2}}}
\newcommand{\EtaEquiv}[1]{\ensuremath{\left[{#1}\right]_{\eta}}}
\DeclareDocumentCommand{\TupDe}{O{\DExp} O{\DType}
    }{\ensuremath{\left[{#1}\right]_{tup}^{#2}}}
\DeclareDocumentCommand{\Vars}{O{\TypeCtx}}{\ensuremath{\left[{#1}\right]_{vars}}}
\DeclareDocumentCommand{\TNeg}{O{\DType}}{\ensuremath{\left[{#1}\right]_{neg}}}
\DeclareDocumentCommand{\TExp}{O{\DType} O{\DType}}{\ensuremath{\left[{#1}\right]_{exp}^{#2}}}
\DeclareDocumentCommand{\Denot}{O{\Refinement}}{\ensuremath{\llbracket{#1}\rrbracket}}
\DeclareDocumentCommand{\Norm}{O{\Refinement}}{\ensuremath{\mathcal{N}({#1})}}
\newcommand{\NegNormN}{\ensuremath{\mathcal{N}}}
\DeclareDocumentCommand{\NegNorm}{O{\Refinement} O{\DType}
    }{\ensuremath{\NegNormN({#1}, {#2})}}
\DeclareDocumentCommand{\ExElim}{O{\Refinement}}{\ensuremath{\mathcal{U}({#1})}}
\DeclareDocumentCommand{\Inhabited}{O{\Refinement}}{\ensuremath{{#1}\ \mathsf{inhabited}}}
\newcommand{\NormN}{\ensuremath{\mathcal{N}}}
\newcommand{\Ctors}[1]{\ensuremath{\mathsf{Ctors}({#1})}}


% Names

\newcommand{\LambdaUI}{\ensuremath{\lambda^{\land,\lor}}}
\newcommand{\myth}{\textsc{Myth}}
\newcommand{\lambdasq}{\ensuremath{\lambda^2}}
\newcommand{\djinn}{\textsc{Djinn}}
\newcommand{\insynth}{\textsc{InSynth}}
\newcommand{\igortwo}{\textsc{IgorII}}
\newcommand{\escher}{\textsc{Escher}}
\newcommand{\sketch}{\textsc{Sketch}}
\newcommand{\leon}{\textsc{Leon}}
\newcommand{\flashextract}{\textsc{FlashExtract}}
\newcommand{\magichaskeller}{\textsc{MagicHaskeller}}
